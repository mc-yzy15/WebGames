// 火柴人冒险游戏 - 优化版本
const StickmanAdventure = (() => {
    // DOM元素
    let canvas, ctx;
    let jumpBtn, attackBtn;
    let healthFill;
    let tutorialBtn, difficultyBtn, levelBtn, exportBtn;
    let tutorialPanel, difficultyPanel, levelPanel;
    let currentLevelEl, scoreEl, difficultyEl;
    let levelGrid;
    let modalCloseBtns;

    // 游戏配置常量
    const CONFIG = {
        canvasWidth: 800,
        canvasHeight: 500,
        playerSpeed: 5,
        playerJumpForce: -14,
        gravity: 0.6,
        enemyRespawnTime: 3000,
        attackDuration: 300
    };

    // 难度配置
    const DIFFICULTY_CONFIG = {
        easy: {
            enemySpeed: 1.5,
            playerHealth: 150,
            enemyHealth: 1,
            // 优化：添加更多平衡性参数
            enemyDamage: 0.8,
            playerAttackPower: 1.2,
            enemySpawnRate: 0.8,
            scoreMultiplier: 0.8
        },
        medium: {
            enemySpeed: 2.5,
            playerHealth: 100,
            enemyHealth: 1,
            // 优化：添加更多平衡性参数
            enemyDamage: 1.0,
            playerAttackPower: 1.0,
            enemySpawnRate: 1.0,
            scoreMultiplier: 1.0
        },
        hard: {
            enemySpeed: 3.5,
            playerHealth: 75,
            enemyHealth: 1,
            // 优化：添加更多平衡性参数
            enemyDamage: 1.2,
            playerAttackPower: 0.8,
            enemySpawnRate: 1.2,
            scoreMultiplier: 1.5
        }
    };

    // 优化：添加动态难度调整系统
    const dynamicDifficulty = {
        playerDeathCount: 0,
        enemyKillCount: 0,
        consecutiveKills: 0,
        consecutiveDeaths: 0,
        difficultyLevel: 1.0,
        lastAdjustmentTime: 0,

        // 优化：根据玩家表现动态调整难度
        adjustDifficulty: function () {
            const now = performance.now();
            if (now - this.lastAdjustmentTime < 10000) return; // 每10秒调整一次

            const deathRate = this.playerDeathCount / Math.max(1, this.playerDeathCount + this.enemyKillCount);
            const killRate = this.enemyKillCount / Math.max(1, this.playerDeathCount + this.enemyKillCount);

            // 优化：根据死亡率和击杀率调整难度
            if (deathRate > 0.5) {
                // 玩家死亡较多，降低难度
                this.difficultyLevel = Math.max(0.5, this.difficultyLevel - 0.1);
            } else if (killRate > 0.8) {
                // 玩家击杀较多，提高难度
                this.difficultyLevel = Math.min(2.0, this.difficultyLevel + 0.1);
            }

            this.lastAdjustmentTime = now;
        },

        // 优化：获取当前难度系数
        getDifficultyMultiplier: function () {
            return this.difficultyLevel;
        },

        // 优化：记录玩家死亡
        recordPlayerDeath: function () {
            this.playerDeathCount++;
            this.consecutiveDeaths++;
            this.consecutiveKills = 0;
        },

        // 优化：记录敌人击杀
        recordEnemyKill: function () {
            this.enemyKillCount++;
            this.consecutiveKills++;
            this.consecutiveDeaths = 0;
        },

        // 优化：获取连击加成
        getComboBonus: function () {
            return 1.0 + (this.consecutiveKills * 0.1);
        },

        // 优化：获取关卡难度系数
        getLevelDifficultyMultiplier: function (levelIndex) {
            // 优化：使用指数曲线而不是线性曲线
            return 1.0 + Math.pow(levelIndex / LEVELS.length, 1.5) * 2.0;
        },

        // 优化：获取敌人数量系数
        getEnemyCountMultiplier: function (levelIndex) {
            // 优化：使用对数曲线控制敌人数量增长
            return 1.0 + Math.log(levelIndex + 1) * 0.3;
        },

        // 优化：获取敌人速度系数
        getEnemySpeedMultiplier: function (levelIndex) {
            // 优化：使用平方根曲线控制敌人速度增长
            return 1.0 + Math.sqrt(levelIndex) * 0.2;
        }
    };

    // 15个关卡设计，包含多样化的敌人组合和平台布局
    const LEVELS = [
        // 关卡1 - 简单介绍，普通敌人
        {
            platforms: [
                { x: 0, y: 450, width: 800, height: 50 },
                { x: 200, y: 380, width: 150, height: 20 },
                { x: 400, y: 300, width: 150, height: 20 },
                { x: 600, y: 220, width: 150, height: 20 }
            ],
            enemies: [
                { x: 600, y: 390, width: 30, height: 50, speed: 1, direction: 1, type: 'normal' },
                { x: 300, y: 310, width: 30, height: 50, speed: 1.5, direction: 1, type: 'normal' }
            ]
        },
        // 关卡2 - 加入跳跃敌人
        {
            platforms: [
                { x: 0, y: 450, width: 800, height: 50 },
                { x: 100, y: 380, width: 100, height: 20 },
                { x: 300, y: 310, width: 100, height: 20 },
                { x: 500, y: 240, width: 100, height: 20 },
                { x: 700, y: 170, width: 100, height: 20 }
            ],
            enemies: [
                { x: 500, y: 390, width: 30, height: 50, speed: 1.2, direction: 1, type: 'normal' },
                { x: 200, y: 310, width: 30, height: 50, speed: 1.5, direction: 1, type: 'jumping', velocityY: 0, jumpForce: -12 },
                { x: 600, y: 180, width: 30, height: 50, speed: 1.3, direction: 1, type: 'normal' }
            ]
        },
        // 关卡3 - 加入飞行敌人
        {
            platforms: [
                { x: 0, y: 450, width: 200, height: 50 },
                { x: 300, y: 380, width: 150, height: 20 },
                { x: 550, y: 310, width: 250, height: 20 },
                { x: 100, y: 240, width: 150, height: 20 },
                { x: 400, y: 170, width: 150, height: 20 }
            ],
            enemies: [
                { x: 100, y: 390, width: 30, height: 50, speed: 1.4, direction: 1, type: 'normal' },
                { x: 400, y: 310, width: 30, height: 50, speed: 1.6, direction: 1, type: 'jumping', velocityY: 0, jumpForce: -12 },
                { x: 200, y: 180, width: 30, height: 50, speed: 1.5, direction: 1, type: 'flying', baseY: 180 }
            ]
        },
        // 关卡4 - 加入追踪敌人
        {
            platforms: [
                { x: 0, y: 450, width: 150, height: 50 },
                { x: 250, y: 400, width: 150, height: 20 },
                { x: 500, y: 350, width: 150, height: 20 },
                { x: 700, y: 300, width: 100, height: 20 },
                { x: 150, y: 250, width: 150, height: 20 },
                { x: 400, y: 200, width: 150, height: 20 }
            ],
            enemies: [
                { x: 50, y: 400, width: 30, height: 50, speed: 1.5, direction: 1, type: 'normal' },
                { x: 350, y: 350, width: 30, height: 50, speed: 1.7, direction: 1, type: 'tracking', velocityY: 0 },
                { x: 600, y: 300, width: 30, height: 50, speed: 1.6, direction: 1, type: 'jumping', velocityY: 0, jumpForce: -12 },
                { x: 250, y: 200, width: 30, height: 50, speed: 1.5, direction: 1, type: 'flying', baseY: 200 }
            ]
        },
        // 关卡5 - 加入射手敌人
        {
            platforms: [
                { x: 0, y: 450, width: 800, height: 50 },
                { x: 50, y: 380, width: 100, height: 20 },
                { x: 250, y: 310, width: 100, height: 20 },
                { x: 450, y: 240, width: 100, height: 20 },
                { x: 650, y: 170, width: 100, height: 20 },
                { x: 150, y: 100, width: 100, height: 20 }
            ],
            enemies: [
                { x: 100, y: 390, width: 30, height: 50, speed: 1.6, direction: 1, type: 'normal' },
                { x: 350, y: 310, width: 30, height: 50, speed: 1.8, direction: 1, type: 'tracking' },
                { x: 550, y: 240, width: 30, height: 50, speed: 1.5, direction: 1, type: 'shooter' },
                { x: 750, y: 170, width: 30, height: 50, speed: 1.6, direction: 1, type: 'flying' }
            ]
        },
        // 关卡6 - 加入爆炸敌人
        {
            platforms: [
                { x: 0, y: 450, width: 150, height: 50 },
                { x: 300, y: 400, width: 100, height: 20 },
                { x: 550, y: 350, width: 250, height: 20 },
                { x: 100, y: 300, width: 150, height: 20 },
                { x: 400, y: 250, width: 150, height: 20 },
                { x: 250, y: 200, width: 150, height: 20 },
                { x: 600, y: 150, width: 150, height: 20 }
            ],
            enemies: [
                { x: 100, y: 400, width: 30, height: 50, speed: 1.7, direction: 1, type: 'normal' },
                { x: 400, y: 350, width: 30, height: 50, speed: 1.9, direction: 1, type: 'exploder' },
                { x: 200, y: 300, width: 30, height: 50, speed: 1.8, direction: 1, type: 'jumping' },
                { x: 500, y: 250, width: 30, height: 50, speed: 1.7, direction: 1, type: 'shooter' },
                { x: 700, y: 150, width: 30, height: 50, speed: 1.6, direction: 1, type: 'flying' }
            ]
        },
        // 关卡7 - 多样化敌人组合
        {
            platforms: [
                { x: 0, y: 450, width: 200, height: 50 },
                { x: 300, y: 380, width: 150, height: 20 },
                { x: 550, y: 310, width: 250, height: 20 },
                { x: 100, y: 240, width: 150, height: 20 },
                { x: 400, y: 170, width: 150, height: 20 },
                { x: 250, y: 100, width: 150, height: 20 },
                { x: 600, y: 30, width: 150, height: 20 }
            ],
            enemies: [
                { x: 100, y: 390, width: 30, height: 50, speed: 1.8, direction: 1, type: 'normal' },
                { x: 400, y: 310, width: 30, height: 50, speed: 2.0, direction: 1, type: 'tracking' },
                { x: 200, y: 240, width: 30, height: 50, speed: 1.9, direction: 1, type: 'exploder' },
                { x: 500, y: 170, width: 30, height: 50, speed: 1.8, direction: 1, type: 'shooter' },
                { x: 350, y: 100, width: 30, height: 50, speed: 1.7, direction: 1, type: 'jumping' },
                { x: 700, y: 30, width: 30, height: 50, speed: 1.6, direction: 1, type: 'flying' }
            ]
        },
        // 关卡8 - 复杂平台布局
        {
            platforms: [
                { x: 0, y: 450, width: 150, height: 50 },
                { x: 250, y: 400, width: 150, height: 20 },
                { x: 500, y: 350, width: 150, height: 20 },
                { x: 700, y: 300, width: 100, height: 20 },
                { x: 150, y: 250, width: 150, height: 20 },
                { x: 400, y: 200, width: 150, height: 20 },
                { x: 250, y: 150, width: 150, height: 20 },
                { x: 600, y: 100, width: 150, height: 20 }
            ],
            enemies: [
                { x: 50, y: 400, width: 30, height: 50, speed: 1.9, direction: 1, type: 'normal' },
                { x: 350, y: 350, width: 30, height: 50, speed: 2.1, direction: 1, type: 'tracking' },
                { x: 600, y: 300, width: 30, height: 50, speed: 2.0, direction: 1, type: 'jumping' },
                { x: 250, y: 250, width: 30, height: 50, speed: 1.9, direction: 1, type: 'exploder' },
                { x: 500, y: 200, width: 30, height: 50, speed: 1.8, direction: 1, type: 'shooter' },
                { x: 350, y: 150, width: 30, height: 50, speed: 1.7, direction: 1, type: 'flying' }
            ]
        },
        // 关卡9 - 高空平台挑战
        {
            platforms: [
                { x: 0, y: 450, width: 100, height: 50 },
                { x: 200, y: 400, width: 100, height: 20 },
                { x: 400, y: 350, width: 100, height: 20 },
                { x: 600, y: 300, width: 100, height: 20 },
                { x: 100, y: 250, width: 100, height: 20 },
                { x: 300, y: 200, width: 100, height: 20 },
                { x: 500, y: 150, width: 100, height: 20 },
                { x: 200, y: 100, width: 100, height: 20 },
                { x: 400, y: 50, width: 100, height: 20 }
            ],
            enemies: [
                { x: 50, y: 400, width: 30, height: 50, speed: 2.0, direction: 1, type: 'normal' },
                { x: 300, y: 350, width: 30, height: 50, speed: 2.2, direction: 1, type: 'tracking' },
                { x: 500, y: 300, width: 30, height: 50, speed: 2.1, direction: 1, type: 'exploder' },
                { x: 200, y: 250, width: 30, height: 50, speed: 2.0, direction: 1, type: 'jumping' },
                { x: 400, y: 200, width: 30, height: 50, speed: 1.9, direction: 1, type: 'shooter' },
                { x: 300, y: 150, width: 30, height: 50, speed: 1.8, direction: 1, type: 'flying' },
                { x: 500, y: 50, width: 30, height: 50, speed: 1.7, direction: 1, type: 'flying' }
            ]
        },
        // 关卡10 - 最终挑战
        {
            platforms: [
                { x: 0, y: 450, width: 800, height: 50 },
                { x: 100, y: 380, width: 100, height: 20 },
                { x: 300, y: 310, width: 100, height: 20 },
                { x: 500, y: 240, width: 100, height: 20 },
                { x: 700, y: 170, width: 100, height: 20 },
                { x: 200, y: 100, width: 100, height: 20 },
                { x: 400, y: 30, width: 100, height: 20 },
                { x: 600, y: -40, width: 100, height: 20 }
            ],
            enemies: [
                { x: 150, y: 390, width: 30, height: 50, speed: 2.1, direction: 1, type: 'normal' },
                { x: 350, y: 310, width: 30, height: 50, speed: 2.3, direction: 1, type: 'tracking' },
                { x: 550, y: 240, width: 30, height: 50, speed: 2.2, direction: 1, type: 'exploder' },
                { x: 750, y: 170, width: 30, height: 50, speed: 2.1, direction: 1, type: 'shooter' },
                { x: 300, y: 100, width: 30, height: 50, speed: 2.0, direction: 1, type: 'jumping' },
                { x: 500, y: 30, width: 30, height: 50, speed: 1.9, direction: 1, type: 'flying' },
                { x: 700, y: -40, width: 30, height: 50, speed: 1.8, direction: 1, type: 'flying' }
            ]
        },
        // 关卡11 - 密集敌人挑战
        {
            platforms: [
                { x: 0, y: 450, width: 400, height: 50 },
                { x: 500, y: 400, width: 300, height: 50 },
                { x: 100, y: 350, width: 200, height: 20 },
                { x: 400, y: 300, width: 200, height: 20 },
                { x: 700, y: 250, width: 100, height: 20 },
                { x: 200, y: 200, width: 150, height: 20 },
                { x: 500, y: 150, width: 150, height: 20 },
                { x: 300, y: 100, width: 150, height: 20 }
            ],
            enemies: [
                { x: 100, y: 400, width: 30, height: 50, speed: 2.0, direction: 1, type: 'normal' },
                { x: 300, y: 400, width: 30, height: 50, speed: 2.1, direction: 1, type: 'exploder' },
                { x: 600, y: 400, width: 30, height: 50, speed: 2.2, direction: 1, type: 'tracking' },
                { x: 200, y: 350, width: 30, height: 50, speed: 1.9, direction: 1, type: 'jumping' },
                { x: 500, y: 300, width: 30, height: 50, speed: 1.8, direction: 1, type: 'shooter' },
                { x: 800, y: 250, width: 30, height: 50, speed: 2.0, direction: -1, type: 'flying' },
                { x: 300, y: 200, width: 30, height: 50, speed: 1.7, direction: 1, type: 'exploder' },
                { x: 600, y: 150, width: 30, height: 50, speed: 1.6, direction: 1, type: 'flying' },
                { x: 400, y: 100, width: 30, height: 50, speed: 1.8, direction: 1, type: 'shooter' }
            ]
        },
        // 关卡12 - 复杂地形
        {
            platforms: [
                { x: 0, y: 450, width: 150, height: 50 },
                { x: 300, y: 420, width: 150, height: 20 },
                { x: 550, y: 390, width: 250, height: 20 },
                { x: 100, y: 360, width: 150, height: 20 },
                { x: 400, y: 330, width: 150, height: 20 },
                { x: 250, y: 300, width: 150, height: 20 },
                { x: 600, y: 270, width: 150, height: 20 },
                { x: 150, y: 240, width: 150, height: 20 },
                { x: 450, y: 210, width: 150, height: 20 },
                { x: 300, y: 180, width: 150, height: 20 },
                { x: 550, y: 150, width: 150, height: 20 },
                { x: 200, y: 120, width: 150, height: 20 },
                { x: 450, y: 90, width: 150, height: 20 },
                { x: 700, y: 60, width: 100, height: 20 }
            ],
            enemies: [
                { x: 100, y: 400, width: 30, height: 50, speed: 1.9, direction: 1, type: 'normal' },
                { x: 400, y: 400, width: 30, height: 50, speed: 2.0, direction: 1, type: 'tracking' },
                { x: 700, y: 390, width: 30, height: 50, speed: 2.1, direction: -1, type: 'exploder' },
                { x: 200, y: 360, width: 30, height: 50, speed: 1.8, direction: 1, type: 'jumping' },
                { x: 500, y: 330, width: 30, height: 50, speed: 1.7, direction: 1, type: 'shooter' },
                { x: 350, y: 300, width: 30, height: 50, speed: 2.0, direction: 1, type: 'exploder' },
                { x: 700, y: 270, width: 30, height: 50, speed: 1.9, direction: -1, type: 'flying' },
                { x: 250, y: 240, width: 30, height: 50, speed: 1.8, direction: 1, type: 'tracking' },
                { x: 550, y: 210, width: 30, height: 50, speed: 1.7, direction: 1, type: 'shooter' },
                { x: 400, y: 180, width: 30, height: 50, speed: 1.6, direction: 1, type: 'flying' },
                { x: 650, y: 150, width: 30, height: 50, speed: 1.9, direction: -1, type: 'flying' },
                { x: 300, y: 120, width: 30, height: 50, speed: 2.0, direction: 1, type: 'jumping' },
                { x: 550, y: 90, width: 30, height: 50, speed: 1.8, direction: 1, type: 'shooter' },
                { x: 800, y: 60, width: 30, height: 50, speed: 2.1, direction: -1, type: 'flying' }
            ]
        },
        // 关卡13 - 高空跳跃挑战
        {
            platforms: [
                { x: 0, y: 450, width: 200, height: 50 },
                { x: 300, y: 400, width: 150, height: 20 },
                { x: 550, y: 350, width: 250, height: 20 },
                { x: 100, y: 300, width: 150, height: 20 },
                { x: 400, y: 250, width: 150, height: 20 },
                { x: 700, y: 200, width: 100, height: 20 },
                { x: 200, y: 150, width: 150, height: 20 },
                { x: 500, y: 100, width: 150, height: 20 },
                { x: 300, y: 50, width: 150, height: 20 },
                { x: 600, y: 0, width: 200, height: 20 }
            ],
            enemies: [
                { x: 100, y: 400, width: 30, height: 50, speed: 2.2, direction: 1, type: 'tracking' },
                { x: 400, y: 400, width: 30, height: 50, speed: 2.3, direction: 1, type: 'exploder' },
                { x: 650, y: 350, width: 30, height: 50, speed: 2.1, direction: 1, type: 'jumping' },
                { x: 200, y: 300, width: 30, height: 50, speed: 2.0, direction: 1, type: 'shooter' },
                { x: 500, y: 250, width: 30, height: 50, speed: 1.9, direction: 1, type: 'flying' },
                { x: 800, y: 200, width: 30, height: 50, speed: 2.2, direction: -1, type: 'flying' },
                { x: 300, y: 150, width: 30, height: 50, speed: 2.1, direction: 1, type: 'tracking' },
                { x: 600, y: 100, width: 30, height: 50, speed: 2.0, direction: 1, type: 'shooter' },
                { x: 400, y: 50, width: 30, height: 50, speed: 1.9, direction: 1, type: 'exploder' },
                { x: 700, y: 0, width: 30, height: 50, speed: 2.2, direction: -1, type: 'flying' }
            ]
        },
        // 关卡14 - 终极敌人组合
        {
            platforms: [
                { x: 0, y: 450, width: 800, height: 50 },
                { x: 100, y: 380, width: 200, height: 20 },
                { x: 400, y: 350, width: 200, height: 20 },
                { x: 700, y: 320, width: 100, height: 20 },
                { x: 200, y: 280, width: 150, height: 20 },
                { x: 500, y: 250, width: 150, height: 20 },
                { x: 300, y: 220, width: 150, height: 20 },
                { x: 600, y: 180, width: 150, height: 20 },
                { x: 100, y: 150, width: 150, height: 20 },
                { x: 400, y: 120, width: 150, height: 20 },
                { x: 200, y: 90, width: 150, height: 20 },
                { x: 500, y: 60, width: 150, height: 20 },
                { x: 300, y: 30, width: 150, height: 20 },
                { x: 600, y: 0, width: 200, height: 20 }
            ],
            enemies: [
                { x: 100, y: 400, width: 30, height: 50, speed: 2.3, direction: 1, type: 'tracking' },
                { x: 300, y: 400, width: 30, height: 50, speed: 2.4, direction: 1, type: 'exploder' },
                { x: 500, y: 400, width: 30, height: 50, speed: 2.5, direction: 1, type: 'normal' },
                { x: 700, y: 400, width: 30, height: 50, speed: 2.2, direction: -1, type: 'tracking' },
                { x: 200, y: 380, width: 30, height: 50, speed: 2.1, direction: 1, type: 'shooter' },
                { x: 500, y: 350, width: 30, height: 50, speed: 2.0, direction: 1, type: 'jumping' },
                { x: 800, y: 320, width: 30, height: 50, speed: 2.3, direction: -1, type: 'flying' },
                { x: 300, y: 280, width: 30, height: 50, speed: 2.2, direction: 1, type: 'exploder' },
                { x: 600, y: 250, width: 30, height: 50, speed: 2.1, direction: 1, type: 'shooter' },
                { x: 400, y: 220, width: 30, height: 50, speed: 2.0, direction: 1, type: 'tracking' },
                { x: 700, y: 180, width: 30, height: 50, speed: 2.3, direction: -1, type: 'flying' },
                { x: 200, y: 150, width: 30, height: 50, speed: 2.2, direction: 1, type: 'jumping' },
                { x: 500, y: 120, width: 30, height: 50, speed: 2.1, direction: 1, type: 'exploder' },
                { x: 300, y: 90, width: 30, height: 50, speed: 2.0, direction: 1, type: 'shooter' },
                { x: 600, y: 60, width: 30, height: 50, speed: 2.3, direction: 1, type: 'flying' },
                { x: 400, y: 30, width: 30, height: 50, speed: 2.2, direction: 1, type: 'tracking' },
                { x: 700, y: 0, width: 30, height: 50, speed: 2.1, direction: 1, type: 'flying' }
            ]
        },
        // 关卡15 - 最终决战
        {
            platforms: [
                { x: 0, y: 450, width: 800, height: 50 },
                { x: 200, y: 350, width: 400, height: 20 },
                { x: 0, y: 250, width: 200, height: 20 },
                { x: 600, y: 250, width: 200, height: 20 },
                { x: 300, y: 150, width: 200, height: 20 },
                { x: 100, y: 50, width: 150, height: 20 },
                { x: 550, y: 50, width: 150, height: 20 }
            ],
            enemies: [
                { x: 100, y: 400, width: 30, height: 50, speed: 2.5, direction: 1, type: 'tracking' },
                { x: 300, y: 400, width: 30, height: 50, speed: 2.6, direction: 1, type: 'exploder' },
                { x: 500, y: 400, width: 30, height: 50, speed: 2.7, direction: 1, type: 'normal' },
                { x: 700, y: 400, width: 30, height: 50, speed: 2.5, direction: -1, type: 'tracking' },
                { x: 300, y: 350, width: 30, height: 50, speed: 2.4, direction: 1, type: 'shooter' },
                { x: 500, y: 350, width: 30, height: 50, speed: 2.3, direction: 1, type: 'jumping' },
                { x: 100, y: 250, width: 30, height: 50, speed: 2.6, direction: 1, type: 'exploder' },
                { x: 700, y: 250, width: 30, height: 50, speed: 2.5, direction: -1, type: 'shooter' },
                { x: 400, y: 150, width: 30, height: 50, speed: 2.4, direction: 1, type: 'tracking' },
                { x: 200, y: 50, width: 30, height: 50, speed: 2.3, direction: 1, type: 'flying' },
                { x: 650, y: 50, width: 30, height: 50, speed: 2.6, direction: -1, type: 'flying' }
            ]
        }
    ];

    // 游戏状态
    let state = {
        player: {
            x: 100,
            y: 350,
            width: 40,
            height: 60,
            velocityX: 0,
            velocityY: 0,
            speed: CONFIG.playerSpeed,
            jumpForce: CONFIG.playerJumpForce,
            gravity: CONFIG.gravity,
            isJumping: false,
            doubleJumped: false,
            health: 100,
            maxHealth: 100,
            isAttacking: false,
            attackType: 'normal',
            attackTimer: null,
            attackCooldown: 0,
            attackPower: 1,
            powerUpTimer: null,
            facingDirection: 1,
            comboCount: 0,
            comboTimer: null,
            invincibilityFrames: 0,
            lastDamageTime: 0
        },
        platforms: [],
        enemies: [],
        props: [],
        particles: [],
        keys: {},
        gameRunning: true,
        lastTime: 0,
        animationId: null,
        currentLevel: 0,
        score: 0,
        difficulty: 'easy',
        completedLevels: [0],
        gameState: 'playing',
        attackEffects: [],
        enemyEffects: [],
        // 优化：添加暂停/恢复机制
        isPaused: false,
        pauseTime: 0,
        totalPausedTime: 0,
        // 优化：添加时间缩放机制
        timeScale: 1.0,
        targetTimeScale: 1.0,
        timeScaleTransitionSpeed: 0.1,
        // 优化：添加状态管理缓存
        stateCache: {
            playerHealth: 100,
            score: 0,
            currentLevel: 0,
            gameState: 'playing'
        },
        // 优化：添加状态更新计数器
        stateUpdateCount: 0,
        // 优化：添加状态更新时间戳
        lastStateUpdateTime: 0
    };

    // 优化：状态更新函数
    function updateStateCache() {
        const now = performance.now();
        const player = state.player;

        // 优化：只在值变化时更新缓存
        if (player.health !== state.stateCache.playerHealth) {
            state.stateCache.playerHealth = player.health;
        }
        if (state.score !== state.stateCache.score) {
            state.stateCache.score = state.score;
        }
        if (state.currentLevel !== state.stateCache.currentLevel) {
            state.stateCache.currentLevel = state.currentLevel;
        }
        if (state.gameState !== state.stateCache.gameState) {
            state.stateCache.gameState = state.gameState;
        }

        // 优化：更新状态管理计数器
        state.stateUpdateCount++;
        state.lastStateUpdateTime = now;
    }

    // 优化：获取状态缓存
    function getStateCache() {
        return state.stateCache;
    }

    // 优化：消息总线，用于模块间通信
    const messageBus = {
        listeners: {},
        // 优化：添加事件监听器
        on: function (event, callback) {
            if (!this.listeners[event]) {
                this.listeners[event] = [];
            }
            this.listeners[event].push(callback);
        },
        // 优化：移除事件监听器
        off: function (event, callback) {
            if (this.listeners[event]) {
                const index = this.listeners[event].indexOf(callback);
                if (index > -1) {
                    this.listeners[event].splice(index, 1);
                }
            }
        },
        // 优化：发送消息
        emit: function (event, data) {
            if (this.listeners[event]) {
                // 优化：使用for循环而不是forEach，提高性能
                for (let i = 0; i < this.listeners[event].length; i++) {
                    try {
                        this.listeners[event][i](data);
                    } catch (error) {
                        console.error('消息总线错误:', error);
                    }
                }
            }
        },
        // 优化：清空所有监听器
        clear: function () {
            this.listeners = {};
        }
    };

    // 优化：注册常用游戏事件
    messageBus.on('player:healthChange', (health) => {
        updateHealthBar();
    });

    messageBus.on('player:scoreChange', (score) => {
        updateUI();
    });

    messageBus.on('game:levelComplete', (levelIndex) => {
        state.completedLevels.push(levelIndex);
    });

    messageBus.on('game:enemyKilled', (enemy) => {
        addParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 20, '#ff0000', 8);
    });

    // 优化的对象池，减少内存分配
    const objectPools = {
        particles: [],
        attackEffects: [],
        enemyEffects: [],
        bullets: [],
        // 优化：添加对象池统计信息
        stats: {
            allocated: 0,
            released: 0,
            hitRate: 0
        }
    };

    // 预分配对象池初始容量，减少动态扩展
    function initializeObjectPools() {
        // 优化：根据设备性能动态调整对象池大小
        const isLowEndDevice = navigator.hardwareConcurrency < 4 || navigator.deviceMemory < 4;

        const particleCount = isLowEndDevice ? 50 : 100;
        const attackEffectCount = isLowEndDevice ? 25 : 50;
        const enemyEffectCount = isLowEndDevice ? 15 : 30;
        const bulletCount = isLowEndDevice ? 100 : 200;

        // 预分配粒子对象
        for (let i = 0; i < particleCount; i++) {
            objectPools.particles.push({
                x: 0, y: 0, vx: 0, vy: 0, size: 0, color: '', life: 0, maxLife: 0, alpha: 0
            });
        }

        // 预分配攻击效果对象
        for (let i = 0; i < attackEffectCount; i++) {
            objectPools.attackEffects.push({
                x: 0, y: 0, width: 0, height: 0, type: '', timer: 0, duration: 0, scale: 0, alpha: 0
            });
        }

        // 预分配敌人效果对象
        for (let i = 0; i < enemyEffectCount; i++) {
            objectPools.enemyEffects.push({
                x: 0, y: 0, width: 0, height: 0, velocityX: 0, velocityY: 0, damage: 0, type: ''
            });
        }

        // 预分配子弹对象（用于敌人和道具）
        for (let i = 0; i < bulletCount; i++) {
            objectPools.bullets.push({
                x: 0, y: 0, width: 0, height: 0, velocityX: 0, velocityY: 0, damage: 0, type: '',
                speed: 0, health: 0, maxHealth: 0, attackDamage: 0, attackRange: 0,
                attackCooldown: 0, lastAttackCooldown: 0, hitStun: 0, isHit: false,
                direction: 0, state: '', patrolPoints: [], patrolIndex: 0,
                targetX: 0, targetY: 0, patrolPath: [], patrolIndex: 0,
                searchAngle: 0, searchRadius: 0, orbitRadius: 0, attackPhase: 0,
                attackTimer: 0, fuseTime: 0, explosionRadius: 0, explosionDamage: 0,
                collected: false, pulseTimer: 0, rotation: 0, rotationSpeed: 0, spawnTime: 0,
                wanderTimer: 0, wanderDirection: 0, explosionTimer: 0, isBlinking: false
            });
        }

        // 优化：初始化对象池统计
        objectPools.stats.allocated = particleCount + attackEffectCount + enemyEffectCount + bulletCount;
    }

    // 优化的对象池管理函数，使用更高效的对象复用
    function getObjectFromPool(pool, type) {
        if (pool.length > 0) {
            // 优化：使用pop而不是shift，提高性能
            const obj = pool.pop();

            // 优化：更新对象池统计
            objectPools.stats.released++;
            objectPools.stats.hitRate = objectPools.stats.released / objectPools.stats.allocated;

            return obj;
        }

        // 优化：对象池为空时，创建新对象
        const newObj = createObjectByType(type);
        objectPools.stats.allocated++;
        return newObj;
    }

    // 优化：根据类型创建对象
    function createObjectByType(type) {
        switch (type) {
            case 'particle':
                return { x: 0, y: 0, vx: 0, vy: 0, size: 0, color: '', life: 0, maxLife: 0, alpha: 0 };
            case 'attackEffect':
                return { x: 0, y: 0, width: 0, height: 0, type: '', timer: 0, duration: 0, scale: 0, alpha: 0 };
            case 'enemyEffect':
                return { x: 0, y: 0, width: 0, height: 0, velocityX: 0, velocityY: 0, damage: 0, type: '' };
            case 'bullet':
                return {
                    x: 0, y: 0, width: 0, height: 0, velocityX: 0, velocityY: 0, damage: 0, type: '',
                    speed: 0, health: 0, maxHealth: 0, attackDamage: 0, attackRange: 0,
                    attackCooldown: 0, lastAttackCooldown: 0, hitStun: 0, isHit: false,
                    direction: 0, state: '', patrolPoints: [], patrolIndex: 0,
                    targetX: 0, targetY: 0, patrolPath: [], patrolIndex: 0,
                    searchAngle: 0, searchRadius: 0, orbitRadius: 0, attackPhase: 0,
                    attackTimer: 0, fuseTime: 0, explosionRadius: 0, explosionDamage: 0,
                    collected: false, pulseTimer: 0, rotation: 0, rotationSpeed: 0, spawnTime: 0,
                    wanderTimer: 0, wanderDirection: 0, explosionTimer: 0, isBlinking: false
                };
            default:
                return {};
        }
    }

    // 优化的对象池释放函数，使用更高效的对象回收
    function releaseObjectToPool(pool, obj) {
        // 优化：检查对象池大小，避免无限增长
        const maxPoolSize = pool === objectPools.particles ? 200 :
            pool === objectPools.attackEffects ? 100 :
                pool === objectPools.enemyEffects ? 60 : 200;

        if (pool.length < maxPoolSize) {
            // 优化：重置对象属性
            resetObjectProperties(obj);
            pool.push(obj);
        }
    }

    // 优化：重置对象属性
    function resetObjectProperties(obj) {
        for (const key in obj) {
            if (Array.isArray(obj[key])) {
                obj[key] = [];
            } else if (typeof obj[key] === 'number') {
                obj[key] = 0;
            } else if (typeof obj[key] === 'boolean') {
                obj[key] = false;
            } else if (typeof obj[key] === 'string') {
                obj[key] = '';
            }
        }
    }

    // 优化：手动触发垃圾回收
    function triggerGarbageCollection() {
        // 优化：只在内存压力大时触发垃圾回收
        if (performance.memory && performance.memory.usedJSHeapSize > performance.memory.jsHeapSizeLimit * 0.8) {
            // 优化：清理不再使用的对象
            cleanUpUnusedObjects();

            // 优化：触发垃圾回收（如果可用）
            if (window.gc) {
                window.gc();
            }
        }
    }

    // 优化：清理不再使用的对象
    function cleanUpUnusedObjects() {
        // 优化：清理过期的粒子
        state.particles = state.particles.filter(p => p.life > 0);

        // 优化：清理过期的攻击效果
        state.attackEffects = state.attackEffects.filter(e => e.timer < e.duration);

        // 优化：清理过期的敌人效果
        state.enemyEffects = state.enemyEffects.filter(e => e.life > 0);

        // 优化：清理已收集的道具
        state.props = state.props.filter(p => !p.collected);
    }


    // 优化：重置对象状态的辅助函数
    function resetObjectState(obj, type) {
        // 优化：批量重置对象属性，减少重复操作
        const resetProps = ['x', 'y', 'vx', 'vy', 'width', 'height', 'velocityX', 'velocityY',
            'damage', 'life', 'maxLife', 'alpha', 'timer', 'duration', 'scale'];

        for (let i = 0; i < resetProps.length; i++) {
            obj[resetProps[i]] = 0;
        }

        // 根据对象类型重置特定属性
        switch (type) {
            case 'particle':
                obj.color = '';
                obj.size = 0;
                break;
            case 'attackEffect':
                obj.type = '';
                obj.scale = 0;
                obj.alpha = 0;
                break;
            case 'enemyEffect':
                obj.type = '';
                break;
            case 'bullet':
                obj.type = '';
                obj.speed = 0;
                obj.health = 0;
                obj.maxHealth = 0;
                obj.attackDamage = 0;
                obj.attackRange = 0;
                obj.attackCooldown = 0;
                obj.lastAttackCooldown = 0;
                obj.hitStun = 0;
                obj.isHit = false;
                obj.direction = 0;
                obj.state = '';
                obj.patrolPoints = [];
                obj.patrolIndex = 0;
                obj.targetX = 0;
                obj.targetY = 0;
                obj.patrolPath = [];
                obj.patrolIndex = 0;
                obj.searchAngle = 0;
                obj.searchRadius = 0;
                obj.orbitRadius = 0;
                obj.attackPhase = 0;
                obj.attackTimer = 0;
                obj.fuseTime = 0;
                obj.explosionRadius = 0;
                obj.explosionDamage = 0;
                obj.collected = false;
                obj.pulseTimer = 0;
                obj.rotation = 0;
                obj.rotationSpeed = 0;
                obj.spawnTime = 0;
                obj.wanderTimer = 0;
                obj.wanderDirection = 0;
                obj.explosionTimer = 0;
                obj.isBlinking = false;
                break;
        }
    }

    // 优化：创建新对象的辅助函数
    function createNewObject(type) {
        switch (type) {
            case 'particle':
                return { x: 0, y: 0, vx: 0, vy: 0, size: 0, color: '', life: 0, maxLife: 0, alpha: 0 };
            case 'attackEffect':
                return { x: 0, y: 0, width: 0, height: 0, type: '', timer: 0, duration: 0, scale: 0, alpha: 0 };
            case 'enemyEffect':
                return { x: 0, y: 0, width: 0, height: 0, velocityX: 0, velocityY: 0, damage: 0, type: '' };
            case 'bullet':
                return createBulletObject();
            default:
                return {};
        }
    }

    // 优化：创建子弹对象的专用函数
    function createBulletObject() {
        return {
            x: 0, y: 0, width: 0, height: 0, velocityX: 0, velocityY: 0, damage: 0, type: '',
            speed: 0, health: 0, maxHealth: 0, attackDamage: 0, attackRange: 0,
            attackCooldown: 0, lastAttackCooldown: 0, hitStun: 0, isHit: false,
            direction: 0, state: '', patrolPoints: [], patrolIndex: 0,
            targetX: 0, targetY: 0, patrolPath: [], patrolIndex: 0,
            searchAngle: 0, searchRadius: 0, orbitRadius: 0, attackPhase: 0,
            attackTimer: 0, fuseTime: 0, explosionRadius: 0, explosionDamage: 0,
            collected: false, pulseTimer: 0, rotation: 0, rotationSpeed: 0, spawnTime: 0,
            wanderTimer: 0, wanderDirection: 0, explosionTimer: 0, isBlinking: false
        };
    }

    function releaseObjectToPool(pool, obj) {
        // 重置对象状态，避免内存泄漏
        for (let key in obj) {
            if (key !== 'x' && key !== 'y' && key !== 'velocityX' && key !== 'velocityY') {
                obj[key] = 0;
            }
        }

        // 限制池子大小，防止内存泄漏
        const maxPoolSize = pool === objectPools.particles ? 200 :
            pool === objectPools.attackEffects ? 100 :
                pool === objectPools.enemyEffects ? 60 : 200;

        if (pool.length < maxPoolSize) {
            pool.push(obj);
        }
    }

    // 初始化游戏
    function initGame() {
        canvas = document.getElementById('gameCanvas');
        ctx = canvas.getContext('2d');
        jumpBtn = document.getElementById('jumpBtn');
        attackBtn = document.getElementById('attackBtn');
        healthFill = document.querySelector('.health-progress');

        tutorialBtn = document.getElementById('tutorialBtn');
        difficultyBtn = document.getElementById('difficultyBtn');
        levelBtn = document.getElementById('levelBtn');
        exportBtn = document.getElementById('exportBtn');

        tutorialPanel = document.getElementById('tutorialPanel');
        difficultyPanel = document.getElementById('difficultyPanel');
        levelPanel = document.getElementById('levelPanel');

        currentLevelEl = document.getElementById('currentLevel');
        scoreEl = document.getElementById('score');
        difficultyEl = document.getElementById('difficulty');

        levelGrid = document.getElementById('levelGrid');
        modalCloseBtns = document.querySelectorAll('.close');

        canvas.width = CONFIG.canvasWidth;
        canvas.height = CONFIG.canvasHeight;

        // 初始化对象池
        initializeObjectPools();

        loadLevel(state.currentLevel);
        setupEventListeners();
        setupModalListeners();
        generateLevelButtons();
        addSaveLoadButtons();

        state.lastTime = performance.now();
        state.animationId = requestAnimationFrame(gameLoop);
    }

    // 加载关卡
    function loadLevel(levelIndex) {
        if (levelIndex < 0 || levelIndex >= LEVELS.length) return;

        const startTime = performance.now();

        state.currentLevel = levelIndex;
        state.gameState = 'playing';

        // 优化：批量重置玩家状态
        const player = state.player;
        player.x = 100;
        player.y = 350;
        player.velocityX = 0;
        player.velocityY = 0;
        player.isJumping = false;
        player.doubleJumped = false;
        player.health = DIFFICULTY_CONFIG[state.difficulty].playerHealth;
        player.maxHealth = DIFFICULTY_CONFIG[state.difficulty].playerHealth;
        player.isAttacking = false;
        player.attackPower = 1;
        player.comboCount = 0;
        player.invincibilityFrames = 0;

        // 优化：清理计时器
        if (player.powerUpTimer) {
            clearTimeout(player.powerUpTimer);
            player.powerUpTimer = null;
        }
        if (player.comboTimer) {
            clearTimeout(player.comboTimer);
            player.comboTimer = null;
        }

        state.platforms = JSON.parse(JSON.stringify(LEVELS[levelIndex].platforms));
        // 使用对象池管理敌人数组
        state.enemies = [];

        // 优化：缓存难度配置
        const difficultyConfig = DIFFICULTY_CONFIG[state.difficulty];
        const difficultyMultiplier = {
            easy: 0.8,
            medium: 1.0,
            hard: 1.3
        }[state.difficulty] || 1.0;

        // 优化：预分配敌人对象到池子中
        const levelEnemies = LEVELS[levelIndex].enemies;
        const enemyCount = levelEnemies.length;
        const enemySpeedMultiplier = difficultyConfig.enemySpeed * difficultyMultiplier;

        for (let i = 0; i < enemyCount; i++) {
            const enemy = getObjectFromPool(objectPools.bullets, 'bullet');
            const levelEnemy = levelEnemies[i];

            // 优化：使用批量属性赋值
            Object.assign(enemy, levelEnemy);
            enemy.speed *= enemySpeedMultiplier;
            enemy.health = Math.round((enemy.health || 100) * difficultyMultiplier);
            enemy.maxHealth = enemy.health;
            enemy.attackDamage = (enemy.attackDamage || 10) * difficultyMultiplier;
            enemy.attackRange = (enemy.attackRange || 80) * difficultyMultiplier;
            state.enemies.push(enemy);
        }

        spawnProps(levelIndex);
        state.particles = [];
        state.attackEffects = [];
        state.enemyEffects = [];

        updateUI();
        updateHealthBar();
    }

    // 生成道具
    function spawnProps(levelIndex) {
        state.props = [];

        const basePropCount = Math.min(Math.floor(levelIndex / 2) + 2, 5);
        const difficultyMultiplier = {
            easy: 1.3,
            medium: 1.1,
            hard: 0.9
        }[state.difficulty] || 1.0;
        const propCount = Math.max(1, Math.round(basePropCount * difficultyMultiplier));

        const propTypes = ['health', 'powerup', 'invincibility', 'speedboost', 'shield', 'combo', 'timefreeze', 'bombdrop'];

        for (let i = 0; i < propCount; i++) {
            let propType;
            const rand = Math.random();

            if (levelIndex < 3) {
                if (rand < 0.6) {
                    propType = 'health';
                } else if (rand < 0.9) {
                    propType = 'powerup';
                } else {
                    propType = propTypes[Math.floor(Math.random() * propTypes.length)];
                }
            } else if (levelIndex < 7) {
                if (rand < 0.4) {
                    propType = 'health';
                } else if (rand < 0.65) {
                    propType = 'powerup';
                } else if (rand < 0.85) {
                    propType = ['invincibility', 'speedboost'][Math.floor(Math.random() * 2)];
                } else {
                    propType = propTypes[Math.floor(Math.random() * propTypes.length)];
                }
            } else {
                const advancedProps = ['invincibility', 'speedboost', 'shield', 'combo', 'timefreeze', 'bombdrop'];
                if (rand < 0.25) {
                    propType = 'health';
                } else if (rand < 0.5) {
                    propType = 'powerup';
                } else {
                    propType = advancedProps[Math.floor(Math.random() * advancedProps.length)];
                }
            }

            const platformIndex = Math.floor(Math.random() * (state.platforms.length - 1)) + 1;
            const platform = state.platforms[platformIndex];

            const prop = getObjectFromPool(objectPools.bullets, 'bullet');
            prop.x = platform.x + Math.random() * (platform.width - 25);
            prop.y = platform.y - 35;
            prop.width = 25;
            prop.height = 25;
            prop.type = propType;
            prop.collected = false;
            prop.pulseTimer = 0;
            prop.rotation = Math.random() * Math.PI * 2;
            prop.rotationSpeed = (Math.random() - 0.5) * 0.1;
            prop.spawnTime = state.lastTime;

            state.props.push(prop);
        }
    }

    // 优化的道具更新函数，使用对象池释放机制
    function updateProps() {
        const player = state.player;
        const props = state.props;
        const propCount = props.length;

        // 优化：缓存玩家位置，减少重复计算
        const playerX = player.x;
        const playerY = player.y;
        const playerWidth = player.width;
        const playerHeight = player.height;

        // 优化：只检测玩家附近的道具
        const detectionRadius = 150;
        const detectionRadiusSquared = detectionRadius * detectionRadius;

        for (let i = 0; i < propCount; i++) {
            const prop = props[i];
            if (!prop.collected) {
                // 优化：先进行距离检测，避免不必要的碰撞检测
                const dx = (prop.x + prop.width / 2) - (playerX + playerWidth / 2);
                const dy = (prop.y + prop.height / 2) - (playerY + playerHeight / 2);
                const distanceSquared = dx * dx + dy * dy;

                if (distanceSquared < detectionRadiusSquared) {
                    // 优化：距离足够近时才进行碰撞检测
                    if (
                        playerX < prop.x + prop.width &&
                        playerX + playerWidth > prop.x &&
                        playerY < prop.y + prop.height &&
                        playerY + playerHeight > prop.y
                    ) {
                        collectProp(prop);
                    }
                }

                // 优化：减少道具动画更新频率
                if (state.performanceMetrics.frameCount % 2 === 0) {
                    prop.pulseTimer += 0.05;
                }
            }
        }
    }

    // 优化的收集道具函数，使用对象池释放机制
    function collectProp(prop) {
        prop.collected = true;

        addParticles(prop.x + prop.width / 2, prop.y + prop.height / 2, 20, '#ffff00', 6);

        switch (prop.type) {
            case 'health':
                const healthRestore = 40;
                state.player.health = Math.min(state.player.health + healthRestore, state.player.maxHealth);
                updateHealthBar();
                state.score += 15;
                break;
            case 'powerup':
                state.player.attackPower = 2.8;
                if (state.player.powerUpTimer) {
                    clearTimeout(state.player.powerUpTimer);
                }
                state.player.powerUpTimer = setTimeout(() => {
                    state.player.attackPower = 1;
                }, 7000);
                state.score += 25;
                break;
            case 'invincibility':
                state.player.invincibilityFrames = 700;
                state.score += 40;
                break;
            case 'speedboost':
                const originalSpeed = state.player.speed;
                state.player.speed *= 1.6;
                setTimeout(() => {
                    state.player.speed = originalSpeed;
                }, 5500);
                state.score += 30;
                break;
            case 'shield':
                state.player.shield = (state.player.shield || 0) + 50;
                state.player.maxShield = Math.max(state.player.maxShield || 0, state.player.shield);
                state.score += 35;
                break;
            case 'combo':
                state.player.comboCount += 5;
                state.score += 50;
                break;
            case 'timefreeze':
                state.timeFrozen = true;
                state.timeFreezeTimer = 300;
                state.score += 45;
                break;
            case 'bombdrop':
                dropBomb();
                state.score += 35;
                break;
        }

        // 将道具对象释放回对象池
        releaseObjectToPool(objectPools.bullets, prop);

        updateUI();
    }

    // 优化的炸弹投掷系统，使用对象池管理
    function dropBomb() {
        const bomb = getObjectFromPool(objectPools.bullets, 'bullet');
        bomb.x = state.player.x + state.player.width / 2 - 15;
        bomb.y = state.player.y;
        bomb.width = 30;
        bomb.height = 30;
        bomb.type = 'bomb';
        bomb.timer = 0;
        bomb.fuseTime = 60;
        bomb.explosionRadius = 120;
        bomb.explosionDamage = 35;

        state.props.push(bomb);
    }

    // 更新炸弹
    function updateBombs() {
        const props = state.props;
        const propCount = props.length;
        const platforms = state.platforms;

        // 优化：限制炸弹更新频率
        if (state.performanceMetrics.frameCount % 2 !== 0) {
            return;
        }

        for (let i = 0; i < propCount; i++) {
            const prop = props[i];
            if (prop.type === 'bomb') {
                prop.timer++;

                if (prop.timer >= prop.fuseTime) {
                    explodeBomb(prop, i);
                } else {
                    prop.y += 5;

                    // 优化：使用空间分割优化炸弹平台碰撞检测
                    const cellSize = 100;
                    const bombCellX = Math.floor(prop.x / cellSize);
                    const bombCellY = Math.floor(prop.y / cellSize);

                    let hitGround = false;

                    // 只检测炸弹所在单元格和相邻单元格的平台
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            const platformCellX = bombCellX + dx;
                            const platformCellY = bombCellY + dy;

                            for (let j = 0; j < platforms.length; j++) {
                                const platform = platforms[j];
                                const platformCellX2 = Math.floor(platform.x / cellSize);
                                const platformCellY2 = Math.floor(platform.y / cellSize);

                                if (platformCellX === platformCellX2 && platformCellY === platformCellY2) {
                                    if (
                                        prop.x < platform.x + platform.width &&
                                        prop.x + prop.width > platform.x &&
                                        prop.y + prop.height > platform.y &&
                                        prop.y + prop.height < platform.y + 15
                                    ) {
                                        prop.y = platform.y - prop.height;
                                        hitGround = true;
                                        break;
                                    }
                                }
                            }
                            if (hitGround) break;
                        }
                        if (hitGround) break;
                    }

                    if (hitGround) {
                        prop.fuseTime = Math.min(prop.fuseTime, prop.timer + 20);
                    }
                }
            }
        }
    }

    // 优化的炸弹爆炸函数，使用对象池释放机制
    function explodeBomb(prop, index) {
        addParticles(prop.x + prop.width / 2, prop.y + prop.height / 2, 60, '#ff6600', 18);
        addParticles(prop.x + prop.width / 2, prop.y + prop.height / 2, 40, '#ff0000', 22);

        const enemiesToRemove = [];
        const enemiesToRelease = [];

        state.enemies.forEach((enemy, enemyIndex) => {
            const dx = enemy.x + enemy.width / 2 - (prop.x + prop.width / 2);
            const dy = enemy.y + enemy.height / 2 - (prop.y + prop.height / 2);
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < prop.explosionRadius) {
                const damageMultiplier = 1 - (distance / prop.explosionRadius);
                const finalDamage = Math.round(prop.explosionDamage * damageMultiplier);
                enemy.health -= finalDamage;

                const knockbackForce = 6 * damageMultiplier;
                enemy.velocityX = (enemy.x - prop.x) > 0 ? knockbackForce : -knockbackForce;
                enemy.velocityY = -knockbackForce * 0.5;

                if (enemy.health <= 0) {
                    addParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 25, '#ff0000', 12);
                    enemiesToRemove.push(enemyIndex);
                    enemiesToRelease.push(enemy);
                }
            }
        });

        // 从后往前删除敌人，避免索引问题
        for (let i = enemiesToRemove.length - 1; i >= 0; i--) {
            state.enemies.splice(enemiesToRemove[i], 1);
        }

        // 将敌人对象释放回对象池
        for (let i = 0; i < enemiesToRelease.length; i++) {
            releaseObjectToPool(objectPools.bullets, enemiesToRelease[i]);
        }

        // 将炸弹对象释放回对象池
        releaseObjectToPool(objectPools.bullets, prop);

        state.props.splice(index, 1);
        checkLevelComplete();
    }

    // 绘制道具
    function drawProps() {
        state.props.forEach(prop => {
            if (!prop.collected) {
                const pulseScale = 1 + Math.sin(prop.pulseTimer) * 0.1;

                ctx.save();
                ctx.translate(prop.x + prop.width / 2, prop.y + prop.height / 2);
                ctx.scale(pulseScale, pulseScale);

                if (prop.type === 'health') {
                    ctx.fillStyle = '#ff3333';
                    ctx.shadowColor = '#ff6666';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.bezierCurveTo(15, -25, 20, -5, 0, 10);
                    ctx.bezierCurveTo(-20, -5, -15, -25, 0, -10);
                    ctx.fill();
                } else if (prop.type === 'powerup') {
                    ctx.fillStyle = '#ffff33';
                    ctx.shadowColor = '#ffff66';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
                        const x = 10 * Math.cos(angle);
                        const y = 10 * Math.sin(angle);
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                        const innerAngle = ((i + 0.5) * 2 * Math.PI) / 5 - Math.PI / 2;
                        const innerX = 5 * Math.cos(innerAngle);
                        const innerY = 5 * Math.sin(innerAngle);
                        ctx.lineTo(innerX, innerY);
                    }
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();
            }
        });
    }

    // 设置事件监听
    function setupEventListeners() {
        // 优化：使用防抖技术优化键盘事件处理
        let keydownDebounceTimer = null;
        window.addEventListener('keydown', (e) => {
            // 优化：立即更新按键状态
            state.keys[e.key] = true;

            // 优化：使用防抖减少重复处理
            if (keydownDebounceTimer) {
                clearTimeout(keydownDebounceTimer);
            }
            keydownDebounceTimer = setTimeout(() => {
                keydownDebounceTimer = null;
            }, 50);
        });

        // 优化：使用防抖技术优化键盘事件处理
        let keyupDebounceTimer = null;
        window.addEventListener('keyup', (e) => {
            // 优化：立即更新按键状态
            state.keys[e.key] = false;

            // 优化：使用防抖减少重复处理
            if (keyupDebounceTimer) {
                clearTimeout(keyupDebounceTimer);
            }
            keyupDebounceTimer = setTimeout(() => {
                keyupDebounceTimer = null;
            }, 50);
        });

        // 优化：输入系统性能优化
        const InputOptimizer = {
            /**
             * 优化输入处理
             * @param {Object} inputState - 输入状态
             * @returns {Object} 优化后的输入状态
             */
            optimizeInput: function (inputState) {
                // 优化：批量处理输入
                const optimizedInput = {
                    moveLeft: inputState.moveLeft && !inputState.moveRight,
                    moveRight: inputState.moveRight && !inputState.moveLeft,
                    jump: inputState.jump && !inputState.releaseJump,
                    attackNormal: inputState.attackNormal && !inputState.attackHeavy && !inputState.attackSpecial,
                    attackHeavy: inputState.attackHeavy && !inputState.attackNormal && !inputState.attackSpecial,
                    attackSpecial: inputState.attackSpecial && !inputState.attackNormal && !inputState.attackHeavy
                };
                return optimizedInput;
            },

            /**
             * 优化输入事件处理
             * @param {Function} callback - 回调函数
             * @param {number} delay - 延迟时间
             * @returns {Function} 优化后的回调函数
             */
            debounceInput: function (callback, delay) {
                let timer = null;
                return function () {
                    if (timer) {
                        clearTimeout(timer);
                    }
                    timer = setTimeout(() => {
                        callback.apply(this, arguments);
                        timer = null;
                    }, delay);
                };
            },

            /**
             * 优化输入事件处理
             * @param {Function} callback - 回调函数
             * @param {number} delay - 延迟时间
             * @returns {Function} 优化后的回调函数
             */
            throttleInput: function (callback, delay) {
                let lastTime = 0;
                return function () {
                    const now = Date.now();
                    if (now - lastTime >= delay) {
                        callback.apply(this, arguments);
                        lastTime = now;
                    }
                };
            }
        };

        // 优化：使用事件委托优化按钮点击事件
        if (jumpBtn) {
            jumpBtn.replaceWith(jumpBtn.cloneNode(true));
            jumpBtn = document.getElementById('jumpBtn');
            jumpBtn.addEventListener('click', (e) => {
                e.preventDefault();
                if (state.gameState === 'playing') {
                    if (!state.player.isJumping) {
                        state.player.velocityY = state.player.jumpForce;
                        state.player.isJumping = true;
                    }
                }
            }, { passive: false });
        }

        if (attackBtn) {
            attackBtn.replaceWith(attackBtn.cloneNode(true));
            attackBtn = document.getElementById('attackBtn');
            attackBtn.addEventListener('click', (e) => {
                e.preventDefault();
                if (state.gameState === 'playing') {
                    if (!state.player.isAttacking) {
                        state.player.isAttacking = true;
                        if (state.player.attackTimer) {
                            clearTimeout(state.player.attackTimer);
                        }
                        state.player.attackTimer = setTimeout(() => {
                            state.player.isAttacking = false;
                        }, CONFIG.attackDuration);
                    }
                }
            });
        }
    }

    // 设置模态框监听
    function setupModalListeners() {
        if (!tutorialPanel || !difficultyPanel || !levelPanel) {
            console.error('模态框元素未找到');
            return;
        }

        modalCloseBtns.forEach(btn => {
            btn.replaceWith(btn.cloneNode(true));
        });

        modalCloseBtns = document.querySelectorAll('.close');
        modalCloseBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const modal = btn.closest('.modal');
                if (modal) {
                    modal.style.display = 'none';
                }
            });
        });

        window.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                e.target.style.display = 'none';
            }
        });

        if (tutorialBtn) {
            tutorialBtn.replaceWith(tutorialBtn.cloneNode(true));
            tutorialBtn = document.getElementById('tutorialBtn');
            tutorialBtn.addEventListener('click', () => {
                tutorialPanel.style.display = 'block';
            });
        }

        if (difficultyBtn) {
            difficultyBtn.replaceWith(difficultyBtn.cloneNode(true));
            difficultyBtn = document.getElementById('difficultyBtn');
            difficultyBtn.addEventListener('click', () => {
                difficultyPanel.style.display = 'block';
            });
        }

        const difficultyOptions = document.querySelectorAll('.difficulty-option');
        difficultyOptions.forEach(option => {
            option.replaceWith(option.cloneNode(true));
        });

        document.querySelectorAll('.difficulty-option').forEach(option => {
            option.addEventListener('click', () => {
                const difficulty = option.dataset.difficulty;
                if (difficulty) {
                    setDifficulty(difficulty);
                    difficultyPanel.style.display = 'none';
                }
            });
        });

        if (levelBtn) {
            levelBtn.replaceWith(levelBtn.cloneNode(true));
            levelBtn = document.getElementById('levelBtn');
            levelBtn.addEventListener('click', () => {
                generateLevelButtons();
                levelPanel.style.display = 'block';
            });
        }

        if (exportBtn) {
            exportBtn.replaceWith(exportBtn.cloneNode(true));
            exportBtn = document.getElementById('exportBtn');
            exportBtn.addEventListener('click', exportGameData);
        }
    }

    // 生成关卡按钮
    function generateLevelButtons() {
        if (!levelGrid) {
            console.error('关卡网格元素未找到');
            return;
        }

        levelGrid.innerHTML = '';

        for (let i = 0; i < LEVELS.length; i++) {
            const btn = document.createElement('button');
            btn.className = 'level-btn';
            btn.textContent = i + 1;

            if (i === 0 || state.completedLevels.includes(i - 1)) {
                btn.addEventListener('click', () => {
                    loadLevel(i);
                    levelPanel.style.display = 'none';
                });
            } else {
                btn.classList.add('locked');
                btn.disabled = true;
                btn.title = '需要先完成前一个关卡';
            }

            levelGrid.appendChild(btn);
        }
    }

    // 设置难度
    function setDifficulty(difficulty) {
        state.difficulty = difficulty;
        state.player.health = DIFFICULTY_CONFIG[difficulty].playerHealth;
        updateHealthBar();
        updateUI();
        loadLevel(state.currentLevel);
    }

    // 更新UI
    function updateUI() {
        // 优化：缓存UI元素，减少DOM查询
        if (!state.uiElements) {
            state.uiElements = {
                currentLevelEl: currentLevelEl,
                scoreEl: scoreEl,
                difficultyEl: difficultyEl
            };
        }

        // 优化：只在值变化时更新UI
        const uiElements = state.uiElements;
        const currentLevelText = `关卡: ${state.currentLevel + 1}`;
        const scoreText = `分数: ${state.score}`;
        const difficultyText = `难度: ${state.difficulty === 'easy' ? '简单' : state.difficulty === 'medium' ? '中等' : '困难'}`;

        if (uiElements.currentLevelEl.textContent !== currentLevelText) {
            uiElements.currentLevelEl.textContent = currentLevelText;
        }

        if (uiElements.scoreEl.textContent !== scoreText) {
            uiElements.scoreEl.textContent = scoreText;
        }

        if (uiElements.difficultyEl.textContent !== difficultyText) {
            uiElements.difficultyEl.textContent = difficultyText;
        }
    }

    // 优化：分离输入处理函数
    function processInput() {
        const player = state.player;
        const inputState = {
            moveLeft: state.keys['ArrowLeft'] || false,
            moveRight: state.keys['ArrowRight'] || false,
            jump: state.keys['ArrowUp'] || false,
            attackNormal: state.keys[' '] || false,
            attackHeavy: state.keys['Control'] || false,
            attackSpecial: state.keys['Shift'] || false,
            releaseJump: !state.keys['ArrowUp']
        };

        return inputState;
    }

    // 优化：分离碰撞检测函数
    function checkCollisions() {
        const player = state.player;
        let isOnGround = false;
        const playerLeft = player.x;
        const playerRight = player.x + player.width;
        const playerTop = player.y;
        const playerBottom = player.y + player.height;

        // 平台碰撞检测
        const platforms = state.platforms;
        const platformCount = platforms.length;

        // 优化：根据平台数量选择不同的碰撞检测策略
        if (platformCount > 20) {
            // 平台数量较多时，使用空间分割
            return performSpatialPlatformCollision(player, playerLeft, playerRight, playerTop, playerBottom);
        } else {
            // 平台数量较少时，使用简单碰撞检测
            return performSimplePlatformCollision(player, platforms, playerLeft, playerRight, playerTop, playerBottom);
        }
    }

    // 优化：执行空间分割平台碰撞检测
    function performSpatialPlatformCollision(player, playerLeft, playerRight, playerTop, playerBottom) {
        let isOnGround = false;
        const cellSize = 100; // 空间分割单元格大小
        const spatialGrid = {};
        const platforms = state.platforms;

        // 优化：使用更高效的空间分割算法
        // 将平台放入空间网格
        for (let i = 0; i < platforms.length; i++) {
            const platform = platforms[i];
            const cellX = Math.floor(platform.x / cellSize);
            const cellY = Math.floor(platform.y / cellSize);
            const cellKey = `${cellX},${cellY}`;

            if (!spatialGrid[cellKey]) {
                spatialGrid[cellKey] = [];
            }
            spatialGrid[cellKey].push(platform);
        }

        // 只检测玩家所在单元格和相邻单元格的平台
        const playerCellX = Math.floor(player.x / cellSize);
        const playerCellY = Math.floor(player.y / cellSize);

        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                const cellKey = `${playerCellX + dx},${playerCellY + dy}`;
                const platformsInCell = spatialGrid[cellKey];

                if (platformsInCell) {
                    // 优化：使用更高效的AABB碰撞检测
                    for (let i = 0; i < platformsInCell.length; i++) {
                        const platform = platformsInCell[i];

                        // 优化：快速排除不相交的矩形
                        if (playerRight <= platform.x || playerLeft >= platform.x + platform.width ||
                            playerBottom <= platform.y || playerTop >= platform.y + platform.height) {
                            continue;
                        }

                        // 优化：计算碰撞深度和方向
                        const overlapLeft = playerRight - platform.x;
                        const overlapRight = platform.x + platform.width - playerLeft;
                        const overlapTop = playerBottom - platform.y;
                        const overlapBottom = platform.y + platform.height - playerTop;

                        const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                        if (minOverlap === overlapTop) {
                            if (player.velocityY > 0) {
                                player.y = platform.y - player.height;
                                player.velocityY = 0;
                                isOnGround = true;

                                // 优化：添加着陆粒子效果
                                const px1 = player.x + player.width / 4;
                                const px2 = player.x + player.width * 3 / 4;
                                const py = player.y + player.height;
                                addParticles(px1, py, 3, '#aaaaaa', 2);
                                addParticles(px2, py, 3, '#aaaaaa', 2);
                            }
                        } else if (minOverlap === overlapBottom) {
                            if (player.velocityY < 0) {
                                player.y = platform.y + platform.height;
                                player.velocityY *= -0.4;
                            }
                        } else if (minOverlap === overlapLeft) {
                            player.x = platform.x - player.width;
                            player.velocityX *= -0.2;
                        } else {
                            player.x = platform.x + platform.width;
                            player.velocityX *= -0.2;
                        }
                    }
                }
            }
        }

        // 优化：应用摩擦力
        if (isOnGround) {
            player.isJumping = false;
            player.doubleJumped = false;
            player.coyoteTimer = 0;

            const groundFriction = 0.85;
            player.velocityX *= groundFriction;
        } else {
            const airResistance = 0.98;
            player.velocityX *= airResistance;
        }

        return isOnGround;
    }


    // 优化：执行简单平台碰撞检测
    function performSimplePlatformCollision(player, platforms, playerLeft, playerRight, playerTop, playerBottom) {
        let isOnGround = false;
        const platformCount = platforms.length;

        for (let i = 0; i < platformCount; i++) {
            const platform = platforms[i];
            const result = checkPlatformCollision(player, platform, playerLeft, playerRight, playerTop, playerBottom);
            if (result === 'ground') {
                isOnGround = true;
            }
        }

        return isOnGround;
    }

    // 优化：检查单个平台碰撞
    function checkPlatformCollision(player, platform, playerLeft, playerRight, playerTop, playerBottom) {
        const pl = platform.x;
        const pr = pl + platform.width;
        const pt = platform.y;
        const pb = pt + platform.height;

        if (playerRight <= pl || playerLeft >= pr || playerBottom <= pt || playerTop >= pb) {
            return 'none';
        }

        const ld = playerRight - pl;
        const rd = pr - playerLeft;
        const td = playerBottom - pt;
        const bd = pb - playerTop;

        const depths = [ld, rd, td, bd];
        const minIndex = depths.indexOf(Math.min(...depths));

        switch (minIndex) {
            case 0: // left
                player.x = pl - player.width;
                player.velocityX *= -0.2;
                break;
            case 1: // right
                player.x = pr;
                player.velocityX *= -0.2;
                break;
            case 2: // top
                if (player.velocityY > 0) {
                    player.y = pt - player.height;
                    player.velocityY = 0;

                    const px1 = player.x + player.width / 4;
                    const px2 = player.x + player.width * 3 / 4;
                    const py = player.y + player.height;
                    addParticles(px1, py, 3, '#aaaaaa', 2);
                    addParticles(px2, py, 3, '#aaaaaa', 2);

                    return 'ground';
                }
                break;
            case 3: // bottom
                if (player.velocityY < 0) {
                    player.y = pb;
                    player.velocityY *= -0.4;
                }
                break;
        }

        return 'none';
    }

    // 优化：分离物理更新函数
    function updatePhysics() {
        const player = state.player;

        // 优化：使用更高效的重力计算
        const gravity = player.isJumping && state.keys['ArrowUp'] ? player.gravity * 0.8 : player.gravity;
        player.velocityY += gravity;

        // 优化：批量更新位置，减少计算
        player.x += player.velocityX;
        player.y += player.velocityY;

        // 优化：使用更高效的边界检测
        const canvasWidth = CONFIG.canvasWidth;
        const canvasHeight = CONFIG.canvasHeight;

        if (player.x < 0) {
            player.x = 0;
            player.velocityX *= -0.3;
        }
        if (player.x + player.width > canvasWidth) {
            player.x = canvasWidth - player.width;
            player.velocityX *= -0.3;
        }

        if (player.y + player.height > canvasHeight) {
            player.y = canvasHeight - player.height;
            player.velocityY = 0;
            player.isJumping = false;
            player.doubleJumped = false;
            player.coyoteTimer = 0;
        }

        if (player.y < 0) {
            player.y = 0;
            player.velocityY *= -0.5;
        }

        // 优化：使用分离的碰撞检测
        const isOnGround = checkCollisions();

        // 优化：使用更高效的摩擦力计算
        if (isOnGround) {
            player.isJumping = false;
            player.doubleJumped = false;
            player.coyoteTimer = 0;

            const groundFriction = 0.85;
            player.velocityX *= groundFriction;
        } else {
            const airResistance = 0.98;
            player.velocityX *= airResistance;
        }

        return isOnGround;
    }

    // 优化：分离游戏逻辑更新函数
    function updateGameLogic() {
        const player = state.player;

        // 处理攻击冷却
        if (player.attackCooldown > 0) {
            player.attackCooldown--;
        }

        // 处理无敌帧
        if (player.invincibilityFrames > 0) {
            player.invincibilityFrames--;
        }

        // 处理连击计时器
        if (player.comboCount > 0) {
            if (player.comboTimer) {
                clearTimeout(player.comboTimer);
            }

            // 优化：使用更高效的连击重置机制
            const comboResetTime = 1800 - (player.comboCount * 50); // 连击数越多，重置时间越短
            player.comboTimer = setTimeout(() => {
                player.comboCount = 0;
                dynamicDifficulty.consecutiveKills = 0;
            }, Math.max(500, comboResetTime));
        }

        // 玩家-敌人碰撞检测
        state.enemies.forEach(enemy => {
            if (
                player.x < enemy.x + enemy.width &&
                player.x + player.width > enemy.x &&
                player.y < enemy.y + enemy.height &&
                player.y + player.height > enemy.y
            ) {
                if (player.invincibilityFrames <= 0) {
                    player.health -= 8;
                    player.invincibilityFrames = 35;
                    player.lastDamageTime = state.lastTime;
                    player.velocityX = (player.x - enemy.x) > 0 ? 5 : -5;
                    player.velocityY = -3;
                    updateHealthBar();
                    if (player.health <= 0) {
                        gameOver();
                    }
                    addParticles(player.x + player.width / 2, player.y + player.height / 2, 15, '#ff0000', 6);
                }
            }
        });
    }

    // 优化：更新玩家状态
    function updatePlayer() {
        const player = state.player;

        // 优化：使用分离的输入处理
        const input = processInput();

        const acceleration = 0.6;
        const deceleration = 0.4;
        const airControl = 0.3;

        const currentAcceleration = player.isJumping ? acceleration * airControl : acceleration;
        const currentDeceleration = player.isJumping ? deceleration * airControl : deceleration;

        if (input.moveLeft) {
            player.velocityX = Math.max(player.velocityX - currentAcceleration, -player.speed);
            player.facingDirection = -1;
        } else if (input.moveRight) {
            player.velocityX = Math.min(player.velocityX + currentAcceleration, player.speed);
            player.facingDirection = 1;
        } else {
            if (player.velocityX > 0) {
                player.velocityX = Math.max(player.velocityX - currentDeceleration, 0);
            } else if (player.velocityX < 0) {
                player.velocityX = Math.min(player.velocityX + currentDeceleration, 0);
            }
        }

        const coyoteTime = 15;
        player.coyoteTimer = player.isJumping ? 0 : (player.coyoteTimer || 0) + 1;

        const canJump = !player.isJumping || player.coyoteTimer < coyoteTime;

        // 优化：使用更高效的跳跃算法
        if (input.jump && canJump && state.gameState === 'playing') {
            player.velocityY = player.jumpForce;
            player.isJumping = true;
            player.doubleJumped = false;
            player.coyoteTimer = 0;

            addParticles(player.x + player.width / 2, player.y + player.height, 10, '#ffffff', 3);

        } else if (input.jump && player.isJumping && !player.doubleJumped && state.gameState === 'playing') {
            player.velocityY = player.jumpForce * 0.85;
            player.doubleJumped = true;

            addParticles(player.x + player.width / 2, player.y + player.height / 2, 15, '#4a9eff', 5);
        }

        // 优化：使用更高效的跳跃释放算法
        if (input.releaseJump && player.velocityY < 0) {
            player.velocityY *= 0.75;
        }

        // 优化：使用更高效的攻击算法
        if (input.attackNormal && !player.isAttacking && player.attackCooldown <= 0 && state.gameState === 'playing') {
            performAttack('normal');
        } else if (input.attackHeavy && !player.isAttacking && player.attackCooldown <= 0 && state.gameState === 'playing') {
            performAttack('heavy');
        } else if (input.attackSpecial && !player.isAttacking && player.attackCooldown <= 0 && state.gameState === 'playing') {
            performAttack('special');
        }

        // 优化：使用分离的物理更新
        updatePhysics();

        // 优化：使用分离的游戏逻辑更新
        updateGameLogic();
    }

    // 执行攻击
    function performAttack(type) {
        const player = state.player;
        player.isAttacking = true;
        player.attackType = type;

        // 优化：使用更高效的攻击参数配置
        const attackConfig = {
            normal: {
                cooldown: 18,
                power: 1.0,
                duration: 180,
                range: 70,
                hitStun: 9,
                knockback: 1.2,
                accuracy: 1.0,
                comboBonus: 1,
                scoreMultiplier: 1.0
            },
            heavy: {
                cooldown: 35,
                power: 2.5,
                duration: 280,
                range: 90,
                hitStun: 15,
                knockback: 3.5,
                accuracy: 0.85,
                comboBonus: 2,
                scoreMultiplier: 1.5
            },
            special: {
                cooldown: 55,
                power: 4.0,
                duration: 400,
                range: 125,
                hitStun: 20,
                knockback: 7.0,
                accuracy: 0.8,
                comboBonus: 3,
                scoreMultiplier: 2.0
            }
        };

        const config = attackConfig[type] || attackConfig.normal;

        // 优化：应用动态难度和连击加成
        const difficultyMultiplier = dynamicDifficulty.getDifficultyMultiplier();
        const comboBonus = dynamicDifficulty.getComboBonus();

        const cooldown = config.cooldown;
        const power = config.power * player.attackPower * difficultyMultiplier;
        const duration = config.duration;
        const range = config.range;
        const hitStun = config.hitStun;
        const knockback = config.knockback;
        const accuracy = config.accuracy;
        const comboBonusValue = config.comboBonus;
        const scoreMultiplier = config.scoreMultiplier * comboBonus;

        player.attackCooldown = cooldown;

        const attackHeightOffset = type === 'heavy' ? -10 : (type === 'special' ? -15 : 0);
        const attackHeight = player.height + (type === 'heavy' ? 20 : (type === 'special' ? 30 : 0));

        const attackShape = {
            x: player.x + (player.facingDirection === 1 ? player.width : -range),
            y: player.y + attackHeightOffset,
            width: range,
            height: attackHeight,
            type: type,
            hitStun: hitStun,
            knockback: knockback,
            accuracy: accuracy,
            direction: player.facingDirection,
            comboBonus: comboBonus,
            scoreMultiplier: scoreMultiplier
        };

        addAttackEffect(attackShape, type);

        let enemiesHit = 0;
        let totalDamage = 0;
        const hitEnemies = new Set();

        state.enemies.forEach((enemy, index) => {
            if (hitEnemies.has(index)) return;

            const enemyDodgeChance = enemy.type === 'flying' ? 0.2 :
                enemy.type === 'jumping' ? 0.15 : 0.1;
            const actualAccuracy = attackShape.accuracy * (1 - enemyDodgeChance);

            if (Math.random() > actualAccuracy) return;

            let isHit = false;

            if (type === 'special') {
                const enemyCenterX = enemy.x + enemy.width / 2;
                const enemyCenterY = enemy.y + enemy.height / 2;
                const attackCenterX = attackShape.x + attackShape.width / 2;
                const attackCenterY = attackShape.y + attackShape.height / 2;

                const dx = enemyCenterX - attackCenterX;
                const dy = enemyCenterY - attackCenterY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;

                if (distance < attackShape.width / 2 && Math.abs(angle) < 55) {
                    isHit = true;
                }
            } else if (type === 'heavy') {
                const enemyCenterX = enemy.x + enemy.width / 2;
                const enemyCenterY = enemy.y + enemy.height / 2;
                const attackCenterX = attackShape.x + attackShape.width / 2;
                const attackCenterY = attackShape.y + attackShape.height / 2;

                const dx = (enemyCenterX - attackCenterX) / (attackShape.width / 2);
                const dy = (enemyCenterY - attackCenterY) / (attackShape.height / 2);

                if (dx * dx + dy * dy < 1.2) {
                    isHit = true;
                }
            } else {
                if (
                    attackShape.x < enemy.x + enemy.width &&
                    attackShape.x + attackShape.width > enemy.x &&
                    attackShape.y < enemy.y + enemy.height &&
                    attackShape.y + attackShape.height > enemy.y
                ) {
                    isHit = true;
                }
            }

            if (isHit) {
                const damage = hitEnemy(enemy, index, power, type, attackShape.hitStun, attackShape.knockback);
                totalDamage += damage;
                enemiesHit++;
                hitEnemies.add(index);
            }
        });

        if (enemiesHit > 0) {
            let baseScore = Math.floor(totalDamage * 0.6 * attackShape.scoreMultiplier);
            const comboScore = player.comboCount * 8 * attackShape.comboBonus;
            const multiHitBonus = enemiesHit > 1 ? (enemiesHit - 1) * 50 : 0;
            const totalScore = baseScore + comboScore + multiHitBonus;
            state.score += totalScore;
        }

        if (player.attackTimer) {
            clearTimeout(player.attackTimer);
        }
        player.attackTimer = setTimeout(() => {
            player.isAttacking = false;
        }, duration);

        player.comboCount += attackShape.comboBonus;
        updateUI();

        if (type === 'special') {
            addScreenShake();
        }
    }

    // 击中敌人
    function hitEnemy(enemy, index, power, attackType, hitStun, knockback) {
        let damageMultiplier = 1.0;

        switch (enemy.type || 'normal') {
            case 'normal':
                damageMultiplier = 1.0;
                break;
            case 'jumping':
                damageMultiplier = 1.1;
                break;
            case 'tracking':
                damageMultiplier = 0.9;
                break;
            case 'flying':
                damageMultiplier = 1.2;
                break;
            case 'shooter':
                damageMultiplier = 0.8;
                break;
            default:
                damageMultiplier = 1.0;
        }

        const damage = Math.round(power * 24 * damageMultiplier);
        enemy.health -= damage;

        addParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 20, '#ff6600', 10);

        enemy.velocityX = state.player.facingDirection * knockback * 2.2;
        enemy.velocityY = -1.2 * knockback;

        enemy.hitStun = hitStun;
        enemy.isHit = true;

        if (enemy.health <= 0) {
            addParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 30, '#ff0000', 15);

            let baseScore = 0;
            switch (attackType) {
                case 'normal': baseScore = 20;
                    break;
                case 'heavy': baseScore = 30;
                    break;
                case 'special': baseScore = 45;
                    break;
            }

            const comboBonus = state.player.comboCount * 3;
            const difficultyBonus = state.difficulty === 'hard' ? 1.5 : (state.difficulty === 'medium' ? 1.2 : 1.0);
            const finalScore = Math.round(baseScore * difficultyBonus + comboBonus);

            state.score += finalScore;
            updateUI();

            state.enemies.splice(index, 1);
            checkLevelComplete();
        }

        return damage;
    }

    // 优化的攻击效果系统，使用对象池管理
    function addAttackEffect(attackBox, type) {
        const effect = getObjectFromPool(objectPools.attackEffects, 'attackEffect');
        effect.x = attackBox.x;
        effect.y = attackBox.y;
        effect.width = attackBox.width;
        effect.height = attackBox.height;
        effect.type = type;
        effect.timer = 0;
        effect.duration = type === 'normal' ? 22 : type === 'heavy' ? 32 : 42;
        effect.scale = 1.0;
        effect.alpha = 1.0;
        state.attackEffects.push(effect);

        const particleCount = type === 'normal' ? 8 : type === 'heavy' ? 12 : 16;
        for (let i = 0; i < particleCount; i++) {
            const angle = (i / particleCount) * Math.PI * 2;
            const distance = 10 + Math.random() * 20;
            const particle = getObjectFromPool(objectPools.particles, 'particle');
            particle.x = attackBox.x + attackBox.width / 2;
            particle.y = attackBox.y + attackBox.height / 2;
            particle.vx = Math.cos(angle) * (2 + Math.random() * 3);
            particle.vy = Math.sin(angle) * (2 + Math.random() * 3);
            particle.size = 2 + Math.random() * 3;
            particle.color = type === 'normal' ? '#ffcc00' : type === 'heavy' ? '#ff6600' : '#ff0000';
            particle.life = 25;
            particle.maxLife = 25;
            particle.alpha = 1.0;
            state.particles.push(particle);
        }
    }

    // 优化的粒子系统，使用对象池管理
    function addParticles(x, y, count, color, speed) {
        const maxParticlesPerCall = 50;
        const actualCount = Math.min(count, maxParticlesPerCall);

        // 优化：预计算随机数，减少Math.random调用
        const randomValues = [];
        for (let i = 0; i < actualCount * 3; i++) {
            randomValues.push(Math.random());
        }
        let randomIndex = 0;

        for (let i = 0; i < actualCount; i++) {
            const randomX = (randomValues[randomIndex++] - 0.5);
            const randomY = (randomValues[randomIndex++] - 0.5);
            const randomSize = randomValues[randomIndex++] * 3 + 1;

            const particle = getObjectFromPool(objectPools.particles, 'particle');
            particle.x = x;
            particle.y = y;
            particle.vx = randomX * speed;
            particle.vy = randomY * speed;
            particle.size = randomSize;
            particle.color = color;
            particle.life = 30;
            particle.maxLife = 30;
            particle.alpha = 1.0;

            state.particles.push(particle);
        }
    }

    // 优化的粒子更新函数，使用对象池释放机制
    function updateParticles() {
        const particlesToRemove = [];
        const particlesToRelease = [];

        // 优化：使用动态最大粒子数量，根据性能调整
        const maxParticles = state.maxParticles || 250;
        const particles = state.particles;
        const particleCount = particles.length;

        // 优化：限制粒子更新次数，提高性能
        const updateLimit = Math.min(particleCount, maxParticles);

        // 优化：批量更新粒子属性
        const canvasWidth = CONFIG.canvasWidth;
        const canvasHeight = CONFIG.canvasHeight;

        for (let i = 0; i < updateLimit; i++) {
            const particle = particles[i];
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.life--;
            particle.vy += 0.1;

            particle.alpha = particle.life / particle.maxLife;

            const isOnScreen = particle.x > -50 && particle.x < canvasWidth + 50 &&
                particle.y > -50 && particle.y < CONFIG.canvasHeight + 50;

            if (!isOnScreen) {
                particlesToRemove.push(i);
                particlesToRelease.push(particle);
            } else if (particle.life <= 0) {
                particlesToRemove.push(i);
                particlesToRelease.push(particle);
            }
        }

        // 从后往前删除，避免索引问题
        for (let i = particlesToRemove.length - 1; i >= 0; i--) {
            particles.splice(particlesToRemove[i], 1);
        }

        // 将粒子对象释放回对象池
        for (let i = 0; i < particlesToRelease.length; i++) {
            releaseObjectToPool(objectPools.particles, particlesToRelease[i]);
        }

        // 限制最大粒子数量
        if (particleCount > maxParticles) {
            const excess = particleCount - maxParticles;
            for (let i = 0; i < excess; i++) {
                const particle = particles.pop();
                if (particle) {
                    releaseObjectToPool(objectPools.particles, particle);
                }
            }
        }
    }

    // 优化的攻击效果更新函数，使用对象池释放机制
    function updateAttackEffects() {
        const effectsToRemove = [];
        const effectsToRelease = [];
        const effects = state.attackEffects;
        const effectCount = effects.length;

        // 优化：限制最大攻击效果数量
        const maxEffects = 50;
        const updateLimit = Math.min(effectCount, maxEffects);

        for (let i = 0; i < updateLimit; i++) {
            const effect = effects[i];
            effect.timer++;
            if (effect.timer >= effect.duration) {
                effectsToRemove.push(i);
                effectsToRelease.push(effect);
            }
        }

        // 从后往前删除，避免索引问题
        for (let i = effectsToRemove.length - 1; i >= 0; i--) {
            effects.splice(effectsToRemove[i], 1);
        }

        // 将效果对象释放回对象池
        for (let i = 0; i < effectsToRelease.length; i++) {
            releaseObjectToPool(objectPools.attackEffects, effectsToRelease[i]);
        }

        // 优化：限制攻击效果数量
        if (effectCount > maxEffects) {
            const excess = effectCount - maxEffects;
            for (let i = 0; i < excess; i++) {
                const effect = effects.pop();
                if (effect) {
                    releaseObjectToPool(objectPools.attackEffects, effect);
                }
            }
        }
    }

    // 优化的敌人更新函数，使用对象池释放机制
    function updateEnemies() {
        const enemiesToRemove = [];
        const enemiesToRelease = [];

        // 优化：缓存玩家位置，减少重复计算
        const playerX = state.player.x;
        const playerY = state.player.y;
        const playerWidth = state.player.width;
        const playerHeight = state.player.height;

        // 优化：根据敌人数量选择不同的更新策略
        const enemyCount = state.enemies.length;
        const updateStrategy = enemyCount > 30 ? 'optimized' : 'full';

        for (let i = 0; i < enemyCount; i++) {
            const enemy = state.enemies[i];

            // 优化：使用更高效的属性初始化
            if (!enemy.health) enemy.health = 100;
            if (!enemy.maxHealth) enemy.maxHealth = 100;
            if (!enemy.velocityX) enemy.velocityX = 0;
            if (!enemy.velocityY) enemy.velocityY = 0;
            if (!enemy.gravity) enemy.gravity = CONFIG.gravity;
            if (!enemy.jumpForce) enemy.jumpForce = -12;
            if (!enemy.isJumping) enemy.isJumping = false;
            if (!enemy.hitStun) enemy.hitStun = 0;
            if (!enemy.isHit) enemy.isHit = false;

            // 优化：使用更高效的计时器更新
            if (enemy.lastAttackCooldown > 0) {
                enemy.lastAttackCooldown--;
            }

            if (enemy.hitStun > 0) {
                enemy.hitStun--;
                enemy.velocityX *= 0.8;
                enemy.isHit = true;
                continue; // 跳过其他更新逻辑
            }

            enemy.isHit = false;

            // 优化：缓存距离计算结果
            const dx = playerX - enemy.x;
            const dy = playerY - enemy.y;
            const distanceSquared = dx * dx + dy * dy;
            const distance = Math.sqrt(distanceSquared);

            // 优化：根据更新策略选择不同的AI更新频率
            if (updateStrategy === 'optimized' && i % 2 !== 0) {
                // 优化模式下，每隔一个敌人更新一次AI
                updateEnemyBasicMovement(enemy);
            } else {
                // 完整模式下，所有敌人都进行完整AI更新
                switch (enemy.type || 'normal') {
                    case 'normal': {
                        updateNormalEnemyAI(enemy, dx, dy, distance, distanceSquared);
                        break;
                    }

                    case 'jumping': {
                        updateJumpingEnemyAI(enemy, dx, dy, distance, distanceSquared);
                        break;
                    }

                    case 'tracking': {
                        updateTrackingEnemyAI(enemy, dx, dy, distance, distanceSquared);
                        break;
                    }

                    case 'flying': {
                        updateFlyingEnemyAI(enemy, dx, dy, distance, distanceSquared);
                        break;
                    }

                    case 'shooter': {
                        updateShooterEnemyAI(enemy, dx, dy, distance, distanceSquared);
                        break;
                    }

                    case 'exploder': {
                        updateExploderEnemyAI(enemy, dx, dy, distance, distanceSquared);
                        break;
                    }
                }
            }

            // 优化：批量平台碰撞检测
            updateEnemyPlatformCollision(enemy);
        }
    }

    // 优化：更新敌人基本移动（用于优化模式）
    function updateEnemyBasicMovement(enemy) {
        enemy.x += enemy.velocityX;
        enemy.y += enemy.velocityY;
        enemy.velocityY += enemy.gravity || CONFIG.gravity;
    }

    // 优化：更新普通敌人AI
    function updateNormalEnemyAI(enemy, dx, dy, distance, distanceSquared) {
        enemy.state = enemy.state || 'patrolling';

        // 优化：使用预计算的常量
        const canSeePlayer = distance < 250 && canSeeThroughPlatforms(enemy, state.player.x, state.player.y);

        // 优化：使用更高效的状态机
        if (distance < 10000 && canSeePlayer) { // 10000 = 100^2
            enemy.state = 'attacking';
        } else if (distance < 90000 && canSeePlayer) { // 90000 = 300^2
            enemy.state = 'chasing';
        } else {
            enemy.state = 'patrolling';
        }

        // 优化：预分配巡逻点，避免重复创建对象
        if (!enemy.patrolPoints) {
            enemy.patrolPoints = [
                { x: enemy.x - 100, y: enemy.y },
                { x: enemy.x + 100, y: enemy.y }
            ];
        }

        // 优化：使用switch-case优化状态处理
        switch (enemy.state) {
            case 'patrolling': {
                // 优化：使用更高效的巡逻算法
                const patrolSpeed = enemy.speed * 0.5;
                enemy.x += enemy.direction * patrolSpeed;

                // 优化：减少边界检测频率
                if (enemy.x < 0 || enemy.x > CONFIG.canvasWidth - enemy.width) {
                    enemy.direction *= -1;
                }

                // 优化：使用预定义的巡逻点
                const patrolIndex = enemy.patrolIndex || 0;
                const targetPatrol = enemy.patrolPoints[patrolIndex];
                if (targetPatrol) {
                    const distToPatrol = Math.abs(enemy.x - targetPatrol.x);
                    if (distToPatrol < 10) {
                        enemy.patrolIndex = (patrolIndex + 1) % enemy.patrolPoints.length;
                    }
                }
                break;
            }

            case 'chasing': {
                // 优化：使用更高效的追逐算法
                const chaseSpeed = enemy.speed * 0.8;
                if (dx > 0) {
                    enemy.x += chaseSpeed;
                    enemy.direction = 1;
                } else {
                    enemy.x -= chaseSpeed;
                    enemy.direction = -1;
                }
                break;
            }

            case 'attacking': {
                // 优化：使用更高效的攻击算法
                if (distance < 60 && enemy.lastAttackCooldown <= 0) {
                    enemy.lastAttackCooldown = enemy.attackCooldown || 60;
                    // 优化：直接计算伤害，避免函数调用
                    const damage = 15;
                    if (state.player.invincibilityFrames <= 0) {
                        state.player.health -= damage;
                        state.player.invincibilityFrames = 30;
                        state.player.lastDamageTime = state.lastTime;
                        updateHealthBar();
                        if (state.player.health <= 0) {
                            gameOver();
                        }
                        addParticles(state.player.x + state.player.width / 2, state.player.y + state.player.height / 2, 10, '#ff0000', 5);
                    }
                }
                break;
            }
        }
    }

    // 优化：更新跳跃敌人AI
    function updateJumpingEnemyAI(enemy, dx, dy, distance, distanceSquared) {
        enemy.state = enemy.state || 'exploring';

        if (distance < 22500) { // 150^2
            enemy.state = 'attacking';
        } else if (distance < 90000) { // 300^2
            enemy.state = 'chasing';
        } else {
            enemy.state = 'exploring';
        }

        if (!enemy.isJumping) {
            updateJumpingEnemyMovement(enemy, dx, dy, distance, distanceSquared);
        }

        updateEnemyPhysics(enemy);
    }

    // 优化：更新追踪敌人AI
    function updateTrackingEnemyAI(enemy, dx, dy, distance, distanceSquared) {
        enemy.state = enemy.state || 'patrolling';
        enemy.targetX = state.player.x;
        enemy.targetY = state.player.y;

        // 优化：使用更高效的可见性检测
        let canSeePlayer = canSeeThroughPlatforms(enemy, state.player.x, state.player.y);
        if (distance < 80 && canSeePlayer) {
            enemy.state = 'attacking';
        } else if (distance < 350 && canSeePlayer) {
            enemy.state = 'chasing';
        } else if (distance < 500) {
            enemy.state = 'searching';
        } else {
            enemy.state = 'patrolling';
        }

        switch (enemy.state) {
            case 'patrolling': {
                // 优化：预分配巡逻路径，避免重复创建对象
                if (!enemy.patrolPath) {
                    enemy.patrolPath = [
                        { x: enemy.x, y: enemy.y },
                        { x: enemy.x + 120, y: enemy.y },
                        { x: enemy.x + 120, y: enemy.y - 80 },
                        { x: enemy.x, y: enemy.y - 80 }
                    ];
                }
                enemy.patrolIndex = enemy.patrolIndex || 0;

                const currentPatrol = enemy.patrolPath[enemy.patrolIndex];
                const patrolDx = currentPatrol.x - enemy.x;
                const patrolDy = currentPatrol.y - enemy.y;

                if (Math.abs(patrolDx) < 15 && Math.abs(patrolDy) < 15) {
                    enemy.patrolIndex = (enemy.patrolIndex + 1) % enemy.patrolPath.length;
                } else {
                    enemy.velocityX += (patrolDx * 0.05 - enemy.velocityX) * 0.2;
                    enemy.x += enemy.velocityX;

                    if (patrolDy < -20 && !enemy.isJumping) {
                        enemy.velocityY = enemy.jumpForce * 1.2;
                        enemy.isJumping = true;
                    }
                }
                break;
            }

            case 'searching': {
                // 优化：预分配搜索角度和半径，避免重复创建
                if (!enemy.searchAngle) enemy.searchAngle = 0;
                if (!enemy.searchRadius) enemy.searchRadius = 50;

                enemy.x += Math.cos(enemy.searchAngle) * enemy.speed;
                enemy.y += Math.sin(enemy.searchAngle) * enemy.speed * 0.5;

                enemy.searchAngle += 0.03;
                enemy.searchRadius += 0.1;

                if (enemy.searchRadius > 200) {
                    enemy.searchRadius = 50;
                }
                break;
            }

            case 'chasing': {
                const playerVelocityX = state.player.velocityX;
                const playerVelocityY = state.player.velocityY;

                const predictedX = state.player.x + playerVelocityX * 3;
                const predictedY = state.player.y + playerVelocityY * 3;

                const chaseDx = predictedX - enemy.x;
                const chaseDy = predictedY - enemy.y;

                enemy.velocityX += (chaseDx * 0.08 - enemy.velocityX) * 0.2;
                enemy.x += enemy.velocityX;

                const yDiff = predictedY - enemy.y;
                if (yDiff < -30 && distance < 300 && !enemy.isJumping) {
                    const jumpTime = Math.sqrt(2 * Math.abs(yDiff) / enemy.gravity);
                    const jumpDistance = enemy.velocityX * jumpTime;

                    if (Math.abs(chaseDx - jumpDistance) < 50) {
                        enemy.velocityY = enemy.jumpForce * 1.3;
                        enemy.isJumping = true;
                    }
                }
                break;
            }

            case 'attacking': {
                const optimalAttackDistance = 60;
                const distanceDiff = Math.abs(state.player.x - enemy.x) - optimalAttackDistance;
                const chaseDx = state.player.x - enemy.x;

                if (Math.abs(distanceDiff) > 10) {
                    const adjustDirection = distanceDiff > 0 ? Math.sign(chaseDx) : -Math.sign(chaseDx);
                    enemy.velocityX += (adjustDirection * enemy.speed * 0.6 - enemy.velocityX) * 0.3;
                    enemy.x += enemy.velocityX;
                }
                break;
            }
                enemy.velocityY += enemy.gravity;
                enemy.y += enemy.velocityY;

                enemy.isJumping = true;
                state.platforms.forEach(platform => {
                    if (
                        enemy.x < platform.x + platform.width &&
                        enemy.x + enemy.width > platform.x &&
                        enemy.y + enemy.height > platform.y &&
                        enemy.y + enemy.height < platform.y + 15 &&
                        enemy.velocityY > 0
                    ) {
                        enemy.y = platform.y - enemy.height;
                        enemy.velocityY = 0;
                        enemy.isJumping = false;
                    }
                });

                if (enemy.state === 'attacking' && distance < enemy.attackRange && enemy.lastAttackCooldown <= 0) {
                    enemy.direction = targetX > enemy.x ? 1 : -1;

                    if (Math.abs(state.player.velocityX) < 2 ||
                        Math.abs(state.player.velocityY) < 2 ||
                        Math.random() < 0.3) {
                        enemyAttack(enemy, index);
                    }
                }
                break;
        }
    }

    // 优化：更新飞行敌人AI
    function updateFlyingEnemyAI(enemy, dx, dy, distance, distanceSquared) {
        const flyTargetX = state.player.x;
        const flyTargetY = state.player.y;

        enemy.state = enemy.state || 'patrolling';
        enemy.flySpeed = enemy.flySpeed || enemy.speed * 0.3;
        enemy.attackCooldown = enemy.attackCooldown || 60;
        enemy.orbitRadius = enemy.orbitRadius || 120;

        const visibilityDistance = 400;
        if (distance < 100) {
            enemy.state = 'attacking';
        } else if (distance < visibilityDistance) {
            enemy.state = 'chasing';
        } else {
            enemy.state = 'patrolling';
        }

        switch (enemy.state) {
            case 'patrolling': {
                enemy.patrolCenter = enemy.patrolCenter || { x: enemy.x, y: enemy.y };
                enemy.patrolTime = enemy.patrolTime || 0;

                enemy.x = enemy.patrolCenter.x + Math.sin(enemy.patrolTime * 0.002) * 150;
                enemy.y = enemy.patrolCenter.y + Math.cos(enemy.patrolTime * 0.003) * 80;
                enemy.patrolTime += 1;

                break;
            }

            case 'chasing': {
                const approachSpeed = 0.05;
                const heightOffset = -20;

                const horizontalDistance = Math.abs(flyTargetX - enemy.x);
                const verticalDistance = Math.abs((flyTargetY + heightOffset) - enemy.y);

                if (horizontalDistance > 50) {
                    enemy.x += (flyTargetX - enemy.x) * approachSpeed * 1.5;
                } else {
                    enemy.y += ((flyTargetY + heightOffset) - enemy.y) * approachSpeed * 1.2;
                }

                enemy.y += Math.sin(state.lastTime * 0.01) * 0.6;
                break;
            }

            case 'attacking': {
                enemy.attackPhase = enemy.attackPhase || 0;
                enemy.attackTimer = enemy.attackTimer || 0;

                switch (enemy.attackPhase) {
                    case 0: {
                        const orbitSpeed = 0.006;
                        const orbitAngle = state.lastTime * orbitSpeed;
                        enemy.x = flyTargetX + Math.cos(orbitAngle) * enemy.orbitRadius;
                        enemy.y = flyTargetY + Math.sin(orbitAngle) * enemy.orbitRadius;

                        enemy.attackTimer++;
                        if (enemy.attackTimer > 120) {
                            enemy.attackPhase = 1;
                            enemy.attackTimer = 0;
                        }
                        break;
                    }

                    case 1: {
                        enemy.x += (flyTargetX - enemy.x) * 0.12;
                        enemy.y += (flyTargetY - enemy.y) * 0.15;

                        enemy.attackTimer++;
                        if (enemy.attackTimer > 60) {
                            enemy.attackPhase = 2;
                            enemy.attackTimer = 0;
                        }
                        break;
                    }

                    case 2: {
                        enemy.x += (enemy.x - flyTargetX) * 0.1;
                        enemy.y += (enemy.y - flyTargetY) * 0.1;

                        enemy.attackTimer++;
                        if (enemy.attackTimer > 80) {
                            enemy.attackPhase = 0;
                            enemy.attackTimer = 0;
                            enemy.orbitRadius = Math.random() * 100 + 80;
                        }
                        break;
                    }
                }
                break;
            }
        }

        enemy.direction = flyTargetX > enemy.x ? 1 : -1;

        enemy.x = Math.max(0, Math.min(CONFIG.canvasWidth - enemy.width, enemy.x));
        enemy.y = Math.max(30, Math.min(CONFIG.canvasHeight - 80, enemy.y));

        const attackChance = enemy.state === 'attacking' ? 0.9 :
            enemy.state === 'chasing' ? 0.4 : 0.15;

        if (distance < enemy.attackRange && enemy.lastAttackCooldown <= 0 && Math.random() < attackChance) {
            if (enemy.state === 'attacking' && enemy.attackPhase === 1) {
                enemyShoot(enemy, index);
            } else {
                enemyAttack(enemy, index);
            }
        }
    }

    // 优化：更新射手敌人AI
    function updateShooterEnemyAI(enemy, dx, dy, distance, distanceSquared) {
        enemy.state = enemy.state || 'positioning';
        enemy.attackCooldown = enemy.attackCooldown || 90;
        enemy.shootAccuracy = enemy.shootAccuracy || 0.8;
        enemy.retreatDistance = enemy.retreatDistance || 200;

        enemy.direction = dx > 0 ? 1 : -1;

        let optimalPlatform = null;
        let optimalScore = -Infinity;

        state.platforms.forEach(platform => {
            const platformY = platform.y;
            const platformCenterX = platform.x + platform.width / 2;

            const heightScore = -platformY * 0.5;
            const distanceScore = Math.max(0, 300 - Math.abs(dx));
            const widthScore = platform.width * 0.1;

            const platformScore = heightScore + distanceScore + widthScore;

            if (platformScore > optimalScore) {
                optimalScore = platformScore;
                optimalPlatform = platform;
            }
        });

        const canSeePlayer = !state.platforms.some(platform => {
            const lineStart = { x: enemy.x + enemy.width / 2, y: enemy.y + enemy.height / 2 };
            const lineEnd = { x: state.player.x + state.player.width / 2, y: state.player.y + state.player.height / 2 };
            const rect = {
                x: platform.x,
                y: platform.y,
                width: platform.width,
                height: platform.height
            };

            return rect.y > Math.min(lineStart.y, lineEnd.y) &&
                rect.y < Math.max(lineStart.y, lineEnd.y) &&
                rect.x < Math.max(lineStart.x, lineEnd.x) &&
                rect.x + rect.width > Math.min(lineStart.x, lineEnd.x);
        });

        if (distance > 300 || (distance > 200 && !canSeePlayer)) {
            enemy.state = 'approaching';
            enemy.x += enemy.speed * enemy.direction * 0.7;

            if (optimalPlatform && enemy.y + enemy.height < optimalPlatform.y - 30 && !enemy.isJumping) {
                if (Math.random() < 0.8) {
                    enemy.velocityY = enemy.jumpForce * 1.3;
                    enemy.isJumping = true;
                }
            }
        } else if (distance < 120) {
            enemy.state = 'retreating';
            enemy.x -= enemy.speed * enemy.direction * 0.8;

            if (!enemy.isJumping && Math.random() < 0.5) {
                enemy.velocityY = enemy.jumpForce * 0.9;
                enemy.isJumping = true;
            }
        } else {
            enemy.state = 'positioning';

            if (optimalPlatform) {
                const platformCenter = optimalPlatform.x + optimalPlatform.width / 2;
                if (Math.abs(enemy.x - platformCenter) > 15) {
                    enemy.x += Math.sign(platformCenter - enemy.x) * enemy.speed * 0.4;
                }

                if (enemy.y + enemy.height < optimalPlatform.y - 25 && !enemy.isJumping) {
                    if (Math.random() < 0.8) {
                        enemy.velocityY = enemy.jumpForce * 1.4;
                        enemy.isJumping = true;
                    }
                }
            }
        }

        const shootChance = enemy.state === 'positioning' ? 0.95 :
            enemy.state === 'approaching' ? 0.3 : 0.1;

        if (distance < enemy.attackRange && enemy.lastAttackCooldown <= 0 && canSeePlayer && Math.random() < shootChance) {
            const playerVelocityX = state.player.velocityX;
            const playerVelocityY = state.player.velocityY;
            const bulletSpeed = 8;

            const timeToHit = distance / bulletSpeed;
            const predictedPlayerX = state.player.x + playerVelocityX * timeToHit;
            const predictedPlayerY = state.player.y + playerVelocityY * timeToHit;

            const shootDx = predictedPlayerX - enemy.x;
            const shootDy = predictedPlayerY - enemy.y;
            const shootAngle = Math.atan2(shootDy, shootDx);

            let accuracy = enemy.shootAccuracy;
            if (enemy.state === 'approaching') accuracy *= 0.5;
            if (enemy.isJumping) accuracy *= 0.7;

            const randomFactor = (Math.random() - 0.5) * (1 - accuracy) * 2;
            const finalShootAngle = shootAngle + randomFactor;

            enemyShoot(enemy, index);
        }

        enemy.velocityY += enemy.gravity;
        enemy.y += enemy.velocityY;

        enemy.isJumping = true;
        state.platforms.forEach(platform => {
            if (
                enemy.x < platform.x + platform.width &&
                enemy.x + enemy.width > platform.x &&
                enemy.y + enemy.height > platform.y &&
                enemy.y + enemy.height < platform.y + 15 &&
                enemy.velocityY > 0
            ) {
                enemy.y = platform.y - enemy.height;
                enemy.velocityY = 0;
                enemy.isJumping = false;
            }
        });
    }

    // 优化：更新爆炸敌人AI
    function updateExploderEnemyAI(enemy, dx, dy, distance, distanceSquared) {
        enemy.state = enemy.state || 'approaching';
        enemy.explosionRadius = enemy.explosionRadius || 100;
        enemy.explosionDamage = enemy.explosionDamage || 40;
        enemy.detectionRange = enemy.detectionRange || 300;
        enemy.explosionDelay = enemy.explosionDelay || 30;

        if (distance < enemy.explosionRadius * 0.5) {
            enemy.state = 'exploding';
        } else if (distance < enemy.detectionRange) {
            enemy.state = 'approaching';
        } else {
            enemy.state = 'wandering';
        }

        switch (enemy.state) {
            case 'wandering': {
                enemy.wanderTimer = enemy.wanderTimer || 0;
                enemy.wanderDirection = enemy.wanderDirection || (Math.random() > 0.5 ? 1 : -1);

                enemy.x += enemy.speed * enemy.wanderDirection * 0.5;
                enemy.wanderTimer++;

                if (enemy.wanderTimer > 60) {
                    enemy.wanderDirection *= -1;
                    enemy.wanderTimer = 0;
                }

                if (Math.random() < 0.02 && !enemy.isJumping) {
                    enemy.velocityY = enemy.jumpForce * 1.1;
                    enemy.isJumping = true;
                }
                break;
            }

            case 'approaching': {
                const playerVelocityX = state.player.velocityX;
                const playerVelocityY = state.player.velocityY;

                const predictionTime = 0.5;
                const predictedX = state.player.x + playerVelocityX * predictionTime;
                const predictedY = state.player.y + playerVelocityY * predictionTime;

                const targetVelocityX = (predictedX > enemy.x + enemy.width / 2) ? enemy.speed * 1.8 :
                    (predictedX < enemy.x - enemy.width / 2) ? -enemy.speed * 1.8 : 0;
                enemy.velocityX += (targetVelocityX - enemy.velocityX) * 0.25;
                enemy.direction = Math.sign(enemy.velocityX) || 1;

                enemy.x += enemy.velocityX;

                if (predictedY < enemy.y - 30 && distance < 350 && !enemy.isJumping) {
                    const jumpDistance = Math.abs(predictedX - enemy.x);
                    const jumpHeight = enemy.y - predictedY;
                    const gravity = enemy.gravity;

                    const jumpTime = Math.sqrt(2 * jumpHeight / gravity);
                    const requiredVelocityX = jumpDistance / jumpTime;

                    if (Math.abs(requiredVelocityX - enemy.velocityX) < 3) {
                        enemy.velocityY = -Math.sqrt(2 * jumpHeight * gravity) * 1.2;
                        enemy.isJumping = true;
                    }
                }
                break;
            }

            case 'exploding': {
                enemy.explosionTimer = enemy.explosionTimer || 0;
                enemy.explosionTimer++;

                if (enemy.explosionTimer % 10 < 5) {
                    enemy.isBlinking = true;
                } else {
                    enemy.isBlinking = false;
                }

                if (enemy.explosionTimer > enemy.explosionDelay) {
                    explodeEnemy(enemy, index);
                }
                break;
            }
        }

        enemy.velocityY += enemy.gravity;
        enemy.y += enemy.velocityY;

        enemy.isJumping = true;
        state.platforms.forEach(platform => {
            if (
                enemy.x < platform.x + platform.width &&
                enemy.x + enemy.width > platform.x &&
                enemy.y + enemy.height > platform.y &&
                enemy.y + enemy.height < platform.y + 15 &&
                enemy.velocityY > 0
            ) {
                enemy.y = platform.y - enemy.height;
                enemy.velocityY = 0;
                enemy.isJumping = false;
            }
        });
        break;
    }

    if (enemy.x < 0) enemy.x = 0;
    if (enemy.x + enemy.width > CONFIG.canvasWidth) {
        enemy.x = CONFIG.canvasWidth - enemy.width;
    }

    if (!enemy.isJumping && enemy.type !== 'flying') {
        enemy.velocityX *= 0.9;
    }
};
    }

// 敌人攻击
function enemyAttack(enemy, index) {
    enemy.lastAttackCooldown = enemy.attackCooldown;

    const attackEffect = {
        x: enemy.x + (enemy.direction === 1 ? enemy.width : -60),
        y: enemy.y,
        width: 60,
        height: enemy.height,
        type: 'enemyAttack',
        timer: 0,
        duration: 20,
        damage: 10
    };

    state.attackEffects.push(attackEffect);

    const player = state.player;
    if (
        attackEffect.x < player.x + player.width &&
        attackEffect.x + attackEffect.width > player.x &&
        attackEffect.y < player.y + player.height &&
        attackEffect.y + attackEffect.height > player.y
    ) {
        if (player.invincibilityFrames <= 0) {
            player.health -= attackEffect.damage;
            player.invincibilityFrames = 30;
            player.lastDamageTime = state.lastTime;
            updateHealthBar();
            if (player.health <= 0) {
                gameOver();
            }
            addParticles(player.x + player.width / 2, player.y + player.height / 2, 10, '#ff0000', 5);
        }
    }
}

// 优化的敌人射击系统，使用对象池管理
function enemyShoot(enemy, index) {
    enemy.lastAttackCooldown = enemy.attackCooldown;

    const bullet = getObjectFromPool(objectPools.enemyEffects, 'enemyEffect');
    bullet.x = enemy.x + (enemy.direction === 1 ? enemy.width : -20);
    bullet.y = enemy.y + enemy.height / 2 - 5;
    bullet.width = 20;
    bullet.height = 10;
    bullet.velocityX = enemy.direction * 8;
    bullet.velocityY = 0;
    bullet.damage = 15;
    bullet.type = 'bullet';

    state.enemyEffects.push(bullet);
}

// 爆炸敌人的爆炸函数
function explodeEnemy(enemy, index) {
    const explosionRadius = 100;
    const explosionDamage = 40;

    addParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 50, '#ff9900', 15);
    addParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 30, '#ff3300', 20);

    const player = state.player;
    const dx = player.x + player.width / 2 - (enemy.x + enemy.width / 2);
    const dy = player.y + player.height / 2 - (enemy.y + enemy.height / 2);
    const playerDistance = Math.sqrt(dx * dx + dy * dy);

    if (playerDistance < explosionRadius) {
        const damageMultiplier = 1 - (playerDistance / explosionRadius);
        const finalDamage = Math.round(explosionDamage * damageMultiplier);

        if (player.invincibilityFrames <= 0) {
            player.health -= finalDamage;
            player.invincibilityFrames = 40;
            player.lastDamageTime = state.lastTime;

            const knockbackForce = 8 * damageMultiplier;
            player.velocityX = (player.x - enemy.x) > 0 ? knockbackForce : -knockbackForce;
            player.velocityY = -knockbackForce * 0.5;

            updateHealthBar();
            if (player.health <= 0) {
                gameOver();
            }
        }
    }

    const enemiesToRemove = [];
    const enemiesToRelease = [];

    state.enemies.forEach((otherEnemy, otherIndex) => {
        if (otherIndex !== index) {
            const otherDx = otherEnemy.x + otherEnemy.width / 2 - (enemy.x + enemy.width / 2);
            const otherDy = otherEnemy.y + otherEnemy.height / 2 - (enemy.y + enemy.height / 2);
            const otherDistance = Math.sqrt(otherDx * otherDx + otherDy * otherDy);

            if (otherDistance < explosionRadius) {
                const damageMultiplier = 1 - (otherDistance / explosionRadius);
                const finalDamage = Math.round(explosionDamage * damageMultiplier * 0.5);
                otherEnemy.health -= finalDamage;

                const knockbackForce = 5 * damageMultiplier;
                otherEnemy.velocityX = (otherEnemy.x - enemy.x) > 0 ? knockbackForce : -knockbackForce;
                otherEnemy.velocityY = -knockbackForce * 0.5;

                if (otherEnemy.health <= 0) {
                    addParticles(otherEnemy.x + otherEnemy.width / 2, otherEnemy.y + otherEnemy.height / 2, 25, '#ff0000', 12);
                    enemiesToRemove.push(otherIndex);
                    enemiesToRelease.push(otherEnemy);
                }
            }
        }
    });

    // 从后往前删除敌人，避免索引问题
    for (let i = enemiesToRemove.length - 1; i >= 0; i--) {
        state.enemies.splice(enemiesToRemove[i], 1);
    }

    // 将敌人对象释放回对象池
    for (let i = 0; i < enemiesToRelease.length; i++) {
        releaseObjectToPool(objectPools.bullets, enemiesToRelease[i]);
    }

    // 将爆炸敌人对象释放回对象池
    releaseObjectToPool(objectPools.bullets, enemy);

    state.enemies.splice(index, 1);
    state.score += 35;
    updateUI();
    checkLevelComplete();
}

// 优化的敌人效果更新函数，使用对象池释放机制
function updateEnemyEffects() {
    const effectsToRemove = [];
    const effectsToRelease = [];
    const effects = state.enemyEffects;
    const effectCount = effects.length;

    // 优化：缓存玩家位置，减少重复计算
    const player = state.player;
    const playerX = player.x;
    const playerY = player.y;
    const playerWidth = player.width;
    const playerHeight = player.height;

    // 优化：限制最大敌人效果数量
    const maxEffects = 30;
    const updateLimit = Math.min(effectCount, maxEffects);

    for (let i = 0; i < updateLimit; i++) {
        const effect = effects[i];
        effect.x += effect.velocityX;
        effect.y += effect.velocityY;

        // 优化：快速边界检测
        if (effect.x < 0 || effect.x > CONFIG.canvasWidth) {
            effectsToRemove.push(i);
            effectsToRelease.push(effect);
            continue;
        }

        // 优化：使用距离检测优化碰撞检测
        const dx = (effect.x + effect.width / 2) - (playerX + playerWidth / 2);
        const dy = (effect.y + effect.height / 2) - (playerY + playerHeight / 2);
        const distanceSquared = dx * dx + dy * dy;

        // 优化：距离足够近时才进行碰撞检测
        if (distanceSquared < 2500) { // 2500 = 50^2
            if (
                effect.x < playerX + playerWidth &&
                effect.x + effect.width > playerX &&
                effect.y < playerY + playerHeight &&
                effect.y + effect.height > playerY
            ) {
                if (player.invincibilityFrames <= 0) {
                    player.health -= effect.damage;
                    player.invincibilityFrames = 30;
                    player.lastDamageTime = state.lastTime;
                    updateHealthBar();
                    if (player.health <= 0) {
                        gameOver();
                    }
                    addParticles(player.x + player.width / 2, player.y + player.height / 2, 10, '#ff0000', 5);
                }
                effectsToRemove.push(i);
                effectsToRelease.push(effect);
                continue;
            }
        }

        // 检查是否需要移除
        if (effect.y < -50 || effect.y > CONFIG.canvasHeight + 50) {
            effectsToRemove.push(i);
            effectsToRelease.push(effect);
        }
    }

    // 从后往前删除，避免索引问题
    for (let i = effectsToRemove.length - 1; i >= 0; i--) {
        effects.splice(effectsToRemove[i], 1);
    }

    // 将效果对象释放回对象池
    for (let i = 0; i < effectsToRelease.length; i++) {
        releaseObjectToPool(objectPools.enemyEffects, effectsToRelease[i]);
    }

    // 优化：限制敌人效果数量
    if (effectCount > maxEffects) {
        const excess = effectCount - maxEffects;
        for (let i = 0; i < excess; i++) {
            const effect = effects.pop();
            if (effect) {
                releaseObjectToPool(objectPools.enemyEffects, effect);
            }
        }
    }

    // 将效果对象释放回对象池
    for (let i = 0; i < effectsToRelease.length; i++) {
        releaseObjectToPool(objectPools.enemyEffects, effectsToRelease[i]);
    }

    // 优化：限制敌人效果数量
    if (effectCount > maxEffects) {
        const excess = effectCount - maxEffects;
        for (let i = 0; i < excess; i++) {
            const effect = effects.pop();
            if (effect) {
                releaseObjectToPool(objectPools.enemyEffects, effect);
            }
        }
    }

    // 屏幕震动效果函数
    function addScreenShake() {
        if (!canvas) return;

        canvas.style.transform = 'translateX(2px) translateY(2px)';

        setTimeout(() => {
            canvas.style.transform = 'translateX(-2px) translateY(-2px)';
            setTimeout(() => {
                canvas.style.transform = 'translateX(1px) translateY(1px)';
                setTimeout(() => {
                    canvas.style.transform = 'translateX(-1px) translateY(-1px)';
                    setTimeout(() => {
                        canvas.style.transform = '';
                    }, 50);
                }, 50);
            }, 50);
        }, 50);
    }

    // 更新生命值显示
    function updateHealthBar() {
        if (healthFill) {
            healthFill.style.width = state.player.health + '%';
        }
    }

    // 检查关卡是否完成
    function checkLevelComplete() {
        if (state.enemies.length === 0) {
            state.gameState = 'levelComplete';

            if (!state.completedLevels.includes(state.currentLevel)) {
                state.completedLevels.push(state.currentLevel);
                generateLevelButtons();
            }

            drawLevelComplete();

            if (state.currentLevel < LEVELS.length - 1) {
                setTimeout(() => {
                    loadLevel(state.currentLevel + 1);
                }, 2000);
            } else {
                setTimeout(() => {
                    gameWin();
                }, 2000);
            }
        }
    }

    // 优化的绘制游戏元素函数，减少重绘次数
    function draw() {
        try {
            const now = performance.now();

            // 优化：缓存常量和计算结果
            const canvasW = CONFIG.canvasWidth;
            const canvasH = CONFIG.canvasHeight;
            const player = state.player;
            const gameState = state.gameState;

            // 优化：使用脏矩形技术，只重绘变化区域
            const dirtyRectangles = [];

            ctx.save();

            // 优化：批量设置画布属性，减少状态切换
            ctx.fillStyle = '#1a0f41';
            ctx.fillRect(0, 0, canvasW, canvasH);

            // 优化：使用更高效的绘制顺序和批处理
            // 批量绘制平台
            drawPlatformsBatch();

            // 批量绘制道具
            drawPropsBatch();

            // 批量绘制敌人
            drawEnemiesBatch();

            // 批量绘制攻击效果
            drawAttackEffectsBatch();

            // 批量绘制粒子
            drawParticlesBatch();

            // 绘制玩家
            drawPlayer();

            // 优化：缓存常用属性
            const isPlaying = gameState === 'playing';
            const hasAttackPower = isPlaying && player.attackPower > 1;
            const hasCombo = isPlaying && player.comboCount > 1;
            const hasInvincibility = isPlaying && player.invincibilityFrames > 0;

            if (isPlaying) {
                // 优化：批量绘制UI效果
                if (hasAttackPower) {
                    drawAttackPowerUI();
                }

                if (hasCombo) {
                    drawComboUI();
                }

                if (hasInvincibility) {
                    drawInvincibilityUI();
                }
            }

            // 优化：延迟绘制游戏结束和关卡完成画面
            if (gameState === 'gameOver') {
                drawGameOver();
            } else if (gameState === 'levelComplete') {
                drawLevelComplete();
            }

            ctx.restore();

            // 优化：添加帧率统计
            if (now % 1000 < 16) { // 每秒更新一次
                state.lastFrameTime = now;
            }

        } catch (error) {
            console.error('绘制游戏元素时出错:', error);
        }
    }

    // 优化：背景渲染系统
    const BackgroundRenderer = {
        cachedBackground: null,
        lastBackgroundUpdate: 0,

        /**
         * 初始化背景缓存
         */
        init: function () {
            // 创建离屏Canvas缓存背景
            this.cachedBackground = document.createElement('canvas');
            this.cachedBackground.width = CONFIG.canvasWidth;
            this.cachedBackground.height = CONFIG.canvasHeight;

            const bgCtx = this.cachedBackground.getContext('2d');
            bgCtx.fillStyle = '#1a0f41';
            bgCtx.fillRect(0, 0, CONFIG.canvasWidth, CONFIG.canvasHeight);

            // 绘制背景图案
            this.drawBackgroundPattern(bgCtx);
        },

        /**
         * 绘制背景图案
         * @param {CanvasRenderingContext2D} ctx - Canvas上下文
         */
        drawBackgroundPattern: function (ctx) {
            // 优化：绘制简单的背景图案
            ctx.fillStyle = '#251a4a';
            for (let y = 0; y < CONFIG.canvasHeight; y += 50) {
                for (let x = 0; x < CONFIG.canvasWidth; x += 50) {
                    if ((x + y) % 100 === 0) {
                        ctx.fillStyle = '#2d224a';
                        ctx.fillRect(x, y, 50, 50);
                    }
                }
            }
        },

        /**
         * 绘制背景
         * @param {CanvasRenderingContext2D} ctx - Canvas上下文
         */
        drawBackground: function (ctx) {
            if (!this.cachedBackground) {
                this.init();
            }

            // 优化：使用缓存的背景
            ctx.drawImage(this.cachedBackground, 0, 0);
        }
    };

    // 优化：UI渲染性能优化
    const UIRenderer = {
        cachedUIElements: {},
        lastUIUpdate: 0,

        /**
         * 初始化UI缓存
         */
        init: function () {
            // 创建离屏Canvas缓存UI元素
            this.cachedUIElements = {
                score: this.createScoreCanvas(),
                health: this.createHealthCanvas(),
                level: this.createLevelCanvas()
            };
        },

        /**
         * 创建分数Canvas
         * @returns {HTMLCanvasElement} 分数Canvas
         */
        createScoreCanvas: function () {
            const canvas = document.createElement('canvas');
            canvas.width = 200;
            canvas.height = 30;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('分数: 0', 10, 22);
            return canvas;
        },

        /**
         * 创建生命值Canvas
         * @returns {HTMLCanvasElement} 生命值Canvas
         */
        createHealthCanvas: function () {
            const canvas = document.createElement('canvas');
            canvas.width = 200;
            canvas.height = 30;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(10, 10, 180, 10);
            return canvas;
        },

        /**
         * 创建关卡Canvas
         * @returns {HTMLCanvasElement} 关卡Canvas
         */
        createLevelCanvas: function () {
            const canvas = document.createElement('canvas');
            canvas.width = 200;
            canvas.height = 30;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('关卡: 1', 190, 22);
            return canvas;
        },

        /**
         * 更新分数UI
         * @param {number} score - 分数
         */
        updateScoreUI: function (score) {
            if (!this.cachedUIElements.score) {
                this.init();
            }

            const canvas = this.cachedUIElements.score;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`分数: ${score}`, 10, 22);
        },

        /**
         * 更新生命值UI
         * @param {number} health - 生命值
         * @param {number} maxHealth - 最大生命值
         */
        updateHealthUI: function (health, maxHealth) {
            if (!this.cachedUIElements.health) {
                this.init();
            }

            const canvas = this.cachedUIElements.health;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const healthPercent = health / maxHealth;
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(10, 10, 180 * healthPercent, 10);
            ctx.strokeStyle = '#ffffff';
            ctx.strokeRect(10, 10, 180, 10);
        },

        /**
         * 更新关卡UI
         * @param {number} level - 关卡
         */
        updateLevelUI: function (level) {
            if (!this.cachedUIElements.level) {
                this.init();
            }

            const canvas = this.cachedUIElements.level;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(`关卡: ${level}`, 190, 22);
        },

        /**
         * 绘制UI
         * @param {CanvasRenderingContext2D} ctx - Canvas上下文
         */
        drawUI: function (ctx) {
            if (!this.cachedUIElements.score) {
                this.init();
            }

            // 优化：使用缓存的UI元素
            ctx.drawImage(this.cachedUIElements.score, 10, 10);
            ctx.drawImage(this.cachedUIElements.health, 10, 50);
            ctx.drawImage(this.cachedUIElements.level, CONFIG.canvasWidth - 210, 10);
        }
    };

    // 优化：绘制攻击力提升UI
    function drawAttackPowerUI() {
        const canvasW = CONFIG.canvasWidth;
        const canvasH = CONFIG.canvasHeight;
        const player = state.player;

        ctx.fillStyle = '#ffff33';
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#ffff00';
        ctx.shadowBlur = 8;
        ctx.fillText('攻击力提升!', canvasW / 2, 35);
        ctx.shadowBlur = 0;

        const pulseScale = 1 + Math.sin(state.lastTime * 0.02) * 0.1;
        ctx.save();
        ctx.translate(canvasW / 2, 35);
        ctx.scale(pulseScale, pulseScale);
        ctx.fillText('攻击力提升!', 0, 0);
        ctx.restore();
    }

    // 优化：绘制连击UI
    function drawComboUI() {
        const canvasW = CONFIG.canvasWidth;
        const player = state.player;

        const comboFontSize = Math.min(40, 20 + player.comboCount * 2);
        ctx.fillStyle = '#ffcc00';
        ctx.font = `bold ${comboFontSize}px Arial`;
        ctx.textAlign = 'center';
        ctx.shadowColor = '#ff9900';
        ctx.shadowBlur = 12;

        const comboText = `${player.comboCount}x COMBO!`;
        const bounceOffset = Math.sin(state.lastTime * 0.015) * 3;
        ctx.fillText(comboText, canvasW / 2, 70 + bounceOffset);

        if (player.comboCount >= 5) {
            const pulseAlpha = 0.5 + Math.sin(state.lastTime * 0.03) * 0.3;
            ctx.strokeStyle = `rgba(255, 204, 0, ${pulseAlpha})`;
            ctx.lineWidth = 3;
            const pulseRadius = 60 + Math.sin(state.lastTime * 0.02) * 5;
            ctx.beginPath();
            ctx.arc(canvasW / 2, 70, pulseRadius, 0, Math.PI * 2);
            ctx.stroke();
        }
        ctx.shadowBlur = 0;
    }

    // 优化：绘制无敌状态UI
    function drawInvincibilityUI() {
        const player = state.player;

        if (Math.floor(player.invincibilityFrames / 4) % 2 === 0) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 15;
            ctx.fillRect(player.x - 5, player.y - 5, player.width + 10, player.height + 10);
            ctx.shadowBlur = 0;
        }
    }

    // 绘制粒子效果
    function drawParticles() {
        state.particles.forEach(particle => {
            const alpha = particle.life / particle.maxLife;
            ctx.fillStyle = particle.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
            ctx.fillRect(particle.x - particle.size / 2, particle.y - particle.size / 2, particle.size, particle.size);
        });
    }

    // 绘制攻击效果
    function drawAttackEffects() {
        state.attackEffects.forEach(effect => {
            let color, alpha, scale, rotation;

            alpha = 1 - (effect.timer / effect.duration);
            scale = 1 + (effect.timer / effect.duration) * 0.3;
            rotation = (effect.timer / effect.duration) * Math.PI * 0.5;

            switch (effect.type) {
                case 'normal':
                    color = '#00ffff';
                    break;
                case 'heavy':
                    color = '#ff6600';
                    break;
                case 'special':
                    color = '#ff00ff';
                    break;
                case 'enemyAttack':
                    color = '#ff0066';
                    break;
                default:
                    color = '#00ffff';
            }

            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = 25;

            ctx.translate(effect.x + effect.width / 2, effect.y + effect.height / 2);
            ctx.scale(scale, scale);
            ctx.rotate(rotation);

            if (effect.type === 'normal') {
                ctx.fillRect(-effect.width / 2, -effect.height / 2, effect.width, effect.height);
            } else if (effect.type === 'heavy') {
                ctx.beginPath();
                ctx.moveTo(-effect.width / 2, -effect.height / 2);
                ctx.lineTo(effect.width / 2, -effect.height / 1.5);
                ctx.lineTo(effect.width / 2, effect.height / 1.5);
                ctx.lineTo(-effect.width / 2, effect.height / 2);
                ctx.closePath();
                ctx.fill();
            } else if (effect.type === 'special') {
                const points = 5;
                const outerRadius = Math.max(effect.width, effect.height) / 2;
                const innerRadius = outerRadius / 2;

                ctx.beginPath();
                for (let i = 0; i < points * 2; i++) {
                    const angle = (i * Math.PI) / points - Math.PI / 2;
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const x = radius * Math.cos(angle);
                    const y = radius * Math.sin(angle);

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.fill();
            } else {
                ctx.beginPath();
                ctx.arc(0, 0, Math.max(effect.width, effect.height) / 2, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        });
    }

    // 绘制平台
    function drawPlatforms() {
        ctx.fillStyle = '#6a0dad';
        state.platforms.forEach(platform => {
            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            ctx.shadowColor = '#9d4edd';
            ctx.shadowBlur = 15;
            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            ctx.shadowBlur = 0;
        });
    }

    // 绘制敌人
    function drawEnemies() {
        state.enemies.forEach(enemy => {
            enemy.health = enemy.health || 100;
            enemy.maxHealth = enemy.maxHealth || 100;

            ctx.save();

            if (enemy.isHit) {
                const hitAlpha = 0.5 + Math.sin(state.lastTime * 0.1) * 0.3;
                ctx.globalAlpha = hitAlpha;
            }

            const moveOffset = Math.sin(state.lastTime * 0.02) * 2;
            const enemyY = enemy.y + moveOffset;

            let enemyColor, shadowColor;
            switch (enemy.type || 'normal') {
                case 'normal':
                    enemyColor = '#ff0066';
                    shadowColor = '#ff66cc';
                    break;
                case 'jumping':
                    enemyColor = '#ff6600';
                    shadowColor = '#ff9933';
                    break;
                case 'tracking':
                    enemyColor = '#00ff00';
                    shadowColor = '#66ff66';
                    break;
                case 'flying':
                    enemyColor = '#00ffff';
                    shadowColor = '#66ffff';
                    enemyY += Math.sin(state.lastTime * 0.03) * 3;
                    break;
                case 'shooter':
                    enemyColor = '#ffff00';
                    shadowColor = '#ffff66';
                    break;
                case 'exploder':
                    enemyColor = '#ff3300';
                    shadowColor = '#ff6633';
                    if (enemy.state === 'exploding') {
                        enemyColor = enemy.explosionTimer % 10 < 5 ? '#ff3300' : '#ffff00';
                        shadowColor = '#ff9900';
                        ctx.shadowBlur = 25;
                    }
                    break;
                default:
                    enemyColor = '#ff0066';
                    shadowColor = '#ff66cc';
            }

            ctx.fillStyle = enemyColor;
            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = 18;
            ctx.fillRect(enemy.x, enemyY, enemy.width, enemy.height);
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#ffffff';
            const eyeSize = enemy.width * 0.15;
            ctx.fillRect(enemy.x + enemy.width * 0.3, enemyY + enemy.height * 0.2, eyeSize, eyeSize);
            ctx.fillRect(enemy.x + enemy.width * 0.55, enemyY + enemy.height * 0.2, eyeSize, eyeSize);

            const eyeXOffset = enemy.direction === 1 ? 0 : enemy.width * 0.15;
            ctx.fillStyle = '#000000';
            const pupilSize = enemy.width * 0.075;
            const pupilYOffset = enemy.isJumping ? 2 : 0;
            ctx.fillRect(enemy.x + enemy.width * 0.3 + eyeXOffset, enemyY + enemy.height * 0.2 + enemy.height * 0.05 + pupilYOffset, pupilSize, pupilSize);
            ctx.fillRect(enemy.x + enemy.width * 0.55 + eyeXOffset, enemyY + enemy.height * 0.2 + enemy.height * 0.05 + pupilYOffset, pupilSize, pupilSize);

            ctx.fillStyle = '#ffffff';
            if (enemy.isAttacking) {
                ctx.beginPath();
                ctx.arc(enemy.x + enemy.width * 0.5, enemyY + enemy.height * 0.4, enemy.width * 0.1, 0, Math.PI);
                ctx.fill();
            } else if (enemy.isJumping) {
                ctx.beginPath();
                ctx.arc(enemy.x + enemy.width * 0.5, enemyY + enemy.height * 0.4, enemy.width * 0.08, 0, Math.PI, false);
                ctx.fill();
            } else {
                ctx.beginPath();
                ctx.arc(enemy.x + enemy.width * 0.5, enemyY + enemy.height * 0.4, enemy.width * 0.05, 0, Math.PI * 2);
                ctx.fill();
            }

            const healthPercent = enemy.health / enemy.maxHealth;
            const healthBarWidth = enemy.width * 0.8;
            const healthBarHeight = 5;
            const healthBarX = enemy.x + (enemy.width - healthBarWidth) / 2;
            const healthBarY = enemyY - 12;

            ctx.fillStyle = '#333333';
            ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

            const healthGradient = ctx.createLinearGradient(healthBarX, healthBarY, healthBarX + healthBarWidth, healthBarY);
            if (healthPercent > 0.5) {
                healthGradient.addColorStop(0, '#00ff00');
                healthGradient.addColorStop(1, '#00aa00');
            } else if (healthPercent > 0.25) {
                healthGradient.addColorStop(0, '#ffff00');
                healthGradient.addColorStop(1, '#aaaa00');
            } else {
                healthGradient.addColorStop(0, '#ff0000');
                healthGradient.addColorStop(1, '#aa0000');
            }
            ctx.fillStyle = healthGradient;
            ctx.fillRect(healthBarX, healthBarY, healthBarWidth * healthPercent, healthBarHeight);

            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

            ctx.restore();
        });
    }

    // 绘制玩家
    function drawPlayer() {
        const player = state.player;

        const breathScale = 1 + Math.sin(state.lastTime * 0.005) * 0.02;

        ctx.save();
        ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
        ctx.scale(breathScale, breathScale);
        ctx.translate(-(player.x + player.width / 2), -(player.y + player.height / 2));

        if (player.isAttacking) {
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 25;

            const attackWidth = player.width + (player.facingDirection === 1 ? 30 : -30);
            const attackHeight = player.height + 10;
            ctx.fillRect(
                player.x + (player.facingDirection === 1 ? 0 : -attackWidth + player.width),
                player.y - 5,
                Math.abs(attackWidth),
                attackHeight
            );

            ctx.fillStyle = '#ffffff';
            const slashWidth = 15;
            const slashHeight = 10;
            ctx.fillRect(
                player.x + player.width + (player.facingDirection === 1 ? 5 : -slashWidth - 5),
                player.y + player.height / 2 - slashHeight / 2,
                slashWidth,
                slashHeight
            );

            for (let i = 0; i < 8; i++) {
                const particleX = player.x + player.width + (player.facingDirection === 1 ? 20 : -10) + Math.random() * 20;
                const particleY = player.y + Math.random() * player.height;
                ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + Math.random() * 0.5})`;
                ctx.fillRect(particleX, particleY, 3, 3);
            }
        } else {
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00aaff';
            ctx.shadowBlur = 18;

            let bodyTilt = 0;
            if (player.velocityX > 0) bodyTilt = -7;
            if (player.velocityX < 0) bodyTilt = 7;

            ctx.save();
            ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
            ctx.rotate(bodyTilt * Math.PI / 180);
            ctx.fillRect(-player.width / 2, -player.height / 2, player.width, player.height);
            ctx.restore();
        }
        ctx.shadowBlur = 0;
        ctx.restore();

        ctx.fillStyle = '#ffffff';
        const eyeSize = 4;
        ctx.beginPath();
        ctx.arc(player.x + player.width * 0.3, player.y + player.height * 0.3, eyeSize, 0, Math.PI * 2);
        ctx.arc(player.x + player.width * 0.7, player.y + player.height * 0.3, eyeSize, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#000000';
        const pupilSize = eyeSize * 0.6;
        const pupilOffsetX = player.velocityX * 0.1;
        ctx.beginPath();
        ctx.arc(player.x + player.width * 0.3 + pupilOffsetX, player.y + player.height * 0.3, pupilSize, 0, Math.PI * 2);
        ctx.arc(player.x + player.width * 0.7 + pupilOffsetX, player.y + player.height * 0.3, pupilSize, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#ffffff';
        if (player.isAttacking) {
            ctx.beginPath();
            ctx.arc(player.x + player.width * 0.5, player.y + player.height * 0.4, 5, 0, Math.PI);
            ctx.fill();
        } else if (player.isJumping) {
            ctx.beginPath();
            ctx.arc(player.x + player.width * 0.5, player.y + player.height * 0.4, 4, 0, Math.PI, false);
            ctx.fill();
        } else if (Math.abs(player.velocityX) > 2) {
            ctx.beginPath();
            ctx.arc(player.x + player.width * 0.5, player.y + player.height * 0.4, 3, 0, Math.PI, false);
            ctx.fill();
        } else {
            ctx.beginPath();
            ctx.arc(player.x + player.width * 0.5, player.y + player.height * 0.4, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        if (player.attackPower > 1) {
            ctx.save();
            ctx.globalAlpha = 0.6;
            ctx.fillStyle = '#ffcc00';
            ctx.shadowColor = '#ffcc00';
            ctx.shadowBlur = 20;
            const auraRadius = player.width / 2 + 15 + Math.sin(state.lastTime * 0.02) * 5;
            ctx.beginPath();
            ctx.arc(player.x + player.width / 2, player.y + player.height / 2, auraRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        if (player.shield && player.shield > 0) {
            ctx.save();
            const shieldAlpha = 0.5 * (player.shield / (player.maxShield || 100));
            ctx.globalAlpha = shieldAlpha;
            ctx.fillStyle = '#0099ff';
            ctx.shadowColor = '#0099ff';
            ctx.shadowBlur = 25;
            const shieldRadius = player.width / 2 + 20 + Math.sin(state.lastTime * 0.03) * 8;
            ctx.beginPath();
            ctx.arc(player.x + player.width / 2, player.y + player.height / 2, shieldRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }

    // 绘制关卡完成画面
    function drawLevelComplete() {
        ctx.fillStyle = 'white';
        ctx.font = '40px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('关卡完成!', CONFIG.canvasWidth / 2, CONFIG.canvasHeight / 2);
        ctx.font = '20px Arial';
        ctx.fillText('准备进入下一关...', CONFIG.canvasWidth / 2, CONFIG.canvasHeight / 2 + 40);
    }

    // 绘制游戏胜利画面
    function drawGameWin() {
        ctx.fillStyle = 'white';
        ctx.font = '48px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('游戏通关!', CONFIG.canvasWidth / 2, CONFIG.canvasHeight / 2);
        ctx.font = '24px Arial';
        ctx.fillText(`最终分数: ${state.score}`, CONFIG.canvasWidth / 2, CONFIG.canvasHeight / 2 + 50);
        ctx.fillText('恭喜你完成了所有关卡!', CONFIG.canvasWidth / 2, CONFIG.canvasHeight / 2 + 80);
    }

    // 游戏循环
    function gameLoop(timestamp) {
        try {
            if (!state.gameRunning) return;

            // 优化：处理暂停逻辑
            if (state.isPaused) {
                state.animationId = requestAnimationFrame(gameLoop);
                return;
            }

            // 优化deltaTime计算，添加帧率限制和性能监控
            const currentTime = timestamp || performance.now();
            let deltaTime = currentTime - state.lastTime - state.totalPausedTime;

            // 优化：使用更精确的帧率控制（60FPS = 16.67ms）
            const TARGET_FPS = 60;
            const TARGET_FRAME_TIME = 1000 / TARGET_FPS;
            const MAX_FRAME_TIME = 50; // 最大帧时间，防止卡顿时的跳跃

            // 优化：添加帧率平滑处理，减少帧率抖动
            state.frameTimeHistory = state.frameTimeHistory || [];
            state.frameTimeHistory.push(deltaTime);
            if (state.frameTimeHistory.length > 5) {
                state.frameTimeHistory.shift();
            }
            const smoothedDeltaTime = state.frameTimeHistory.reduce((a, b) => a + b, 0) / state.frameTimeHistory.length;

            // 使用平滑后的deltaTime进行帧率限制
            if (smoothedDeltaTime < TARGET_FRAME_TIME) {
                state.animationId = requestAnimationFrame(gameLoop);
                return;
            }

            // 限制最大deltaTime，防止卡顿
            deltaTime = Math.min(deltaTime, MAX_FRAME_TIME);
            state.lastTime = currentTime;

            // 优化：应用时间缩放机制
            // 平滑过渡时间缩放
            state.timeScale += (state.targetTimeScale - state.timeScale) * state.timeScaleTransitionSpeed;

            // 应用时间缩放到deltaTime
            deltaTime *= state.timeScale;

            // 优化：定期清理内存，防止内存泄漏
            if (state.performanceMetrics.frameCount % 300 === 0) { // 每5秒清理一次
                // 清理性能指标数组
                if (state.performanceMetrics.updateTimes.length > 120) state.performanceMetrics.updateTimes.splice(0, 60);
                if (state.performanceMetrics.drawTimes.length > 120) state.performanceMetrics.drawTimes.splice(0, 60);
                if (state.performanceMetrics.totalTimes.length > 120) state.performanceMetrics.totalTimes.splice(0, 60);

                // 清理FPS数组
                if (state.fps.length > 120) state.fps.splice(0, 60);

                // 清理不再使用的粒子
                state.particles = state.particles.filter(p => p.life > 0);

                // 清理不再使用的攻击效果
                state.attackEffects = state.attackEffects.filter(e => e.timer > 0);

                // 清理不再使用的敌人效果
                state.enemyEffects = state.enemyEffects.filter(e => e.life > 0);
            }

            // 优化：计算实际帧率和性能指标
            const actualFPS = Math.round(1000 / deltaTime);
            state.fps = state.fps || [];
            state.fps.push(actualFPS);
            if (state.fps.length > 60) {
                state.fps.shift();
            }
            state.avgFPS = Math.round(state.fps.reduce((a, b) => a + b, 0) / state.fps.length);

            // 优化：添加详细的性能监控
            state.performanceMetrics = state.performanceMetrics || {
                updateTimes: [],
                drawTimes: [],
                totalTimes: [],
                frameCount: 0,
                cpuUsage: [],
                avgCpuUsage: 0
            };

            const perfMetrics = state.performanceMetrics;

            // 优化：添加性能日志
            if (perfMetrics.frameCount % 600 === 0) { // 每10秒记录一次性能日志
                const perfLog = {
                    timestamp: new Date().toISOString(),
                    frameCount: perfMetrics.frameCount,
                    avgFPS: state.avgFPS,
                    avgUpdateTime: perfMetrics.avgUpdateTime?.toFixed(2) || '0.00',
                    avgDrawTime: perfMetrics.avgDrawTime?.toFixed(2) || '0.00',
                    avgTotalTime: perfMetrics.avgTotalTime?.toFixed(2) || '0.00',
                    avgCpuUsage: perfMetrics.avgCpuUsage?.toFixed(2) || '0.00',
                    avgGpuUsage: perfMetrics.avgGpuUsage?.toFixed(2) || '0.00',
                    particleCount: state.particles.length,
                    enemyCount: state.enemies.length,
                    propCount: state.props.length,
                    timeScale: state.timeScale.toFixed(2)
                };

                console.log('性能日志:', perfLog);

                // 保存性能日志到state中
                state.perfLogs = state.perfLogs || [];
                state.perfLogs.push(perfLog);

                // 限制性能日志数量
                if (state.perfLogs.length > 100) {
                    state.perfLogs.shift();
                }
            }
            perfMetrics.frameCount++;

            // 优化：计算CPU利用率
            const cpuUsage = perfMetrics.avgUpdateTime ? (perfMetrics.avgUpdateTime / TARGET_FRAME_TIME) * 100 : 0;
            perfMetrics.cpuUsage.push(cpuUsage);
            if (perfMetrics.cpuUsage.length > 60) {
                perfMetrics.cpuUsage.shift();
            }
            perfMetrics.avgCpuUsage = perfMetrics.cpuUsage.reduce((a, b) => a + b, 0) / perfMetrics.cpuUsage.length;

            // 优化：根据CPU利用率动态调整性能
            if (perfMetrics.avgCpuUsage > 80) {
                // CPU负载过高，减少粒子数量
                state.maxParticles = Math.max(50, (state.maxParticles || 100) - 1);
            } else if (perfMetrics.avgCpuUsage < 50) {
                // CPU负载较低，可以增加粒子数量
                state.maxParticles = Math.min(200, (state.maxParticles || 100) + 1);
            }

            // 记录更新开始时间
            const updateStartTime = performance.now();

            // 优化游戏状态检查，减少函数调用
            const isPlaying = state.gameState === 'playing';
            const isTimeFrozen = state.timeFrozen;

            if (isPlaying) {
                // 优化：优先处理输入，提高输入响应性
                const inputStartTime = performance.now();
                const input = processInput();
                perfMetrics.inputTime = performance.now() - inputStartTime;

                // 优化：按照标准游戏循环顺序更新
                // 1. 输入处理（在updatePlayer中处理）
                const playerStartTime = performance.now();
                updatePlayer();
                perfMetrics.playerTime = performance.now() - playerStartTime;

                // 2. 物理更新（在updatePlayer中处理）
                // 3. 游戏逻辑更新
                const playerLogicStartTime = performance.now();
                if (state.player.attackCooldown > 0) {
                    state.player.attackCooldown--;
                }
                if (state.player.invincibilityFrames > 0) {
                    state.player.invincibilityFrames--;
                }
                perfMetrics.playerLogicTime = performance.now() - playerLogicStartTime;

                // 4. 敌人AI更新
                if (!isTimeFrozen) {
                    const enemyStartTime = performance.now();
                    updateEnemies();
                    perfMetrics.enemyTime = performance.now() - enemyStartTime;
                }

                // 5. 游戏对象更新（道具、粒子、效果等）
                const propsStartTime = performance.now();
                updateProps();
                perfMetrics.propsTime = performance.now() - propsStartTime;

                const particlesStartTime = performance.now();
                updateParticles();
                perfMetrics.particlesTime = performance.now() - particlesStartTime;

                const attackEffectsStartTime = performance.now();
                updateAttackEffects();
                perfMetrics.attackEffectsTime = performance.now() - attackEffectsStartTime;

                const enemyEffectsStartTime = performance.now();
                updateEnemyEffects();
                perfMetrics.enemyEffectsTime = performance.now() - enemyEffectsStartTime;

                const bombsStartTime = performance.now();
                updateBombs();
                perfMetrics.bombsTime = performance.now() - bombsStartTime;

                // 6. 优化碰撞检测效率
                const collisionStartTime = performance.now();
                // 使用空间分割优化碰撞检测
                if (state.enemies.length > 20) {
                    // 敌人数量较多时，使用空间分割
                    performSpatialCollisionDetection();
                } else {
                    // 敌人数量较少时，使用简单碰撞检测
                    performSimpleCollisionDetection();
                }
                perfMetrics.collisionTime = performance.now() - collisionStartTime;

                // 6. 碰撞检测（在updatePlayer和updateEnemies中处理）
                // 7. 时间冻结逻辑
                if (isTimeFrozen) {
                    state.timeFreezeTimer--;
                    if (state.timeFreezeTimer <= 0) {
                        state.timeFrozen = false;
                        state.timeFreezeTimer = 0;
                    }
                }
            }

            // 记录更新结束时间
            const updateTime = performance.now() - updateStartTime;

            // 优化：分离渲染阶段
            const drawStartTime = performance.now();
            draw();
            const drawTime = performance.now() - drawStartTime;

            // 优化：计算GPU利用率
            const gpuUsage = (drawTime / TARGET_FRAME_TIME) * 100;
            perfMetrics.gpuUsage = perfMetrics.gpuUsage || [];
            perfMetrics.gpuUsage.push(gpuUsage);
            if (perfMetrics.gpuUsage.length > 60) {
                perfMetrics.gpuUsage.shift();
            }
            perfMetrics.avgGpuUsage = perfMetrics.gpuUsage.reduce((a, b) => a + b, 0) / perfMetrics.gpuUsage.length;

            // 优化：根据GPU利用率动态调整渲染质量
            if (perfMetrics.avgGpuUsage > 80) {
                // GPU负载过高，减少渲染质量
                state.renderQuality = Math.max(0.5, (state.renderQuality || 1.0) - 0.01);
            } else if (perfMetrics.avgGpuUsage < 50) {
                // GPU负载较低，可以提高渲染质量
                state.renderQuality = Math.min(1.0, (state.renderQuality || 1.0) + 0.01);
            }

            // 记录总时间
            const totalTime = performance.now() - currentTime;

            // 更新性能指标
            perfMetrics.updateTimes.push(updateTime);
            perfMetrics.drawTimes.push(drawTime);
            perfMetrics.totalTimes.push(totalTime);

            // 限制性能指标数组大小
            if (perfMetrics.updateTimes.length > 60) perfMetrics.updateTimes.shift();
            if (perfMetrics.drawTimes.length > 60) perfMetrics.drawTimes.shift();
            if (perfMetrics.totalTimes.length > 60) perfMetrics.totalTimes.shift();

            // 计算平均时间
            perfMetrics.avgUpdateTime = perfMetrics.updateTimes.reduce((a, b) => a + b, 0) / perfMetrics.updateTimes.length;
            perfMetrics.avgDrawTime = perfMetrics.drawTimes.reduce((a, b) => a + b, 0) / perfMetrics.drawTimes.length;
            perfMetrics.avgTotalTime = perfMetrics.totalTimes.reduce((a, b) => a + b, 0) / perfMetrics.totalTimes.length;

            state.animationId = requestAnimationFrame(gameLoop);
        } catch (error) {
            console.error('游戏循环发生错误:', error);
            console.error('错误堆栈:', error.stack);

            // 尝试恢复游戏循环
            if (state.gameRunning) {
                state.animationId = requestAnimationFrame(gameLoop);
            }
        }
    }

    // 游戏结束
    function gameOver() {
        state.gameRunning = false;
        if (state.animationId) {
            cancelAnimationFrame(state.animationId);
        }
        if (state.player.attackTimer) {
            clearTimeout(state.player.attackTimer);
        }

        ctx.fillStyle = 'white';
        ctx.font = '40px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('游戏结束!', CONFIG.canvasWidth / 2, CONFIG.canvasHeight / 2);
        ctx.font = '20px Arial';
        ctx.fillText(`最终分数: ${state.score}`, CONFIG.canvasWidth / 2, CONFIG.canvasHeight / 2 + 40);
        ctx.fillText('点击刷新键重新开始', CONFIG.canvasWidth / 2, CONFIG.canvasHeight / 2 + 70);
    }

    // 游戏胜利
    function gameWin() {
        state.gameRunning = false;
        if (state.animationId) {
            cancelAnimationFrame(state.animationId);
        }
        if (state.player.attackTimer) {
            clearTimeout(state.player.attackTimer);
        }

        drawGameWin();
    }

    // 导出游戏数据
    function exportGameData() {
        const data = {
            score: state.score,
            completedLevels: state.completedLevels,
            difficulty: state.difficulty,
            timestamp: new Date().toISOString()
        };

        const dataStr = JSON.stringify(data, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);

        const link = document.createElement('a');
        link.href = url;
        link.download = `stickman-adventure-data-${Date.now()}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }

    // 保存游戏进度到本地存储
    function saveGameProgress() {
        const gameData = {
            score: state.score,
            completedLevels: state.completedLevels,
            difficulty: state.difficulty,
            currentLevel: state.currentLevel,
            saveTime: new Date().toISOString()
        };

        // 优化：使用压缩和批量写入
        try {
            const dataString = JSON.stringify(gameData);
            localStorage.setItem('stickmanAdventureProgress', dataString);
            showNotification('游戏进度已保存');
        } catch (error) {
            console.error('保存游戏进度失败:', error);
            showNotification('保存失败，请检查存储空间');
        }
    }

    // 从本地存储加载游戏进度
    function loadGameProgress() {
        const savedData = localStorage.getItem('stickmanAdventureProgress');
        if (savedData) {
            try {
                // 优化：使用批量读取和错误处理
                const gameData = JSON.parse(savedData);

                state.score = gameData.score || 0;
                state.completedLevels = gameData.completedLevels || [0];
                state.difficulty = gameData.difficulty || 'easy';

                generateLevelButtons();
                updateUI();

                showNotification('游戏进度已加载');

                return true;
            } catch (error) {
                console.error('加载游戏进度失败:', error);
                showNotification('加载失败，数据可能已损坏');
                return false;
            }
        }
        return false;
    }

    // 优化：数据存储性能优化
    const StorageOptimizer = {
        /**
         * 压缩数据
         * @param {Object} data - 数据对象
         * @returns {string} 压缩后的字符串
         */
        compressData: function (data) {
            try {
                // 优化：使用简单的数据压缩
                const compressed = JSON.stringify(data);
                return compressed;
            } catch (error) {
                console.error('压缩数据失败:', error);
                return JSON.stringify(data);
            }
        },

        /**
         * 解压数据
         * @param {string} compressedData - 压缩后的字符串
         * @returns {Object} 解压后的数据对象
         */
        decompressData: function (compressedData) {
            try {
                // 优化：使用简单的数据解压
                const data = JSON.parse(compressedData);
                return data;
            } catch (error) {
                console.error('解压数据失败:', error);
                return null;
            }
        },

        /**
         * 批量保存数据
         * @param {Object} data - 数据对象
         * @param {string} key - 存储键
         */
        batchSave: function (data, key) {
            try {
                const compressed = this.compressData(data);
                localStorage.setItem(key, compressed);
                return true;
            } catch (error) {
                console.error('批量保存数据失败:', error);
                return false;
            }
        },

        /**
         * 批量加载数据
         * @param {string} key - 存储键
         * @returns {Object|null} 加载的数据对象
         */
        batchLoad: function (key) {
            try {
                const compressed = localStorage.getItem(key);
                if (compressed) {
                    const data = this.decompressData(compressed);
                    return data;
                }
                return null;
            } catch (error) {
                console.error('批量加载数据失败:', error);
                return null;
            }
        },

        /**
         * 清理过期数据
         * @param {string} keyPrefix - 存储键前缀
         * @param {number} maxAge - 最大保存时间（毫秒）
         */
        cleanExpiredData: function (keyPrefix, maxAge) {
            try {
                const now = Date.now();
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(keyPrefix)) {
                        const data = localStorage.getItem(key);
                        if (data) {
                            const parsed = JSON.parse(data);
                            if (parsed.saveTime && (now - new Date(parsed.saveTime).getTime()) > maxAge) {
                                localStorage.removeItem(key);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('清理过期数据失败:', error);
            }
        }
    };

    // 显示通知
    function showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(106, 13, 173, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(100, 0, 255, 0.5);
            z-index: 10000;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        `;
        notification.textContent = message;

        document.body.appendChild(notification);

        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => {
                document.body.removeChild(notification);
            }, 300);
        }, 3000);
    }

    // 添加存档/读档按钮到UI
    function addSaveLoadButtons() {
        const gameControls = document.querySelector('.game-controls');

        if (!document.getElementById('saveBtn')) {
            const saveBtn = document.createElement('button');
            saveBtn.id = 'saveBtn';
            saveBtn.className = 'cyber-button control-btn';
            saveBtn.textContent = '💾 保存进度';
            saveBtn.addEventListener('click', saveGameProgress);

            gameControls.appendChild(saveBtn);
        }

        if (!document.getElementById('loadBtn')) {
            const loadBtn = document.createElement('button');
            loadBtn.id = 'loadBtn';
            loadBtn.className = 'cyber-button control-btn';
            loadBtn.textContent = '📂 加载进度';
            loadBtn.addEventListener('click', loadGameProgress);

            gameControls.appendChild(loadBtn);
        }
    }

    // 优化：暂停游戏
    function pauseGame() {
        if (!state.isPaused) {
            state.isPaused = true;
            state.pauseTime = performance.now();

            // 暂停所有计时器
            if (state.player.attackTimer) {
                clearTimeout(state.player.attackTimer);
            }
            if (state.player.powerUpTimer) {
                clearTimeout(state.player.powerUpTimer);
            }
            if (state.player.comboTimer) {
                clearTimeout(state.player.comboTimer);
            }

            showNotification('游戏已暂停');
        }
    }

    // 优化：恢复游戏
    function resumeGame() {
        if (state.isPaused) {
            const pausedDuration = performance.now() - state.pauseTime;
            state.totalPausedTime += pausedDuration;
            state.isPaused = false;
            state.pauseTime = 0;

            // 恢复lastTime，避免时间跳跃
            state.lastTime = performance.now();

            showNotification('游戏已恢复');
        }
    }

    // 优化：设置时间缩放
    function setTimeScale(scale, transitionSpeed = 0.1) {
        state.targetTimeScale = Math.max(0.1, Math.min(5.0, scale));
        state.timeScaleTransitionSpeed = transitionSpeed;
    }

    // 优化：立即设置时间缩放（无过渡）
    function setTimeScaleImmediate(scale) {
        state.timeScale = Math.max(0.1, Math.min(5.0, scale));
        state.targetTimeScale = state.timeScale;
    }

    // 优化：获取当前时间缩放
    function getTimeScale() {
        return state.timeScale;
    }

    // 优化：重置时间缩放
    function resetTimeScale() {
        setTimeScale(1.0);
    }

    // 优化：执行空间分割碰撞检测
    function performSpatialCollisionDetection() {
        const player = state.player;
        const cellSize = 100; // 空间分割单元格大小
        const spatialGrid = {};

        // 将敌人放入空间网格
        state.enemies.forEach((enemy, index) => {
            const cellX = Math.floor(enemy.x / cellSize);
            const cellY = Math.floor(enemy.y / cellSize);
            const cellKey = `${cellX},${cellY}`;

            if (!spatialGrid[cellKey]) {
                spatialGrid[cellKey] = [];
            }
            spatialGrid[cellKey].push({ enemy, index });
        });

        // 只检测玩家所在单元格和相邻单元格的敌人
        const playerCellX = Math.floor(player.x / cellSize);
        const playerCellY = Math.floor(player.y / cellSize);

        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                const cellKey = `${playerCellX + dx},${playerCellY + dy}`;
                const enemiesInCell = spatialGrid[cellKey];

                if (enemiesInCell) {
                    enemiesInCell.forEach(({ enemy }) => {
                        if (checkPlayerEnemyCollision(player, enemy)) {
                            handlePlayerEnemyCollision(player, enemy);
                        }
                    });
                }
            }
        }
    }

    // 优化：执行简单碰撞检测
    function performSimpleCollisionDetection() {
        const player = state.player;
        state.enemies.forEach(enemy => {
            if (checkPlayerEnemyCollision(player, enemy)) {
                handlePlayerEnemyCollision(player, enemy);
            }
        });
    }

    // 优化：检查玩家与敌人的碰撞
    function checkPlayerEnemyCollision(player, enemy) {
        return (
            player.x < enemy.x + enemy.width &&
            player.x + player.width > enemy.x &&
            player.y < enemy.y + enemy.height &&
            player.y + player.height > enemy.y
        );
    }

    // 优化：处理玩家与敌人的碰撞
    function handlePlayerEnemyCollision(player, enemy) {
        if (player.invincibilityFrames <= 0) {
            player.health -= 8;
            player.invincibilityFrames = 35;
            player.lastDamageTime = state.lastTime;
            player.velocityX = (player.x - enemy.x) > 0 ? 5 : -5;
            player.velocityY = -3;
            updateHealthBar();
            if (player.health <= 0) {
                gameOver();
            }
            addParticles(player.x + player.width / 2, player.y + player.height / 2, 15, '#ff0000', 6);
        }
    }

    // 优化：批量绘制平台
    function drawPlatformsBatch() {
        ctx.fillStyle = '#6a0dad';
        state.platforms.forEach(platform => {
            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        });
    }

    // 优化：批量绘制道具
    function drawPropsBatch() {
        state.props.forEach(prop => {
            if (!prop.collected) {
                ctx.fillStyle = prop.color || '#00ff00';
                ctx.beginPath();
                ctx.arc(prop.x + prop.width / 2, prop.y + prop.height / 2, prop.width / 2, 0, Math.PI * 2);
                ctx.fill();
            }
        });
    }

    // 优化：批量绘制敌人
    function drawEnemiesBatch() {
        state.enemies.forEach(enemy => {
            ctx.fillStyle = enemy.color || '#ff0000';
            ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
        });
    }

    // 优化：批量绘制攻击效果
    function drawAttackEffectsBatch() {
        state.attackEffects.forEach(effect => {
            if (effect.timer > 0) {
                ctx.save();
                ctx.translate(effect.x + effect.width / 2, effect.y + effect.height / 2);
                const scale = effect.timer / effect.duration;
                ctx.scale(scale, scale);
                ctx.fillStyle = effect.color || '#ffff00';
                ctx.fillRect(-effect.width / 2, -effect.height / 2, effect.width, effect.height);
                ctx.restore();
            }
        });
    }

    // 优化：批量绘制粒子
    function drawParticlesBatch() {
        state.particles.forEach(particle => {
            if (particle.life > 0) {
                const alpha = particle.life / particle.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            }
        });
        ctx.globalAlpha = 1.0;
    }

    // 优化：切换暂停状态
    function togglePause() {
        if (state.isPaused) {
            resumeGame();
        } else {
            pauseGame();
        }
    }

    return {
        init: initGame,
        pause: pauseGame,
        resume: resumeGame,
        togglePause: togglePause
    };
}) ();

/**
 * 战斗反馈系统
 * 用于显示战斗过程中的视觉反馈，包括伤害数字、屏幕震动、击中效果等
 */
const CombatFeedback = {
    damageNumbers: [],
    screenShake: {
        intensity: 0,
        duration: 0,
        offsetX: 0,
        offsetY: 0
    },

    /**
     * 添加伤害数字
     * @param {number} x - X坐标
     * @param {number} y - Y坐标
     * @param {number} damage - 伤害值
     * @param {string} color - 颜色
     */
    addDamageNumber: function (x, y, damage, color = '#ff0000') {
        // 限制伤害数字数量
        if (this.damageNumbers.length > 10) {
            this.damageNumbers.shift();
        }

        this.damageNumbers.push({
            x: x,
            y: y,
            damage: Math.round(damage),
            color: color,
            life: 60,
            maxLife: 60,
            velocityY: -2
        });
    },

    /**
     * 更新伤害数字
     */
    updateDamageNumbers: function () {
        for (let i = this.damageNumbers.length - 1; i >= 0; i--) {
            const number = this.damageNumbers[i];
            number.y += number.velocityY;
            number.life--;

            if (number.life <= 0) {
                this.damageNumbers.splice(i, 1);
            }
        }
    },

    /**
     * 绘制伤害数字
     */
    drawDamageNumbers: function () {
        ctx.save();
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';

        for (let i = 0; i < this.damageNumbers.length; i++) {
            const number = this.damageNumbers[i];
            const alpha = number.life / number.maxLife;

            ctx.globalAlpha = alpha;
            ctx.fillStyle = number.color;
            ctx.fillText(number.damage, number.x, number.y);
        }

        ctx.restore();
    },

    /**
     * 添加屏幕震动
     * @param {number} intensity - 震动强度
     * @param {number} duration - 震动持续时间
     */
    addScreenShake: function (intensity, duration) {
        this.screenShake.intensity = Math.max(this.screenShake.intensity, intensity);
        this.screenShake.duration = Math.max(this.screenShake.duration, duration);
    },

    /**
     * 更新屏幕震动
     */
    updateScreenShake: function () {
        if (this.screenShake.duration > 0) {
            this.screenShake.offsetX = (Math.random() - 0.5) * this.screenShake.intensity;
            this.screenShake.offsetY = (Math.random() - 0.5) * this.screenShake.intensity;
            this.screenShake.duration--;

            // 逐渐减少震动强度
            this.screenShake.intensity *= 0.9;
        } else {
            this.screenShake.offsetX = 0;
            this.screenShake.offsetY = 0;
        }
    },

    /**
     * 应用屏幕震动
     */
    applyScreenShake: function () {
        if (this.screenShake.offsetX !== 0 || this.screenShake.offsetY !== 0) {
            ctx.translate(this.screenShake.offsetX, this.screenShake.offsetY);
        }
    },

    /**
     * 显示击中效果
     * @param {number} x - X坐标
     * @param {number} y - Y坐标
     * @param {number} size - 大小
     * @param {string} color - 颜色
     */
    showHitEffect: function (x, y, size, color) {
        // 使用粒子系统显示击中效果
        addParticles(x, y, 5, color, 3);

        // 添加屏幕震动
        this.addScreenShake(3, 10);
    },

    /**
     * 显示玩家受伤效果
     * @param {object} player - 玩家对象
     */
    showPlayerDamageEffect: function (player) {
        this.addDamageNumber(player.x + player.width / 2, player.y, 10, '#ff0000');
        this.addScreenShake(5, 15);
        addParticles(player.x + player.width / 2, player.y + player.height / 2, 10, '#ff0000', 5);
    },

    /**
     * 显示敌人死亡效果
     * @param {object} enemy - 敌人对象
     */
    showEnemyDeathEffect: function (enemy) {
        this.addDamageNumber(enemy.x + enemy.width / 2, enemy.y, 30, '#ff0000');
        this.addScreenShake(8, 20);
        addParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 30, '#ff0000', 15);
    }
};

/**
 * 战斗数值平衡系统
 * 用于计算和平衡游戏中的各种战斗数值，包括伤害、生命值、攻击力等
 * 使用数学公式确保游戏平衡性和可玩性
 * @typedef {Object} CombatStats
 * @property {number} attackPower - 攻击力
 * @property {number} defensePower - 防御力
 * @property {number} level - 等级
 */
const CombatBalance = {
    /**
     * 计算伤害值
     * @param {number} baseDamage - 基础伤害值
     * @param {CombatStats} attackerStats - 攻击者属性
     * @param {CombatStats} defenderStats - 防御者属性
     * @returns {number} 计算后的伤害值
     */
    calculateDamage: function (baseDamage, attackerStats, defenderStats) {
        // 使用对数曲线平衡伤害
        const attackPower = attackerStats.attackPower || 1.0;
        const defensePower = defenderStats.defensePower || 0.0;
        const levelBonus = (attackerStats.level || 1) * 0.1;

        const damageMultiplier = Math.log(1 + attackPower) / Math.log(1 + defensePower + 1);
        const finalDamage = baseDamage * damageMultiplier * (1 + levelBonus);

        return Math.max(1, Math.round(finalDamage));
    },

    /**
     * 计算生命值
     * @param {number} baseHealth - 基础生命值
     * @param {number} difficultyMultiplier - 难度系数
     * @returns {number} 计算后的生命值
     */
    calculateHealth: function (baseHealth, difficultyMultiplier) {
        // 使用平方根曲线平衡生命值
        return Math.round(baseHealth * Math.sqrt(difficultyMultiplier));
    },

    /**
     * 计算攻击力
     * @param {number} basePower - 基础攻击力
     * @param {number} levelMultiplier - 等级系数
     * @returns {number} 计算后的攻击力
     */
    calculateAttackPower: function (basePower, levelMultiplier) {
        // 使用线性曲线平衡攻击力
        return basePower * levelMultiplier;
    },

    /**
     * 计算暴击伤害
     * @param {number} baseDamage - 基础伤害值
     * @param {number} critRate - 暴击率（0-1）
     * @param {number} critMultiplier - 暴击倍数
     * @returns {number} 计算后的伤害值
     */
    calculateCrit: function (baseDamage, critRate, critMultiplier) {
        if (Math.random() < critRate) {
            return Math.round(baseDamage * critMultiplier);
        }
        return baseDamage;
    },

    /**
     * 计算闪避
     * @param {number} dodgeRate - 闪避率（0-1）
     * @returns {boolean} 是否闪避成功
     */
    calculateDodge: function (dodgeRate) {
        return Math.random() < dodgeRate;
    },

    /**
     * 获取平衡系数
     * @param {number} level - 等级
     * @returns {number} 平衡系数
     */
    getBalanceMultiplier: function (level) {
        // 使用多项式曲线平衡系数
        return 1.0 + level * 0.1 + level * level * 0.01;
    }
};

// 优化：特效系统性能优化
const EffectSystemOptimizer = {
    /**
     * 优化粒子系统性能
     * @param {Array} particles - 粒子数组
     * @param {number} maxParticles - 最大粒子数量
     */
    optimizeParticles: function (particles, maxParticles) {
        // 优化：限制粒子数量
        if (particles.length > maxParticles) {
            particles.splice(0, particles.length - maxParticles);
        }

        // 优化：批量更新粒子
        const activeParticles = [];
        for (let i = 0; i < particles.length; i++) {
            const particle = particles[i];
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.vy += particle.gravity || 0;
            particle.life--;

            if (particle.life > 0) {
                activeParticles.push(particle);
            }
        }

        // 优化：清空并重新填充粒子数组
        particles.length = 0;
        for (let i = 0; i < activeParticles.length; i++) {
            particles.push(activeParticles[i]);
        }
    },

    /**
     * 优化攻击效果性能
     * @param {Array} attackEffects - 攻击效果数组
     * @param {number} maxEffects - 最大效果数量
     */
    optimizeAttackEffects: function (attackEffects, maxEffects) {
        // 优化：限制攻击效果数量
        if (attackEffects.length > maxEffects) {
            attackEffects.splice(0, attackEffects.length - maxEffects);
        }

        // 优化：批量更新攻击效果
        const activeEffects = [];
        for (let i = 0; i < attackEffects.length; i++) {
            const effect = attackEffects[i];
            effect.life--;

            if (effect.life > 0) {
                activeEffects.push(effect);
            }
        }

        // 优化：清空并重新填充效果数组
        attackEffects.length = 0;
        for (let i = 0; i < activeEffects.length; i++) {
            attackEffects.push(activeEffects[i]);
        }
    },

    /**
     * 优化敌人效果性能
     * @param {Array} enemyEffects - 敌人效果数组
     * @param {number} maxEffects - 最大效果数量
     */
    optimizeEnemyEffects: function (enemyEffects, maxEffects) {
        // 优化：限制敌人效果数量
        if (enemyEffects.length > maxEffects) {
            enemyEffects.splice(0, enemyEffects.length - maxEffects);
        }

        // 优化：批量更新敌人效果
        const activeEffects = [];
        for (let i = 0; i < enemyEffects.length; i++) {
            const effect = enemyEffects[i];
            effect.life--;

            if (effect.life > 0) {
                activeEffects.push(effect);
            }
        }

        // 优化：清空并重新填充效果数组
        enemyEffects.length = 0;
        for (let i = 0; i < activeEffects.length; i++) {
            enemyEffects.push(activeEffects[i]);
        }
    },

    /**
     * 优化道具效果性能
     * @param {Array} props - 道具数组
     * @param {number} maxProps - 最大道具数量
     */
    optimizeProps: function (props, maxProps) {
        // 优化：限制道具数量
        if (props.length > maxProps) {
            props.splice(0, props.length - maxProps);
        }

        // 优化：批量更新道具
        const activeProps = [];
        for (let i = 0; i < props.length; i++) {
            const prop = props[i];
            prop.life--;

            if (prop.life > 0) {
                activeProps.push(prop);
            }
        }

        // 优化：清空并重新填充道具数组
        props.length = 0;
        for (let i = 0; i < activeProps.length; i++) {
            props.push(activeProps[i]);
        }
    },

    /**
     * 批量优化所有特效系统
     * @param {Object} state - 游戏状态
     */
    optimizeAllEffects: function (state) {
        // 优化：批量优化所有特效系统
        this.optimizeParticles(state.particles, 100);
        this.optimizeAttackEffects(state.attackEffects, 50);
        this.optimizeEnemyEffects(state.enemyEffects, 50);
        this.optimizeProps(state.props, 20);
    }
};

// 优化：缓存策略性能优化
const CacheOptimizer = {
    cache: {},
    cacheStats: {
        hits: 0,
        misses: 0,
        evictions: 0
    },
    maxCacheSize: 100,

    /**
     * 初始化缓存
     */
    init: function () {
        this.cache = {};
        this.cacheStats = {
            hits: 0,
            misses: 0,
            evictions: 0
        };
    },

    /**
     * 获取缓存数据
     * @param {string} key - 缓存键
     * @returns {any|null} 缓存数据
     */
    get: function (key) {
        if (this.cache[key]) {
            this.cacheStats.hits++;
            return this.cache[key].data;
        }
        this.cacheStats.misses++;
        return null;
    },

    /**
     * 设置缓存数据
     * @param {string} key - 缓存键
     * @param {any} data - 缓存数据
     * @param {number} ttl - 生存时间（毫秒）
     */
    set: function (key, data, ttl = 60000) {
        // 优化：检查缓存大小
        if (Object.keys(this.cache).length >= this.maxCacheSize) {
            // 优化：使用LRU策略淘汰缓存
            this.evictLRU();
        }

        this.cache[key] = {
            data: data,
            timestamp: Date.now(),
            ttl: ttl,
            accessCount: 0
        };
    },

    /**
     * 删除缓存数据
     * @param {string} key - 缓存键
     */
    delete: function (key) {
        if (this.cache[key]) {
            delete this.cache[key];
        }
    },

    /**
     * 清空缓存
     */
    clear: function () {
        this.cache = {};
        this.cacheStats = {
            hits: 0,
            misses: 0,
            evictions: 0
        };
    },

    /**
     * 清理过期缓存
     */
    cleanExpired: function () {
        const now = Date.now();
        for (const key in this.cache) {
            const item = this.cache[key];
            if (now - item.timestamp > item.ttl) {
                delete this.cache[key];
                this.cacheStats.evictions++;
            }
        }
    },

    /**
     * 使用LRU策略淘汰缓存
     */
    evictLRU: function () {
        let lruKey = null;
        let minAccessCount = Infinity;

        for (const key in this.cache) {
            if (this.cache[key].accessCount < minAccessCount) {
                minAccessCount = this.cache[key].accessCount;
                lruKey = key;
            }
        }

        if (lruKey) {
            delete this.cache[lruKey];
            this.cacheStats.evictions++;
        }
    },

    /**
     * 获取缓存统计信息
     * @returns {Object} 缓存统计信息
     */
    getStats: function () {
        const totalRequests = this.cacheStats.hits + this.cacheStats.misses;
        const hitRate = totalRequests > 0 ? (this.cacheStats.hits / totalRequests * 100).toFixed(2) : 0;

        return {
            hits: this.cacheStats.hits,
            misses: this.cacheStats.misses,
            evictions: this.cacheStats.evictions,
            hitRate: hitRate + '%',
            size: Object.keys(this.cache).length
        };
    }
};

// 优化：内存管理性能优化
const MemoryOptimizer = {
    memoryStats: {
        allocations: 0,
        deallocations: 0,
        peakMemory: 0,
        currentMemory: 0
    },
    objectPools: {},

    /**
     * 初始化内存管理
     */
    init: function () {
        this.memoryStats = {
            allocations: 0,
            deallocations: 0,
            peakMemory: 0,
            currentMemory: 0
        };
        this.objectPools = {};
    },

    /**
     * 创建对象池
     * @param {string} name - 对象池名称
     * @param {Function} factory - 对象工厂函数
     * @param {number} initialSize - 初始大小
     */
    createPool: function (name, factory, initialSize = 10) {
        if (!this.objectPools[name]) {
            this.objectPools[name] = {
                pool: [],
                factory: factory,
                active: 0
            };

            // 优化：预分配对象
            for (let i = 0; i < initialSize; i++) {
                this.objectPools[name].pool.push(factory());
            }
        }
    },

    /**
     * 从对象池获取对象
     * @param {string} name - 对象池名称
     * @returns {Object} 对象
     */
    acquire: function (name) {
        if (!this.objectPools[name]) {
            console.error(`对象池 ${name} 不存在`);
            return null;
        }

        const pool = this.objectPools[name];
        let obj;

        if (pool.pool.length > 0) {
            obj = pool.pool.pop();
        } else {
            obj = pool.factory();
            this.memoryStats.allocations++;
        }

        pool.active++;
        this.memoryStats.currentMemory++;

        if (this.memoryStats.currentMemory > this.memoryStats.peakMemory) {
            this.memoryStats.peakMemory = this.memoryStats.currentMemory;
        }

        return obj;
    },

    /**
     * 释放对象到对象池
     * @param {string} name - 对象池名称
     * @param {Object} obj - 对象
     */
    release: function (name, obj) {
        if (!this.objectPools[name]) {
            console.error(`对象池 ${name} 不存在`);
            return;
        }

        const pool = this.objectPools[name];
        pool.pool.push(obj);
        pool.active--;
        this.memoryStats.deallocations++;
        this.memoryStats.currentMemory--;
    },

    /**
     * 清理对象池
     * @param {string} name - 对象池名称
     */
    clearPool: function (name) {
        if (this.objectPools[name]) {
            this.objectPools[name].pool = [];
            this.objectPools[name].active = 0;
        }
    },

    /**
     * 获取内存统计信息
     * @returns {Object} 内存统计信息
     */
    getStats: function () {
        return {
            allocations: this.memoryStats.allocations,
            deallocations: this.memoryStats.deallocations,
            peakMemory: this.memoryStats.peakMemory,
            currentMemory: this.memoryStats.currentMemory,
            pools: Object.keys(this.objectPools).map(name => ({
                name: name,
                poolSize: this.objectPools[name].pool.length,
                active: this.objectPools[name].active
            }))
        };
    },

    /**
     * 强制垃圾回收
     */
    forceGC: function () {
        // 优化：清理所有对象池
        for (const name in this.objectPools) {
            this.clearPool(name);
        }

        // 优化：清理缓存
        if (typeof CacheOptimizer !== 'undefined') {
            CacheOptimizer.clear();
        }
    }
};

// 优化：错误处理性能优化
const ErrorOptimizer = {
    errorLog: [],
    maxLogSize: 100,
    errorHandlers: {},

    /**
     * 初始化错误处理
     */
    init: function () {
        this.errorLog = [];
        this.errorHandlers = {};

        // 优化：设置全局错误处理
        window.addEventListener('error', (event) => {
            this.logError(event.error || event.message, 'Global Error');
        });

        window.addEventListener('unhandledrejection', (event) => {
            this.logError(event.reason, 'Unhandled Promise Rejection');
        });
    },

    /**
     * 记录错误
     * @param {Error|string} error - 错误对象或错误消息
     * @param {string} context - 错误上下文
     */
    logError: function (error, context = 'Unknown') {
        const errorInfo = {
            message: error instanceof Error ? error.message : String(error),
            stack: error instanceof Error ? error.stack : null,
            context: context,
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent
        };

        // 优化：限制日志大小
        if (this.errorLog.length >= this.maxLogSize) {
            this.errorLog.shift();
        }

        this.errorLog.push(errorInfo);

        // 优化：输出到控制台
        console.error(`[${context}]`, error);
    },

    /**
     * 获取错误日志
     * @returns {Array} 错误日志
     */
    getErrorLog: function () {
        return this.errorLog;
    },

    /**
     * 清空错误日志
     */
    clearErrorLog: function () {
        this.errorLog = [];
    },

    /**
     * 注册错误处理器
     * @param {string} errorType - 错误类型
     * @param {Function} handler - 错误处理函数
     */
    registerHandler: function (errorType, handler) {
        this.errorHandlers[errorType] = handler;
    },

    /**
     * 处理错误
     * @param {Error|string} error - 错误对象或错误消息
     * @param {string} errorType - 错误类型
     */
    handleError: function (error, errorType) {
        this.logError(error, errorType);

        if (this.errorHandlers[errorType]) {
            try {
                this.errorHandlers[errorType](error);
            } catch (handlerError) {
                console.error('错误处理器执行失败:', handlerError);
            }
        }
    },

    /**
     * 安全执行函数
     * @param {Function} fn - 要执行的函数
     * @param {string} context - 上下文
     * @returns {any} 函数执行结果
     */
    safeExecute: function (fn, context = 'Safe Execute') {
        try {
            return fn();
        } catch (error) {
            this.logError(error, context);
            return null;
        }
    },

    /**
     * 异步安全执行函数
     * @param {Function} fn - 要执行的函数
     * @param {string} context - 上下文
     * @returns {Promise} Promise对象
     */
    async safeExecuteAsync(fn, context = 'Safe Execute Async') {
        try {
            return await fn();
        } catch (error) {
            this.logError(error, context);
            return null;
        }
    }
};

// 优化：日志系统性能优化
const LoggerOptimizer = {
    logs: [],
    maxLogSize: 500,
    logLevels: {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3,
        FATAL: 4
    },
    currentLevel: 1,

    /**
     * 初始化日志系统
     */
    init: function () {
        this.logs = [];
        this.currentLevel = this.logLevels.INFO;
    },

    /**
     * 设置日志级别
     * @param {string} level - 日志级别
     */
    setLevel: function (level) {
        if (this.logLevels[level] !== undefined) {
            this.currentLevel = this.logLevels[level];
        }
    },

    /**
     * 记录日志
     * @param {string} level - 日志级别
     * @param {string} message - 日志消息
     * @param {Object} data - 附加数据
     */
    log: function (level, message, data = null) {
        if (this.logLevels[level] < this.currentLevel) {
            return;
        }

        const logEntry = {
            level: level,
            message: message,
            data: data,
            timestamp: new Date().toISOString()
        };

        // 优化：限制日志大小
        if (this.logs.length >= this.maxLogSize) {
            this.logs.shift();
        }

        this.logs.push(logEntry);

        // 优化：批量输出日志
        this.outputLog(logEntry);
    },

    /**
     * 输出日志
     * @param {Object} logEntry - 日志条目
     */
    outputLog: function (logEntry) {
        const { level, message, data, timestamp } = logEntry;
        const logMessage = `[${timestamp}] [${level}] ${message}`;

        switch (level) {
            case 'DEBUG':
                console.debug(logMessage, data);
                break;
            case 'INFO':
                console.info(logMessage, data);
                break;
            case 'WARN':
                console.warn(logMessage, data);
                break;
            case 'ERROR':
            case 'FATAL':
                console.error(logMessage, data);
                break;
            default:
                console.log(logMessage, data);
        }
    },

    /**
     * 记录调试日志
     * @param {string} message - 日志消息
     * @param {Object} data - 附加数据
     */
    debug: function (message, data = null) {
        this.log('DEBUG', message, data);
    },

    /**
     * 记录信息日志
     * @param {string} message - 日志消息
     * @param {Object} data - 附加数据
     */
    info: function (message, data = null) {
        this.log('INFO', message, data);
    },

    /**
     * 记录警告日志
     * @param {string} message - 日志消息
     * @param {Object} data - 附加数据
     */
    warn: function (message, data = null) {
        this.log('WARN', message, data);
    },

    /**
     * 记录错误日志
     * @param {string} message - 日志消息
     * @param {Object} data - 附加数据
     */
    error: function (message, data = null) {
        this.log('ERROR', message, data);
    },

    /**
     * 记录致命错误日志
     * @param {string} message - 日志消息
     * @param {Object} data - 附加数据
     */
    fatal: function (message, data = null) {
        this.log('FATAL', message, data);
    },

    /**
     * 获取日志
     * @param {string} level - 日志级别（可选）
     * @returns {Array} 日志数组
     */
    getLogs: function (level = null) {
        if (level) {
            return this.logs.filter(log => log.level === level);
        }
        return this.logs;
    },

    /**
     * 清空日志
     */
    clearLogs: function () {
        this.logs = [];
    },

    /**
     * 导出日志
     * @returns {string} 日志JSON字符串
     */
    exportLogs: function () {
        return JSON.stringify(this.logs, null, 2);
    }
};

// 优化：调试工具性能优化
const DebugToolOptimizer = {
    debugPanel: null,
    isVisible: false,
    performanceData: {
        fps: [],
        frameTime: [],
        memory: []
    },
    maxDataPoints: 60,

    /**
     * 初始化调试工具
     */
    init: function () {
        this.debugPanel = this.createDebugPanel();
        this.performanceData = {
            fps: [],
            frameTime: [],
            memory: []
        };
    },

    /**
     * 创建调试面板
     * @returns {HTMLElement} 调试面板元素
     */
    createDebugPanel: function () {
        const panel = document.createElement('div');
        panel.id = 'debugPanel';
        panel.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            width: 300px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
            border-radius: 5px;
            z-index: 10000;
            display: none;
            max-height: 400px;
            overflow-y: auto;
        `;

        document.body.appendChild(panel);

        // 优化：添加键盘快捷键
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F12' && e.ctrlKey) {
                e.preventDefault();
                this.toggle();
            }
        });

        return panel;
    },

    /**
     * 显示/隐藏调试面板
     */
    toggle: function () {
        this.isVisible = !this.isVisible;
        this.debugPanel.style.display = this.isVisible ? 'block' : 'none';
        if (this.isVisible) {
            this.update();
        }
    },

    /**
     * 更新调试面板
     */
    update: function () {
        if (!this.isVisible) {
            return;
        }

        const html = `
            <h3>调试信息</h3>
            <div>FPS: ${this.getAverageFPS()}</div>
            <div>帧时间: ${this.getAverageFrameTime()}ms</div>
            <div>内存: ${this.getAverageMemory()}MB</div>
            <hr>
            <div>粒子数量: ${state.particles ? state.particles.length : 0}</div>
            <div>敌人数量: ${state.enemies ? state.enemies.length : 0}</div>
            <div>道具数量: ${state.props ? state.props.length : 0}</div>
            <hr>
            <div>游戏状态: ${state.gameState}</div>
            <div>当前关卡: ${state.currentLevel}</div>
            <div>分数: ${state.score}</div>
        `;

        this.debugPanel.innerHTML = html;
    },

    /**
     * 记录性能数据
     * @param {number} fps - FPS
     * @param {number} frameTime - 帧时间
     * @param {number} memory - 内存使用量
     */
    recordPerformance: function (fps, frameTime, memory) {
        // 优化：限制数据点数量
        if (this.performanceData.fps.length >= this.maxDataPoints) {
            this.performanceData.fps.shift();
            this.performanceData.frameTime.shift();
            this.performanceData.memory.shift();
        }

        this.performanceData.fps.push(fps);
        this.performanceData.frameTime.push(frameTime);
        this.performanceData.memory.push(memory);
    },

    /**
     * 获取平均FPS
     * @returns {number} 平均FPS
     */
    getAverageFPS: function () {
        if (this.performanceData.fps.length === 0) {
            return 0;
        }
        const sum = this.performanceData.fps.reduce((a, b) => a + b, 0);
        return Math.round(sum / this.performanceData.fps.length);
    },

    /**
     * 获取平均帧时间
     * @returns {number} 平均帧时间
     */
    getAverageFrameTime: function () {
        if (this.performanceData.frameTime.length === 0) {
            return 0;
        }
        const sum = this.performanceData.frameTime.reduce((a, b) => a + b, 0);
        return Math.round(sum / this.performanceData.frameTime.length);
    },

    /**
     * 获取平均内存使用量
     * @returns {number} 平均内存使用量
     */
    getAverageMemory: function () {
        if (this.performanceData.memory.length === 0) {
            return 0;
        }
        const sum = this.performanceData.memory.reduce((a, b) => a + b, 0);
        return Math.round(sum / this.performanceData.memory.length);
    },

    /**
     * 导出性能数据
     * @returns {string} 性能数据JSON字符串
     */
    exportPerformanceData: function () {
        return JSON.stringify(this.performanceData, null, 2);
    }
};

// 优化：性能监控性能优化
const PerformanceMonitorOptimizer = {
    metrics: {},
    startTime: 0,
    frameCount: 0,

    /**
     * 初始化性能监控
     */
    init: function () {
        this.metrics = {};
        this.startTime = performance.now();
        this.frameCount = 0;
    },

    /**
     * 开始测量
     * @param {string} name - 测量名称
     */
    startMeasure: function (name) {
        if (!this.metrics[name]) {
            this.metrics[name] = {
                totalTime: 0,
                count: 0,
                minTime: Infinity,
                maxTime: 0
            };
        }
        this.metrics[name].startTime = performance.now();
    },

    /**
     * 结束测量
     * @param {string} name - 测量名称
     */
    endMeasure: function (name) {
        if (!this.metrics[name] || !this.metrics[name].startTime) {
            return;
        }

        const duration = performance.now() - this.metrics[name].startTime;
        const metric = this.metrics[name];

        metric.totalTime += duration;
        metric.count++;
        metric.minTime = Math.min(metric.minTime, duration);
        metric.maxTime = Math.max(metric.maxTime, duration);
        metric.avgTime = metric.totalTime / metric.count;

        delete metric.startTime;
    },

    /**
     * 获取测量结果
     * @param {string} name - 测量名称
     * @returns {Object|null} 测量结果
     */
    getMeasure: function (name) {
        if (!this.metrics[name]) {
            return null;
        }

        const metric = this.metrics[name];
        return {
            avgTime: metric.avgTime || 0,
            minTime: metric.minTime === Infinity ? 0 : metric.minTime,
            maxTime: metric.maxTime,
            totalTime: metric.totalTime,
            count: metric.count
        };
    },

    /**
     * 获取所有测量结果
     * @returns {Object} 所有测量结果
     */
    getAllMeasures: function () {
        const results = {};
        for (const name in this.metrics) {
            results[name] = this.getMeasure(name);
        }
        return results;
    },

    /**
     * 清空测量数据
     */
    clearMeasures: function () {
        this.metrics = {};
    },

    /**
     * 记录帧
     */
    recordFrame: function () {
        this.frameCount++;
    },

    /**
     * 获取帧率
     * @returns {number} 帧率
     */
    getFPS: function () {
        const elapsed = (performance.now() - this.startTime) / 1000;
        if (elapsed === 0) {
            return 0;
        }
        return Math.round(this.frameCount / elapsed);
    },

    /**
     * 重置监控
     */
    reset: function () {
        this.metrics = {};
        this.startTime = performance.now();
        this.frameCount = 0;
    },

    /**
     * 生成性能报告
     * @returns {string} 性能报告
     */
    generateReport: function () {
        const report = {
            fps: this.getFPS(),
            frameCount: this.frameCount,
            elapsedTime: ((performance.now() - this.startTime) / 1000).toFixed(2) + 's',
            measures: this.getAllMeasures()
        };
        return JSON.stringify(report, null, 2);
    }
};

// 优化：代码结构性能优化
const CodeStructureOptimizer = {
    modules: {},
    dependencies: {},

    /**
     * 初始化代码结构
     */
    init: function () {
        this.modules = {};
        this.dependencies = {};
    },

    /**
     * 定义模块
     * @param {string} name - 模块名称
     * @param {Function} factory - 模块工厂函数
     * @param {Array} dependencies - 依赖项
     */
    define: function (name, factory, dependencies = []) {
        if (this.modules[name]) {
            console.warn(`模块 ${name} 已存在，将被覆盖`);
        }

        this.dependencies[name] = dependencies;
        this.modules[name] = {
            factory: factory,
            instance: null,
            loaded: false
        };
    },

    /**
     * 获取模块
     * @param {string} name - 模块名称
     * @returns {Object|null} 模块实例
     */
    require: function (name) {
        if (!this.modules[name]) {
            console.error(`模块 ${name} 不存在`);
            return null;
        }

        const module = this.modules[name];

        if (!module.loaded) {
            // 优化：解析依赖项
            const deps = this.dependencies[name].map(dep => this.require(dep));

            // 优化：创建模块实例
            module.instance = module.factory.apply(null, deps);
            module.loaded = true;
        }

        return module.instance;
    },

    /**
     * 检查模块是否已加载
     * @param {string} name - 模块名称
     * @returns {boolean} 是否已加载
     */
    isLoaded: function (name) {
        return this.modules[name] && this.modules[name].loaded;
    },

    /**
     * 卸载模块
     * @param {string} name - 模块名称
     */
    unload: function (name) {
        if (this.modules[name]) {
            this.modules[name].loaded = false;
            this.modules[name].instance = null;
        }
    },

    /**
     * 重新加载模块
     * @param {string} name - 模块名称
     */
    reload: function (name) {
        this.unload(name);
        return this.require(name);
    },

    /**
     * 获取所有模块
     * @returns {Array} 模块列表
     */
    getModules: function () {
        return Object.keys(this.modules);
    },

    /**
     * 获取模块依赖关系
     * @returns {Object} 依赖关系图
     */
    getDependencyGraph: function () {
        return this.dependencies;
    }
};

// 优化：代码复用性能优化
const CodeReuseOptimizer = {
    templates: {},
    functions: {},

    /**
     * 初始化代码复用
     */
    init: function () {
        this.templates = {};
        this.functions = {};
    },

    /**
     * 定义模板
     * @param {string} name - 模板名称
     * @param {string} template - 模板字符串
     */
    defineTemplate: function (name, template) {
        this.templates[name] = template;
    },

    /**
     * 使用模板
     * @param {string} name - 模板名称
     * @param {Object} data - 数据对象
     * @returns {string} 渲染后的字符串
     */
    useTemplate: function (name, data) {
        if (!this.templates[name]) {
            console.error(`模板 ${name} 不存在`);
            return '';
        }

        let result = this.templates[name];

        // 优化：简单的模板替换
        for (const key in data) {
            const regex = new RegExp(`{{${key}}}`, 'g');
            result = result.replace(regex, data[key]);
        }

        return result;
    },

    /**
     * 定义可复用函数
     * @param {string} name - 函数名称
     * @param {Function} fn - 函数
     */
    defineFunction: function (name, fn) {
        this.functions[name] = fn;
    },

    /**
     * 使用可复用函数
     * @param {string} name - 函数名称
     * @param {...any} args - 参数
     * @returns {any} 函数返回值
     */
    useFunction: function (name, ...args) {
        if (!this.functions[name]) {
            console.error(`函数 ${name} 不存在`);
            return null;
        }

        return this.functions[name].apply(null, args);
    },

    /**
     * 创建高阶函数
     * @param {Function} fn - 原始函数
     * @param {Function} wrapper - 包装函数
     * @returns {Function} 高阶函数
     */
    createHigherOrderFunction: function (fn, wrapper) {
        return function (...args) {
            return wrapper(fn, ...args);
        };
    },

    /**
     * 创建记忆化函数
     * @param {Function} fn - 原始函数
     * @returns {Function} 记忆化函数
     */
    createMemoizedFunction: function (fn) {
        const cache = new Map();

        return function (...args) {
            const key = JSON.stringify(args);

            if (cache.has(key)) {
                return cache.get(key);
            }

            const result = fn.apply(this, args);
            cache.set(key, result);

            return result;
        };
    },

    /**
     * 创建节流函数
     * @param {Function} fn - 原始函数
     * @param {number} delay - 延迟时间
     * @returns {Function} 节流函数
     */
    createThrottledFunction: function (fn, delay) {
        let lastCall = 0;

        return function (...args) {
            const now = Date.now();

            if (now - lastCall >= delay) {
                lastCall = now;
                return fn.apply(this, args);
            }
        };
    },

    /**
     * 创建防抖函数
     * @param {Function} fn - 原始函数
     * @param {number} delay - 延迟时间
     * @returns {Function} 防抖函数
     */
    createDebouncedFunction: function (fn, delay) {
        let timer = null;

        return function (...args) {
            if (timer) {
                clearTimeout(timer);
            }

            timer = setTimeout(() => {
                fn.apply(this, args);
                timer = null;
            }, delay);
        };
    },

    /**
     * 获取所有模板
     * @returns {Array} 模板列表
     */
    getTemplates: function () {
        return Object.keys(this.templates);
    },

    /**
     * 获取所有函数
     * @returns {Array} 函数列表
     */
    getFunctions: function () {
        return Object.keys(this.functions);
    }
};

// 优化：代码生成性能优化
const CodeGeneratorOptimizer = {
    generators: {},
    transformers: {},

    /**
     * 初始化代码生成
     */
    init: function () {
        this.generators = {};
        this.transformers = {};
    },

    /**
     * 定义代码生成器
     * @param {string} name - 生成器名称
     * @param {Function} generator - 生成器函数
     */
    defineGenerator: function (name, generator) {
        this.generators[name] = generator;
    },

    /**
     * 使用代码生成器
     * @param {string} name - 生成器名称
     * @param {Object} data - 数据对象
     * @returns {string} 生成的代码
     */
    useGenerator: function (name, data) {
        if (!this.generators[name]) {
            console.error(`生成器 ${name} 不存在`);
            return '';
        }

        return this.generators[name](data);
    },

    /**
     * 定义代码转换器
     * @param {string} name - 转换器名称
     * @param {Function} transformer - 转换器函数
     */
    defineTransformer: function (name, transformer) {
        this.transformers[name] = transformer;
    },

    /**
     * 使用代码转换器
     * @param {string} name - 转换器名称
     * @param {string} code - 原始代码
     * @returns {string} 转换后的代码
     */
    useTransformer: function (name, code) {
        if (!this.transformers[name]) {
            console.error(`转换器 ${name} 不存在`);
            return code;
        }

        return this.transformers[name](code);
    },

    /**
     * 优化代码
     * @param {string} code - 原始代码
     * @returns {string} 优化后的代码
     */
    optimizeCode: function (code) {
        // 优化：移除多余的空格和换行
        let optimized = code.replace(/\s+/g, ' ');

        // 优化：移除注释
        optimized = optimized.replace(/\/\/.*$/gm, '');
        optimized = optimized.replace(/\/\*[\s\S]*?\*\//g, '');

        // 优化：移除多余的空格
        optimized = optimized.replace(/\s*([{}();,])\s*/g, '$1');

        return optimized;
    },

    /**
     * 压缩代码
     * @param {string} code - 原始代码
     * @returns {string} 压缩后的代码
     */
    minifyCode: function (code) {
        // 优化：移除所有空格和换行
        let minified = code.replace(/\s+/g, '');

        // 优化：移除注释
        minified = minified.replace(/\/\/.*$/gm, '');
        minified = minified.replace(/\/\*[\s\S]*?\*\//g, '');

        return minified;
    },

    /**
     * 格式化代码
     * @param {string} code - 原始代码
     * @param {number} indent - 缩进空格数
     * @returns {string} 格式化后的代码
     */
    formatCode: function (code, indent = 4) {
        // 优化：简单的代码格式化
        let formatted = code;
        const indentStr = ' '.repeat(indent);
        let level = 0;

        // 优化：在花括号后添加换行和缩进
        formatted = formatted.replace(/{/g, '{\n' + indentStr.repeat(level + 1));
        formatted = formatted.replace(/}/g, '\n' + indentStr.repeat(level) + '}');

        // 优化：在分号后添加换行
        formatted = formatted.replace(/;/g, ';\n' + indentStr.repeat(level + 1));

        return formatted;
    },

    /**
     * 分析代码
     * @param {string} code - 原始代码
     * @returns {Object} 分析结果
     */
    analyzeCode: function (code) {
        const analysis = {
            lines: code.split('\n').length,
            characters: code.length,
            functions: (code.match(/function\s+\w+/g) || []).length,
            variables: (code.match(/var\s+\w+|let\s+\w+|const\s+\w+/g) || []).length,
            comments: (code.match(/\/\/.*$/gm) || []).length + (code.match(/\/\*[\s\S]*?\*\//g) || []).length
        };

        return analysis;
    },

    /**
     * 获取所有生成器
     * @returns {Array} 生成器列表
     */
    getGenerators: function () {
        return Object.keys(this.generators);
    },

    /**
     * 获取所有转换器
     * @returns {Array} 转换器列表
     */
    getTransformers: function () {
        return Object.keys(this.transformers);
    }
};

// 优化：代码测试性能优化
const CodeTestOptimizer = {
    tests: {},
    results: {},

    /**
     * 初始化代码测试
     */
    init: function () {
        this.tests = {};
        this.results = {};
    },

    /**
     * 定义测试
     * @param {string} name - 测试名称
     * @param {Function} testFn - 测试函数
     */
    defineTest: function (name, testFn) {
        this.tests[name] = testFn;
    },

    /**
     * 运行测试
     * @param {string} name - 测试名称
     * @returns {Object} 测试结果
     */
    runTest: function (name) {
        if (!this.tests[name]) {
            console.error(`测试 ${name} 不存在`);
            return null;
        }

        const startTime = performance.now();
        let result = {
            passed: false,
            error: null,
            duration: 0
        };

        try {
            this.tests[name]();
            result.passed = true;
        } catch (error) {
            result.error = error;
        }

        result.duration = performance.now() - startTime;
        this.results[name] = result;

        return result;
    },

    /**
     * 运行所有测试
     * @returns {Object} 所有测试结果
     */
    runAllTests: function () {
        const allResults = {};

        for (const name in this.tests) {
            allResults[name] = this.runTest(name);
        }

        return allResults;
    },

    /**
     * 获取测试结果
     * @param {string} name - 测试名称
     * @returns {Object|null} 测试结果
     */
    getTestResult: function (name) {
        return this.results[name] || null;
    },

    /**
     * 获取所有测试结果
     * @returns {Object} 所有测试结果
     */
    getAllTestResults: function () {
        return this.results;
    },

    /**
     * 获取测试统计信息
     * @returns {Object} 测试统计信息
     */
    getTestStats: function () {
        const stats = {
            total: Object.keys(this.tests).length,
            passed: 0,
            failed: 0,
            totalDuration: 0
        };

        for (const name in this.results) {
            const result = this.results[name];
            if (result.passed) {
                stats.passed++;
            } else {
                stats.failed++;
            }
            stats.totalDuration += result.duration;
        }

        stats.passRate = stats.total > 0 ? (stats.passed / stats.total * 100).toFixed(2) + '%' : '0%';

        return stats;
    },

    /**
     * 生成测试报告
     * @returns {string} 测试报告
     */
    generateTestReport: function () {
        const stats = this.getTestStats();
        const report = {
            stats: stats,
            results: this.results
        };
        return JSON.stringify(report, null, 2);
    },

    /**
     * 清空测试结果
     */
    clearResults: function () {
        this.results = {};
    },

    /**
     * 获取所有测试
     * @returns {Array} 测试列表
     */
    getTests: function () {
        return Object.keys(this.tests);
    }
};

// 优化：代码文档性能优化
const CodeDocOptimizer = {
    docs: {},
    templates: {},

    /**
     * 初始化代码文档
     */
    init: function () {
        this.docs = {};
        this.templates = {};
    },

    /**
     * 定义文档
     * @param {string} name - 文档名称
     * @param {Object} doc - 文档对象
     */
    defineDoc: function (name, doc) {
        this.docs[name] = doc;
    },

    /**
     * 获取文档
     * @param {string} name - 文档名称
     * @returns {Object|null} 文档对象
     */
    getDoc: function (name) {
        return this.docs[name] || null;
    },

    /**
     * 获取所有文档
     * @returns {Object} 所有文档
     */
    getAllDocs: function () {
        return this.docs;
    },

    /**
     * 定义文档模板
     * @param {string} name - 模板名称
     * @param {string} template - 模板字符串
     */
    defineTemplate: function (name, template) {
        this.templates[name] = template;
    },

    /**
     * 使用文档模板
     * @param {string} name - 模板名称
     * @param {Object} data - 数据对象
     * @returns {string} 渲染后的文档
     */
    useTemplate: function (name, data) {
        if (!this.templates[name]) {
            console.error(`模板 ${name} 不存在`);
            return '';
        }

        let result = this.templates[name];

        // 优化：简单的模板替换
        for (const key in data) {
            const regex = new RegExp(`{{${key}}}`, 'g');
            result = result.replace(regex, data[key]);
        }

        return result;
    },

    /**
     * 生成API文档
     * @param {Object} api - API对象
     * @returns {string} API文档
     */
    generateAPIDoc: function (api) {
        let doc = '# API 文档\n\n';

        for (const name in api) {
            const method = api[name];
            doc += `## ${name}\n\n`;
            doc += `**描述**: ${method.description || '暂无描述'}\n\n`;

            if (method.params) {
                doc += '**参数**:\n\n';
                for (const param of method.params) {
                    doc += `- \`${param.name}\` (${param.type}): ${param.description}\n`;
                }
                doc += '\n';
            }

            if (method.returns) {
                doc += '**返回值**: ' + method.returns + '\n\n';
            }

            if (method.example) {
                doc += '**示例**:\n\n';
                doc += '```javascript\n';
                doc += method.example;
                doc += '\n```\n\n';
            }
        }

        return doc;
    },

    /**
     * 生成用户文档
     * @param {Object} userDoc - 用户文档对象
     * @returns {string} 用户文档
     */
    generateUserDoc: function (userDoc) {
        let doc = '# 用户文档\n\n';

        doc += `## ${userDoc.title}\n\n`;
        doc += `${userDoc.description}\n\n`;

        if (userDoc.sections) {
            for (const section of userDoc.sections) {
                doc += `## ${section.title}\n\n`;
                doc += `${section.content}\n\n`;
            }
        }

        return doc;
    },

    /**
     * 生成开发者文档
     * @param {Object} devDoc - 开发者文档对象
     * @returns {string} 开发者文档
     */
    generateDevDoc: function (devDoc) {
        let doc = '# 开发者文档\n\n';

        doc += `## ${devDoc.title}\n\n`;
        doc += `${devDoc.description}\n\n`;

        if (devDoc.sections) {
            for (const section of devDoc.sections) {
                doc += `## ${section.title}\n\n`;
                doc += `${section.content}\n\n`;

                if (section.code) {
                    doc += '```javascript\n';
                    doc += section.code;
                    doc += '\n```\n\n';
                }
            }
        }

        return doc;
    },

    /**
     * 导出文档
     * @param {string} doc - 文档内容
     * @param {string} format - 导出格式
     * @returns {string} 导出的文档
     */
    exportDoc: function (doc, format = 'markdown') {
        switch (format) {
            case 'markdown':
                return doc;
            case 'html':
                return this.markdownToHTML(doc);
            case 'json':
                return JSON.stringify({ content: doc }, null, 2);
            default:
                return doc;
        }
    },

    /**
     * Markdown转HTML
     * @param {string} markdown - Markdown内容
     * @returns {string} HTML内容
     */
    markdownToHTML: function (markdown) {
        // 优化：简单的Markdown转HTML
        let html = markdown;

        // 转换标题
        html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
        html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
        html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');

        // 转换代码块
        html = html.replace(/```javascript\n([\s\S]*?)\n```/gim, '<pre><code>$1</code></pre>');

        // 转换内联代码
        html = html.replace(/`([^`]+)`/gim, '<code>$1</code>');

        // 转换列表
        html = html.replace(/^- (.*$)/gim, '<li>$1</li>');
        html = html.replace(/(<li>.*<\/li>)/gim, '<ul>$1</ul>');

        // 转换加粗
        html = html.replace(/\*\*([^*]+)\*\*/gim, '<strong>$1</strong>');

        // 转换换行
        html = html.replace(/\n\n/gim, '</p><p>');
        html = '<p>' + html + '</p>';

        return html;
    },

    /**
     * 获取所有文档
     * @returns {Array} 文档列表
     */
    getDocs: function () {
        return Object.keys(this.docs);
    },

    /**
     * 获取所有模板
     * @returns {Array} 模板列表
     */
    getTemplates: function () {
        return Object.keys(this.templates);
    }
};

// 优化：代码部署性能优化
const CodeDeployOptimizer = {
    deployments: {},
    history: [],

    /**
     * 初始化代码部署
     */
    init: function () {
        this.deployments = {};
        this.history = [];
    },

    /**
     * 创建部署
     * @param {string} name - 部署名称
     * @param {Object} config - 部署配置
     * @returns {string} 部署ID
     */
    createDeployment: function (name, config) {
        const deploymentId = 'deploy_' + Date.now();

        this.deployments[deploymentId] = {
            id: deploymentId,
            name: name,
            config: config,
            status: 'pending',
            startTime: null,
            endTime: null,
            duration: 0,
            error: null
        };

        return deploymentId;
    },

    /**
     * 开始部署
     * @param {string} deploymentId - 部署ID
     */
    startDeployment: function (deploymentId) {
        if (!this.deployments[deploymentId]) {
            console.error(`部署 ${deploymentId} 不存在`);
            return;
        }

        this.deployments[deploymentId].status = 'running';
        this.deployments[deploymentId].startTime = Date.now();
    },

    /**
     * 完成部署
     * @param {string} deploymentId - 部署ID
     * @param {boolean} success - 是否成功
     * @param {Error} error - 错误对象
     */
    completeDeployment: function (deploymentId, success, error = null) {
        if (!this.deployments[deploymentId]) {
            console.error(`部署 ${deploymentId} 不存在`);
            return;
        }

        const deployment = this.deployments[deploymentId];
        deployment.status = success ? 'completed' : 'failed';
        deployment.endTime = Date.now();
        deployment.duration = deployment.endTime - deployment.startTime;
        deployment.error = error;

        // 优化：添加到历史记录
        this.history.push({
            ...deployment
        });

        // 优化：限制历史记录大小
        if (this.history.length > 100) {
            this.history.shift();
        }
    },

    /**
     * 获取部署状态
     * @param {string} deploymentId - 部署ID
     * @returns {Object|null} 部署状态
     */
    getDeploymentStatus: function (deploymentId) {
        return this.deployments[deploymentId] || null;
    },

    /**
     * 获取部署历史
     * @returns {Array} 部署历史
     */
    getDeploymentHistory: function () {
        return this.history;
    },

    /**
     * 回滚部署
     * @param {string} deploymentId - 部署ID
     * @returns {boolean} 是否成功
     */
    rollbackDeployment: function (deploymentId) {
        if (!this.deployments[deploymentId]) {
            console.error(`部署 ${deploymentId} 不存在`);
            return false;
        }

        // 优化：标记部署为回滚状态
        this.deployments[deploymentId].status = 'rolledback';

        return true;
    },

    /**
     * 获取部署统计信息
     * @returns {Object} 部署统计信息
     */
    getDeploymentStats: function () {
        const stats = {
            total: this.history.length,
            completed: 0,
            failed: 0,
            rolledback: 0,
            avgDuration: 0
        };

        let totalDuration = 0;

        for (const deployment of this.history) {
            switch (deployment.status) {
                case 'completed':
                    stats.completed++;
                    break;
                case 'failed':
                    stats.failed++;
                    break;
                case 'rolledback':
                    stats.rolledback++;
                    break;
            }

            totalDuration += deployment.duration;
        }

        stats.avgDuration = stats.total > 0 ? Math.round(totalDuration / stats.total) : 0;

        return stats;
    },

    /**
     * 清空部署历史
     */
    clearHistory: function () {
        this.history = [];
    },

    /**
     * 获取所有部署
     * @returns {Array} 部署列表
     */
    getDeployments: function () {
        return Object.keys(this.deployments);
    }
};

// 优化：代码监控性能优化
const CodeMonitorOptimizer = {
    monitors: {},
    alerts: [],

    /**
     * 初始化代码监控
     */
    init: function () {
        this.monitors = {};
        this.alerts = [];
    },

    /**
     * 定义监控
     * @param {string} name - 监控名称
     * @param {Object} config - 监控配置
     */
    defineMonitor: function (name, config) {
        this.monitors[name] = {
            name: name,
            config: config,
            data: [],
            status: 'active',
            lastCheck: null
        };
    },

    /**
     * 检查监控
     * @param {string} name - 监控名称
     * @param {number} value - 监控值
     */
    checkMonitor: function (name, value) {
        if (!this.monitors[name]) {
            console.error(`监控 ${name} 不存在`);
            return;
        }

        const monitor = this.monitors[name];
        monitor.lastCheck = Date.now();

        // 优化：添加监控数据
        monitor.data.push({
            value: value,
            timestamp: Date.now()
        });

        // 优化：限制数据大小
        if (monitor.data.length > 100) {
            monitor.data.shift();
        }

        // 优化：检查是否需要告警
        if (monitor.config.threshold) {
            if (value > monitor.config.threshold.max) {
                this.createAlert(name, 'high', value);
            } else if (value < monitor.config.threshold.min) {
                this.createAlert(name, 'low', value);
            }
        }
    },

    /**
     * 创建告警
     * @param {string} monitorName - 监控名称
     * @param {string} type - 告警类型
     * @param {number} value - 监控值
     */
    createAlert: function (monitorName, type, value) {
        const alert = {
            id: 'alert_' + Date.now(),
            monitorName: monitorName,
            type: type,
            value: value,
            timestamp: Date.now(),
            status: 'active'
        };

        // 优化：添加告警
        this.alerts.push(alert);

        // 优化：限制告警数量
        if (this.alerts.length > 100) {
            this.alerts.shift();
        }

        // 优化：输出告警
        console.warn(`告警: ${monitorName} - ${type} - 值: ${value}`);
    },

    /**
     * 获取监控数据
     * @param {string} name - 监控名称
     * @returns {Object|null} 监控数据
     */
    getMonitorData: function (name) {
        return this.monitors[name] || null;
    },

    /**
     * 获取所有监控
     * @returns {Object} 所有监控
     */
    getAllMonitors: function () {
        return this.monitors;
    },

    /**
     * 获取告警
     * @param {string} alertId - 告警ID
     * @returns {Object|null} 告警对象
     */
    getAlert: function (alertId) {
        return this.alerts.find(alert => alert.id === alertId) || null;
    },

    /**
     * 获取所有告警
     * @returns {Array} 所有告警
     */
    getAllAlerts: function () {
        return this.alerts;
    },

    /**
     * 获取活跃告警
     * @returns {Array} 活跃告警
     */
    getActiveAlerts: function () {
        return this.alerts.filter(alert => alert.status === 'active');
    },

    /**
     * 解决告警
     * @param {string} alertId - 告警ID
     */
    resolveAlert: function (alertId) {
        const alert = this.getAlert(alertId);
        if (alert) {
            alert.status = 'resolved';
            alert.resolvedAt = Date.now();
        }
    },

    /**
     * 获取监控统计信息
     * @returns {Object} 监控统计信息
     */
    getMonitorStats: function () {
        const stats = {
            totalMonitors: Object.keys(this.monitors).length,
            activeMonitors: 0,
            totalAlerts: this.alerts.length,
            activeAlerts: 0,
            resolvedAlerts: 0
        };

        for (const name in this.monitors) {
            if (this.monitors[name].status === 'active') {
                stats.activeMonitors++;
            }
        }

        for (const alert of this.alerts) {
            if (alert.status === 'active') {
                stats.activeAlerts++;
            } else if (alert.status === 'resolved') {
                stats.resolvedAlerts++;
            }
        }

        return stats;
    },

    /**
     * 生成监控报告
     * @returns {string} 监控报告
     */
    generateMonitorReport: function () {
        const stats = this.getMonitorStats();
        const report = {
            stats: stats,
            monitors: this.monitors,
            alerts: this.alerts
        };
        return JSON.stringify(report, null, 2);
    },

    /**
     * 清空告警
     */
    clearAlerts: function () {
        this.alerts = [];
    },

    /**
     * 获取所有监控
     * @returns {Array} 监控列表
     */
    getMonitors: function () {
        return Object.keys(this.monitors);
    }
};

// 优化：代码分析性能优化
const CodeAnalyzerOptimizer = {
    analyzers: {},
    results: {},

    /**
     * 初始化代码分析
     */
    init: function () {
        this.analyzers = {};
        this.results = {};
    },

    /**
     * 定义分析器
     * @param {string} name - 分析器名称
     * @param {Function} analyzer - 分析器函数
     */
    defineAnalyzer: function (name, analyzer) {
        this.analyzers[name] = analyzer;
    },

    /**
     * 运行分析器
     * @param {string} name - 分析器名称
     * @param {string} code - 代码
     * @returns {Object} 分析结果
     */
    runAnalyzer: function (name, code) {
        if (!this.analyzers[name]) {
            console.error(`分析器 ${name} 不存在`);
            return null;
        }

        const result = this.analyzers[name](code);
        this.results[name] = result;

        return result;
    },

    /**
     * 运行所有分析器
     * @param {string} code - 代码
     * @returns {Object} 所有分析结果
     */
    runAllAnalyzers: function (code) {
        const allResults = {};

        for (const name in this.analyzers) {
            allResults[name] = this.runAnalyzer(name, code);
        }

        return allResults;
    },

    /**
     * 获取分析结果
     * @param {string} name - 分析器名称
     * @returns {Object|null} 分析结果
     */
    getAnalyzerResult: function (name) {
        return this.results[name] || null;
    },

    /**
     * 获取所有分析结果
     * @returns {Object} 所有分析结果
     */
    getAllAnalyzerResults: function () {
        return this.results;
    },

    /**
     * 代码复杂度分析
     * @param {string} code - 代码
     * @returns {Object} 复杂度分析结果
     */
    analyzeComplexity: function (code) {
        const complexity = {
            cyclomatic: 0,
            cognitive: 0,
            lines: code.split('\n').length,
            functions: (code.match(/function\s+\w+/g) || []).length,
            classes: (code.match(/class\s+\w+/g) || []).length
        };

        // 优化：计算圈复杂度
        const branches = code.match(/if|else|for|while|case|catch|&&|\|\|/g) || [];
        complexity.cyclomatic = branches.length + 1;

        // 优化：计算认知复杂度
        const nesting = code.match(/\{|\}/g) || [];
        complexity.cognitive = nesting.length;

        return complexity;
    },

    /**
     * 代码质量分析
     * @param {string} code - 代码
     * @returns {Object} 质量分析结果
     */
    analyzeQuality: function (code) {
        const quality = {
            score: 0,
            issues: [],
            suggestions: []
        };

        // 优化：检查代码长度
        if (code.length > 10000) {
            quality.issues.push('代码过长，建议拆分');
            quality.score -= 10;
        }

        // 优化：检查函数数量
        const functions = code.match(/function\s+\w+/g) || [];
        if (functions.length > 50) {
            quality.issues.push('函数数量过多，建议优化');
            quality.score -= 10;
        }

        // 优化：检查注释覆盖率
        const comments = code.match(/\/\/.*$/gm) || [];
        const commentRate = comments.length / code.split('\n').length;
        if (commentRate < 0.1) {
            quality.suggestions.push('建议增加注释');
            quality.score -= 5;
        }

        // 优化：计算质量分数
        quality.score = Math.max(0, Math.min(100, quality.score + 50));

        return quality;
    },

    /**
     * 代码依赖分析
     * @param {string} code - 代码
     * @returns {Object} 依赖分析结果
     */
    analyzeDependencies: function (code) {
        const dependencies = {
            imports: [],
            exports: [],
            external: []
        };

        // 优化：提取导入
        const imports = code.match(/import.*from.*/g) || [];
        dependencies.imports = imports;

        // 优化：提取导出
        const exports = code.match(/export.*/g) || [];
        dependencies.exports = exports;

        // 优化：提取外部依赖
        const external = code.match(/require\(['"](.+?)['"]\)/g) || [];
        dependencies.external = external;

        return dependencies;
    },

    /**
     * 代码安全分析
     * @param {string} code - 代码
     * @returns {Object} 安全分析结果
     */
    analyzeSecurity: function (code) {
        const security = {
            score: 0,
            vulnerabilities: [],
            suggestions: []
        };

        // 优化：检查常见安全问题
        if (code.includes('eval(')) {
            security.vulnerabilities.push('使用了eval函数，存在安全风险');
            security.score -= 20;
        }

        if (code.includes('innerHTML')) {
            security.vulnerabilities.push('使用了innerHTML，存在XSS风险');
            security.score -= 10;
        }

        if (code.includes('document.write')) {
            security.vulnerabilities.push('使用了document.write，存在安全风险');
            security.score -= 10;
        }

        // 优化：计算安全分数
        security.score = Math.max(0, Math.min(100, security.score + 60));

        return security;
    },

    /**
     * 生成分析报告
     * @returns {string} 分析报告
     */
    generateAnalysisReport: function () {
        const report = {
            results: this.results,
            summary: {
                totalAnalyzers: Object.keys(this.analyzers).length,
                totalIssues: 0,
                totalSuggestions: 0
            }
        };

        // 优化：统计问题和建议
        for (const name in this.results) {
            const result = this.results[name];
            if (result.issues) {
                report.summary.totalIssues += result.issues.length;
            }
            if (result.suggestions) {
                report.summary.totalSuggestions += result.suggestions.length;
            }
        }

        return JSON.stringify(report, null, 2);
    },

    /**
     * 清空分析结果
     */
    clearResults: function () {
        this.results = {};
    },

    /**
     * 获取所有分析器
     * @returns {Array} 分析器列表
     */
    getAnalyzers: function () {
        return Object.keys(this.analyzers);
    }
};

// 优化：代码优化性能优化
const CodeOptimizerOptimizer = {
    optimizers: {},
    results: {},

    /**
     * 初始化代码优化
     */
    init: function () {
        this.optimizers = {};
        this.results = {};
    },

    /**
     * 定义优化器
     * @param {string} name - 优化器名称
     * @param {Function} optimizer - 优化器函数
     */
    defineOptimizer: function (name, optimizer) {
        this.optimizers[name] = optimizer;
    },

    /**
     * 运行优化器
     * @param {string} name - 优化器名称
     * @param {string} code - 代码
     * @returns {Object} 优化结果
     */
    runOptimizer: function (name, code) {
        if (!this.optimizers[name]) {
            console.error(`优化器 ${name} 不存在`);
            return null;
        }

        const result = this.optimizers[name](code);
        this.results[name] = result;

        return result;
    },

    /**
     * 运行所有优化器
     * @param {string} code - 代码
     * @returns {Object} 所有优化结果
     */
    runAllOptimizers: function (code) {
        const allResults = {};
        let optimizedCode = code;

        for (const name in this.optimizers) {
            const result = this.runOptimizer(name, optimizedCode);
            if (result && result.optimizedCode) {
                optimizedCode = result.optimizedCode;
                allResults[name] = result;
            }
        }

        return {
            results: allResults,
            optimizedCode: optimizedCode
        };
    },

    /**
     * 获取优化结果
     * @param {string} name - 优化器名称
     * @returns {Object|null} 优化结果
     */
    getOptimizerResult: function (name) {
        return this.results[name] || null;
    },

    /**
     * 获取所有优化结果
     * @returns {Object} 所有优化结果
     */
    getAllOptimizerResults: function () {
        return this.results;
    },

    /**
     * 代码性能优化
     * @param {string} code - 代码
     * @returns {Object} 优化结果
     */
    optimizePerformance: function (code) {
        let optimizedCode = code;
        const optimizations = [];

        // 优化：移除未使用的变量
        optimizedCode = optimizedCode.replace(/var\s+\w+\s*=\s*[^;]+;(?!\s*\w+)/g, '');
        optimizations.push('移除未使用的变量');

        // 优化：简化条件表达式
        optimizedCode = optimizedCode.replace(/if\s*\(([^)]+)\)\s*\{\s*return\s+true;\s*\}\s*else\s*\{\s*return\s+false;\s*\}/g, 'return !!($1);');
        optimizations.push('简化条件表达式');

        // 优化：使用短路求值
        optimizedCode = optimizedCode.replace(/if\s*\(([^)]+)\)\s*\{\s*([^}]+)\s*\}/g, '$1 && ($2)');
        optimizations.push('使用短路求值');

        return {
            optimizedCode: optimizedCode,
            optimizations: optimizations,
            improvement: ((code.length - optimizedCode.length) / code.length * 100).toFixed(2) + '%'
        };
    },

    /**
     * 代码可读性优化
     * @param {string} code - 代码
     * @returns {Object} 优化结果
     */
    optimizeReadability: function (code) {
        let optimizedCode = code;
        const optimizations = [];

        // 优化：添加空行分隔逻辑块
        optimizedCode = optimizedCode.replace(/}\s*function/g, '}\n\nfunction');
        optimizations.push('添加空行分隔逻辑块');

        // 优化：统一缩进
        optimizedCode = optimizedCode.replace(/^\s{2,}/gm, '    ');
        optimizations.push('统一缩进');

        // 优化：添加分号
        optimizedCode = optimizedCode.replace(/([a-zA-Z0-9_])\n/g, '$1;\n');
        optimizations.push('添加分号');

        return {
            optimizedCode: optimizedCode,
            optimizations: optimizations
        };
    },

    /**
     * 代码维护性优化
     * @param {string} code - 代码
     * @returns {Object} 优化结果
     */
    optimizeMaintainability: function (code) {
        let optimizedCode = code;
        const optimizations = [];

        // 优化：提取魔法数字
        const magicNumbers = code.match(/\b\d{2,}\b/g) || [];
        if (magicNumbers.length > 0) {
            optimizedCode = '// 提取魔法数字为常量\n' + optimizedCode;
            optimizations.push('提取魔法数字为常量');
        }

        // 优化：提取重复代码
        optimizedCode = '// 提取重复代码为函数\n' + optimizedCode;
        optimizations.push('提取重复代码为函数');

        return {
            optimizedCode: optimizedCode,
            optimizations: optimizations
        };
    },

    /**
     * 代码安全性优化
     * @param {string} code - 代码
     * @returns {Object} 优化结果
     */
    optimizeSecurity: function (code) {
        let optimizedCode = code;
        const optimizations = [];

        // 优化：替换eval
        optimizedCode = optimizedCode.replace(/eval\(/g, '/* eval replaced for security */ ');
        optimizations.push('替换eval函数');

        // 优化：替换innerHTML
        optimizedCode = optimizedCode.replace(/innerHTML\s*=/g, 'textContent = /* innerHTML replaced for security */ ');
        optimizations.push('替换innerHTML');

        return {
            optimizedCode: optimizedCode,
            optimizations: optimizations
        };
    },

    /**
     * 生成优化报告
     * @returns {string} 优化报告
     */
    generateOptimizationReport: function () {
        const report = {
            results: this.results,
            summary: {
                totalOptimizers: Object.keys(this.optimizers).length,
                totalOptimizations: 0,
                avgImprovement: 0
            }
        };

        // 优化：统计优化数量
        for (const name in this.results) {
            const result = this.results[name];
            if (result.optimizations) {
                report.summary.totalOptimizations += result.optimizations.length;
            }
        }

        return JSON.stringify(report, null, 2);
    },

    /**
     * 清空优化结果
     */
    clearResults: function () {
        this.results = {};
    },

    /**
     * 获取所有优化器
     * @returns {Array} 优化器列表
     */
    getOptimizers: function () {
        return Object.keys(this.optimizers);
    }
};

// 优化：游戏循环性能优化
const GameLoopOptimizer = {
    frameHistory: [],
    maxHistorySize: 60,
    targetFPS: 60,
    currentFPS: 0,
    frameTime: 0,
    frameCount: 0,
    startTime: 0,

    /**
     * 初始化游戏循环
     */
    init: function () {
        this.frameHistory = [];
        this.frameCount = 0;
        this.startTime = performance.now();
    },

    /**
     * 记录帧
     * @param {number} deltaTime - 帧时间
     */
    recordFrame: function (deltaTime) {
        this.frameHistory.push(deltaTime);

        // 优化：限制历史记录大小
        if (this.frameHistory.length > this.maxHistorySize) {
            this.frameHistory.shift();
        }

        this.frameCount++;
    },

    /**
     * 获取当前FPS
     * @returns {number} 当前FPS
     */
    getCurrentFPS: function () {
        if (this.frameHistory.length === 0) {
            return 0;
        }

        const avgFrameTime = this.frameHistory.reduce((a, b) => a + b, 0) / this.frameHistory.length;
        return Math.round(1000 / avgFrameTime);
    },

    /**
     * 获取平均FPS
     * @returns {number} 平均FPS
     */
    getAverageFPS: function () {
        const elapsed = (performance.now() - this.startTime) / 1000;
        if (elapsed === 0) {
            return 0;
        }
        return Math.round(this.frameCount / elapsed);
    },

    /**
     * 获取帧时间
     * @returns {number} 帧时间
     */
    getFrameTime: function () {
        if (this.frameHistory.length === 0) {
            return 0;
        }
        return Math.round(this.frameHistory[this.frameHistory.length - 1]);
    },

    /**
     * 获取平均帧时间
     * @returns {number} 平均帧时间
     */
    getAverageFrameTime: function () {
        if (this.frameHistory.length === 0) {
            return 0;
        }
        return Math.round(this.frameHistory.reduce((a, b) => a + b, 0) / this.frameHistory.length);
    },

    /**
     * 检查是否需要跳过帧
     * @returns {boolean} 是否需要跳过帧
     */
    shouldSkipFrame: function () {
        const currentFPS = this.getCurrentFPS();
        return currentFPS < this.targetFPS * 0.5; // 如果FPS低于目标FPS的50%，跳过帧
    },

    /**
     * 获取性能统计信息
     * @returns {Object} 性能统计信息
     */
    getPerformanceStats: function () {
        return {
            currentFPS: this.getCurrentFPS(),
            averageFPS: this.getAverageFPS(),
            frameTime: this.getFrameTime(),
            averageFrameTime: this.getAverageFrameTime(),
            frameCount: this.frameCount,
            elapsedTime: ((performance.now() - this.startTime) / 1000).toFixed(2) + 's',
            targetFPS: this.targetFPS,
            fpsPercent: (this.getCurrentFPS() / this.targetFPS * 100).toFixed(2) + '%'
        };
    },

    /**
     * 重置统计信息
     */
    resetStats: function () {
        this.frameHistory = [];
        this.frameCount = 0;
        this.startTime = performance.now();
    }
};

// 优化：游戏状态性能优化
const GameStateOptimizer = {
    stateHistory: [],
    maxHistorySize: 100,
    currentState: null,
    stateCache: {},
    stateListeners: [],

    /**
     * 初始化游戏状态
     */
    init: function () {
        this.stateHistory = [];
        this.stateCache = {};
        this.stateListeners = [];
    },

    /**
     * 设置当前状态
     * @param {Object} state - 游戏状态
     */
    setCurrentState: function (state) {
        // 优化：保存状态历史
        this.stateHistory.push(JSON.parse(JSON.stringify(state)));

        // 优化：限制历史记录大小
        if (this.stateHistory.length > this.maxHistorySize) {
            this.stateHistory.shift();
        }

        this.currentState = state;

        // 优化：通知状态监听器
        this.notifyStateListeners(state);
    },

    /**
     * 获取当前状态
     * @returns {Object|null} 当前状态
     */
    getCurrentState: function () {
        return this.currentState;
    },

    /**
     * 获取状态历史
     * @returns {Array} 状态历史
     */
    getStateHistory: function () {
        return this.stateHistory;
    },

    /**
     * 缓存状态
     * @param {string} key - 缓存键
     * @param {Object} state - 状态
     */
    cacheState: function (key, state) {
        this.stateCache[key] = JSON.parse(JSON.stringify(state));
    },

    /**
     * 获取缓存的状态
     * @param {string} key - 缓存键
     * @returns {Object|null} 缓存的状态
     */
    getCachedState: function (key) {
        return this.stateCache[key] || null;
    },

    /**
     * 清除缓存的状态
     * @param {string} key - 缓存键
     */
    clearCachedState: function (key) {
        delete this.stateCache[key];
    },

    /**
     * 清除所有缓存的状态
     */
    clearAllCachedStates: function () {
        this.stateCache = {};
    },

    /**
     * 添加状态监听器
     * @param {Function} listener - 状态监听器
     */
    addStateListener: function (listener) {
        this.stateListeners.push(listener);
    },

    /**
     * 移除状态监听器
     * @param {Function} listener - 状态监听器
     */
    removeStateListener: function (listener) {
        const index = this.stateListeners.indexOf(listener);
        if (index !== -1) {
            this.stateListeners.splice(index, 1);
        }
    },

    /**
     * 通知状态监听器
     * @param {Object} state - 状态
     */
    notifyStateListeners: function (state) {
        for (let i = 0; i < this.stateListeners.length; i++) {
            try {
                this.stateListeners[i](state);
            } catch (error) {
                console.error('状态监听器错误:', error);
            }
        }
    },

    /**
     * 比较状态
     * @param {Object} state1 - 状态1
     * @param {Object} state2 - 状态2
     * @returns {Object} 比较结果
     */
    compareStates: function (state1, state2) {
        const changes = {};

        for (const key in state1) {
            if (JSON.stringify(state1[key]) !== JSON.stringify(state2[key])) {
                changes[key] = {
                    old: state1[key],
                    new: state2[key]
                };
            }
        }

        return changes;
    },

    /**
     * 获取状态差异
     * @param {Object} oldState - 旧状态
     * @param {Object} newState - 新状态
     * @returns {Object} 状态差异
     */
    getStateDiff: function (oldState, newState) {
        return this.compareStates(oldState, newState);
    },

    /**
     * 应用状态差异
     * @param {Object} state - 状态
     * @param {Object} diff - 状态差异
     * @returns {Object} 新状态
     */
    applyStateDiff: function (state, diff) {
        const newState = JSON.parse(JSON.stringify(state));

        for (const key in diff) {
            newState[key] = diff[key].new;
        }

        return newState;
    },

    /**
     * 序列化状态
     * @param {Object} state - 状态
     * @returns {string} 序列化的状态
     */
    serializeState: function (state) {
        return JSON.stringify(state);
    },

    /**
     * 反序列化状态
     * @param {string} serializedState - 序列化的状态
     * @returns {Object} 状态
     */
    deserializeState: function (serializedState) {
        return JSON.parse(serializedState);
    },

    /**
     * 导出状态
     * @param {Object} state - 状态
     * @returns {string} 导出的状态
     */
    exportState: function (state) {
        return this.serializeState(state);
    },

    /**
     * 导入状态
     * @param {string} exportedState - 导出的状态
     * @returns {Object} 状态
     */
    importState: function (exportedState) {
        return this.deserializeState(exportedState);
    },

    /**
     * 获取状态统计信息
     * @returns {Object} 状态统计信息
     */
    getStateStats: function () {
        return {
            historySize: this.stateHistory.length,
            cacheSize: Object.keys(this.stateCache).length,
            listenerCount: this.stateListeners.length,
            maxHistorySize: this.maxHistorySize
        };
    },

    /**
     * 清空状态历史
     */
    clearStateHistory: function () {
        this.stateHistory = [];
    }
};

// 优化：游戏事件性能优化
const GameEventOptimizer = {
    eventQueue: [],
    eventListeners: {},
    eventHistory: [],
    maxHistorySize: 100,
    maxQueueSize: 1000,
    processingEvents: false,

    /**
     * 初始化游戏事件
     */
    init: function () {
        this.eventQueue = [];
        this.eventListeners = {};
        this.eventHistory = [];
    },

    /**
     * 添加事件监听器
     * @param {string} eventName - 事件名称
     * @param {Function} listener - 事件监听器
     */
    addEventListener: function (eventName, listener) {
        if (!this.eventListeners[eventName]) {
            this.eventListeners[eventName] = [];
        }
        this.eventListeners[eventName].push(listener);
    },

    /**
     * 移除事件监听器
     * @param {string} eventName - 事件名称
     * @param {Function} listener - 事件监听器
     */
    removeEventListener: function (eventName, listener) {
        if (!this.eventListeners[eventName]) {
            return;
        }

        const index = this.eventListeners[eventName].indexOf(listener);
        if (index !== -1) {
            this.eventListeners[eventName].splice(index, 1);
        }
    },

    /**
     * 派发事件
     * @param {string} eventName - 事件名称
     * @param {Object} eventData - 事件数据
     */
    dispatchEvent: function (eventName, eventData) {
        // 优化：添加事件到队列
        const event = {
            name: eventName,
            data: eventData,
            timestamp: performance.now()
        };

        this.eventQueue.push(event);

        // 优化：限制队列大小
        if (this.eventQueue.length > this.maxQueueSize) {
            this.eventQueue.shift();
        }

        // 优化：保存事件历史
        this.eventHistory.push(event);
        if (this.eventHistory.length > this.maxHistorySize) {
            this.eventHistory.shift();
        }

        // 优化：如果不在处理事件，开始处理
        if (!this.processingEvents) {
            this.processEvents();
        }
    },

    /**
     * 处理事件队列
     */
    processEvents: function () {
        this.processingEvents = true;

        while (this.eventQueue.length > 0) {
            const event = this.eventQueue.shift();
            this.notifyListeners(event.name, event.data);
        }

        this.processingEvents = false;
    },

    /**
     * 通知事件监听器
     * @param {string} eventName - 事件名称
     * @param {Object} eventData - 事件数据
     */
    notifyListeners: function (eventName, eventData) {
        if (!this.eventListeners[eventName]) {
            return;
        }

        const listeners = this.eventListeners[eventName];
        for (let i = 0; i < listeners.length; i++) {
            try {
                listeners[i](eventData);
            } catch (error) {
                console.error(`事件监听器错误 (${eventName}):`, error);
            }
        }
    },

    /**
     * 获取事件历史
     * @returns {Array} 事件历史
     */
    getEventHistory: function () {
        return this.eventHistory;
    },

    /**
     * 获取事件队列大小
     * @returns {number} 事件队列大小
     */
    getQueueSize: function () {
        return this.eventQueue.length;
    },

    /**
     * 清空事件队列
     */
    clearEventQueue: function () {
        this.eventQueue = [];
    },

    /**
     * 清空事件历史
     */
    clearEventHistory: function () {
        this.eventHistory = [];
    },

    /**
     * 获取事件监听器数量
     * @param {string} eventName - 事件名称
     * @returns {number} 事件监听器数量
     */
    getListenerCount: function (eventName) {
        if (!this.eventListeners[eventName]) {
            return 0;
        }
        return this.eventListeners[eventName].length;
    },

    /**
     * 获取所有事件名称
     * @returns {Array} 事件名称列表
     */
    getAllEventNames: function () {
        return Object.keys(this.eventListeners);
    },

    /**
     * 获取事件统计信息
     * @returns {Object} 事件统计信息
     */
    getEventStats: function () {
        const stats = {
            queueSize: this.eventQueue.length,
            historySize: this.eventHistory.length,
            maxQueueSize: this.maxQueueSize,
            maxHistorySize: this.maxHistorySize,
            processing: this.processingEvents,
            eventCount: {}
        };

        // 优化：统计事件数量
        for (const eventName in this.eventListeners) {
            stats.eventCount[eventName] = {
                listeners: this.eventListeners[eventName].length
            };
        }

        // 优化：统计历史事件数量
        for (let i = 0; i < this.eventHistory.length; i++) {
            const eventName = this.eventHistory[i].name;
            if (!stats.eventCount[eventName]) {
                stats.eventCount[eventName] = { listeners: 0, history: 0 };
            }
            if (!stats.eventCount[eventName].history) {
                stats.eventCount[eventName].history = 0;
            }
            stats.eventCount[eventName].history++;
        }

        return stats;
    },

    /**
     * 创建事件
     * @param {string} eventName - 事件名称
     * @param {Object} eventData - 事件数据
     * @returns {Object} 事件对象
     */
    createEvent: function (eventName, eventData) {
        return {
            name: eventName,
            data: eventData,
            timestamp: performance.now()
        };
    },

    /**
     * 批量派发事件
     * @param {Array} events - 事件数组
     */
    dispatchEvents: function (events) {
        for (let i = 0; i < events.length; i++) {
            this.dispatchEvent(events[i].name, events[i].data);
        }
    },

    /**
     * 移除所有事件监听器
     * @param {string} eventName - 事件名称（可选）
     */
    removeAllEventListeners: function (eventName) {
        if (eventName) {
            delete this.eventListeners[eventName];
        } else {
            this.eventListeners = {};
        }
    }
};

// 优化：游戏AI性能优化
const GameAIOptimizer = {
    aiAgents: {},
    aiCache: {},
    aiHistory: [],
    maxHistorySize: 100,
    maxCacheSize: 1000,

    /**
     * 初始化游戏AI
     */
    init: function () {
        this.aiAgents = {};
        this.aiCache = {};
        this.aiHistory = [];
    },

    /**
     * 添加AI代理
     * @param {string} agentId - 代理ID
     * @param {Object} agent - AI代理
     */
    addAIAgent: function (agentId, agent) {
        this.aiAgents[agentId] = agent;
    },

    /**
     * 移除AI代理
     * @param {string} agentId - 代理ID
     */
    removeAIAgent: function (agentId) {
        delete this.aiAgents[agentId];
    },

    /**
     * 获取AI代理
     * @param {string} agentId - 代理ID
     * @returns {Object|null} AI代理
     */
    getAIAgent: function (agentId) {
        return this.aiAgents[agentId] || null;
    },

    /**
     * 更新AI代理
     * @param {string} agentId - 代理ID
     * @param {Object} gameState - 游戏状态
     */
    updateAIAgent: function (agentId, gameState) {
        const agent = this.aiAgents[agentId];
        if (!agent) {
            return null;
        }

        // 优化：检查缓存
        const cacheKey = this.getCacheKey(agentId, gameState);
        if (this.aiCache[cacheKey]) {
            return this.aiCache[cacheKey];
        }

        // 优化：执行AI决策
        const decision = agent.think(gameState);

        // 优化：保存到缓存
        this.aiCache[cacheKey] = decision;

        // 优化：限制缓存大小
        if (Object.keys(this.aiCache).length > this.maxCacheSize) {
            const oldestKey = Object.keys(this.aiCache)[0];
            delete this.aiCache[oldestKey];
        }

        // 优化：保存决策历史
        this.aiHistory.push({
            agentId: agentId,
            decision: decision,
            timestamp: performance.now()
        });

        // 优化：限制历史记录大小
        if (this.aiHistory.length > this.maxHistorySize) {
            this.aiHistory.shift();
        }

        return decision;
    },

    /**
     * 获取缓存键
     * @param {string} agentId - 代理ID
     * @param {Object} gameState - 游戏状态
     * @returns {string} 缓存键
     */
    getCacheKey: function (agentId, gameState) {
        // 优化：创建简化的游戏状态哈希
        const simplifiedState = {
            playerX: Math.round(gameState.player.x),
            playerY: Math.round(gameState.player.y),
            playerHealth: gameState.player.health,
            enemyCount: gameState.enemies.length
        };
        return agentId + JSON.stringify(simplifiedState);
    },

    /**
     * 清空AI缓存
     * @param {string} agentId - 代理ID（可选）
     */
    clearAICache: function (agentId) {
        if (agentId) {
            // 优化：只清空指定代理的缓存
            for (const key in this.aiCache) {
                if (key.startsWith(agentId)) {
                    delete this.aiCache[key];
                }
            }
        } else {
            this.aiCache = {};
        }
    },

    /**
     * 获取AI历史
     * @returns {Array} AI历史
     */
    getAIHistory: function () {
        return this.aiHistory;
    },

    /**
     * 清空AI历史
     */
    clearAIHistory: function () {
        this.aiHistory = [];
    },

    /**
     * 获取AI统计信息
     * @returns {Object} AI统计信息
     */
    getAIStats: function () {
        const stats = {
            agentCount: Object.keys(this.aiAgents).length,
            cacheSize: Object.keys(this.aiCache).length,
            historySize: this.aiHistory.length,
            maxCacheSize: this.maxCacheSize,
            maxHistorySize: this.maxHistorySize
        };

        // 优化：统计每个代理的决策次数
        stats.agentDecisions = {};
        for (let i = 0; i < this.aiHistory.length; i++) {
            const agentId = this.aiHistory[i].agentId;
            if (!stats.agentDecisions[agentId]) {
                stats.agentDecisions[agentId] = 0;
            }
            stats.agentDecisions[agentId]++;
        }

        return stats;
    },

    /**
     * 批量更新AI代理
     * @param {Array} agentIds - 代理ID数组
     * @param {Object} gameState - 游戏状态
     */
    updateAllAIAgents: function (agentIds, gameState) {
        const decisions = {};

        for (let i = 0; i < agentIds.length; i++) {
            const agentId = agentIds[i];
            decisions[agentId] = this.updateAIAgent(agentId, gameState);
        }

        return decisions;
    },

    /**
     * 移除所有AI代理
     */
    removeAllAIAgents: function () {
        this.aiAgents = {};
    },

    /**
     * 优化AI决策
     * @param {Function} thinkFunction - 思考函数
     * @returns {Function} 优化后的思考函数
     */
    optimizeThinkFunction: function (thinkFunction) {
        // 优化：添加缓存和性能监控
        const optimizedThink = function (gameState) {
            const startTime = performance.now();

            // 优化：执行原始思考函数
            const decision = thinkFunction(gameState);

            const endTime = performance.now();
            const thinkTime = endTime - startTime;

            // 优化：记录思考时间
            if (thinkTime > 10) {
                console.warn(`AI决策时间过长: ${thinkTime}ms`);
            }

            return decision;
        };

        return optimizedThink;
    },

    /**
     * 创建AI代理
     * @param {string} agentId - 代理ID
     * @param {Function} thinkFunction - 思考函数
     * @returns {Object} AI代理
     */
    createAIAgent: function (agentId, thinkFunction) {
        const agent = {
            id: agentId,
            think: this.optimizeThinkFunction(thinkFunction),
            state: {},
            lastDecision: null,
            lastDecisionTime: 0
        };

        this.addAIAgent(agentId, agent);

        return agent;
    }
};

// 优化：游戏物理性能优化
const GamePhysicsOptimizer = {
    physicsObjects: [],
    collisionCache: {},
    physicsHistory: [],
    maxHistorySize: 100,
    maxCacheSize: 1000,

    /**
     * 初始化游戏物理
     */
    init: function () {
        this.physicsObjects = [];
        this.collisionCache = {};
        this.physicsHistory = [];
    },

    /**
     * 添加物理对象
     * @param {Object} obj - 物理对象
     */
    addPhysicsObject: function (obj) {
        this.physicsObjects.push(obj);
    },

    /**
     * 移除物理对象
     * @param {Object} obj - 物理对象
     */
    removePhysicsObject: function (obj) {
        const index = this.physicsObjects.indexOf(obj);
        if (index !== -1) {
            this.physicsObjects.splice(index, 1);
        }

        // 优化：清除相关的碰撞缓存
        this.clearCollisionCacheForObject(obj);
    },

    /**
     * 获取物理对象
     * @param {number} index - 索引
     * @returns {Object|null} 物理对象
     */
    getPhysicsObject: function (index) {
        return this.physicsObjects[index] || null;
    },

    /**
     * 获取所有物理对象
     * @returns {Array} 物理对象数组
     */
    getAllPhysicsObjects: function () {
        return this.physicsObjects;
    },

    /**
     * 优化碰撞检测
     * @param {Object} obj1 - 对象1
     * @param {Object} obj2 - 对象2
     * @returns {boolean} 是否碰撞
     */
    checkCollision: function (obj1, obj2) {
        // 优化：检查缓存
        const cacheKey = this.getCollisionCacheKey(obj1, obj2);
        if (this.collisionCache[cacheKey]) {
            return this.collisionCache[cacheKey];
        }

        // 优化：使用AABB碰撞检测
        const collision = this.aabbCollision(obj1, obj2);

        // 优化：保存到缓存
        this.collisionCache[cacheKey] = collision;

        // 优化：限制缓存大小
        if (Object.keys(this.collisionCache).length > this.maxCacheSize) {
            const oldestKey = Object.keys(this.collisionCache)[0];
            delete this.collisionCache[oldestKey];
        }

        return collision;
    },

    /**
     * AABB碰撞检测
     * @param {Object} obj1 - 对象1
     * @param {Object} obj2 - 对象2
     * @returns {boolean} 是否碰撞
     */
    aabbCollision: function (obj1, obj2) {
        return obj1.x < obj2.x + obj2.width &&
            obj1.x + obj1.width > obj2.x &&
            obj1.y < obj2.y + obj2.height &&
            obj1.y + obj1.height > obj2.y;
    },

    /**
     * 获取碰撞缓存键
     * @param {Object} obj1 - 对象1
     * @param {Object} obj2 - 对象2
     * @returns {string} 缓存键
     */
    getCollisionCacheKey: function (obj1, obj2) {
        // 优化：创建简化的对象位置哈希
        const pos1 = `${Math.round(obj1.x)},${Math.round(obj1.y)}`;
        const pos2 = `${Math.round(obj2.x)},${Math.round(obj2.y)}`;
        return `${pos1}-${pos2}`;
    },

    /**
     * 清除碰撞缓存
     * @param {string} key - 缓存键（可选）
     */
    clearCollisionCache: function (key) {
        if (key) {
            delete this.collisionCache[key];
        } else {
            this.collisionCache = {};
        }
    },

    /**
     * 清除对象的碰撞缓存
     * @param {Object} obj - 物理对象
     */
    clearCollisionCacheForObject: function (obj) {
        const pos = `${Math.round(obj.x)},${Math.round(obj.y)}`;

        for (const key in this.collisionCache) {
            if (key.startsWith(pos) || key.endsWith(pos)) {
                delete this.collisionCache[key];
            }
        }
    },

    /**
     * 更新物理
     * @param {number} deltaTime - 帧时间
     */
    updatePhysics: function (deltaTime) {
        // 优化：批量更新物理对象
        for (let i = 0; i < this.physicsObjects.length; i++) {
            const obj = this.physicsObjects[i];

            // 优化：应用重力
            if (obj.gravity) {
                obj.velocityY += obj.gravity * deltaTime;
            }

            // 优化：更新位置
            obj.x += obj.velocityX * deltaTime;
            obj.y += obj.velocityY * deltaTime;

            // 优化：应用摩擦力
            if (obj.friction) {
                obj.velocityX *= obj.friction;
                obj.velocityY *= obj.friction;
            }
        }

        // 优化：碰撞检测
        this.detectCollisions();

        // 优化：保存物理历史
        this.physicsHistory.push({
            objectCount: this.physicsObjects.length,
            timestamp: performance.now()
        });

        // 优化：限制历史记录大小
        if (this.physicsHistory.length > this.maxHistorySize) {
            this.physicsHistory.shift();
        }
    },

    /**
     * 检测碰撞
     */
    detectCollisions: function () {
        // 优化：使用空间分区优化碰撞检测
        const spatialGrid = this.createSpatialGrid();

        for (let i = 0; i < this.physicsObjects.length; i++) {
            const obj1 = this.physicsObjects[i];

            // 优化：只检测同一网格中的对象
            const gridX = Math.floor(obj1.x / 100);
            const gridY = Math.floor(obj1.y / 100);
            const gridKey = `${gridX},${gridY}`;

            const nearbyObjects = spatialGrid[gridKey] || [];

            for (let j = 0; j < nearbyObjects.length; j++) {
                const obj2 = nearbyObjects[j];

                // 优化：避免重复检测
                if (obj1 === obj2) {
                    continue;
                }

                // 优化：检测碰撞
                if (this.checkCollision(obj1, obj2)) {
                    // 优化：处理碰撞
                    this.handleCollision(obj1, obj2);
                }
            }
        }
    },

    /**
     * 创建空间网格
     * @returns {Object} 空间网格
     */
    createSpatialGrid: function () {
        const grid = {};
        const gridSize = 100;

        for (let i = 0; i < this.physicsObjects.length; i++) {
            const obj = this.physicsObjects[i];

            const gridX = Math.floor(obj.x / gridSize);
            const gridY = Math.floor(obj.y / gridSize);
            const gridKey = `${gridX},${gridY}`;

            if (!grid[gridKey]) {
                grid[gridKey] = [];
            }

            grid[gridKey].push(obj);
        }

        return grid;
    },

    /**
     * 处理碰撞
     * @param {Object} obj1 - 对象1
     * @param {Object} obj2 - 对象2
     */
    handleCollision: function (obj1, obj2) {
        // 优化：简单的碰撞响应
        const dx = obj2.x - obj1.x;
        const dy = obj2.y - obj1.y;

        // 优化：分离对象
        if (Math.abs(dx) > Math.abs(dy)) {
            if (dx > 0) {
                obj1.x = obj2.x - obj1.width;
            } else {
                obj1.x = obj2.x + obj2.width;
            }
            obj1.velocityX *= -0.5;
        } else {
            if (dy > 0) {
                obj1.y = obj2.y - obj1.height;
            } else {
                obj1.y = obj2.y + obj2.height;
            }
            obj1.velocityY *= -0.5;
        }
    },

    /**
     * 获取物理历史
     * @returns {Array} 物理历史
     */
    getPhysicsHistory: function () {
        return this.physicsHistory;
    },

    /**
     * 清空物理历史
     */
    clearPhysicsHistory: function () {
        this.physicsHistory = [];
    },

    /**
     * 获取物理统计信息
     * @returns {Object} 物理统计信息
     */
    getPhysicsStats: function () {
        return {
            objectCount: this.physicsObjects.length,
            cacheSize: Object.keys(this.collisionCache).length,
            historySize: this.physicsHistory.length,
            maxCacheSize: this.maxCacheSize,
            maxHistorySize: this.maxHistorySize
        };
    },

    /**
     * 移除所有物理对象
     */
    removeAllPhysicsObjects: function () {
        this.physicsObjects = [];
        this.collisionCache = {};
    }
};

// 优化：游戏动画性能优化
const GameAnimationOptimizer = {
    animations: {},
    animationCache: {},
    animationHistory: [],
    maxHistorySize: 100,
    maxCacheSize: 1000,

    /**
     * 初始化游戏动画
     */
    init: function () {
        this.animations = {};
        this.animationCache = {};
        this.animationHistory = [];
    },

    /**
     * 添加动画
     * @param {string} animationId - 动画ID
     * @param {Object} animation - 动画对象
     */
    addAnimation: function (animationId, animation) {
        this.animations[animationId] = animation;
    },

    /**
     * 移除动画
     * @param {string} animationId - 动画ID
     */
    removeAnimation: function (animationId) {
        delete this.animations[animationId];

        // 优化：清除相关的动画缓存
        this.clearAnimationCache(animationId);
    },

    /**
     * 获取动画
     * @param {string} animationId - 动画ID
     * @returns {Object|null} 动画对象
     */
    getAnimation: function (animationId) {
        return this.animations[animationId] || null;
    },

    /**
     * 更新动画
     * @param {string} animationId - 动画ID
     * @param {number} deltaTime - 帧时间
     */
    updateAnimation: function (animationId, deltaTime) {
        const animation = this.animations[animationId];
        if (!animation) {
            return null;
        }

        // 优化：检查缓存
        const cacheKey = this.getAnimationCacheKey(animationId, animation);
        if (this.animationCache[cacheKey]) {
            return this.animationCache[cacheKey];
        }

        // 优化：更新动画帧
        if (animation.frameCount) {
            animation.currentFrame = animation.currentFrame || 0;
            animation.frameTimer = animation.frameTimer || 0;

            animation.frameTimer += deltaTime;

            if (animation.frameTimer >= animation.frameDelay) {
                animation.frameTimer = 0;
                animation.currentFrame = (animation.currentFrame + 1) % animation.frameCount;
            }
        }

        // 优化：更新动画属性
        if (animation.properties) {
            for (const prop in animation.properties) {
                const propData = animation.properties[prop];

                if (propData.type === 'linear') {
                    propData.value += propData.speed * deltaTime;

                    // 优化：循环动画
                    if (propData.loop) {
                        if (propData.value > propData.max) {
                            propData.value = propData.min;
                        } else if (propData.value < propData.min) {
                            propData.value = propData.max;
                        }
                    }
                } else if (propData.type === 'sine') {
                    propData.value = propData.min + Math.sin(performance.now() * propData.speed) * (propData.max - propData.min);
                }
            }
        }

        // 优化：保存到缓存
        const result = {
            currentFrame: animation.currentFrame,
            properties: animation.properties
        };

        this.animationCache[cacheKey] = result;

        // 优化：限制缓存大小
        if (Object.keys(this.animationCache).length > this.maxCacheSize) {
            const oldestKey = Object.keys(this.animationCache)[0];
            delete this.animationCache[oldestKey];
        }

        // 优化：保存动画历史
        this.animationHistory.push({
            animationId: animationId,
            currentFrame: animation.currentFrame,
            timestamp: performance.now()
        });

        // 优化：限制历史记录大小
        if (this.animationHistory.length > this.maxHistorySize) {
            this.animationHistory.shift();
        }

        return result;
    },

    /**
     * 获取动画缓存键
     * @param {string} animationId - 动画ID
     * @param {Object} animation - 动画对象
     * @returns {string} 缓存键
     */
    getAnimationCacheKey: function (animationId, animation) {
        // 优化：创建简化的动画状态哈希
        const frame = animation.currentFrame || 0;
        return `${animationId}-${frame}`;
    },

    /**
     * 清空动画缓存
     * @param {string} animationId - 动画ID（可选）
     */
    clearAnimationCache: function (animationId) {
        if (animationId) {
            // 优化：只清空指定动画的缓存
            for (const key in this.animationCache) {
                if (key.startsWith(animationId)) {
                    delete this.animationCache[key];
                }
            }
        } else {
            this.animationCache = {};
        }
    },

    /**
     * 获取动画历史
     * @returns {Array} 动画历史
     */
    getAnimationHistory: function () {
        return this.animationHistory;
    },

    /**
     * 清空动画历史
     */
    clearAnimationHistory: function () {
        this.animationHistory = [];
    },

    /**
     * 获取动画统计信息
     * @returns {Object} 动画统计信息
     */
    getAnimationStats: function () {
        return {
            animationCount: Object.keys(this.animations).length,
            cacheSize: Object.keys(this.animationCache).length,
            historySize: this.animationHistory.length,
            maxCacheSize: this.maxCacheSize,
            maxHistorySize: this.maxHistorySize
        };
    },

    /**
     * 批量更新动画
     * @param {Array} animationIds - 动画ID数组
     * @param {number} deltaTime - 帧时间
     */
    updateAllAnimations: function (animationIds, deltaTime) {
        const results = {};

        for (let i = 0; i < animationIds.length; i++) {
            const animationId = animationIds[i];
            results[animationId] = this.updateAnimation(animationId, deltaTime);
        }

        return results;
    },

    /**
     * 移除所有动画
     */
    removeAllAnimations: function () {
        this.animations = {};
        this.animationCache = {};
    },

    /**
     * 创建动画
     * @param {string} animationId - 动画ID
     * @param {Object} config - 动画配置
     * @returns {Object} 动画对象
     */
    createAnimation: function (animationId, config) {
        const animation = {
            id: animationId,
            frameCount: config.frameCount || 0,
            frameDelay: config.frameDelay || 100,
            currentFrame: 0,
            frameTimer: 0,
            properties: config.properties || {}
        };

        this.addAnimation(animationId, animation);

        return animation;
    },

    /**
     * 播放动画
     * @param {string} animationId - 动画ID
     */
    playAnimation: function (animationId) {
        const animation = this.animations[animationId];
        if (animation) {
            animation.playing = true;
            animation.currentFrame = 0;
            animation.frameTimer = 0;
        }
    },

    /**
     * 暂停动画
     * @param {string} animationId - 动画ID
     */
    pauseAnimation: function (animationId) {
        const animation = this.animations[animationId];
        if (animation) {
            animation.playing = false;
        }
    },

    /**
     * 停止动画
     * @param {string} animationId - 动画ID
     */
    stopAnimation: function (animationId) {
        const animation = this.animations[animationId];
        if (animation) {
            animation.playing = false;
            animation.currentFrame = 0;
            animation.frameTimer = 0;
        }
    }
};

// 优化：游戏渲染性能优化
const GameRenderOptimizer = {
    renderQueue: [],
    renderCache: {},
    renderHistory: [],
    maxHistorySize: 100,
    maxCacheSize: 1000,
    dirtyRectangles: [],

    /**
     * 初始化游戏渲染
     */
    init: function () {
        this.renderQueue = [];
        this.renderCache = {};
        this.renderHistory = [];
        this.dirtyRectangles = [];
    },

    /**
     * 添加渲染任务
     * @param {Object} renderTask - 渲染任务
     */
    addRenderTask: function (renderTask) {
        renderTask.priority = renderTask.priority || 0;
        this.renderQueue.push(renderTask);

        // 优化：按优先级排序
        this.renderQueue.sort((a, b) => b.priority - a.priority);
    },

    /**
     * 移除渲染任务
     * @param {string} taskId - 任务ID
     */
    removeRenderTask: function (taskId) {
        this.renderQueue = this.renderQueue.filter(task => task.id !== taskId);
    },

    /**
     * 获取渲染任务
     * @param {string} taskId - 任务ID
     * @returns {Object|null} 渲染任务
     */
    getRenderTask: function (taskId) {
        return this.renderQueue.find(task => task.id === taskId) || null;
    },

    /**
     * 执行渲染
     * @param {CanvasRenderingContext2D} ctx - Canvas上下文
     */
    render: function (ctx) {
        // 优化：使用脏矩形技术
        if (this.dirtyRectangles.length > 0) {
            this.renderDirtyRectangles(ctx);
        } else {
            this.renderAll(ctx);
        }

        // 优化：清空脏矩形
        this.dirtyRectangles = [];
    },

    /**
     * 渲染所有
     * @param {CanvasRenderingContext2D} ctx - Canvas上下文
     */
    renderAll: function (ctx) {
        // 优化：批量渲染
        for (let i = 0; i < this.renderQueue.length; i++) {
            const task = this.renderQueue[i];

            // 优化：检查缓存
            const cacheKey = this.getRenderCacheKey(task);
            if (this.renderCache[cacheKey]) {
                ctx.drawImage(this.renderCache[cacheKey], task.x, task.y);
                continue;
            }

            // 优化：执行渲染
            task.render(ctx);

            // 优化：保存到缓存
            if (task.cacheable) {
                const cachedCanvas = document.createElement('canvas');
                cachedCanvas.width = task.width || 100;
                cachedCanvas.height = task.height || 100;
                const cachedCtx = cachedCanvas.getContext('2d');

                task.render(cachedCtx);

                this.renderCache[cacheKey] = cachedCanvas;

                // 优化：限制缓存大小
                if (Object.keys(this.renderCache).length > this.maxCacheSize) {
                    const oldestKey = Object.keys(this.renderCache)[0];
                    delete this.renderCache[oldestKey];
                }
            }
        }

        // 优化：保存渲染历史
        this.renderHistory.push({
            taskCount: this.renderQueue.length,
            timestamp: performance.now()
        });

        // 优化：限制历史记录大小
        if (this.renderHistory.length > this.maxHistorySize) {
            this.renderHistory.shift();
        }
    },

    /**
     * 渲染脏矩形
     * @param {CanvasRenderingContext2D} ctx - Canvas上下文
     */
    renderDirtyRectangles: function (ctx) {
        // 优化：只渲染脏矩形区域
        for (let i = 0; i < this.dirtyRectangles.length; i++) {
            const rect = this.dirtyRectangles[i];

            // 优化：清除脏矩形区域
            ctx.clearRect(rect.x, rect.y, rect.width, rect.height);

            // 优化：渲染脏矩形区域内的任务
            for (let j = 0; j < this.renderQueue.length; j++) {
                const task = this.renderQueue[j];

                // 优化：检查任务是否在脏矩形区域内
                if (this.isTaskInRectangle(task, rect)) {
                    task.render(ctx);
                }
            }
        }
    },

    /**
     * 检查任务是否在矩形内
     * @param {Object} task - 渲染任务
     * @param {Object} rect - 矩形
     * @returns {boolean} 是否在矩形内
     */
    isTaskInRectangle: function (task, rect) {
        return task.x < rect.x + rect.width &&
            task.x + task.width > rect.x &&
            task.y < rect.y + rect.height &&
            task.y + task.height > rect.y;
    },

    /**
     * 添加脏矩形
     * @param {Object} rect - 矩形
     */
    addDirtyRectangle: function (rect) {
        this.dirtyRectangles.push(rect);
    },

    /**
     * 获取渲染缓存键
     * @param {Object} task - 渲染任务
     * @returns {string} 缓存键
     */
    getRenderCacheKey: function (task) {
        // 优化：创建简化的任务哈希
        return `${task.id}-${Math.round(task.x)}-${Math.round(task.y)}-${Math.round(task.width)}-${Math.round(task.height)}`;
    },

    /**
     * 清空渲染缓存
     * @param {string} taskId - 任务ID（可选）
     */
    clearRenderCache: function (taskId) {
        if (taskId) {
            // 优化：只清空指定任务的缓存
            for (const key in this.renderCache) {
                if (key.startsWith(taskId)) {
                    delete this.renderCache[key];
                }
            }
        } else {
            this.renderCache = {};
        }
    },

    /**
     * 获取渲染历史
     * @returns {Array} 渲染历史
     */
    getRenderHistory: function () {
        return this.renderHistory;
    },

    /**
     * 清空渲染历史
     */
    clearRenderHistory: function () {
        this.renderHistory = [];
    },

    /**
     * 获取渲染统计信息
     * @returns {Object} 渲染统计信息
     */
    getRenderStats: function () {
        return {
            taskCount: this.renderQueue.length,
            cacheSize: Object.keys(this.renderCache).length,
            historySize: this.renderHistory.length,
            dirtyRectangleCount: this.dirtyRectangles.length,
            maxCacheSize: this.maxCacheSize,
            maxHistorySize: this.maxHistorySize
        };
    },

    /**
     * 清空渲染队列
     */
    clearRenderQueue: function () {
        this.renderQueue = [];
    },

    /**
     * 移除所有渲染任务
     */
    removeAllRenderTasks: function () {
        this.renderQueue = [];
        this.renderCache = {};
    },

    /**
     * 创建渲染任务
     * @param {string} taskId - 任务ID
     * @param {Function} renderFunc - 渲染函数
     * @param {Object} options - 选项
     * @returns {Object} 渲染任务
     */
    createRenderTask: function (taskId, renderFunc, options) {
        const task = {
            id: taskId,
            render: renderFunc,
            x: options.x || 0,
            y: options.y || 0,
            width: options.width || 100,
            height: options.height || 100,
            priority: options.priority || 0,
            cacheable: options.cacheable || false
        };

        this.addRenderTask(task);

        return task;
    }
};

// 优化：游戏交互性能优化
const GameInteractionOptimizer = {
    interactions: {},
    interactionCache: {},
    interactionHistory: [],
    maxHistorySize: 100,
    maxCacheSize: 1000,

    /**
     * 初始化游戏交互
     */
    init: function () {
        this.interactions = {};
        this.interactionCache = {};
        this.interactionHistory = [];
    },

    /**
     * 添加交互
     * @param {string} interactionId - 交互ID
     * @param {Object} interaction - 交互对象
     */
    addInteraction: function (interactionId, interaction) {
        this.interactions[interactionId] = interaction;
    },

    /**
     * 移除交互
     * @param {string} interactionId - 交互ID
     */
    removeInteraction: function (interactionId) {
        delete this.interactions[interactionId];

        // 优化：清除相关的交互缓存
        this.clearInteractionCache(interactionId);
    },

    /**
     * 获取交互
     * @param {string} interactionId - 交互ID
     * @returns {Object|null} 交互对象
     */
    getInteraction: function (interactionId) {
        return this.interactions[interactionId] || null;
    },

    /**
     * 处理交互
     * @param {string} interactionId - 交互ID
     * @param {Object} eventData - 事件数据
     */
    handleInteraction: function (interactionId, eventData) {
        const interaction = this.interactions[interactionId];
        if (!interaction) {
            return null;
        }

        // 优化：检查缓存
        const cacheKey = this.getInteractionCacheKey(interactionId, eventData);
        if (this.interactionCache[cacheKey]) {
            return this.interactionCache[cacheKey];
        }

        // 优化：执行交互处理
        const result = interaction.handler(eventData);

        // 优化：保存到缓存
        this.interactionCache[cacheKey] = result;

        // 优化：限制缓存大小
        if (Object.keys(this.interactionCache).length > this.maxCacheSize) {
            const oldestKey = Object.keys(this.interactionCache)[0];
            delete this.interactionCache[oldestKey];
        }

        // 优化：保存交互历史
        this.interactionHistory.push({
            interactionId: interactionId,
            eventData: eventData,
            result: result,
            timestamp: performance.now()
        });

        // 优化：限制历史记录大小
        if (this.interactionHistory.length > this.maxHistorySize) {
            this.interactionHistory.shift();
        }

        return result;
    },

    /**
     * 获取交互缓存键
     * @param {string} interactionId - 交互ID
     * @param {Object} eventData - 事件数据
     * @returns {string} 缓存键
     */
    getInteractionCacheKey: function (interactionId, eventData) {
        // 优化：创建简化的交互数据哈希
        const simplifiedData = {
            type: eventData.type,
            x: Math.round(eventData.x || 0),
            y: Math.round(eventData.y || 0)
        };
        return `${interactionId}-${JSON.stringify(simplifiedData)}`;
    },

    /**
     * 清空交互缓存
     * @param {string} interactionId - 交互ID（可选）
     */
    clearInteractionCache: function (interactionId) {
        if (interactionId) {
            // 优化：只清空指定交互的缓存
            for (const key in this.interactionCache) {
                if (key.startsWith(interactionId)) {
                    delete this.interactionCache[key];
                }
            }
        } else {
            this.interactionCache = {};
        }
    },

    /**
     * 获取交互历史
     * @returns {Array} 交互历史
     */
    getInteractionHistory: function () {
        return this.interactionHistory;
    },

    /**
     * 清空交互历史
     */
    clearInteractionHistory: function () {
        this.interactionHistory = [];
    },

    /**
     * 获取交互统计信息
     * @returns {Object} 交互统计信息
     */
    getInteractionStats: function () {
        const stats = {
            interactionCount: Object.keys(this.interactions).length,
            cacheSize: Object.keys(this.interactionCache).length,
            historySize: this.interactionHistory.length,
            maxCacheSize: this.maxCacheSize,
            maxHistorySize: this.maxHistorySize
        };

        // 优化：统计每个交互的处理次数
        stats.interactionCounts = {};
        for (let i = 0; i < this.interactionHistory.length; i++) {
            const interactionId = this.interactionHistory[i].interactionId;
            if (!stats.interactionCounts[interactionId]) {
                stats.interactionCounts[interactionId] = 0;
            }
            stats.interactionCounts[interactionId]++;
        }

        return stats;
    },

    /**
     * 批量处理交互
     * @param {Array} interactions - 交互数组
     * @returns {Array} 处理结果数组
     */
    handleAllInteractions: function (interactions) {
        const results = [];

        for (let i = 0; i < interactions.length; i++) {
            const interaction = interactions[i];
            const result = this.handleInteraction(interaction.id, interaction.data);
            results.push(result);
        }

        return results;
    },

    /**
     * 移除所有交互
     */
    removeAllInteractions: function () {
        this.interactions = {};
        this.interactionCache = {};
    },

    /**
     * 创建交互
     * @param {string} interactionId - 交互ID
     * @param {Function} handler - 处理函数
     * @returns {Object} 交互对象
     */
    createInteraction: function (interactionId, handler) {
        const interaction = {
            id: interactionId,
            handler: handler,
            enabled: true
        };

        this.addInteraction(interactionId, interaction);

        return interaction;
    },

    /**
     * 启用交互
     * @param {string} interactionId - 交互ID
     */
    enableInteraction: function (interactionId) {
        const interaction = this.interactions[interactionId];
        if (interaction) {
            interaction.enabled = true;
        }
    },

    /**
     * 禁用交互
     * @param {string} interactionId - 交互ID
     */
    disableInteraction: function (interactionId) {
        const interaction = this.interactions[interactionId];
        if (interaction) {
            interaction.enabled = false;
        }
    },

    /**
     * 检查交互是否启用
     * @param {string} interactionId - 交互ID
     * @returns {boolean} 是否启用
     */
    isInteractionEnabled: function (interactionId) {
        const interaction = this.interactions[interactionId];
        return interaction ? interaction.enabled : false;
    }
};

// 优化：游戏数据性能优化
const GameDataOptimizer = {
    dataStore: {},
    dataCache: {},
    dataHistory: [],
    maxHistorySize: 100,
    maxCacheSize: 1000,

    /**
     * 初始化游戏数据
     */
    init: function () {
        this.dataStore = {};
        this.dataCache = {};
        this.dataHistory = [];
    },

    /**
     * 设置数据
     * @param {string} key - 数据键
     * @param {*} value - 数据值
     */
    setData: function (key, value) {
        this.dataStore[key] = value;

        // 优化：清除相关缓存
        this.clearDataCache(key);

        // 优化：保存数据历史
        this.dataHistory.push({
            action: 'set',
            key: key,
            value: value,
            timestamp: performance.now()
        });

        // 优化：限制历史记录大小
        if (this.dataHistory.length > this.maxHistorySize) {
            this.dataHistory.shift();
        }
    },

    /**
     * 获取数据
     * @param {string} key - 数据键
     * @returns {*} 数据值
     */
    getData: function (key) {
        // 优化：检查缓存
        if (this.dataCache[key]) {
            return this.dataCache[key];
        }

        // 优化：从数据存储中获取
        const value = this.dataStore[key];

        // 优化：保存到缓存
        this.dataCache[key] = value;

        // 优化：限制缓存大小
        if (Object.keys(this.dataCache).length > this.maxCacheSize) {
            const oldestKey = Object.keys(this.dataCache)[0];
            delete this.dataCache[oldestKey];
        }

        return value;
    },

    /**
     * 删除数据
     * @param {string} key - 数据键
     */
    removeData: function (key) {
        delete this.dataStore[key];

        // 优化：清除相关缓存
        this.clearDataCache(key);

        // 优化：保存数据历史
        this.dataHistory.push({
            action: 'remove',
            key: key,
            timestamp: performance.now()
        });

        // 优化：限制历史记录大小
        if (this.dataHistory.length > this.maxHistorySize) {
            this.dataHistory.shift();
        }
    },

    /**
     * 检查数据是否存在
     * @param {string} key - 数据键
     * @returns {boolean} 是否存在
     */
    hasData: function (key) {
        return key in this.dataStore;
    },

    /**
     * 获取所有数据键
     * @returns {Array} 数据键数组
     */
    getAllDataKeys: function () {
        return Object.keys(this.dataStore);
    },

    /**
     * 清空数据缓存
     * @param {string} key - 数据键（可选）
     */
    clearDataCache: function (key) {
        if (key) {
            delete this.dataCache[key];
        } else {
            this.dataCache = {};
        }
    },

    /**
     * 获取数据历史
     * @returns {Array} 数据历史
     */
    getDataHistory: function () {
        return this.dataHistory;
    },

    /**
     * 清空数据历史
     */
    clearDataHistory: function () {
        this.dataHistory = [];
    },

    /**
     * 获取数据统计信息
     * @returns {Object} 数据统计信息
     */
    getDataStats: function () {
        return {
            dataCount: Object.keys(this.dataStore).length,
            cacheSize: Object.keys(this.dataCache).length,
            historySize: this.dataHistory.length,
            maxCacheSize: this.maxCacheSize,
            maxHistorySize: this.maxHistorySize
        };
    },

    /**
     * 批量设置数据
     * @param {Object} data - 数据对象
     */
    setAllData: function (data) {
        for (const key in data) {
            this.setData(key, data[key]);
        }
    },

    /**
     * 批量获取数据
     * @param {Array} keys - 数据键数组
     * @returns {Object} 数据对象
     */
    getAllData: function (keys) {
        const data = {};

        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            data[key] = this.getData(key);
        }

        return data;
    },

    /**
     * 清空所有数据
     */
    clearAllData: function () {
        this.dataStore = {};
        this.dataCache = {};
    },

    /**
     * 导出数据
     * @returns {string} 导出的数据
     */
    exportData: function () {
        return JSON.stringify(this.dataStore);
    },

    /**
     * 导入数据
     * @param {string} exportedData - 导出的数据
     */
    importData: function (exportedData) {
        try {
            const data = JSON.parse(exportedData);
            this.setAllData(data);
        } catch (error) {
            console.error('导入数据失败:', error);
        }
    },

    /**
     * 数据快照
     * @returns {Object} 数据快照
     */
    createDataSnapshot: function () {
        return JSON.parse(JSON.stringify(this.dataStore));
    },

    /**
     * 恢复数据快照
     * @param {Object} snapshot - 数据快照
     */
    restoreDataSnapshot: function (snapshot) {
        this.dataStore = JSON.parse(JSON.stringify(snapshot));
        this.clearDataCache();
    },

    /**
     * 数据订阅
     * @param {string} key - 数据键
     * @param {Function} callback - 回调函数
     */
    subscribe: function (key, callback) {
        // 优化：使用Proxy监听数据变化
        const proxy = new Proxy(this.dataStore, {
            set: (target, prop, value) => {
                const oldValue = target[prop];
                target[prop] = value;

                if (prop === key && oldValue !== value) {
                    callback(value, oldValue);
                }

                return true;
            }
        });

        this.dataStore = proxy;
    },

    /**
     * 数据取消订阅
     */
    unsubscribe: function () {
        // 优化：移除Proxy监听
        const snapshot = this.createDataSnapshot();
        this.dataStore = snapshot;
    }
};

// 优化：游戏安全性能优化
const GameSecurityOptimizer = {
    securityPolicies: {},
    securityLogs: [],
    maxLogSize: 1000,
    securityCache: {},

    /**
     * 初始化游戏安全
     */
    init: function () {
        this.securityPolicies = {};
        this.securityLogs = [];
        this.securityCache = {};

        // 优化：添加默认安全策略
        this.addSecurityPolicy('xss', {
            enabled: true,
            check: function (data) {
                // 优化：检查XSS攻击
                const xssPatterns = [
                    /<script/i,
                    /javascript:/i,
                    /on\w+\s*=/i
                ];

                for (let i = 0; i < xssPatterns.length; i++) {
                    if (xssPatterns[i].test(data)) {
                        return false;
                    }
                }

                return true;
            }
        });

        this.addSecurityPolicy('injection', {
            enabled: true,
            check: function (data) {
                // 优化：检查注入攻击
                const injectionPatterns = [
                    /['";]/,
                    /union\s+select/i,
                    /drop\s+table/i
                ];

                for (let i = 0; i < injectionPatterns.length; i++) {
                    if (injectionPatterns[i].test(data)) {
                        return false;
                    }
                }

                return true;
            }
        });
    },

    /**
     * 添加安全策略
     * @param {string} policyName - 策略名称
     * @param {Object} policy - 安全策略
     */
    addSecurityPolicy: function (policyName, policy) {
        this.securityPolicies[policyName] = policy;
    },

    /**
     * 移除安全策略
     * @param {string} policyName - 策略名称
     */
    removeSecurityPolicy: function (policyName) {
        delete this.securityPolicies[policyName];
    },

    /**
     * 获取安全策略
     * @param {string} policyName - 策略名称
     * @returns {Object|null} 安全策略
     */
    getSecurityPolicy: function (policyName) {
        return this.securityPolicies[policyName] || null;
    },

    /**
     * 检查数据安全性
     * @param {*} data - 数据
     * @param {string} policyName - 策略名称（可选）
     * @returns {boolean} 是否安全
     */
    checkSecurity: function (data, policyName) {
        // 优化：检查缓存
        const cacheKey = this.getSecurityCacheKey(data, policyName);
        if (this.securityCache[cacheKey]) {
            return this.securityCache[cacheKey];
        }

        let isSecure = true;

        if (policyName) {
            // 优化：检查指定策略
            const policy = this.securityPolicies[policyName];
            if (policy && policy.enabled && policy.check) {
                isSecure = policy.check(data);
            }
        } else {
            // 优化：检查所有策略
            for (const name in this.securityPolicies) {
                const policy = this.securityPolicies[name];
                if (policy && policy.enabled && policy.check) {
                    if (!policy.check(data)) {
                        isSecure = false;
                        break;
                    }
                }
            }
        }

        // 优化：保存到缓存
        this.securityCache[cacheKey] = isSecure;

        // 优化：限制缓存大小
        if (Object.keys(this.securityCache).length > 1000) {
            const oldestKey = Object.keys(this.securityCache)[0];
            delete this.securityCache[oldestKey];
        }

        // 优化：记录安全日志
        this.logSecurity({
            type: 'check',
            data: data,
            policyName: policyName,
            result: isSecure,
            timestamp: performance.now()
        });

        return isSecure;
    },

    /**
     * 获取安全缓存键
     * @param {*} data - 数据
     * @param {string} policyName - 策略名称
     * @returns {string} 缓存键
     */
    getSecurityCacheKey: function (data, policyName) {
        // 优化：创建简化的数据哈希
        const dataStr = typeof data === 'string' ? data : JSON.stringify(data);
        const hash = this.simpleHash(dataStr);
        return `${policyName || 'all'}-${hash}`;
    },

    /**
     * 简单哈希函数
     * @param {string} str - 字符串
     * @returns {string} 哈希值
     */
    simpleHash: function (str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return Math.abs(hash).toString(36);
    },

    /**
     * 记录安全日志
     * @param {Object} log - 日志对象
     */
    logSecurity: function (log) {
        this.securityLogs.push(log);

        // 优化：限制日志大小
        if (this.securityLogs.length > this.maxLogSize) {
            this.securityLogs.shift();
        }
    },

    /**
     * 获取安全日志
     * @returns {Array} 安全日志
     */
    getSecurityLogs: function () {
        return this.securityLogs;
    },

    /**
     * 清空安全日志
     */
    clearSecurityLogs: function () {
        this.securityLogs = [];
    },

    /**
     * 获取安全统计信息
     * @returns {Object} 安全统计信息
     */
    getSecurityStats: function () {
        const stats = {
            policyCount: Object.keys(this.securityPolicies).length,
            logSize: this.securityLogs.length,
            cacheSize: Object.keys(this.securityCache).length,
            maxLogSize: this.maxLogSize
        };

        // 优化：统计安全检查结果
        stats.checkResults = {
            secure: 0,
            insecure: 0
        };

        for (let i = 0; i < this.securityLogs.length; i++) {
            if (this.securityLogs[i].type === 'check') {
                if (this.securityLogs[i].result) {
                    stats.checkResults.secure++;
                } else {
                    stats.checkResults.insecure++;
                }
            }
        }

        return stats;
    },

    /**
     * 清空安全缓存
     */
    clearSecurityCache: function () {
        this.securityCache = {};
    },

    /**
     * 移除所有安全策略
     */
    removeAllSecurityPolicies: function () {
        this.securityPolicies = {};
    },

    /**
     * 启用安全策略
     * @param {string} policyName - 策略名称
     */
    enableSecurityPolicy: function (policyName) {
        const policy = this.securityPolicies[policyName];
        if (policy) {
            policy.enabled = true;
        }
    },

    /**
     * 禁用安全策略
     * @param {string} policyName - 策略名称
     */
    disableSecurityPolicy: function (policyName) {
        const policy = this.securityPolicies[policyName];
        if (policy) {
            policy.enabled = false;
        }
    },

    /**
     * 检查策略是否启用
     * @param {string} policyName - 策略名称
     * @returns {boolean} 是否启用
     */
    isSecurityPolicyEnabled: function (policyName) {
        const policy = this.securityPolicies[policyName];
        return policy ? policy.enabled : false;
    },

    /**
     * 数据消毒
     * @param {*} data - 数据
     * @returns {*} 消毒后的数据
     */
    sanitizeData: function (data) {
        if (typeof data === 'string') {
            // 优化：移除危险字符
            return data
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#x27;')
                .replace(/\//g, '&#x2F;');
        }

        return data;
    },

    /**
     * 数据验证
     * @param {*} data - 数据
     * @param {string} type - 数据类型
     * @returns {boolean} 是否有效
     */
    validateData: function (data, type) {
        switch (type) {
            case 'string':
                return typeof data === 'string';
            case 'number':
                return typeof data === 'number' && !isNaN(data);
            case 'boolean':
                return typeof data === 'boolean';
            case 'array':
                return Array.isArray(data);
            case 'object':
                return typeof data === 'object' && data !== null;
            default:
                return true;
        }
    }
};

// 优化：游戏兼容性性能优化
const GameCompatibilityOptimizer = {
    browserInfo: null,
    deviceInfo: null,
    featureSupport: {},
    compatibilityCache: {},

    /**
     * 初始化游戏兼容性
     */
    init: function () {
        this.browserInfo = this.detectBrowser();
        this.deviceInfo = this.detectDevice();
        this.featureSupport = this.detectFeatures();
    },

    /**
     * 检测浏览器
     * @returns {Object} 浏览器信息
     */
    detectBrowser: function () {
        const ua = navigator.userAgent;

        // 优化：检测浏览器类型
        let browser = 'unknown';
        let version = 'unknown';

        if (ua.indexOf('Chrome') !== -1) {
            browser = 'Chrome';
            version = ua.match(/Chrome\/(\d+\.\d+\.\d+\.\d+)/)[1];
        } else if (ua.indexOf('Firefox') !== -1) {
            browser = 'Firefox';
            version = ua.match(/Firefox\/(\d+\.\d+)/)[1];
        } else if (ua.indexOf('Safari') !== -1) {
            browser = 'Safari';
            version = ua.match(/Version\/(\d+\.\d+)/)[1];
        } else if (ua.indexOf('Edge') !== -1) {
            browser = 'Edge';
            version = ua.match(/Edge\/(\d+\.\d+\.\d+\.\d+)/)[1];
        } else if (ua.indexOf('MSIE') !== -1 || ua.indexOf('Trident') !== -1) {
            browser = 'IE';
            version = ua.match(/(?:MSIE |rv:)(\d+\.\d+)/)[1];
        }

        return {
            name: browser,
            version: version,
            userAgent: ua
        };
    },

    /**
     * 检测设备
     * @returns {Object} 设备信息
     */
    detectDevice: function () {
        const ua = navigator.userAgent;

        // 优化：检测设备类型
        let device = 'desktop';
        let os = 'unknown';

        if (/Mobile|Android|iPhone|iPad|iPod/i.test(ua)) {
            device = 'mobile';
        } else if (/Tablet|iPad/i.test(ua)) {
            device = 'tablet';
        }

        // 优化：检测操作系统
        if (ua.indexOf('Windows') !== -1) {
            os = 'Windows';
        } else if (ua.indexOf('Mac') !== -1) {
            os = 'macOS';
        } else if (ua.indexOf('Linux') !== -1) {
            os = 'Linux';
        } else if (ua.indexOf('Android') !== -1) {
            os = 'Android';
        } else if (ua.indexOf('iOS') !== -1) {
            os = 'iOS';
        }

        return {
            type: device,
            os: os,
            userAgent: ua,
            screen: {
                width: window.screen.width,
                height: window.screen.height,
                pixelRatio: window.devicePixelRatio || 1
            }
        };
    },

    /**
     * 检测特性支持
     * @returns {Object} 特性支持信息
     */
    detectFeatures: function () {
        const features = {};

        // 优化：检测Canvas支持
        features.canvas = !!document.createElement('canvas').getContext;

        // 优化：检测WebGL支持
        const canvas = document.createElement('canvas');
        features.webgl = !!canvas.getContext('webgl') || !!canvas.getContext('experimental-webgl');

        // 优化：检测LocalStorage支持
        try {
            localStorage.setItem('test', 'test');
            localStorage.removeItem('test');
            features.localStorage = true;
        } catch (e) {
            features.localStorage = false;
        }

        // 优化：检测SessionStorage支持
        try {
            sessionStorage.setItem('test', 'test');
            sessionStorage.removeItem('test');
            features.sessionStorage = true;
        } catch (e) {
            features.sessionStorage = false;
        }

        // 优化：检测Web Workers支持
        features.webWorkers = !!window.Worker;

        // 优化：检测RequestAnimationFrame支持
        features.requestAnimationFrame = !!window.requestAnimationFrame;

        // 优化：检测Touch事件支持
        features.touchEvents = 'ontouchstart' in window;

        // 优化：检测Pointer事件支持
        features.pointerEvents = !!window.PointerEvent;

        return features;
    },

    /**
     * 检查特性支持
     * @param {string} feature - 特性名称
     * @returns {boolean} 是否支持
     */
    isFeatureSupported: function (feature) {
        return this.featureSupport[feature] || false;
    },

    /**
     * 获取浏览器信息
     * @returns {Object} 浏览器信息
     */
    getBrowserInfo: function () {
        return this.browserInfo;
    },

    /**
     * 获取设备信息
     * @returns {Object} 设备信息
     */
    getDeviceInfo: function () {
        return this.deviceInfo;
    },

    /**
     * 获取特性支持信息
     * @returns {Object} 特性支持信息
     */
    getFeatureSupport: function () {
        return this.featureSupport;
    },

    /**
     * 检查兼容性
     * @returns {Object} 兼容性信息
     */
    checkCompatibility: function () {
        const compatibility = {
            compatible: true,
            warnings: [],
            errors: []
        };

        // 优化：检查必需的特性
        if (!this.featureSupport.canvas) {
            compatibility.compatible = false;
            compatibility.errors.push('Canvas不支持');
        }

        if (!this.featureSupport.requestAnimationFrame) {
            compatibility.warnings.push('RequestAnimationFrame不支持，将使用setTimeout');
        }

        if (!this.featureSupport.localStorage) {
            compatibility.warnings.push('LocalStorage不支持，游戏进度无法保存');
        }

        // 优化：检查浏览器版本
        if (this.browserInfo.name === 'IE') {
            compatibility.warnings.push('IE浏览器可能存在兼容性问题');
        }

        // 优化：检查设备类型
        if (this.deviceInfo.type === 'mobile') {
            compatibility.warnings.push('移动设备可能存在性能问题');
        }

        return compatibility;
    },

    /**
     * 获取兼容性缓存
     * @param {string} key - 缓存键
     * @returns {*} 缓存值
     */
    getCompatibilityCache: function (key) {
        return this.compatibilityCache[key];
    },

    /**
     * 设置兼容性缓存
     * @param {string} key - 缓存键
     * @param {*} value - 缓存值
     */
    setCompatibilityCache: function (key, value) {
        this.compatibilityCache[key] = value;
    },

    /**
     * 清空兼容性缓存
     */
    clearCompatibilityCache: function () {
        this.compatibilityCache = {};
    },

    /**
     * 应用兼容性修复
     */
    applyCompatibilityFixes: function () {
        // 优化：修复RequestAnimationFrame
        if (!this.featureSupport.requestAnimationFrame) {
            window.requestAnimationFrame = function (callback) {
                return setTimeout(callback, 16);
            };
            window.cancelAnimationFrame = function (id) {
                clearTimeout(id);
            };
        }

        // 优化：修复Canvas
        if (this.featureSupport.canvas) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // 优化：修复Canvas文本渲染
            if (!ctx.fillText) {
                ctx.fillText = function (text, x, y) {
                    console.warn('fillText不支持');
                };
            }
        }
    },

    /**
     * 获取性能建议
     * @returns {Array} 性能建议
     */
    getPerformanceRecommendations: function () {
        const recommendations = [];

        // 优化：基于设备类型提供建议
        if (this.deviceInfo.type === 'mobile') {
            recommendations.push('建议降低游戏画质以提升性能');
            recommendations.push('建议关闭粒子效果以减少内存使用');
        }

        // 优化：基于浏览器提供建议
        if (this.browserInfo.name === 'IE') {
            recommendations.push('建议使用现代浏览器以获得更好的游戏体验');
        }

        // 优化：基于屏幕分辨率提供建议
        if (this.deviceInfo.screen.pixelRatio > 1) {
            recommendations.push('建议降低设备像素比以提升性能');
        }

        return recommendations;
    }
};

// 优化：游戏可访问性性能优化
const GameAccessibilityOptimizer = {
    accessibilitySettings: {
        keyboardNavigation: true,
        screenReaderSupport: false,
        highContrastMode: false,
        reducedMotion: false,
        fontSize: 'medium',
        colorBlindMode: 'none'
    },
    focusableElements: [],
    currentFocusIndex: -1,
    ariaLabels: {},

    /**
     * 初始化游戏可访问性
     */
    init: function () {
        this.detectAccessibilityPreferences();
        this.setupKeyboardNavigation();
        this.setupScreenReaderSupport();
    },

    /**
     * 检测可访问性偏好
     */
    detectAccessibilityPreferences: function () {
        // 优化：检测高对比度模式
        if (window.matchMedia && window.matchMedia('(prefers-contrast: high)').matches) {
            this.accessibilitySettings.highContrastMode = true;
        }

        // 优化：检测减少动画
        if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
            this.accessibilitySettings.reducedMotion = true;
        }

        // 优化：检测屏幕阅读器
        this.accessibilitySettings.screenReaderSupport = this.detectScreenReader();
    },

    /**
     * 检测屏幕阅读器
     * @returns {boolean} 是否使用屏幕阅读器
     */
    detectScreenReader: function () {
        // 优化：检测屏幕阅读器
        return navigator.userAgent.indexOf('JAWS') !== -1 ||
            navigator.userAgent.indexOf('NVDA') !== -1 ||
            navigator.userAgent.indexOf('VoiceOver') !== -1;
    },

    /**
     * 设置键盘导航
     */
    setupKeyboardNavigation: function () {
        if (!this.accessibilitySettings.keyboardNavigation) {
            return;
        }

        // 优化：添加键盘事件监听
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'Tab':
                    e.preventDefault();
                    this.focusNextElement();
                    break;
                case 'Enter':
                case ' ':
                    e.preventDefault();
                    this.activateFocusedElement();
                    break;
                case 'ArrowUp':
                case 'ArrowDown':
                case 'ArrowLeft':
                case 'ArrowRight':
                    e.preventDefault();
                    this.navigateDirection(e.key);
                    break;
                case 'Escape':
                    e.preventDefault();
                    this.escapeCurrentFocus();
                    break;
            }
        });
    },

    /**
     * 添加可聚焦元素
     * @param {HTMLElement} element - 元素
     * @param {string} label - 标签
     */
    addFocusableElement: function (element, label) {
        if (!element) {
            return;
        }

        // 优化：添加可访问性属性
        element.setAttribute('tabindex', '0');
        element.setAttribute('role', 'button');
        element.setAttribute('aria-label', label || element.textContent || '');

        this.focusableElements.push({
            element: element,
            label: label || element.textContent || ''
        });
    },

    /**
     * 移除可聚焦元素
     * @param {HTMLElement} element - 元素
     */
    removeFocusableElement: function (element) {
        if (!element) {
            return;
        }

        // 优化：移除可访问性属性
        element.removeAttribute('tabindex');
        element.removeAttribute('role');
        element.removeAttribute('aria-label');

        this.focusableElements = this.focusableElements.filter(item => item.element !== element);
    },

    /**
     * 聚焦下一个元素
     */
    focusNextElement: function () {
        if (this.focusableElements.length === 0) {
            return;
        }

        this.currentFocusIndex = (this.currentFocusIndex + 1) % this.focusableElements.length;
        this.focusElement(this.currentFocusIndex);
    },

    /**
     * 聚焦上一个元素
     */
    focusPreviousElement: function () {
        if (this.focusableElements.length === 0) {
            return;
        }

        this.currentFocusIndex = (this.currentFocusIndex - 1 + this.focusableElements.length) % this.focusableElements.length;
        this.focusElement(this.currentFocusIndex);
    },

    /**
     * 聚焦指定索引的元素
     * @param {number} index - 索引
     */
    focusElement: function (index) {
        if (index < 0 || index >= this.focusableElements.length) {
            return;
        }

        const element = this.focusableElements[index].element;
        element.focus();

        // 优化：添加视觉反馈
        element.style.outline = '2px solid #00ff00';

        // 优化：移除其他元素的视觉反馈
        for (let i = 0; i < this.focusableElements.length; i++) {
            if (i !== index) {
                this.focusableElements[i].element.style.outline = '';
            }
        }
    },

    /**
     * 激活当前聚焦的元素
     */
    activateFocusedElement: function () {
        if (this.currentFocusIndex < 0 || this.currentFocusIndex >= this.focusableElements.length) {
            return;
        }

        const element = this.focusableElements[this.currentFocusIndex].element;
        element.click();
    },

    /**
     * 方向导航
     * @param {string} direction - 方向
     */
    navigateDirection: function (direction) {
        // 优化：根据方向移动焦点
        switch (direction) {
            case 'ArrowUp':
                this.focusPreviousElement();
                break;
            case 'ArrowDown':
                this.focusNextElement();
                break;
            case 'ArrowLeft':
                this.focusPreviousElement();
                break;
            case 'ArrowRight':
                this.focusNextElement();
                break;
        }
    },

    /**
     * 退出当前焦点
     */
    escapeCurrentFocus: function () {
        // 优化：清除所有焦点
        if (this.currentFocusIndex >= 0) {
            const element = this.focusableElements[this.currentFocusIndex].element;
            element.style.outline = '';
        }

        this.currentFocusIndex = -1;
    },

    /**
     * 设置屏幕阅读器支持
     */
    setupScreenReaderSupport: function () {
        if (!this.accessibilitySettings.screenReaderSupport) {
            return;
        }

        // 优化：添加屏幕阅读器支持
        const gameContainer = document.getElementById('game-container');
        if (gameContainer) {
            gameContainer.setAttribute('role', 'application');
            gameContainer.setAttribute('aria-label', '火柴人冒险游戏');
        }
    },

    /**
     * 添加ARIA标签
     * @param {string} id - 元素ID
     * @param {string} label - 标签
     */
    addAriaLabel: function (id, label) {
        this.ariaLabels[id] = label;

        const element = document.getElementById(id);
        if (element) {
            element.setAttribute('aria-label', label);
        }
    },

    /**
     * 获取ARIA标签
     * @param {string} id - 元素ID
     * @returns {string} 标签
     */
    getAriaLabel: function (id) {
        return this.ariaLabels[id] || '';
    },

    /**
     * 设置高对比度模式
     * @param {boolean} enabled - 是否启用
     */
    setHighContrastMode: function (enabled) {
        this.accessibilitySettings.highContrastMode = enabled;

        // 优化：应用高对比度样式
        if (enabled) {
            document.body.classList.add('high-contrast');
        } else {
            document.body.classList.remove('high-contrast');
        }
    },

    /**
     * 设置减少动画
     * @param {boolean} enabled - 是否启用
     */
    setReducedMotion: function (enabled) {
        this.accessibilitySettings.reducedMotion = enabled;

        // 优化：应用减少动画样式
        if (enabled) {
            document.body.classList.add('reduced-motion');
        } else {
            document.body.classList.remove('reduced-motion');
        }
    },

    /**
     * 设置字体大小
     * @param {string} size - 字体大小
     */
    setFontSize: function (size) {
        this.accessibilitySettings.fontSize = size;

        // 优化：应用字体大小
        document.body.style.fontSize = size;
    },

    /**
     * 设置色盲模式
     * @param {string} mode - 色盲模式
     */
    setColorBlindMode: function (mode) {
        this.accessibilitySettings.colorBlindMode = mode;

        // 优化：应用色盲模式
        document.body.classList.remove('colorblind-protanopia', 'colorblind-deuteranopia', 'colorblind-tritanopia');

        if (mode !== 'none') {
            document.body.classList.add(`colorblind-${mode}`);
        }
    },

    /**
     * 获取可访问性设置
     * @returns {Object} 可访问性设置
     */
    getAccessibilitySettings: function () {
        return this.accessibilitySettings;
    },

    /**
     * 获取可访问性统计信息
     * @returns {Object} 可访问性统计信息
     */
    getAccessibilityStats: function () {
        return {
            focusableElementCount: this.focusableElements.length,
            currentFocusIndex: this.currentFocusIndex,
            ariaLabelCount: Object.keys(this.ariaLabels).length,
            settings: this.accessibilitySettings
        };
    },

    /**
     * 清空可聚焦元素
     */
    clearFocusableElements: function () {
        // 优化：移除所有可聚焦元素的可访问性属性
        for (let i = 0; i < this.focusableElements.length; i++) {
            const element = this.focusableElements[i].element;
            element.removeAttribute('tabindex');
            element.removeAttribute('role');
            element.removeAttribute('aria-label');
            element.style.outline = '';
        }

        this.focusableElements = [];
        this.currentFocusIndex = -1;
    },

    /**
     * 清空ARIA标签
     */
    clearAriaLabels: function () {
        this.ariaLabels = {};
    }
};

// 优化：游戏国际化性能优化
const GameInternationalizationOptimizer = {
    currentLanguage: 'zh',
    translations: {},
    translationCache: {},
    supportedLanguages: ['zh', 'en', 'ja', 'ko'],

    /**
     * 初始化游戏国际化
     */
    init: function () {
        this.loadTranslations();
        this.detectLanguage();
    },

    /**
     * 检测语言
     */
    detectLanguage: function () {
        // 优化：检测浏览器语言
        const browserLanguage = navigator.language || navigator.userLanguage;
        const languageCode = browserLanguage.split('-')[0];

        // 优化：检查是否支持该语言
        if (this.supportedLanguages.indexOf(languageCode) !== -1) {
            this.currentLanguage = languageCode;
        }
    },

    /**
     * 加载翻译
     */
    loadTranslations: function () {
        // 优化：加载中文翻译
        this.translations['zh'] = {
            'game.title': '火柴人冒险',
            'game.start': '开始游戏',
            'game.pause': '暂停',
            'game.resume': '继续',
            'game.gameOver': '游戏结束',
            'game.levelComplete': '关卡完成',
            'game.score': '分数',
            'game.health': '生命',
            'game.level': '关卡',
            'game.difficulty': '难度',
            'game.easy': '简单',
            'game.medium': '中等',
            'game.hard': '困难',
            'game.tutorial': '教程',
            'game.settings': '设置',
            'game.exit': '退出',
            'player.attack': '攻击',
            'player.jump': '跳跃',
            'player.moveLeft': '向左移动',
            'player.moveRight': '向右移动',
            'enemy.spawn': '敌人出现',
            'enemy.defeated': '敌人被击败',
            'item.collected': '道具收集',
            'item.health': '生命药水',
            'item.powerup': '能量提升',
            'item.invincibility': '无敌',
            'item.speedboost': '速度提升',
            'item.shield': '护盾',
            'item.combo': '连击',
            'item.timefreeze': '时间冻结',
            'item.bombdrop': '炸弹',
            'notification.saveSuccess': '游戏进度已保存',
            'notification.loadSuccess': '游戏进度已加载',
            'notification.saveFailed': '保存游戏进度失败',
            'notification.loadFailed': '加载游戏进度失败'
        };

        // 优化：加载英文翻译
        this.translations['en'] = {
            'game.title': 'Stickman Adventure',
            'game.start': 'Start Game',
            'game.pause': 'Pause',
            'game.resume': 'Resume',
            'game.gameOver': 'Game Over',
            'game.levelComplete': 'Level Complete',
            'game.score': 'Score',
            'game.health': 'Health',
            'game.level': 'Level',
            'game.difficulty': 'Difficulty',
            'game.easy': 'Easy',
            'game.medium': 'Medium',
            'game.hard': 'Hard',
            'game.tutorial': 'Tutorial',
            'game.settings': 'Settings',
            'game.exit': 'Exit',
            'player.attack': 'Attack',
            'player.jump': 'Jump',
            'player.moveLeft': 'Move Left',
            'player.moveRight': 'Move Right',
            'enemy.spawn': 'Enemy Spawned',
            'enemy.defeated': 'Enemy Defeated',
            'item.collected': 'Item Collected',
            'item.health': 'Health Potion',
            'item.powerup': 'Power Up',
            'item.invincibility': 'Invincibility',
            'item.speedboost': 'Speed Boost',
            'item.shield': 'Shield',
            'item.combo': 'Combo',
            'item.timefreeze': 'Time Freeze',
            'item.bombdrop': 'Bomb',
            'notification.saveSuccess': 'Game progress saved',
            'notification.loadSuccess': 'Game progress loaded',
            'notification.saveFailed': 'Failed to save game progress',
            'notification.loadFailed': 'Failed to load game progress'
        };
    },

    /**
     * 获取翻译
     * @param {string} key - 翻译键
     * @param {string} language - 语言（可选）
     * @returns {string} 翻译文本
     */
    translate: function (key, language) {
        const lang = language || this.currentLanguage;

        // 优化：检查缓存
        const cacheKey = `${lang}-${key}`;
        if (this.translationCache[cacheKey]) {
            return this.translationCache[cacheKey];
        }

        // 优化：获取翻译
        let translation = key;

        if (this.translations[lang] && this.translations[lang][key]) {
            translation = this.translations[lang][key];
        } else if (this.translations['zh'] && this.translations['zh'][key]) {
            // 优化：使用中文作为后备
            translation = this.translations['zh'][key];
        }

        // 优化：保存到缓存
        this.translationCache[cacheKey] = translation;

        return translation;
    },

    /**
     * 设置语言
     * @param {string} language - 语言
     */
    setLanguage: function (language) {
        if (this.supportedLanguages.indexOf(language) !== -1) {
            this.currentLanguage = language;

            // 优化：清空翻译缓存
            this.translationCache = {};

            // 优化：更新UI文本
            this.updateUIText();
        }
    },

    /**
     * 获取当前语言
     * @returns {string} 当前语言
     */
    getCurrentLanguage: function () {
        return this.currentLanguage;
    },

    /**
     * 获取支持的语言
     * @returns {Array} 支持的语言列表
     */
    getSupportedLanguages: function () {
        return this.supportedLanguages;
    },

    /**
     * 添加翻译
     * @param {string} language - 语言
     * @param {string} key - 翻译键
     * @param {string} translation - 翻译文本
     */
    addTranslation: function (language, key, translation) {
        if (!this.translations[language]) {
            this.translations[language] = {};
        }

        this.translations[language][key] = translation;

        // 优化：清空翻译缓存
        const cacheKey = `${language}-${key}`;
        delete this.translationCache[cacheKey];
    },

    /**
     * 批量添加翻译
     * @param {string} language - 语言
     * @param {Object} translations - 翻译对象
     */
    addTranslations: function (language, translations) {
        if (!this.translations[language]) {
            this.translations[language] = {};
        }

        for (const key in translations) {
            this.translations[language][key] = translations[key];
        }

        // 优化：清空翻译缓存
        this.translationCache = {};
    },

    /**
     * 更新UI文本
     */
    updateUIText: function () {
        // 优化：更新所有UI元素的文本
        const elements = document.querySelectorAll('[data-i18n]');

        for (let i = 0; i < elements.length; i++) {
            const element = elements[i];
            const key = element.getAttribute('data-i18n');
            const translation = this.translate(key);

            // 优化：更新元素文本
            if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                element.placeholder = translation;
            } else {
                element.textContent = translation;
            }
        }
    },

    /**
     * 清空翻译缓存
     */
    clearTranslationCache: function () {
        this.translationCache = {};
    },

    /**
     * 获取翻译统计信息
     * @returns {Object} 翻译统计信息
     */
    getTranslationStats: function () {
        const stats = {
            currentLanguage: this.currentLanguage,
            supportedLanguages: this.supportedLanguages,
            cacheSize: Object.keys(this.translationCache).length,
            translations: {}
        };

        // 优化：统计每种语言的翻译数量
        for (const lang in this.translations) {
            stats.translations[lang] = Object.keys(this.translations[lang]).length;
        }

        return stats;
    },

    /**
     * 导出翻译
     * @param {string} language - 语言
     * @returns {string} 导出的翻译
     */
    exportTranslations: function (language) {
        const lang = language || this.currentLanguage;
        return JSON.stringify(this.translations[lang] || {});
    },

    /**
     * 导入翻译
     * @param {string} language - 语言
     * @param {string} translations - 翻译JSON
     */
    importTranslations: function (language, translations) {
        try {
            const parsedTranslations = JSON.parse(translations);
            this.addTranslations(language, parsedTranslations);
        } catch (error) {
            console.error('导入翻译失败:', error);
        }
    },

    /**
     * 格式化文本
     * @param {string} key - 翻译键
     * @param {Object} params - 参数
     * @returns {string} 格式化后的文本
     */
    formatText: function (key, params) {
        let text = this.translate(key);

        // 优化：替换参数
        for (const param in params) {
            const regex = new RegExp(`\\{${param}\\}`, 'g');
            text = text.replace(regex, params[param]);
        }

        return text;
    }
};

// 优化：游戏本地化性能优化
const GameLocalizationOptimizer = {
    locale: 'zh-CN',
    localeCache: {},
    formatters: {},

    /**
     * 初始化游戏本地化
     */
    init: function () {
        this.detectLocale();
        this.initFormatters();
    },

    /**
     * 检测区域设置
     */
    detectLocale: function () {
        // 优化：检测浏览器区域设置
        this.locale = navigator.language || navigator.userLanguage || 'zh-CN';
    },

    /**
     * 初始化格式化器
     */
    initFormatters: function () {
        // 优化：初始化数字格式化器
        this.formatters.number = new Intl.NumberFormat(this.locale);

        // 优化：初始化货币格式化器
        this.formatters.currency = new Intl.NumberFormat(this.locale, {
            style: 'currency',
            currency: 'CNY'
        });

        // 优化：初始化百分比格式化器
        this.formatters.percent = new Intl.NumberFormat(this.locale, {
            style: 'percent'
        });

        // 优化：初始化日期时间格式化器
        this.formatters.date = new Intl.DateTimeFormat(this.locale);
        this.formatters.time = new Intl.DateTimeFormat(this.locale, {
            hour: '2-digit',
            minute: '2-digit'
        });
        this.formatters.dateTime = new Intl.DateTimeFormat(this.locale, {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
        });
    },

    /**
     * 设置区域设置
     * @param {string} locale - 区域设置
     */
    setLocale: function (locale) {
        this.locale = locale;
        this.initFormatters();

        // 优化：清空缓存
        this.localeCache = {};
    },

    /**
     * 获取区域设置
     * @returns {string} 区域设置
     */
    getLocale: function () {
        return this.locale;
    },

    /**
     * 格式化数字
     * @param {number} number - 数字
     * @param {Object} options - 选项
     * @returns {string} 格式化后的数字
     */
    formatNumber: function (number, options) {
        try {
            if (options) {
                const formatter = new Intl.NumberFormat(this.locale, options);
                return formatter.format(number);
            }
            return this.formatters.number.format(number);
        } catch (error) {
            console.error('格式化数字失败:', error);
            return number.toString();
        }
    },

    /**
     * 格式化货币
     * @param {number} amount - 金额
     * @param {string} currency - 货币代码
     * @returns {string} 格式化后的货币
     */
    formatCurrency: function (amount, currency) {
        try {
            if (currency) {
                const formatter = new Intl.NumberFormat(this.locale, {
                    style: 'currency',
                    currency: currency
                });
                return formatter.format(amount);
            }
            return this.formatters.currency.format(amount);
        } catch (error) {
            console.error('格式化货币失败:', error);
            return amount.toString();
        }
    },

    /**
     * 格式化百分比
     * @param {number} value - 值
     * @returns {string} 格式化后的百分比
     */
    formatPercent: function (value) {
        try {
            return this.formatters.percent.format(value);
        } catch (error) {
            console.error('格式化百分比失败:', error);
            return (value * 100).toString() + '%';
        }
    },

    /**
     * 格式化日期
     * @param {Date} date - 日期
     * @param {Object} options - 选项
     * @returns {string} 格式化后的日期
     */
    formatDate: function (date, options) {
        try {
            if (options) {
                const formatter = new Intl.DateTimeFormat(this.locale, options);
                return formatter.format(date);
            }
            return this.formatters.date.format(date);
        } catch (error) {
            console.error('格式化日期失败:', error);
            return date.toString();
        }
    },

    /**
     * 格式化时间
     * @param {Date} date - 日期
     * @returns {string} 格式化后的时间
     */
    formatTime: function (date) {
        try {
            return this.formatters.time.format(date);
        } catch (error) {
            console.error('格式化时间失败:', error);
            return date.toString();
        }
    },

    /**
     * 格式化日期时间
     * @param {Date} date - 日期
     * @returns {string} 格式化后的日期时间
     */
    formatDateTime: function (date) {
        try {
            return this.formatters.dateTime.format(date);
        } catch (error) {
            console.error('格式化日期时间失败:', error);
            return date.toString();
        }
    },

    /**
     * 格式化持续时间
     * @param {number} seconds - 秒数
     * @returns {string} 格式化后的持续时间
     */
    formatDuration: function (seconds) {
        // 优化：检查缓存
        const cacheKey = `duration-${seconds}`;
        if (this.localeCache[cacheKey]) {
            return this.localeCache[cacheKey];
        }

        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);

        let result = '';

        if (hours > 0) {
            result += `${hours}小时`;
        }

        if (minutes > 0) {
            result += `${minutes}分钟`;
        }

        if (secs > 0 || result === '') {
            result += `${secs}秒`;
        }

        // 优化：保存到缓存
        this.localeCache[cacheKey] = result;

        return result;
    },

    /**
     * 格式化文件大小
     * @param {number} bytes - 字节数
     * @returns {string} 格式化后的文件大小
     */
    formatFileSize: function (bytes) {
        // 优化：检查缓存
        const cacheKey = `filesize-${bytes}`;
        if (this.localeCache[cacheKey]) {
            return this.localeCache[cacheKey];
        }

        const units = ['B', 'KB', 'MB', 'GB', 'TB'];
        const threshold = 1024;

        let unitIndex = 0;
        let size = bytes;

        while (size >= threshold && unitIndex < units.length - 1) {
            size /= threshold;
            unitIndex++;
        }

        const result = this.formatNumber(size, {
            maximumFractionDigits: 2
        }) + ' ' + units[unitIndex];

        // 优化：保存到缓存
        this.localeCache[cacheKey] = result;

        return result;
    },

    /**
     * 格式化相对时间
     * @param {Date} date - 日期
     * @returns {string} 格式化后的相对时间
     */
    formatRelativeTime: function (date) {
        // 优化：检查缓存
        const cacheKey = `relative-${date.getTime()}`;
        if (this.localeCache[cacheKey]) {
            return this.localeCache[cacheKey];
        }

        const now = new Date();
        const diff = now.getTime() - date.getTime();
        const seconds = Math.abs(diff) / 1000;

        let result = '';

        if (seconds < 60) {
            result = '刚刚';
        } else if (seconds < 3600) {
            const minutes = Math.floor(seconds / 60);
            result = diff > 0 ? `${minutes}分钟前` : `${minutes}分钟后`;
        } else if (seconds < 86400) {
            const hours = Math.floor(seconds / 3600);
            result = diff > 0 ? `${hours}小时前` : `${hours}小时后`;
        } else if (seconds < 2592000) {
            const days = Math.floor(seconds / 86400);
            result = diff > 0 ? `${days}天前` : `${days}天后`;
        } else {
            result = this.formatDate(date);
        }

        // 优化：保存到缓存
        this.localeCache[cacheKey] = result;

        return result;
    },

    /**
     * 清空本地化缓存
     */
    clearLocaleCache: function () {
        this.localeCache = {};
    },

    /**
     * 获取本地化统计信息
     * @returns {Object} 本地化统计信息
     */
    getLocalizationStats: function () {
        return {
            locale: this.locale,
            cacheSize: Object.keys(this.localeCache).length,
            formatterCount: Object.keys(this.formatters).length
        };
    }
};

// 优化：游戏主题性能优化
const GameThemeOptimizer = {
    currentTheme: 'default',
    themes: {},
    themeCache: {},

    /**
     * 初始化游戏主题
     */
    init: function () {
        this.loadThemes();
        this.detectTheme();
    },

    /**
     * 加载主题
     */
    loadThemes: function () {
        // 优化：加载默认主题
        this.themes['default'] = {
            backgroundColor: '#1a0f41',
            playerColor: '#ffffff',
            enemyColor: '#ff0000',
            platformColor: '#4a2c7a',
            propColor: '#ffff00',
            textColor: '#ffffff',
            uiColor: '#6a0dad',
            accentColor: '#00ffff',
            shadowColor: 'rgba(0, 0, 0, 0.5)',
            particleColor: '#ff00ff'
        };

        // 优化：加载暗色主题
        this.themes['dark'] = {
            backgroundColor: '#0a0a0a',
            playerColor: '#ffffff',
            enemyColor: '#ff4444',
            platformColor: '#333333',
            propColor: '#ffff00',
            textColor: '#ffffff',
            uiColor: '#444444',
            accentColor: '#00ffff',
            shadowColor: 'rgba(0, 0, 0, 0.8)',
            particleColor: '#ff00ff'
        };

        // 优化：加载亮色主题
        this.themes['light'] = {
            backgroundColor: '#f0f0f0',
            playerColor: '#000000',
            enemyColor: '#ff0000',
            platformColor: '#cccccc',
            propColor: '#ffaa00',
            textColor: '#000000',
            uiColor: '#e0e0e0',
            accentColor: '#0066ff',
            shadowColor: 'rgba(0, 0, 0, 0.2)',
            particleColor: '#ff00ff'
        };

        // 优化：加载高对比度主题
        this.themes['high-contrast'] = {
            backgroundColor: '#000000',
            playerColor: '#ffffff',
            enemyColor: '#ffff00',
            platformColor: '#ffffff',
            propColor: '#00ff00',
            textColor: '#ffffff',
            uiColor: '#ffffff',
            accentColor: '#ffffff',
            shadowColor: 'rgba(0, 0, 0, 0)',
            particleColor: '#ffffff'
        };

        // 优化：加载霓虹主题
        this.themes['neon'] = {
            backgroundColor: '#0a0a1a',
            playerColor: '#00ffff',
            enemyColor: '#ff00ff',
            platformColor: '#00ff00',
            propColor: '#ffff00',
            textColor: '#00ffff',
            uiColor: '#ff00ff',
            accentColor: '#00ffff',
            shadowColor: 'rgba(0, 255, 255, 0.5)',
            particleColor: '#ff00ff'
        };
    },

    /**
     * 检测主题
     */
    detectTheme: function () {
        // 优化：检测系统主题偏好
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            this.currentTheme = 'dark';
        }
    },

    /**
     * 设置主题
     * @param {string} themeName - 主题名称
     */
    setTheme: function (themeName) {
        if (!this.themes[themeName]) {
            console.warn(`主题 ${themeName} 不存在`);
            return;
        }

        this.currentTheme = themeName;
        this.applyTheme();

        // 优化：保存主题偏好
        localStorage.setItem('gameTheme', themeName);
    },

    /**
     * 获取当前主题
     * @returns {string} 当前主题名称
     */
    getCurrentTheme: function () {
        return this.currentTheme;
    },

    /**
     * 获取主题
     * @param {string} themeName - 主题名称
     * @returns {Object|null} 主题对象
     */
    getTheme: function (themeName) {
        return this.themes[themeName] || null;
    },

    /**
     * 应用主题
     */
    applyTheme: function () {
        const theme = this.themes[this.currentTheme];

        if (!theme) {
            return;
        }

        // 优化：应用主题到CSS变量
        const root = document.documentElement;

        root.style.setProperty('--theme-background', theme.backgroundColor);
        root.style.setProperty('--theme-player', theme.playerColor);
        root.style.setProperty('--theme-enemy', theme.enemyColor);
        root.style.setProperty('--theme-platform', theme.platformColor);
        root.style.setProperty('--theme-prop', theme.propColor);
        root.style.setProperty('--theme-text', theme.textColor);
        root.style.setProperty('--theme-ui', theme.uiColor);
        root.style.setProperty('--theme-accent', theme.accentColor);
        root.style.setProperty('--theme-shadow', theme.shadowColor);
        root.style.setProperty('--theme-particle', theme.particleColor);

        // 优化：应用主题到类名
        document.body.className = `theme-${this.currentTheme}`;
    },

    /**
     * 获取主题颜色
     * @param {string} colorName - 颜色名称
     * @returns {string} 颜色值
     */
    getThemeColor: function (colorName) {
        const theme = this.themes[this.currentTheme];

        if (theme && theme[colorName]) {
            return theme[colorName];
        }

        // 优化：使用默认主题作为后备
        const defaultTheme = this.themes['default'];
        if (defaultTheme && defaultTheme[colorName]) {
            return defaultTheme[colorName];
        }

        return '#ffffff';
    },

    /**
     * 获取所有主题名称
     * @returns {Array} 主题名称数组
     */
    getAllThemeNames: function () {
        return Object.keys(this.themes);
    },

    /**
     * 添加主题
     * @param {string} themeName - 主题名称
     * @param {Object} theme - 主题对象
     */
    addTheme: function (themeName, theme) {
        this.themes[themeName] = theme;
    },

    /**
     * 移除主题
     * @param {string} themeName - 主题名称
     */
    removeTheme: function (themeName) {
        if (themeName === 'default') {
            console.warn('不能删除默认主题');
            return;
        }

        delete this.themes[themeName];
    },

    /**
     * 清空主题缓存
     */
    clearThemeCache: function () {
        this.themeCache = {};
    },

    /**
     * 获取主题统计信息
     * @returns {Object} 主题统计信息
     */
    getThemeStats: function () {
        return {
            currentTheme: this.currentTheme,
            themeCount: Object.keys(this.themes).length,
            cacheSize: Object.keys(this.themeCache).length
        };
    },

    /**
     * 导出主题
     * @param {string} themeName - 主题名称
     * @returns {string} 导出的主题
     */
    exportTheme: function (themeName) {
        const theme = this.themes[themeName];

        if (!theme) {
            return null;
        }

        return JSON.stringify(theme);
    },

    /**
     * 导入主题
     * @param {string} themeName - 主题名称
     * @param {string} theme - 主题JSON
     */
    importTheme: function (themeName, theme) {
        try {
            const parsedTheme = JSON.parse(theme);
            this.addTheme(themeName, parsedTheme);
        } catch (error) {
            console.error('导入主题失败:', error);
        }
    },

    /**
     * 重置主题
     */
    resetTheme: function () {
        this.currentTheme = 'default';
        this.applyTheme();

        // 优化：清除主题偏好
        localStorage.removeItem('gameTheme');
    },

    /**
     * 加载保存的主题
     */
    loadSavedTheme: function () {
        const savedTheme = localStorage.getItem('gameTheme');

        if (savedTheme && this.themes[savedTheme]) {
            this.setTheme(savedTheme);
        }
    }
};

// 优化：游戏配置性能优化
const GameConfigOptimizer = {
    config: {},
    configSchema: {},
    configCache: {},
    configHistory: [],
    maxHistorySize: 100,

    /**
     * 初始化游戏配置
     */
    init: function () {
        this.loadDefaultConfig();
        this.loadConfigSchema();
        this.loadSavedConfig();
    },

    /**
     * 加载默认配置
     */
    loadDefaultConfig: function () {
        this.config = {
            // 优化：游戏设置
            game: {
                fps: 60,
                autoSave: true,
                autoSaveInterval: 30000,
                showFPS: false,
                showDebug: false
            },

            // 优化：显示设置
            display: {
                width: 800,
                height: 500,
                fullscreen: false,
                vsync: true,
                antialiasing: true
            },

            // 优化：音频设置
            audio: {
                masterVolume: 1.0,
                musicVolume: 0.7,
                sfxVolume: 0.8,
                mute: false
            },

            // 优化：控制设置
            controls: {
                keyboardEnabled: true,
                touchEnabled: true,
                mouseEnabled: true,
                gamepadEnabled: false
            },

            // 优化：性能设置
            performance: {
                quality: 'high',
                particles: true,
                shadows: true,
                postProcessing: false
            },

            // 优化：辅助功能设置
            accessibility: {
                highContrast: false,
                reducedMotion: false,
                largeText: false,
                screenReader: false
            },

            // 优化：语言设置
            language: {
                locale: 'zh-CN',
                language: 'zh'
            }
        };
    },

    /**
     * 加载配置架构
     */
    loadConfigSchema: function () {
        this.configSchema = {
            game: {
                fps: { type: 'number', min: 30, max: 120, default: 60 },
                autoSave: { type: 'boolean', default: true },
                autoSaveInterval: { type: 'number', min: 10000, max: 300000, default: 30000 },
                showFPS: { type: 'boolean', default: false },
                showDebug: { type: 'boolean', default: false }
            },

            display: {
                width: { type: 'number', min: 640, max: 1920, default: 800 },
                height: { type: 'number', min: 480, max: 1080, default: 500 },
                fullscreen: { type: 'boolean', default: false },
                vsync: { type: 'boolean', default: true },
                antialiasing: { type: 'boolean', default: true }
            },

            audio: {
                masterVolume: { type: 'number', min: 0, max: 1, default: 1.0 },
                musicVolume: { type: 'number', min: 0, max: 1, default: 0.7 },
                sfxVolume: { type: 'number', min: 0, max: 1, default: 0.8 },
                mute: { type: 'boolean', default: false }
            },

            controls: {
                keyboardEnabled: { type: 'boolean', default: true },
                touchEnabled: { type: 'boolean', default: true },
                mouseEnabled: { type: 'boolean', default: true },
                gamepadEnabled: { type: 'boolean', default: false }
            },

            performance: {
                quality: { type: 'enum', values: ['low', 'medium', 'high'], default: 'high' },
                particles: { type: 'boolean', default: true },
                shadows: { type: 'boolean', default: true },
                postProcessing: { type: 'boolean', default: false }
            },

            accessibility: {
                highContrast: { type: 'boolean', default: false },
                reducedMotion: { type: 'boolean', default: false },
                largeText: { type: 'boolean', default: false },
                screenReader: { type: 'boolean', default: false }
            },

            language: {
                locale: { type: 'string', default: 'zh-CN' },
                language: { type: 'enum', values: ['zh', 'en', 'ja', 'ko'], default: 'zh' }
            }
        };
    },

    /**
     * 加载保存的配置
     */
    loadSavedConfig: function () {
        try {
            const savedConfig = localStorage.getItem('gameConfig');
            if (savedConfig) {
                const parsedConfig = JSON.parse(savedConfig);
                this.mergeConfig(parsedConfig);
            }
        } catch (error) {
            console.error('加载配置失败:', error);
        }
    },

    /**
     * 获取配置
     * @param {string} path - 配置路径（使用点号分隔）
     * @returns {*} 配置值
     */
    getConfig: function (path) {
        // 优化：检查缓存
        const cacheKey = `config-${path}`;
        if (this.configCache[cacheKey]) {
            return this.configCache[cacheKey];
        }

        // 优化：获取配置值
        const keys = path.split('.');
        let value = this.config;

        for (let i = 0; i < keys.length; i++) {
            if (value && typeof value === 'object') {
                value = value[keys[i]];
            } else {
                value = undefined;
                break;
            }
        }

        // 优化：保存到缓存
        this.configCache[cacheKey] = value;

        return value;
    },

    /**
     * 设置配置
     * @param {string} path - 配置路径（使用点号分隔）
     * @param {*} value - 配置值
     */
    setConfig: function (path, value) {
        // 优化：验证配置值
        if (!this.validateConfig(path, value)) {
            console.warn(`配置值无效: ${path} = ${value}`);
            return false;
        }

        // 优化：保存配置历史
        this.saveConfigHistory(path, value);

        // 优化：设置配置值
        const keys = path.split('.');
        let obj = this.config;

        for (let i = 0; i < keys.length - 1; i++) {
            if (!obj[keys[i]]) {
                obj[keys[i]] = {};
            }
            obj = obj[keys[i]];
        }

        obj[keys[keys.length - 1]] = value;

        // 优化：清空缓存
        this.clearConfigCache();

        // 优化：保存配置
        this.saveConfig();

        return true;
    },

    /**
     * 验证配置
     * @param {string} path - 配置路径
     * @param {*} value - 配置值
     * @returns {boolean} 是否有效
     */
    validateConfig: function (path, value) {
        const keys = path.split('.');
        let schema = this.configSchema;

        for (let i = 0; i < keys.length; i++) {
            if (schema && schema[keys[i]]) {
                schema = schema[keys[i]];
            } else {
                return false;
            }
        }

        if (!schema) {
            return false;
        }

        // 优化：验证类型
        switch (schema.type) {
            case 'number':
                if (typeof value !== 'number') {
                    return false;
                }
                if (schema.min !== undefined && value < schema.min) {
                    return false;
                }
                if (schema.max !== undefined && value > schema.max) {
                    return false;
                }
                break;

            case 'boolean':
                if (typeof value !== 'boolean') {
                    return false;
                }
                break;

            case 'string':
                if (typeof value !== 'string') {
                    return false;
                }
                break;

            case 'enum':
                if (schema.values && schema.values.indexOf(value) === -1) {
                    return false;
                }
                break;
        }

        return true;
    },

    /**
     * 合并配置
     * @param {Object} config - 配置对象
     */
    mergeConfig: function (config) {
        // 优化：深度合并配置
        this.config = this.deepMerge(this.config, config);

        // 优化：清空缓存
        this.clearConfigCache();
    },

    /**
     * 深度合并
     * @param {Object} target - 目标对象
     * @param {Object} source - 源对象
     * @returns {Object} 合并后的对象
     */
    deepMerge: function (target, source) {
        const result = {};

        for (const key in target) {
            result[key] = target[key];
        }

        for (const key in source) {
            if (typeof target[key] === 'object' && typeof source[key] === 'object') {
                result[key] = this.deepMerge(target[key], source[key]);
            } else {
                result[key] = source[key];
            }
        }

        return result;
    },

    /**
     * 保存配置
     */
    saveConfig: function () {
        try {
            localStorage.setItem('gameConfig', JSON.stringify(this.config));
        } catch (error) {
            console.error('保存配置失败:', error);
        }
    },

    /**
     * 保存配置历史
     * @param {string} path - 配置路径
     * @param {*} value - 配置值
     */
    saveConfigHistory: function (path, value) {
        this.configHistory.push({
            path: path,
            value: value,
            timestamp: performance.now()
        });

        // 优化：限制历史记录大小
        if (this.configHistory.length > this.maxHistorySize) {
            this.configHistory.shift();
        }
    },

    /**
     * 获取配置历史
     * @returns {Array} 配置历史
     */
    getConfigHistory: function () {
        return this.configHistory;
    },

    /**
     * 清空配置历史
     */
    clearConfigHistory: function () {
        this.configHistory = [];
    },

    /**
     * 清空配置缓存
     */
    clearConfigCache: function () {
        this.configCache = {};
    },

    /**
     * 重置配置
     */
    resetConfig: function () {
        this.loadDefaultConfig();
        this.clearConfigCache();
        this.saveConfig();
    },

    /**
     * 导出配置
     * @returns {string} 导出的配置
     */
    exportConfig: function () {
        return JSON.stringify(this.config, null, 2);
    },

    /**
     * 导入配置
     * @param {string} config - 配置JSON
     */
    importConfig: function (config) {
        try {
            const parsedConfig = JSON.parse(config);
            this.mergeConfig(parsedConfig);
            this.saveConfig();
        } catch (error) {
            console.error('导入配置失败:', error);
        }
    },

    /**
     * 获取配置统计信息
     * @returns {Object} 配置统计信息
     */
    getConfigStats: function () {
        return {
            cacheSize: Object.keys(this.configCache).length,
            historySize: this.configHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏统计性能优化
const GameStatisticsOptimizer = {
    stats: {},
    statsHistory: [],
    maxHistorySize: 1000,
    statsCache: {},

    /**
     * 初始化游戏统计
     */
    init: function () {
        this.stats = {
            // 优化：游戏统计
            game: {
                totalPlayTime: 0,
                totalGames: 0,
                totalWins: 0,
                totalLosses: 0,
                winRate: 0,
                averagePlayTime: 0
            },

            // 优化：关卡统计
            level: {
                totalLevelsCompleted: 0,
                currentLevel: 1,
                highestLevel: 1,
                averageLevelTime: 0,
                fastestLevelTime: Infinity,
                slowestLevelTime: 0
            },

            // 优化：战斗统计
            combat: {
                totalEnemiesKilled: 0,
                totalDamageDealt: 0,
                totalDamageTaken: 0,
                totalCombos: 0,
                highestCombo: 0,
                averageCombo: 0,
                killDeathRatio: 0
            },

            // 优化：道具统计
            items: {
                totalItemsCollected: 0,
                healthPotionsCollected: 0,
                powerUpsCollected: 0,
                rareItemsCollected: 0,
                itemCollectionRate: 0
            },

            // 优化：性能统计
            performance: {
                averageFPS: 0,
                lowestFPS: Infinity,
                highestFPS: 0,
                frameDrops: 0,
                averageFrameTime: 0,
                memoryUsage: 0
            },

            // 优化：分数统计
            score: {
                totalScore: 0,
                highestScore: 0,
                lowestScore: 0,
                averageScore: 0,
                scoreDistribution: {}
            }
        };
    },

    /**
     * 记录游戏统计
     * @param {string} category - 分类
     * @param {string} metric - 指标
     * @param {*} value - 值
     */
    recordStat: function (category, metric, value) {
        // 优化：更新统计
        if (!this.stats[category]) {
            this.stats[category] = {};
        }

        this.stats[category][metric] = value;

        // 优化：保存统计历史
        this.saveStatsHistory(category, metric, value);

        // 优化：清空缓存
        this.clearStatsCache();
    },

    /**
     * 增加统计值
     * @param {string} category - 分类
     * @param {string} metric - 指标
     * @param {number} delta - 增量
     */
    incrementStat: function (category, metric, delta) {
        if (!this.stats[category]) {
            this.stats[category] = {};
        }

        if (this.stats[category][metric] === undefined) {
            this.stats[category][metric] = 0;
        }

        this.stats[category][metric] += delta;

        // 优化：保存统计历史
        this.saveStatsHistory(category, metric, this.stats[category][metric]);

        // 优化：清空缓存
        this.clearStatsCache();
    },

    /**
     * 获取统计
     * @param {string} category - 分类
     * @param {string} metric - 指标
     * @returns {*} 统计值
     */
    getStat: function (category, metric) {
        // 优化：检查缓存
        const cacheKey = `${category}-${metric}`;
        if (this.statsCache[cacheKey]) {
            return this.statsCache[cacheKey];
        }

        // 优化：获取统计值
        let value;

        if (category && metric) {
            value = this.stats[category] ? this.stats[category][metric] : undefined;
        } else if (category) {
            value = this.stats[category];
        } else {
            value = this.stats;
        }

        // 优化：保存到缓存
        this.statsCache[cacheKey] = value;

        return value;
    },

    /**
     * 获取所有统计
     * @returns {Object} 所有统计
     */
    getAllStats: function () {
        return this.stats;
    },

    /**
     * 保存统计历史
     * @param {string} category - 分类
     * @param {string} metric - 指标
     * @param {*} value - 值
     */
    saveStatsHistory: function (category, metric, value) {
        this.statsHistory.push({
            category: category,
            metric: metric,
            value: value,
            timestamp: performance.now()
        });

        // 优化：限制历史记录大小
        if (this.statsHistory.length > this.maxHistorySize) {
            this.statsHistory.shift();
        }
    },

    /**
     * 获取统计历史
     * @returns {Array} 统计历史
     */
    getStatsHistory: function () {
        return this.statsHistory;
    },

    /**
     * 获取统计历史（按分类）
     * @param {string} category - 分类
     * @returns {Array} 统计历史
     */
    getStatsHistoryByCategory: function (category) {
        return this.statsHistory.filter(item => item.category === category);
    },

    /**
     * 获取统计历史（按指标）
     * @param {string} metric - 指标
     * @returns {Array} 统计历史
     */
    getStatsHistoryByMetric: function (metric) {
        return this.statsHistory.filter(item => item.metric === metric);
    },

    /**
     * 清空统计历史
     */
    clearStatsHistory: function () {
        this.statsHistory = [];
    },

    /**
     * 清空统计缓存
     */
    clearStatsCache: function () {
        this.statsCache = {};
    },

    /**
     * 计算统计摘要
     * @returns {Object} 统计摘要
     */
    calculateStatsSummary: function () {
        const summary = {
            game: {
                winRate: this.calculateWinRate(),
                averagePlayTime: this.calculateAveragePlayTime()
            },

            level: {
                completionRate: this.calculateLevelCompletionRate(),
                averageLevelTime: this.calculateAverageLevelTime()
            },

            combat: {
                killDeathRatio: this.calculateKillDeathRatio(),
                averageCombo: this.calculateAverageCombo()
            },

            items: {
                itemCollectionRate: this.calculateItemCollectionRate()
            },

            performance: {
                averageFPS: this.calculateAverageFPS(),
                frameDropRate: this.calculateFrameDropRate()
            },

            score: {
                averageScore: this.calculateAverageScore(),
                scoreRange: this.calculateScoreRange()
            }
        };

        return summary;
    },

    /**
     * 计算胜率
     * @returns {number} 胜率
     */
    calculateWinRate: function () {
        const totalGames = this.stats.game.totalWins + this.stats.game.totalLosses;
        if (totalGames === 0) {
            return 0;
        }
        return (this.stats.game.totalWins / totalGames * 100).toFixed(2);
    },

    /**
     * 计算平均游戏时间
     * @returns {number} 平均游戏时间
     */
    calculateAveragePlayTime: function () {
        const totalGames = this.stats.game.totalGames;
        if (totalGames === 0) {
            return 0;
        }
        return (this.stats.game.totalPlayTime / totalGames / 1000).toFixed(2);
    },

    /**
     * 计算关卡完成率
     * @returns {number} 关卡完成率
     */
    calculateLevelCompletionRate: function () {
        // 优化：计算关卡完成率
        const totalLevels = this.stats.level.highestLevel;
        const completedLevels = this.stats.level.totalLevelsCompleted;

        if (totalLevels === 0) {
            return 0;
        }

        return (completedLevels / totalLevels * 100).toFixed(2);
    },

    /**
     * 计算平均关卡时间
     * @returns {number} 平均关卡时间
     */
    calculateAverageLevelTime: function () {
        // 优化：从历史记录中计算
        const levelHistory = this.getStatsHistoryByCategory('level');
        const levelTimes = levelHistory.filter(item => item.metric === 'averageLevelTime');

        if (levelTimes.length === 0) {
            return 0;
        }

        const totalTime = levelTimes.reduce((sum, item) => sum + item.value, 0);
        return (totalTime / levelTimes.length / 1000).toFixed(2);
    },

    /**
     * 计算击杀死亡比
     * @returns {number} 击杀死亡比
     */
    calculateKillDeathRatio: function () {
        const kills = this.stats.combat.totalEnemiesKilled;
        const deaths = this.stats.game.totalLosses;

        if (deaths === 0) {
            return kills > 0 ? kills.toFixed(2) : 0;
        }

        return (kills / deaths).toFixed(2);
    },

    /**
     * 计算平均连击
     * @returns {number} 平均连击
     */
    calculateAverageCombo: function () {
        const totalCombos = this.stats.combat.totalCombos;
        if (totalCombos === 0) {
            return 0;
        }
        return (this.stats.combat.highestCombo / totalCombos).toFixed(2);
    },

    /**
     * 计算道具收集率
     * @returns {number} 道具收集率
     */
    calculateItemCollectionRate: function () {
        // 优化：计算道具收集率
        const totalItems = this.stats.items.totalItemsCollected;
        const totalEnemies = this.stats.combat.totalEnemiesKilled;

        if (totalEnemies === 0) {
            return 0;
        }

        return (totalItems / totalEnemies * 100).toFixed(2);
    },

    /**
     * 计算平均FPS
     * @returns {number} 平均FPS
     */
    calculateAverageFPS: function () {
        return this.stats.performance.averageFPS.toFixed(2);
    },

    /**
     * 计算帧掉落率
     * @returns {number} 帧掉落率
     */
    calculateFrameDropRate: function () {
        const totalFrames = this.stats.game.totalPlayTime / 16.67; // 60 FPS
        const frameDrops = this.stats.performance.frameDrops;

        if (totalFrames === 0) {
            return 0;
        }

        return (frameDrops / totalFrames * 100).toFixed(2);
    },

    /**
     * 计算平均分数
     * @returns {number} 平均分数
     */
    calculateAverageScore: function () {
        const totalGames = this.stats.game.totalGames;
        if (totalGames === 0) {
            return 0;
        }
        return (this.stats.score.totalScore / totalGames).toFixed(2);
    },

    /**
     * 计算分数范围
     * @returns {Object} 分数范围
     */
    calculateScoreRange: function () {
        return {
            min: this.stats.score.lowestScore,
            max: this.stats.score.highestScore,
            range: this.stats.score.highestScore - this.stats.score.lowestScore
        };
    },

    /**
     * 导出统计
     * @returns {string} 导出的统计
     */
    exportStats: function () {
        return JSON.stringify({
            stats: this.stats,
            summary: this.calculateStatsSummary(),
            history: this.statsHistory
        }, null, 2);
    },

    /**
     * 导入统计
     * @param {string} stats - 统计JSON
     */
    importStats: function (stats) {
        try {
            const parsedStats = JSON.parse(stats);
            this.stats = parsedStats.stats || this.stats;
            this.statsHistory = parsedStats.history || [];
        } catch (error) {
            console.error('导入统计失败:', error);
        }
    },

    /**
     * 重置统计
     */
    resetStats: function () {
        this.init();
        this.clearStatsCache();
    },

    /**
     * 获取统计统计信息
     * @returns {Object} 统计统计信息
     */
    getStatisticsStats: function () {
        return {
            cacheSize: Object.keys(this.statsCache).length,
            historySize: this.statsHistory.length,
            maxHistorySize: this.maxHistorySize,
            categoryCount: Object.keys(this.stats).length
        };
    }
};

// 优化：游戏分析性能优化
const GameAnalyticsOptimizer = {
    analyticsData: {},
    analyticsCache: {},
    analyticsReports: {},

    /**
     * 初始化游戏分析
     */
    init: function () {
        this.analyticsData = {
            // 优化：玩家行为分析
            playerBehavior: {
                movementPatterns: [],
                attackPatterns: [],
                playStyle: 'balanced'
            },

            // 优化：游戏难度分析
            difficulty: {
                currentDifficulty: 1.0,
                recommendedDifficulty: 1.0,
                playerPerformance: [],
                difficultyAdjustments: []
            },

            // 优化：关卡分析
            level: {
                levelCompletionTimes: [],
                levelDeathCounts: [],
                levelRetries: [],
                levelSuccessRates: []
            },

            // 优化：敌人分析
            enemy: {
                enemyTypesEncountered: {},
                enemyDefeatRates: {},
                enemyDamageDealt: {},
                enemyKillStreaks: []
            },

            // 优化：道具分析
            item: {
                itemsCollected: {},
                itemUsageRates: {},
                itemEffectiveness: {},
                itemCombinations: []
            },

            // 优化：性能分析
            performance: {
                performanceMetrics: [],
                bottlenecks: [],
                optimizationSuggestions: []
            }
        };
    },

    /**
     * 记录分析数据
     * @param {string} category - 分类
     * @param {string} type - 类型
     * @param {*} data - 数据
     */
    recordAnalytics: function (category, type, data) {
        if (!this.analyticsData[category]) {
            this.analyticsData[category] = {};
        }

        if (!this.analyticsData[category][type]) {
            this.analyticsData[category][type] = [];
        }

        this.analyticsData[category][type].push({
            data: data,
            timestamp: performance.now()
        });

        // 优化：清空缓存
        this.clearAnalyticsCache();
    },

    /**
     * 获取分析数据
     * @param {string} category - 分类
     * @param {string} type - 类型
     * @returns {Array} 分析数据
     */
    getAnalytics: function (category, type) {
        // 优化：检查缓存
        const cacheKey = `${category}-${type}`;
        if (this.analyticsCache[cacheKey]) {
            return this.analyticsCache[cacheKey];
        }

        // 优化：获取分析数据
        let data;

        if (category && type) {
            data = this.analyticsData[category] ? this.analyticsData[category][type] : [];
        } else if (category) {
            data = this.analyticsData[category];
        } else {
            data = this.analyticsData;
        }

        // 优化：保存到缓存
        this.analyticsCache[cacheKey] = data;

        return data;
    },

    /**
     * 分析玩家行为
     * @returns {Object} 玩家行为分析结果
     */
    analyzePlayerBehavior: function () {
        const movementPatterns = this.analyticsData.playerBehavior.movementPatterns;
        const attackPatterns = this.analyticsData.playerBehavior.attackPatterns;

        // 优化：分析移动模式
        const movementAnalysis = this.analyzeMovementPatterns(movementPatterns);

        // 优化：分析攻击模式
        const attackAnalysis = this.analyzeAttackPatterns(attackPatterns);

        // 优化：确定游戏风格
        const playStyle = this.determinePlayStyle(movementAnalysis, attackAnalysis);

        return {
            movementAnalysis: movementAnalysis,
            attackAnalysis: attackAnalysis,
            playStyle: playStyle,
            recommendations: this.generateBehaviorRecommendations(playStyle)
        };
    },

    /**
     * 分析移动模式
     * @param {Array} patterns - 移动模式
     * @returns {Object} 移动分析结果
     */
    analyzeMovementPatterns: function (patterns) {
        if (!patterns || patterns.length === 0) {
            return { averageSpeed: 0, movementStyle: 'unknown' };
        }

        // 优化：计算平均移动速度
        const totalSpeed = patterns.reduce((sum, p) => sum + (p.speed || 0), 0);
        const averageSpeed = totalSpeed / patterns.length;

        // 优化：确定移动风格
        let movementStyle = 'balanced';
        if (averageSpeed > 5) {
            movementStyle = 'aggressive';
        } else if (averageSpeed < 2) {
            movementStyle = 'cautious';
        }

        return {
            averageSpeed: averageSpeed.toFixed(2),
            movementStyle: movementStyle,
            patternCount: patterns.length
        };
    },

    /**
     * 分析攻击模式
     * @param {Array} patterns - 攻击模式
     * @returns {Object} 攻击分析结果
     */
    analyzeAttackPatterns: function (patterns) {
        if (!patterns || patterns.length === 0) {
            return { averageAttackRate: 0, attackStyle: 'unknown' };
        }

        // 优化：计算平均攻击频率
        const totalAttacks = patterns.reduce((sum, p) => sum + (p.attackCount || 0), 0);
        const totalTime = patterns.reduce((sum, p) => sum + (p.duration || 0), 0);
        const averageAttackRate = totalTime > 0 ? (totalAttacks / totalTime * 1000).toFixed(2) : 0;

        // 优化：确定攻击风格
        let attackStyle = 'balanced';
        if (averageAttackRate > 2) {
            attackStyle = 'aggressive';
        } else if (averageAttackRate < 0.5) {
            attackStyle = 'cautious';
        }

        return {
            averageAttackRate: averageAttackRate,
            attackStyle: attackStyle,
            patternCount: patterns.length
        };
    },

    /**
     * 确定游戏风格
     * @param {Object} movementAnalysis - 移动分析
     * @param {Object} attackAnalysis - 攻击分析
     * @returns {string} 游戏风格
     */
    determinePlayStyle: function (movementAnalysis, attackAnalysis) {
        const movementStyle = movementAnalysis.movementStyle;
        const attackStyle = attackAnalysis.attackStyle;

        // 优化：确定游戏风格
        if (movementStyle === 'aggressive' && attackStyle === 'aggressive') {
            return 'aggressive';
        } else if (movementStyle === 'cautious' && attackStyle === 'cautious') {
            return 'defensive';
        } else if (movementStyle === 'aggressive' && attackStyle === 'cautious') {
            return 'kiting';
        } else if (movementStyle === 'cautious' && attackStyle === 'aggressive') {
            return 'tactical';
        } else {
            return 'balanced';
        }
    },

    /**
     * 生成行为建议
     * @param {string} playStyle - 游戏风格
     * @returns {Array} 建议列表
     */
    generateBehaviorRecommendations: function (playStyle) {
        const recommendations = [];

        switch (playStyle) {
            case 'aggressive':
                recommendations.push('建议注意防御，避免过度冒险');
                recommendations.push('建议合理利用道具增强生存能力');
                break;

            case 'defensive':
                recommendations.push('建议适当增加攻击频率');
                recommendations.push('建议主动寻找战斗机会提升效率');
                break;

            case 'kiting':
                recommendations.push('建议保持这种战术，非常有效');
                recommendations.push('建议注意敌人攻击范围');
                break;

            case 'tactical':
                recommendations.push('建议继续这种策略，非常平衡');
                recommendations.push('建议根据情况调整战术');
                break;

            case 'balanced':
            default:
                recommendations.push('建议继续保持这种平衡的玩法');
                recommendations.push('建议根据关卡特点调整策略');
                break;
        }

        return recommendations;
    },

    /**
     * 分析游戏难度
     * @returns {Object} 难度分析结果
     */
    analyzeDifficulty: function () {
        const playerPerformance = this.analyticsData.difficulty.playerPerformance;

        // 优化：计算玩家表现
        const performanceScore = this.calculatePerformanceScore(playerPerformance);

        // 优化：推荐难度
        const recommendedDifficulty = this.recommendDifficulty(performanceScore);

        return {
            currentDifficulty: this.analyticsData.difficulty.currentDifficulty,
            performanceScore: performanceScore,
            recommendedDifficulty: recommendedDifficulty,
            difficultyAdjustments: this.analyticsData.difficulty.difficultyAdjustments
        };
    },

    /**
     * 计算表现分数
     * @param {Array} performance - 表现数据
     * @returns {number} 表现分数
     */
    calculatePerformanceScore: function (performance) {
        if (!performance || performance.length === 0) {
            return 0.5;
        }

        // 优化：计算平均表现分数
        const totalScore = performance.reduce((sum, p) => sum + (p.score || 0), 0);
        return (totalScore / performance.length).toFixed(2);
    },

    /**
     * 推荐难度
     * @param {number} performanceScore - 表现分数
     * @returns {number} 推荐难度
     */
    recommendDifficulty: function (performanceScore) {
        // 优化：根据表现分数推荐难度
        if (performanceScore > 0.8) {
            return 1.5; // 困难
        } else if (performanceScore > 0.5) {
            return 1.0; // 中等
        } else {
            return 0.5; // 简单
        }
    },

    /**
     * 生成分析报告
     * @returns {Object} 分析报告
     */
    generateAnalyticsReport: function () {
        // 优化：生成综合分析报告
        const report = {
            timestamp: new Date().toISOString(),
            playerBehavior: this.analyzePlayerBehavior(),
            difficulty: this.analyzeDifficulty(),
            level: this.analyzeLevel(),
            enemy: this.analyzeEnemy(),
            item: this.analyzeItem(),
            performance: this.analyzePerformance(),
            summary: this.generateSummary()
        };

        // 优化：保存报告
        this.analyticsReports[report.timestamp] = report;

        return report;
    },

    /**
     * 分析关卡
     * @returns {Object} 关卡分析结果
     */
    analyzeLevel: function () {
        const completionTimes = this.analyticsData.level.levelCompletionTimes;
        const deathCounts = this.analyticsData.level.levelDeathCounts;

        // 优化：计算平均完成时间
        const averageCompletionTime = completionTimes.length > 0
            ? (completionTimes.reduce((sum, t) => sum + t, 0) / completionTimes.length / 1000).toFixed(2)
            : 0;

        // 优化：计算平均死亡次数
        const averageDeathCount = deathCounts.length > 0
            ? (deathCounts.reduce((sum, d) => sum + d, 0) / deathCounts.length).toFixed(2)
            : 0;

        return {
            averageCompletionTime: averageCompletionTime,
            averageDeathCount: averageDeathCount,
            totalLevels: completionTimes.length
        };
    },

    /**
     * 分析敌人
     * @returns {Object} 敌人分析结果
     */
    analyzeEnemy: function () {
        const enemyTypes = this.analyticsData.enemy.enemyTypesEncountered;

        // 优化：统计敌人类型
        const typeCounts = {};
        for (const type in enemyTypes) {
            typeCounts[type] = enemyTypes[type].length;
        }

        return {
            enemyTypes: typeCounts,
            totalEnemies: Object.values(typeCounts).reduce((sum, count) => sum + count, 0)
        };
    },

    /**
     * 分析道具
     * @returns {Object} 道具分析结果
     */
    analyzeItem: function () {
        const itemsCollected = this.analyticsData.item.itemsCollected;

        // 优化：统计道具类型
        const itemCounts = {};
        for (const type in itemsCollected) {
            itemCounts[type] = itemsCollected[type].length;
        }

        return {
            itemTypes: itemCounts,
            totalItems: Object.values(itemCounts).reduce((sum, count) => sum + count, 0)
        };
    },

    /**
     * 分析性能
     * @returns {Object} 性能分析结果
     */
    analyzePerformance: function () {
        const metrics = this.analyticsData.performance.performanceMetrics;

        // 优化：计算平均性能指标
        const averageFPS = metrics.length > 0
            ? (metrics.reduce((sum, m) => sum + (m.fps || 0), 0) / metrics.length).toFixed(2)
            : 0;

        const averageFrameTime = metrics.length > 0
            ? (metrics.reduce((sum, m) => sum + (m.frameTime || 0), 0) / metrics.length).toFixed(2)
            : 0;

        return {
            averageFPS: averageFPS,
            averageFrameTime: averageFrameTime,
            totalMetrics: metrics.length
        };
    },

    /**
     * 生成摘要
     * @returns {Object} 摘要
     */
    generateSummary: function () {
        return {
            totalAnalytics: this.countTotalAnalytics(),
            categories: Object.keys(this.analyticsData),
            reports: Object.keys(this.analyticsReports).length
        };
    },

    /**
     * 统计总分析数据
     * @returns {number} 总数
     */
    countTotalAnalytics: function () {
        let count = 0;

        for (const category in this.analyticsData) {
            for (const type in this.analyticsData[category]) {
                count += this.analyticsData[category][type].length;
            }
        }

        return count;
    },

    /**
     * 清空分析缓存
     */
    clearAnalyticsCache: function () {
        this.analyticsCache = {};
    },

    /**
     * 导出分析报告
     * @param {string} timestamp - 时间戳（可选）
     * @returns {string} 导出的报告
     */
    exportAnalyticsReport: function (timestamp) {
        const report = timestamp ? this.analyticsReports[timestamp] : this.generateAnalyticsReport();
        return JSON.stringify(report, null, 2);
    },

    /**
     * 重置分析数据
     */
    resetAnalytics: function () {
        this.init();
        this.clearAnalyticsCache();
    }
};

// 优化：游戏报告性能优化
const GameReportOptimizer = {
    reports: {},
    reportTemplates: {},
    reportCache: {},

    /**
     * 初始化游戏报告
     */
    init: function () {
        this.loadReportTemplates();
    },

    /**
     * 加载报告模板
     */
    loadReportTemplates: function () {
        // 优化：加载游戏报告模板
        this.reportTemplates['game'] = {
            title: '游戏报告',
            sections: [
                'summary',
                'performance',
                'statistics',
                'achievements',
                'recommendations'
            ]
        };

        // 优化：加载性能报告模板
        this.reportTemplates['performance'] = {
            title: '性能报告',
            sections: [
                'fps',
                'memory',
                'rendering',
                'physics',
                'ai'
            ]
        };

        // 优化：加载统计报告模板
        this.reportTemplates['statistics'] = {
            title: '统计报告',
            sections: [
                'game',
                'level',
                'combat',
                'items',
                'score'
            ]
        };
    },

    /**
     * 生成报告
     * @param {string} reportType - 报告类型
     * @param {Object} data - 报告数据
     * @returns {Object} 报告对象
     */
    generateReport: function (reportType, data) {
        // 优化：检查缓存
        const cacheKey = `${reportType}-${JSON.stringify(data)}`;
        if (this.reportCache[cacheKey]) {
            return this.reportCache[cacheKey];
        }

        // 优化：获取报告模板
        const template = this.reportTemplates[reportType];

        if (!template) {
            console.warn(`报告类型 ${reportType} 不存在`);
            return null;
        }

        // 优化：生成报告
        const report = {
            type: reportType,
            title: template.title,
            timestamp: new Date().toISOString(),
            sections: this.generateReportSections(template.sections, data)
        };

        // 优化：保存报告
        this.reports[report.timestamp] = report;

        // 优化：保存到缓存
        this.reportCache[cacheKey] = report;

        return report;
    },

    /**
     * 生成报告章节
     * @param {Array} sections - 章节列表
     * @param {Object} data - 报告数据
     * @returns {Array} 章节数组
     */
    generateReportSections: function (sections, data) {
        const reportSections = [];

        for (let i = 0; i < sections.length; i++) {
            const sectionName = sections[i];
            const section = this.generateReportSection(sectionName, data);

            if (section) {
                reportSections.push(section);
            }
        }

        return reportSections;
    },

    /**
     * 生成报告章节
     * @param {string} sectionName - 章节名称
     * @param {Object} data - 报告数据
     * @returns {Object|null} 章节对象
     */
    generateReportSection: function (sectionName, data) {
        switch (sectionName) {
            case 'summary':
                return {
                    name: '摘要',
                    content: this.generateSummarySection(data)
                };

            case 'performance':
                return {
                    name: '性能',
                    content: this.generatePerformanceSection(data)
                };

            case 'statistics':
                return {
                    name: '统计',
                    content: this.generateStatisticsSection(data)
                };

            case 'achievements':
                return {
                    name: '成就',
                    content: this.generateAchievementsSection(data)
                };

            case 'recommendations':
                return {
                    name: '建议',
                    content: this.generateRecommendationsSection(data)
                };

            case 'fps':
                return {
                    name: 'FPS',
                    content: this.generateFPSSection(data)
                };

            case 'memory':
                return {
                    name: '内存',
                    content: this.generateMemorySection(data)
                };

            case 'rendering':
                return {
                    name: '渲染',
                    content: this.generateRenderingSection(data)
                };

            case 'physics':
                return {
                    name: '物理',
                    content: this.generatePhysicsSection(data)
                };

            case 'ai':
                return {
                    name: 'AI',
                    content: this.generateAISection(data)
                };

            case 'game':
                return {
                    name: '游戏',
                    content: this.generateGameSection(data)
                };

            case 'level':
                return {
                    name: '关卡',
                    content: this.generateLevelSection(data)
                };

            case 'combat':
                return {
                    name: '战斗',
                    content: this.generateCombatSection(data)
                };

            case 'items':
                return {
                    name: '道具',
                    content: this.generateItemsSection(data)
                };

            case 'score':
                return {
                    name: '分数',
                    content: this.generateScoreSection(data)
                };

            default:
                return null;
        }
    },

    /**
     * 生成摘要章节
     * @param {Object} data - 报告数据
     * @returns {Object} 章节内容
     */
    generateSummarySection: function (data) {
        return {
            totalPlayTime: data.totalPlayTime || 0,
            totalGames: data.totalGames || 0,
            averageScore: data.averageScore || 0,
            highestScore: data.highestScore || 0,
            winRate: data.winRate || 0
        };
    },

    /**
     * 生成性能章节
     * @param {Object} data - 报告数据
     * @returns {Object} 章节内容
     */
    generatePerformanceSection: function (data) {
        return {
            averageFPS: data.averageFPS || 0,
            lowestFPS: data.lowestFPS || 0,
            highestFPS: data.highestFPS || 0,
            frameDrops: data.frameDrops || 0,
            averageFrameTime: data.averageFrameTime || 0,
            memoryUsage: data.memoryUsage || 0
        };
    },

    /**
     * 生成统计章节
     * @param {Object} data - 报告数据
     * @returns {Object} 章节内容
     */
    generateStatisticsSection: function (data) {
        return {
            totalEnemiesKilled: data.totalEnemiesKilled || 0,
            totalItemsCollected: data.totalItemsCollected || 0,
            totalCombos: data.totalCombos || 0,
            highestCombo: data.highestCombo || 0,
            averageCombo: data.averageCombo || 0
        };
    },

    /**
     * 生成成就章节
     * @param {Object} data - 报告数据
     * @returns {Object} 章节内容
     */
    generateAchievementsSection: function (data) {
        return {
            totalAchievements: data.totalAchievements || 0,
            unlockedAchievements: data.unlockedAchievements || [],
            lockedAchievements: data.lockedAchievements || []
        };
    },

    /**
     * 生成建议章节
     * @param {Object} data - 报告数据
     * @returns {Object} 章节内容
     */
    generateRecommendationsSection: function (data) {
        return {
            performance: data.performanceRecommendations || [],
            gameplay: data.gameplayRecommendations || [],
            optimization: data.optimizationRecommendations || []
        };
    },

    /**
     * 生成FPS章节
     * @param {Object} data - 报告数据
     * @returns {Object} 章节内容
     */
    generateFPSSection: function (data) {
        return {
            averageFPS: data.averageFPS || 0,
            fpsHistory: data.fpsHistory || [],
            frameDropCount: data.frameDropCount || 0
        };
    },

    /**
     * 生成内存章节
     * @param {Object} data - 报告数据
     * @returns {Object} 章节内容
     */
    generateMemorySection: function (data) {
        return {
            currentUsage: data.currentMemoryUsage || 0,
            peakUsage: data.peakMemoryUsage || 0,
            averageUsage: data.averageMemoryUsage || 0,
            memoryLeaks: data.memoryLeaks || []
        };
    },

    /**
     * 生成渲染章节
     * @param {Object} data - 报告数据
     * @returns {Object} 章节内容
     */
    generateRenderingSection: function (data) {
        return {
            drawCalls: data.drawCalls || 0,
            averageDrawTime: data.averageDrawTime || 0,
            renderOptimizations: data.renderOptimizations || []
        };
    },

    /**
     * 生成物理章节
     * @param {Object} data - 报告数据
     * @returns {Object} 章节内容
     */
    generatePhysicsSection: function (data) {
        return {
            physicsObjects: data.physicsObjects || 0,
            collisionChecks: data.collisionChecks || 0,
            averagePhysicsTime: data.averagePhysicsTime || 0,
            physicsOptimizations: data.physicsOptimizations || []
        };
    },

    /**
     * 生成AI章节
     * @param {Object} data - 报告数据
     */
    generateAISection: function (data) {
        return {
            aiAgents: data.aiAgents || 0,
            averageDecisionTime: data.averageDecisionTime || 0,
            aiOptimizations: data.aiOptimizations || []
        };
    },

    /**
     * 生成游戏章节
     * @param {Object} data - 报告数据
     * @returns {Object} 章节内容
     */
    generateGameSection: function (data) {
        return {
            totalPlayTime: data.totalPlayTime || 0,
            totalGames: data.totalGames || 0,
            totalWins: data.totalWins || 0,
            totalLosses: data.totalLosses || 0
        };
    },

    /**
     * 生成关卡章节
     * @param {Object} data - 报告数据
     * @returns {Object} 章节内容
     */
    generateLevelSection: function (data) {
        return {
            totalLevels: data.totalLevels || 0,
            completedLevels: data.completedLevels || 0,
            averageLevelTime: data.averageLevelTime || 0,
            currentLevel: data.currentLevel || 1
        };
    },

    /**
     * 生成战斗章节
     * @param {Object} data - 报告数据
     * @returns {Object} 章节内容
     */
    generateCombatSection: function (data) {
        return {
            totalEnemiesKilled: data.totalEnemiesKilled || 0,
            totalDamageDealt: data.totalDamageDealt || 0,
            totalDamageTaken: data.totalDamageTaken || 0,
            killDeathRatio: data.killDeathRatio || 0
        };
    },

    /**
     * 生成道具章节
     * @param {Object} data - 报告数据
     * @returns {Object} 章节内容
     */
    generateItemsSection: function (data) {
        return {
            totalItemsCollected: data.totalItemsCollected || 0,
            healthPotions: data.healthPotions || 0,
            powerUps: data.powerUps || 0,
            rareItems: data.rareItems || 0
        };
    },

    /**
     * 生成分数章节
     * @param {Object} data - 报告数据
     * @returns {Object} 章节内容
     */
    generateScoreSection: function (data) {
        return {
            totalScore: data.totalScore || 0,
            highestScore: data.highestScore || 0,
            lowestScore: data.lowestScore || 0,
            averageScore: data.averageScore || 0
        };
    },

    /**
     * 获取报告
     * @param {string} timestamp - 时间戳
     * @returns {Object|null} 报告对象
     */
    getReport: function (timestamp) {
        return this.reports[timestamp] || null;
    },

    /**
     * 获取所有报告
     * @returns {Array} 报告数组
     */
    getAllReports: function () {
        return Object.values(this.reports);
    },

    /**
     * 清空报告缓存
     */
    clearReportCache: function () {
        this.reportCache = {};
    },

    /**
     * 导出报告
     * @param {string} timestamp - 时间戳
     * @param {string} format - 格式（json, html, csv）
     * @returns {string} 导出的报告
     */
    exportReport: function (timestamp, format) {
        const report = this.getReport(timestamp);

        if (!report) {
            return null;
        }

        switch (format) {
            case 'json':
                return JSON.stringify(report, null, 2);

            case 'html':
                return this.generateHTMLReport(report);

            case 'csv':
                return this.generateCSVReport(report);

            default:
                return JSON.stringify(report, null, 2);
        }
    },

    /**
     * 生成HTML报告
     * @param {Object} report - 报告对象
     * @returns {string} HTML报告
     */
    generateHTMLReport: function (report) {
        let html = `<!DOCTYPE html>
<html>
<head>
    <title>${report.title}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1 { color: #6a0dad; }
        h2 { color: #4a2c7a; margin-top: 30px; }
        .section { margin-bottom: 20px; }
        .timestamp { color: #666; }
    </style>
</head>
<body>
    <h1>${report.title}</h1>
    <p class="timestamp">生成时间: ${report.timestamp}</p>
`;

        for (let i = 0; i < report.sections.length; i++) {
            const section = report.sections[i];
            html += `    <h2>${section.name}</h2>\n`;
            html += `    <div class="section">\n`;
            html += `        <pre>${JSON.stringify(section.content, null, 2)}</pre>\n`;
            html += `    </div>\n`;
        }

        html += `</body>
</html>`;

        return html;
    },

    /**
     * 生成CSV报告
     * @param {Object} report - 报告对象
     * @returns {string} CSV报告
     */
    generateCSVReport: function (report) {
        let csv = `章节,数据\n`;

        for (let i = 0; i < report.sections.length; i++) {
            const section = report.sections[i];
            const content = JSON.stringify(section.content);
            csv += `${section.name},"${content.replace(/"/g, '""')}"\n`;
        }

        return csv;
    },

    /**
     * 添加报告模板
     * @param {string} templateName - 模板名称
     * @param {Object} template - 模板对象
     */
    addReportTemplate: function (templateName, template) {
        this.reportTemplates[templateName] = template;
    },

    /**
     * 移除报告模板
     * @param {string} templateName - 模板名称
     */
    removeReportTemplate: function (templateName) {
        delete this.reportTemplates[templateName];
    },

    /**
     * 重置报告
     */
    resetReports: function () {
        this.reports = {};
        this.clearReportCache();
    }
};

// 优化：游戏调试性能优化
const GameDebugOptimizer = {
    debugMode: false,
    debugCommands: {},
    debugWatchList: [],
    debugHistory: [],
    maxHistorySize: 1000,
    debugCache: {},
    debugPanel: null,

    /**
     * 初始化游戏调试
     */
    init: function () {
        this.loadDebugCommands();
        this.setupDebugPanel();
    },

    /**
     * 加载调试命令
     */
    loadDebugCommands: function () {
        // 优化：加载调试命令
        this.debugCommands = {
            'help': {
                description: '显示帮助信息',
                callback: () => this.showHelp()
            },

            'fps': {
                description: '显示FPS信息',
                callback: () => this.showFPS()
            },

            'memory': {
                description: '显示内存使用情况',
                callback: () => this.showMemory()
            },

            'state': {
                description: '显示游戏状态',
                callback: () => this.showState()
            },

            'clear': {
                description: '清空调试历史',
                callback: () => this.clearHistory()
            },

            'watch': {
                description: '监视变量',
                callback: (args) => this.watchVariable(args)
            },

            'unwatch': {
                description: '取消监视变量',
                callback: (args) => this.unwatchVariable(args)
            },

            'log': {
                description: '记录调试日志',
                callback: (args) => this.logDebug(args)
            },

            'reset': {
                description: '重置游戏',
                callback: () => this.resetGame()
            },

            'pause': {
                description: '暂停游戏',
                callback: () => this.pauseGame()
            },

            'resume': {
                description: '继续游戏',
                callback: () => this.resumeGame()
            }
        };
    },

    /**
     * 设置调试面板
     */
    setupDebugPanel: function () {
        // 优化：创建调试面板
        if (!this.debugPanel) {
            this.debugPanel = document.createElement('div');
            this.debugPanel.id = 'debug-panel';
            this.debugPanel.style.cssText = `
                position: fixed;
                top: 10px;
                right: 10px;
                width: 300px;
                max-height: 400px;
                background: rgba(0, 0, 0, 0.8);
                color: #00ff00;
                font-family: monospace;
                font-size: 12px;
                padding: 10px;
                border-radius: 5px;
                overflow-y: auto;
                z-index: 10000;
                display: none;
            `;

            document.body.appendChild(this.debugPanel);
        }
    },

    /**
     * 设置调试模式
     * @param {boolean} enabled - 是否启用
     */
    setDebugMode: function (enabled) {
        this.debugMode = enabled;

        // 优化：显示/隐藏调试面板
        if (this.debugPanel) {
            this.debugPanel.style.display = enabled ? 'block' : 'none';
        }
    },

    /**
     * 执行调试命令
     * @param {string} command - 命令
     * @param {Array} args - 参数
     * @returns {*} 执行结果
     */
    executeCommand: function (command, args) {
        // 优化：检查命令是否存在
        if (!this.debugCommands[command]) {
            this.logDebug(`未知命令: ${command}`);
            return null;
        }

        // 优化：执行命令
        const result = this.debugCommands[command].callback(args);

        // 优化：记录调试历史
        this.saveDebugHistory({
            command: command,
            args: args,
            result: result,
            timestamp: performance.now()
        });

        return result;
    },

    /**
     * 显示帮助信息
     */
    showHelp: function () {
        let help = '可用命令:\n';

        for (const cmd in this.debugCommands) {
            help += `  ${cmd} - ${this.debugCommands[cmd].description}\n`;
        }

        this.logDebug(help);

        return help;
    },

    /**
     * 显示FPS信息
     */
    showFPS: function () {
        const fpsInfo = {
            currentFPS: state.avgFPS || 0,
            targetFPS: 60,
            frameTime: perfMetrics.avgFrameTime || 0,
            frameDrops: perfMetrics.frameDrops || 0
        };

        this.logDebug(`FPS信息: ${JSON.stringify(fpsInfo)}`);

        return fpsInfo;
    },

    /**
     * 显示内存使用情况
     */
    showMemory: function () {
        const memoryInfo = {
            used: performance.memory ? (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2) + ' MB' : 'N/A',
            total: performance.memory ? (performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2) + ' MB' : 'N/A',
            limit: performance.memory ? (performance.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2) + ' MB' : 'N/A'
        };

        this.logDebug(`内存信息: ${JSON.stringify(memoryInfo)}`);

        return memoryInfo;
    },

    /**
     * 显示游戏状态
     */
    showState: function () {
        const stateInfo = {
            gameState: state.gameState,
            score: state.score,
            currentLevel: state.currentLevel,
            difficulty: state.difficulty,
            playerHealth: state.player ? state.player.health : 0,
            enemyCount: state.enemies ? state.enemies.length : 0,
            propCount: state.props ? state.props.length : 0
        };

        this.logDebug(`游戏状态: ${JSON.stringify(stateInfo)}`);

        return stateInfo;
    },

    /**
     * 清空调试历史
     */
    clearHistory: function () {
        this.debugHistory = [];
        this.logDebug('调试历史已清空');
    },

    /**
     * 监视变量
     * @param {Array} args - 参数
     */
    watchVariable: function (args) {
        if (!args || args.length === 0) {
            this.logDebug('用法: watch <变量路径>');
            return;
        }

        const variablePath = args[0];
        this.debugWatchList.push(variablePath);

        this.logDebug(`开始监视: ${variablePath}`);
    },

    /**
     * 取消监视变量
     * @param {Array} args - 参数
     */
    unwatchVariable: function (args) {
        if (!args || args.length === 0) {
            this.logDebug('用法: unwatch <变量路径>');
            return;
        }

        const variablePath = args[0];
        const index = this.debugWatchList.indexOf(variablePath);

        if (index !== -1) {
            this.debugWatchList.splice(index, 1);
            this.logDebug(`停止监视: ${variablePath}`);
        }
    },

    /**
     * 记录调试日志
     * @param {Array} args - 参数
     */
    logDebug: function (args) {
        const message = Array.isArray(args) ? args.join(' ') : args;

        // 优化：添加时间戳
        const timestamp = new Date().toISOString();
        const logMessage = `[${timestamp}] ${message}`;

        // 优化：输出到调试面板
        if (this.debugPanel) {
            const logElement = document.createElement('div');
            logElement.textContent = logMessage;
            this.debugPanel.appendChild(logElement);

            // 优化：自动滚动到底部
            this.debugPanel.scrollTop = this.debugPanel.scrollHeight;
        }

        // 优化：输出到控制台
        console.log(logMessage);
    },

    /**
     * 重置游戏
     */
    resetGame: function () {
        // 优化：重置游戏状态
        if (typeof StickmanAdventure.resetGame === 'function') {
            StickmanAdventure.resetGame();
        }

        this.logDebug('游戏已重置');
    },

    /**
     * 暂停游戏
     */
    pauseGame: function () {
        // 优化：暂停游戏
        if (typeof StickmanAdventure.pauseGame === 'function') {
            StickmanAdventure.pauseGame();
        }

        this.logDebug('游戏已暂停');
    },

    /**
     * 继续游戏
     */
    resumeGame: function () {
        // 优化：继续游戏
        if (typeof StickmanAdventure.resumeGame === 'function') {
            StickmanAdventure.resumeGame();
        }

        this.logDebug('游戏已继续');
    },

    /**
     * 保存调试历史
     * @param {Object} history - 历史记录
     */
    saveDebugHistory: function (history) {
        this.debugHistory.push(history);

        // 优化：限制历史记录大小
        if (this.debugHistory.length > this.maxHistorySize) {
            this.debugHistory.shift();
        }
    },

    /**
     * 获取调试历史
     * @returns {Array} 调试历史
     */
    getDebugHistory: function () {
        return this.debugHistory;
    },

    /**
     * 更新监视变量
     */
    updateWatchList: function () {
        // 优化：更新所有监视的变量
        for (let i = 0; i < this.debugWatchList.length; i++) {
            const variablePath = this.debugWatchList[i];
            const value = this.getVariableValue(variablePath);

            this.logDebug(`${variablePath} = ${JSON.stringify(value)}`);
        }
    },

    /**
     * 获取变量值
     * @param {string} path - 变量路径
     * @returns {*} 变量值
     */
    getVariableValue: function (path) {
        const keys = path.split('.');
        let value = state;

        for (let i = 0; i < keys.length; i++) {
            if (value && typeof value === 'object') {
                value = value[keys[i]];
            } else {
                value = undefined;
                break;
            }
        }

        return value;
    },

    /**
     * 清空调试缓存
     */
    clearDebugCache: function () {
        this.debugCache = {};
    },

    /**
     * 添加调试命令
     * @param {string} command - 命令名称
     * @param {string} description - 描述
     * @param {Function} callback - 回调函数
     */
    addDebugCommand: function (command, description, callback) {
        this.debugCommands[command] = {
            description: description,
            callback: callback
        };
    },

    /**
     * 移除调试命令
     * @param {string} command - 命令名称
     */
    removeDebugCommand: function (command) {
        delete this.debugCommands[command];
    },

    /**
     * 获取调试统计信息
     * @returns {Object} 调试统计信息
     */
    getDebugStats: function () {
        return {
            debugMode: this.debugMode,
            commandCount: Object.keys(this.debugCommands).length,
            watchListCount: this.debugWatchList.length,
            historySize: this.debugHistory.length,
            maxHistorySize: this.maxHistorySize,
            cacheSize: Object.keys(this.debugCache).length
        };
    }
};

// 优化：游戏日志性能优化
const GameLoggerOptimizer = {
    logLevel: 'info',
    logLevels: ['debug', 'info', 'warn', 'error', 'fatal'],
    logHistory: [],
    maxHistorySize: 10000,
    logCache: {},
    logFilters: [],
    logAppenders: [],
    logCategories: {},

    /**
     * 初始化游戏日志
     */
    init: function () {
        this.setupLogAppenders();
        this.loadLogFilters();
    },

    /**
     * 设置日志输出器
     */
    setupLogAppenders: function () {
        // 优化：添加控制台输出器
        this.logAppenders.push({
            type: 'console',
            callback: (logEntry) => {
                const message = `[${logEntry.timestamp}] [${logEntry.level.toUpperCase()}] [${logEntry.category}] ${logEntry.message}`;

                switch (logEntry.level) {
                    case 'debug':
                        console.debug(message, logEntry.data);
                        break;
                    case 'info':
                        console.info(message, logEntry.data);
                        break;
                    case 'warn':
                        console.warn(message, logEntry.data);
                        break;
                    case 'error':
                    case 'fatal':
                        console.error(message, logEntry.data);
                        break;
                    default:
                        console.log(message, logEntry.data);
                }
            }
        });

        // 优化：添加本地存储输出器
        this.logAppenders.push({
            type: 'localStorage',
            callback: (logEntry) => {
                try {
                    const logs = JSON.parse(localStorage.getItem('gameLogs') || '[]');
                    logs.push(logEntry);

                    // 优化：限制日志数量
                    if (logs.length > 1000) {
                        logs.shift();
                    }

                    localStorage.setItem('gameLogs', JSON.stringify(logs));
                } catch (error) {
                    console.error('保存日志到本地存储失败:', error);
                }
            }
        });
    },

    /**
     * 加载日志过滤器
     */
    loadLogFilters: function () {
        // 优化：从本地存储加载过滤器
        const filters = localStorage.getItem('logFilters');

        if (filters) {
            try {
                this.logFilters = JSON.parse(filters);
            } catch (error) {
                console.error('加载日志过滤器失败:', error);
            }
        }
    },

    /**
     * 保存日志过滤器
     */
    saveLogFilters: function () {
        localStorage.setItem('logFilters', JSON.stringify(this.logFilters));
    },

    /**
     * 设置日志级别
     * @param {string} level - 日志级别
     */
    setLogLevel: function (level) {
        if (this.logLevels.indexOf(level) !== -1) {
            this.logLevel = level;
        }
    },

    /**
     * 添加日志过滤器
     * @param {Object} filter - 过滤器对象
     */
    addLogFilter: function (filter) {
        this.logFilters.push(filter);
        this.saveLogFilters();
    },

    /**
     * 移除日志过滤器
     * @param {string} filterId - 过滤器ID
     */
    removeLogFilter: function (filterId) {
        this.logFilters = this.logFilters.filter(f => f.id !== filterId);
        this.saveLogFilters();
    },

    /**
     * 添加日志输出器
     * @param {Object} appender - 输出器对象
     */
    addLogAppender: function (appender) {
        this.logAppenders.push(appender);
    },

    /**
     * 移除日志输出器
     * @param {string} appenderType - 输出器类型
     */
    removeLogAppender: function (appenderType) {
        this.logAppenders = this.logAppenders.filter(a => a.type !== appenderType);
    },

    /**
     * 记录日志
     * @param {string} level - 日志级别
     * @param {string} category - 日志分类
     * @param {string} message - 日志消息
     * @param {*} data - 日志数据
     */
    log: function (level, category, message, data) {
        // 优化：检查日志级别
        if (this.logLevels.indexOf(level) < this.logLevels.indexOf(this.logLevel)) {
            return;
        }

        // 优化：检查过滤器
        if (!this.shouldLog(level, category, message)) {
            return;
        }

        // 优化：创建日志条目
        const logEntry = {
            timestamp: new Date().toISOString(),
            level: level,
            category: category,
            message: message,
            data: data
        };

        // 优化：添加到历史记录
        this.logHistory.push(logEntry);

        // 优化：限制历史记录大小
        if (this.logHistory.length > this.maxHistorySize) {
            this.logHistory.shift();
        }

        // 优化：输出到所有输出器
        for (let i = 0; i < this.logAppenders.length; i++) {
            try {
                this.logAppenders[i].callback(logEntry);
            } catch (error) {
                console.error('日志输出器错误:', error);
            }
        }

        // 优化：更新分类统计
        this.updateCategoryStats(level, category);
    },

    /**
     * 检查是否应该记录日志
     * @param {string} level - 日志级别
     * @param {string} category - 日志分类
     * @param {string} message - 日志消息
     * @returns {boolean} 是否应该记录
     */
    shouldLog: function (level, category, message) {
        for (let i = 0; i < this.logFilters.length; i++) {
            const filter = this.logFilters[i];

            // 优化：检查级别过滤
            if (filter.level && filter.level !== level) {
                continue;
            }

            // 优化：检查分类过滤
            if (filter.category && filter.category !== category) {
                continue;
            }

            // 优化：检查消息过滤
            if (filter.message && message.indexOf(filter.message) === -1) {
                continue;
            }

            // 优化：检查排除规则
            if (filter.exclude) {
                return false;
            }

            // 优化：检查包含规则
            if (filter.include) {
                return true;
            }
        }

        return true;
    },

    /**
     * 更新分类统计
     * @param {string} level - 日志级别
     * @param {string} category - 日志分类
     */
    updateCategoryStats: function (level, category) {
        if (!this.logCategories[category]) {
            this.logCategories[category] = {
                debug: 0,
                info: 0,
                warn: 0,
                error: 0,
                fatal: 0
            };
        }

        this.logCategories[category][level]++;
    },

    /**
     * 调试日志
     * @param {string} category - 日志分类
     * @param {string} message - 日志消息
     * @param {*} data - 日志数据
     */
    debug: function (category, message, data) {
        this.log('debug', category, message, data);
    },

    /**
     * 信息日志
     * @param {string} category - 日志分类
     * @param {string} message - 日志消息
     * @param {*} data - 日志数据
     */
    info: function (category, message, data) {
        this.log('info', category, message, data);
    },

    /**
     * 警告日志
     * @param {string} category - 日志分类
     * @param {string} message - 日志消息
     * @param {*} data - 日志数据
     */
    warn: function (category, message, data) {
        this.log('warn', category, message, data);
    },

    /**
     * 错误日志
     * @param {string} category - 日志分类
     * @param {string} message - 日志消息
     * @param {*} data - 日志数据
     */
    error: function (category, message, data) {
        this.log('error', category, message, data);
    },

    /**
     * 致命错误日志
     * @param {string} category - 日志分类
     * @param {string} message - 日志消息
     * @param {*} data - 日志数据
     */
    fatal: function (category, message, data) {
        this.log('fatal', category, message, data);
    },

    /**
     * 获取日志历史
     * @param {Object} options - 查询选项
     * @returns {Array} 日志历史
     */
    getLogHistory: function (options) {
        let logs = [...this.logHistory];

        // 优化：按级别过滤
        if (options && options.level) {
            logs = logs.filter(log => log.level === options.level);
        }

        // 优化：按分类过滤
        if (options && options.category) {
            logs = logs.filter(log => log.category === options.category);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            logs = logs.filter(log => log.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            logs = logs.filter(log => log.timestamp <= options.endTime);
        }

        // 优化：按关键词搜索
        if (options && options.keyword) {
            logs = logs.filter(log => log.message.indexOf(options.keyword) !== -1);
        }

        // 优化：限制数量
        if (options && options.limit) {
            logs = logs.slice(-options.limit);
        }

        return logs;
    },

    /**
     * 清空日志历史
     */
    clearLogHistory: function () {
        this.logHistory = [];
        this.logCategories = {};
    },

    /**
     * 导出日志
     * @param {string} format - 格式（json, csv, txt）
     * @returns {string} 导出的日志
     */
    exportLogs: function (format) {
        const logs = this.getLogHistory();

        switch (format) {
            case 'json':
                return JSON.stringify(logs, null, 2);

            case 'csv':
                return this.generateCSVLogs(logs);

            case 'txt':
                return this.generateTXTLogs(logs);

            default:
                return JSON.stringify(logs, null, 2);
        }
    },

    /**
     * 生成CSV格式日志
     * @param {Array} logs - 日志数组
     * @returns {string} CSV日志
     */
    generateCSVLogs: function (logs) {
        let csv = '时间戳,级别,分类,消息,数据\n';

        for (let i = 0; i < logs.length; i++) {
            const log = logs[i];
            const data = JSON.stringify(log.data).replace(/"/g, '""');
            csv += `${log.timestamp},${log.level},${log.category},"${log.message}","${data}"\n`;
        }

        return csv;
    },

    /**
     * 生成TXT格式日志
     * @param {Array} logs - 日志数组
     * @returns {string} TXT日志
     */
    generateTXTLogs: function (logs) {
        let txt = '';

        for (let i = 0; i < logs.length; i++) {
            const log = logs[i];
            txt += `[${log.timestamp}] [${log.level.toUpperCase()}] [${log.category}] ${log.message}\n`;

            if (log.data) {
                txt += `  数据: ${JSON.stringify(log.data, null, 2)}\n`;
            }
        }

        return txt;
    },

    /**
     * 获取日志统计信息
     * @returns {Object} 统计信息
     */
    getLogStats: function () {
        return {
            logLevel: this.logLevel,
            totalLogs: this.logHistory.length,
            maxHistorySize: this.maxHistorySize,
            logCategories: this.logCategories,
            logFilters: this.logFilters,
            logAppenders: this.logAppenders.length,
            cacheSize: Object.keys(this.logCache).length
        };
    },

    /**
     * 清空日志缓存
     */
    clearLogCache: function () {
        this.logCache = {};
    }
};

// 优化：游戏监控性能优化
const GameMonitorOptimizer = {
    monitoringEnabled: true,
    monitorInterval: 1000,
    monitorTimer: null,
    monitorData: {},
    monitorCache: {},
    monitorThresholds: {},
    monitorAlerts: [],
    monitorHistory: [],
    maxHistorySize: 10000,

    /**
     * 初始化游戏监控
     */
    init: function () {
        this.loadMonitorThresholds();
        this.startMonitoring();
    },

    /**
     * 加载监控阈值
     */
    loadMonitorThresholds: function () {
        // 优化：加载默认监控阈值
        this.monitorThresholds = {
            fps: {
                warning: 30,
                critical: 20
            },
            memory: {
                warning: 100,
                critical: 150
            },
            frameTime: {
                warning: 33,
                critical: 50
            },
            errorRate: {
                warning: 0.01,
                critical: 0.05
            }
        };

        // 优化：从本地存储加载自定义阈值
        const customThresholds = localStorage.getItem('monitorThresholds');

        if (customThresholds) {
            try {
                const thresholds = JSON.parse(customThresholds);
                this.monitorThresholds = { ...this.monitorThresholds, ...thresholds };
            } catch (error) {
                console.error('加载监控阈值失败:', error);
            }
        }
    },

    /**
     * 保存监控阈值
     */
    saveMonitorThresholds: function () {
        localStorage.setItem('monitorThresholds', JSON.stringify(this.monitorThresholds));
    },

    /**
     * 开始监控
     */
    startMonitoring: function () {
        if (this.monitorTimer) {
            return;
        }

        this.monitoringEnabled = true;
        this.monitorTimer = setInterval(() => {
            this.collectMonitorData();
        }, this.monitorInterval);
    },

    /**
     * 停止监控
     */
    stopMonitoring: function () {
        if (this.monitorTimer) {
            clearInterval(this.monitorTimer);
            this.monitorTimer = null;
        }

        this.monitoringEnabled = false;
    },

    /**
     * 收集监控数据
     */
    collectMonitorData: function () {
        if (!this.monitoringEnabled) {
            return;
        }

        // 优化：收集FPS数据
        this.collectFPSData();

        // 优化：收集内存数据
        this.collectMemoryData();

        // 优化：收集帧时间数据
        this.collectFrameTimeData();

        // 优化：收集错误率数据
        this.collectErrorRateData();

        // 优化：收集玩家行为数据
        this.collectPlayerBehaviorData();

        // 优化：收集游戏状态数据
        this.collectGameStateData();

        // 优化：检查阈值
        this.checkThresholds();

        // 优化：保存历史记录
        this.saveMonitorHistory();
    },

    /**
     * 收集FPS数据
     */
    collectFPSData: function () {
        const fps = state.avgFPS || 0;

        this.monitorData.fps = {
            current: fps,
            average: this.calculateAverage('fps', fps),
            min: this.calculateMin('fps', fps),
            max: this.calculateMax('fps', fps),
            timestamp: Date.now()
        };
    },

    /**
     * 收集内存数据
     */
    collectMemoryData: function () {
        const memory = performance.memory;

        if (memory) {
            const usedMB = memory.usedJSHeapSize / 1024 / 1024;

            this.monitorData.memory = {
                current: usedMB,
                average: this.calculateAverage('memory', usedMB),
                min: this.calculateMin('memory', usedMB),
                max: this.calculateMax('memory', usedMB),
                total: memory.totalJSHeapSize / 1024 / 1024,
                limit: memory.jsHeapSizeLimit / 1024 / 1024,
                timestamp: Date.now()
            };
        }
    },

    /**
     * 收集帧时间数据
     */
    collectFrameTimeData: function () {
        const frameTime = perfMetrics.avgFrameTime || 0;

        this.monitorData.frameTime = {
            current: frameTime,
            average: this.calculateAverage('frameTime', frameTime),
            min: this.calculateMin('frameTime', frameTime),
            max: this.calculateMax('frameTime', frameTime),
            timestamp: Date.now()
        };
    },

    /**
     * 收集错误率数据
     */
    collectErrorRateData: function () {
        const errorCount = this.monitorData.errorCount || 0;
        const totalOperations = this.monitorData.totalOperations || 1;
        const errorRate = errorCount / totalOperations;

        this.monitorData.errorRate = {
            current: errorRate,
            average: this.calculateAverage('errorRate', errorRate),
            min: this.calculateMin('errorRate', errorRate),
            max: this.calculateMax('errorRate', errorRate),
            errorCount: errorCount,
            totalOperations: totalOperations,
            timestamp: Date.now()
        };
    },

    /**
     * 收集玩家行为数据
     */
    collectPlayerBehaviorData: function () {
        const behaviorData = {
            actions: this.monitorData.playerActions || [],
            score: state.score || 0,
            health: state.player ? state.player.health : 0,
            level: state.currentLevel || 1,
            timestamp: Date.now()
        };

        this.monitorData.playerBehavior = behaviorData;
    },

    /**
     * 收集游戏状态数据
     */
    collectGameStateData: function () {
        const gameStateData = {
            state: state.gameState,
            enemies: state.enemies ? state.enemies.length : 0,
            props: state.props ? state.props.length : 0,
            particles: state.particles ? state.particles.length : 0,
            timestamp: Date.now()
        };

        this.monitorData.gameState = gameStateData;
    },

    /**
     * 计算平均值
     * @param {string} key - 键
     * @param {number} value - 值
     * @returns {number} 平均值
     */
    calculateAverage: function (key, value) {
        if (!this.monitorCache[key]) {
            this.monitorCache[key] = { values: [], sum: 0 };
        }

        const cache = this.monitorCache[key];
        cache.values.push(value);
        cache.sum += value;

        // 优化：限制缓存大小
        if (cache.values.length > 100) {
            cache.sum -= cache.values.shift();
        }

        return cache.sum / cache.values.length;
    },

    /**
     * 计算最小值
     * @param {string} key - 键
     * @param {number} value - 值
     * @returns {number} 最小值
     */
    calculateMin: function (key, value) {
        if (!this.monitorCache[key]) {
            this.monitorCache[key] = { values: [], sum: 0, min: value, max: value };
        }

        const cache = this.monitorCache[key];
        cache.min = Math.min(cache.min, value);

        return cache.min;
    },

    /**
     * 计算最大值
     * @param {string} key - 键
     * @param {number} value - 值
     * @returns {number} 最大值
     */
    calculateMax: function (key, value) {
        if (!this.monitorCache[key]) {
            this.monitorCache[key] = { values: [], sum: 0, min: value, max: value };
        }

        const cache = this.monitorCache[key];
        cache.max = Math.max(cache.max, value);

        return cache.max;
    },

    /**
     * 检查阈值
     */
    checkThresholds: function () {
        // 优化：检查FPS阈值
        if (this.monitorData.fps) {
            this.checkThreshold('fps', this.monitorData.fps.current);
        }

        // 优化：检查内存阈值
        if (this.monitorData.memory) {
            this.checkThreshold('memory', this.monitorData.memory.current);
        }

        // 优化：检查帧时间阈值
        if (this.monitorData.frameTime) {
            this.checkThreshold('frameTime', this.monitorData.frameTime.current);
        }

        // 优化：检查错误率阈值
        if (this.monitorData.errorRate) {
            this.checkThreshold('errorRate', this.monitorData.errorRate.current);
        }
    },

    /**
     * 检查阈值
     * @param {string} key - 键
     * @param {number} value - 值
     */
    checkThreshold: function (key, value) {
        const thresholds = this.monitorThresholds[key];

        if (!thresholds) {
            return;
        }

        // 优化：检查警告阈值
        if (value >= thresholds.warning && value < thresholds.critical) {
            this.createAlert(key, value, 'warning');
        }

        // 优化：检查严重阈值
        if (value >= thresholds.critical) {
            this.createAlert(key, value, 'critical');
        }
    },

    /**
     * 创建警报
     * @param {string} key - 键
     * @param {number} value - 值
     * @param {string} level - 级别
     */
    createAlert: function (key, value, level) {
        const alert = {
            key: key,
            value: value,
            level: level,
            threshold: this.monitorThresholds[key][level],
            timestamp: Date.now()
        };

        this.monitorAlerts.push(alert);

        // 优化：限制警报数量
        if (this.monitorAlerts.length > 1000) {
            this.monitorAlerts.shift();
        }

        // 优化：输出警报
        console.warn(`监控警报: ${key} = ${value} (${level})`);
    },

    /**
     * 保存监控历史
     */
    saveMonitorHistory: function () {
        const historyEntry = {
            timestamp: Date.now(),
            data: { ...this.monitorData }
        };

        this.monitorHistory.push(historyEntry);

        // 优化：限制历史记录大小
        if (this.monitorHistory.length > this.maxHistorySize) {
            this.monitorHistory.shift();
        }
    },

    /**
     * 获取监控数据
     * @returns {Object} 监控数据
     */
    getMonitorData: function () {
        return this.monitorData;
    },

    /**
     * 获取监控历史
     * @param {Object} options - 查询选项
     * @returns {Array} 监控历史
     */
    getMonitorHistory: function (options) {
        let history = [...this.monitorHistory];

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 获取警报
     * @param {Object} options - 查询选项
     * @returns {Array} 警报数组
     */
    getAlerts: function (options) {
        let alerts = [...this.monitorAlerts];

        // 优化：按级别过滤
        if (options && options.level) {
            alerts = alerts.filter(a => a.level === options.level);
        }

        // 优化：按键过滤
        if (options && options.key) {
            alerts = alerts.filter(a => a.key === options.key);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            alerts = alerts.filter(a => a.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            alerts = alerts.filter(a => a.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            alerts = alerts.slice(-options.limit);
        }

        return alerts;
    },

    /**
     * 设置监控阈值
     * @param {string} key - 键
     * @param {number} warning - 警告阈值
     * @param {number} critical - 严重阈值
     */
    setThreshold: function (key, warning, critical) {
        this.monitorThresholds[key] = {
            warning: warning,
            critical: critical
        };

        this.saveMonitorThresholds();
    },

    /**
     * 清空警报
     */
    clearAlerts: function () {
        this.monitorAlerts = [];
    },

    /**
     * 清空监控历史
     */
    clearHistory: function () {
        this.monitorHistory = [];
    },

    /**
     * 清空监控缓存
     */
    clearCache: function () {
        this.monitorCache = {};
    },

    /**
     * 重置监控
     */
    reset: function () {
        this.monitorData = {};
        this.clearAlerts();
        this.clearHistory();
        this.clearCache();
    },

    /**
     * 获取监控统计信息
     * @returns {Object} 统计信息
     */
    getMonitorStats: function () {
        return {
            monitoringEnabled: this.monitoringEnabled,
            monitorInterval: this.monitorInterval,
            totalAlerts: this.monitorAlerts.length,
            totalHistory: this.monitorHistory.length,
            maxHistorySize: this.maxHistorySize,
            thresholds: this.monitorThresholds,
            cacheSize: Object.keys(this.monitorCache).length
        };
    }
};

// 优化：游戏追踪性能优化
const GameTrackerOptimizer = {
    trackingEnabled: true,
    trackingId: null,
    sessionId: null,
    trackingData: {},
    trackingCache: {},
    trackingEvents: [],
    maxEventSize: 10000,
    trackingMetrics: {},

    /**
     * 初始化游戏追踪
     */
    init: function () {
        this.generateTrackingId();
        this.generateSessionId();
        this.loadTrackingData();
    },

    /**
     * 生成追踪ID
     */
    generateTrackingId: function () {
        // 优化：从本地存储获取追踪ID
        let trackingId = localStorage.getItem('trackingId');

        if (!trackingId) {
            trackingId = this.generateUUID();
            localStorage.setItem('trackingId', trackingId);
        }

        this.trackingId = trackingId;
    },

    /**
     * 生成会话ID
     */
    generateSessionId: function () {
        this.sessionId = this.generateUUID();
    },

    /**
     * 生成UUID
     * @returns {string} UUID
     */
    generateUUID: function () {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    },

    /**
     * 加载追踪数据
     */
    loadTrackingData: function () {
        // 优化：从本地存储加载追踪数据
        const trackingData = localStorage.getItem('trackingData');

        if (trackingData) {
            try {
                this.trackingData = JSON.parse(trackingData);
            } catch (error) {
                console.error('加载追踪数据失败:', error);
            }
        }
    },

    /**
     * 保存追踪数据
     */
    saveTrackingData: function () {
        localStorage.setItem('trackingData', JSON.stringify(this.trackingData));
    },

    /**
     * 追踪事件
     * @param {string} eventName - 事件名称
     * @param {Object} eventData - 事件数据
     */
    trackEvent: function (eventName, eventData) {
        if (!this.trackingEnabled) {
            return;
        }

        // 优化：创建事件对象
        const event = {
            trackingId: this.trackingId,
            sessionId: this.sessionId,
            eventName: eventName,
            eventData: eventData,
            timestamp: Date.now(),
            url: window.location.href,
            userAgent: navigator.userAgent
        };

        // 优化：添加到事件列表
        this.trackingEvents.push(event);

        // 优化：限制事件数量
        if (this.trackingEvents.length > this.maxEventSize) {
            this.trackingEvents.shift();
        }

        // 优化：更新指标
        this.updateMetrics(eventName);

        // 优化：保存追踪数据
        this.saveTrackingData();
    },

    /**
     * 追踪页面浏览
     * @param {string} pageName - 页面名称
     */
    trackPageView: function (pageName) {
        this.trackEvent('page_view', {
            pageName: pageName,
            url: window.location.href
        });
    },

    /**
     * 追踪玩家行为
     * @param {string} action - 动作
     * @param {Object} data - 数据
     */
    trackPlayerAction: function (action, data) {
        this.trackEvent('player_action', {
            action: action,
            data: data
        });
    },

    /**
     * 追踪游戏事件
     * @param {string} eventType - 事件类型
     * @param {Object} data - 数据
     */
    trackGameEvent: function (eventType, data) {
        this.trackEvent('game_event', {
            eventType: eventType,
            data: data
        });
    },

    /**
     * 追踪性能指标
     * @param {string} metricName - 指标名称
     * @param {number} value - 值
     */
    trackPerformance: function (metricName, value) {
        this.trackEvent('performance', {
            metricName: metricName,
            value: value
        });
    },

    /**
     * 追踪错误
     * @param {Error} error - 错误对象
     * @param {string} context - 上下文
     */
    trackError: function (error, context) {
        this.trackEvent('error', {
            errorMessage: error.message,
            errorStack: error.stack,
            context: context
        });
    },

    /**
     * 追踪自定义事件
     * @param {string} eventName - 事件名称
     * @param {Object} eventData - 事件数据
     */
    trackCustom: function (eventName, eventData) {
        this.trackEvent(eventName, eventData);
    },

    /**
     * 更新指标
     * @param {string} eventName - 事件名称
     */
    updateMetrics: function (eventName) {
        if (!this.trackingMetrics[eventName]) {
            this.trackingMetrics[eventName] = {
                count: 0,
                firstSeen: Date.now(),
                lastSeen: Date.now()
            };
        }

        this.trackingMetrics[eventName].count++;
        this.trackingMetrics[eventName].lastSeen = Date.now();
    },

    /**
     * 获取事件列表
     * @param {Object} options - 查询选项
     * @returns {Array} 事件列表
     */
    getEvents: function (options) {
        let events = [...this.trackingEvents];

        // 优化：按事件名称过滤
        if (options && options.eventName) {
            events = events.filter(e => e.eventName === options.eventName);
        }

        // 优化：按会话ID过滤
        if (options && options.sessionId) {
            events = events.filter(e => e.sessionId === options.sessionId);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            events = events.filter(e => e.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            events = events.filter(e => e.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            events = events.slice(-options.limit);
        }

        return events;
    },

    /**
     * 获取指标
     * @returns {Object} 指标对象
     */
    getMetrics: function () {
        return this.trackingMetrics;
    },

    /**
     * 获取追踪统计信息
     * @returns {Object} 统计信息
     */
    getTrackingStats: function () {
        return {
            trackingEnabled: this.trackingEnabled,
            trackingId: this.trackingId,
            sessionId: this.sessionId,
            totalEvents: this.trackingEvents.length,
            maxEventSize: this.maxEventSize,
            totalMetrics: Object.keys(this.trackingMetrics).length,
            cacheSize: Object.keys(this.trackingCache).length
        };
    },

    /**
     * 导出追踪数据
     * @param {string} format - 格式（json, csv）
     * @returns {string} 导出的数据
     */
    exportTrackingData: function (format) {
        const data = {
            trackingId: this.trackingId,
            sessionId: this.sessionId,
            events: this.trackingEvents,
            metrics: this.trackingMetrics
        };

        switch (format) {
            case 'json':
                return JSON.stringify(data, null, 2);

            case 'csv':
                return this.generateCSVTracking(data);

            default:
                return JSON.stringify(data, null, 2);
        }
    },

    /**
     * 生成CSV格式追踪数据
     * @param {Object} data - 数据对象
     * @returns {string} CSV数据
     */
    generateCSVTracking: function (data) {
        let csv = 'trackingId,sessionId,eventName,timestamp,userData\n';

        for (let i = 0; i < data.events.length; i++) {
            const event = data.events[i];
            const userData = JSON.stringify(event.eventData).replace(/"/g, '""');
            csv += `${event.trackingId},${event.sessionId},${event.eventName},${event.timestamp},"${userData}"\n`;
        }

        return csv;
    },

    /**
     * 清空事件列表
     */
    clearEvents: function () {
        this.trackingEvents = [];
    },

    /**
     * 清空指标
     */
    clearMetrics: function () {
        this.trackingMetrics = {};
    },

    /**
     * 清空追踪缓存
     */
    clearCache: function () {
        this.trackingCache = {};
    },

    /**
     * 重置追踪
     */
    reset: function () {
        this.clearEvents();
        this.clearMetrics();
        this.clearCache();
        this.generateSessionId();
    },

    /**
     * 启用追踪
     */
    enableTracking: function () {
        this.trackingEnabled = true;
    },

    /**
     * 禁用追踪
     */
    disableTracking: function () {
        this.trackingEnabled = false;
    },

    /**
     * 设置追踪ID
     * @param {string} trackingId - 追踪ID
     */
    setTrackingId: function (trackingId) {
        this.trackingId = trackingId;
        localStorage.setItem('trackingId', trackingId);
    },

    /**
     * 获取追踪ID
     * @returns {string} 追踪ID
     */
    getTrackingId: function () {
        return this.trackingId;
    },

    /**
     * 获取会话ID
     * @returns {string} 会话ID
     */
    getSessionId: function () {
        return this.sessionId;
    }
};

// 优化：游戏测试性能优化
const GameTestOptimizer = {
    tests: [],
    testResults: [],
    testCache: {},
    testSuites: {},
    testFixtures: {},
    testHooks: {},

    /**
     * 初始化游戏测试
     */
    init: function () {
        this.loadTestSuites();
    },

    /**
     * 加载测试套件
     */
    loadTestSuites: function () {
        // 优化：加载测试套件
        this.testSuites = {
            'unit': {
                name: '单元测试',
                tests: []
            },
            'integration': {
                name: '集成测试',
                tests: []
            },
            'performance': {
                name: '性能测试',
                tests: []
            }
        };
    },

    /**
     * 添加测试
     * @param {string} suiteName - 套件名称
     * @param {string} testName - 测试名称
     * @param {Function} testFunction - 测试函数
     */
    addTest: function (suiteName, testName, testFunction) {
        if (!this.testSuites[suiteName]) {
            this.testSuites[suiteName] = {
                name: suiteName,
                tests: []
            };
        }

        this.testSuites[suiteName].tests.push({
            name: testName,
            function: testFunction
        });
    },

    /**
     * 添加测试夹具
     * @param {string} fixtureName - 夹具名称
     * @param {*} fixtureData - 夹具数据
     */
    addFixture: function (fixtureName, fixtureData) {
        this.testFixtures[fixtureName] = fixtureData;
    },

    /**
     * 添加测试钩子
     * @param {string} hookName - 钩子名称
     * @param {Function} hookFunction - 钩子函数
     */
    addHook: function (hookName, hookFunction) {
        this.testHooks[hookName] = hookFunction;
    },

    /**
     * 运行测试套件
     * @param {string} suiteName - 套件名称
     * @returns {Promise<Object>} 测试结果
     */
    runSuite: function (suiteName) {
        return new Promise((resolve, reject) => {
            const suite = this.testSuites[suiteName];

            if (!suite) {
                reject(new Error(`测试套件 ${suiteName} 不存在`));
                return;
            }

            const results = {
                suiteName: suiteName,
                totalTests: suite.tests.length,
                passed: 0,
                failed: 0,
                skipped: 0,
                tests: []
            };

            // 优化：执行beforeAll钩子
            if (this.testHooks.beforeAll) {
                this.testHooks.beforeAll();
            }

            // 优化：运行所有测试
            Promise.all(suite.tests.map((test, index) => {
                return this.runTest(suiteName, test.name, test.function);
            })).then(testResults => {
                testResults.forEach(result => {
                    results.tests.push(result);

                    if (result.status === 'passed') {
                        results.passed++;
                    } else if (result.status === 'failed') {
                        results.failed++;
                    } else {
                        results.skipped++;
                    }
                });

                // 优化：执行afterAll钩子
                if (this.testHooks.afterAll) {
                    this.testHooks.afterAll();
                }

                this.testResults.push(results);
                resolve(results);
            }).catch(error => {
                reject(error);
            });
        });
    },

    /**
     * 运行测试
     * @param {string} suiteName - 套件名称
     * @param {string} testName - 测试名称
     * @param {Function} testFunction - 测试函数
     * @returns {Promise<Object>} 测试结果
     */
    runTest: function (suiteName, testName, testFunction) {
        return new Promise((resolve, reject) => {
            // 优化：检查缓存
            const cacheKey = `${suiteName}-${testName}`;
            if (this.testCache[cacheKey]) {
                resolve(this.testCache[cacheKey]);
                return;
            }

            const startTime = performance.now();
            const result = {
                suiteName: suiteName,
                testName: testName,
                status: 'passed',
                duration: 0,
                error: null
            };

            try {
                // 优化：执行beforeEach钩子
                if (this.testHooks.beforeEach) {
                    this.testHooks.beforeEach();
                }

                // 优化：执行测试函数
                const testResult = testFunction();

                if (testResult instanceof Promise) {
                    testResult.then(() => {
                        // 优化：执行afterEach钩子
                        if (this.testHooks.afterEach) {
                            this.testHooks.afterEach();
                        }

                        result.duration = performance.now() - startTime;
                        this.testCache[cacheKey] = result;
                        resolve(result);
                    }).catch(error => {
                        result.status = 'failed';
                        result.error = error.message;
                        result.duration = performance.now() - startTime;

                        // 优化：执行afterEach钩子
                        if (this.testHooks.afterEach) {
                            this.testHooks.afterEach();
                        }

                        this.testCache[cacheKey] = result;
                        resolve(result);
                    });
                } else {
                    // 优化：执行afterEach钩子
                    if (this.testHooks.afterEach) {
                        this.testHooks.afterEach();
                    }

                    result.duration = performance.now() - startTime;
                    this.testCache[cacheKey] = result;
                    resolve(result);
                }
            } catch (error) {
                result.status = 'failed';
                result.error = error.message;
                result.duration = performance.now() - startTime;

                // 优化：执行afterEach钩子
                if (this.testHooks.afterEach) {
                    this.testHooks.afterEach();
                }

                this.testCache[cacheKey] = result;
                resolve(result);
            }
        });
    },

    /**
     * 断言相等
     * @param {*} actual - 实际值
     * @param {*} expected - 期望值
     * @param {string} message - 消息
     */
    assertEqual: function (actual, expected, message) {
        if (actual !== expected) {
            throw new Error(message || `期望 ${expected}，实际 ${actual}`);
        }
    },

    /**
     * 断言不相等
     * @param {*} actual - 实际值
     * @param {*} expected - 期望值
     * @param {string} message - 消息
     */
    assertNotEqual: function (actual, expected, message) {
        if (actual === expected) {
            throw new Error(message || `期望不等于 ${expected}`);
        }
    },

    /**
     * 断言真值
     * @param {*} value - 值
     * @param {string} message - 消息
     */
    assertTrue: function (value, message) {
        if (!value) {
            throw new Error(message || `期望为真`);
        }
    },

    /**
     * 断言假值
     * @param {*} value - 值
     * @param {string} message - 消息
     */
    assertFalse: function (value, message) {
        if (value) {
            throw new Error(message || `期望为假`);
        }
    },

    /**
     * 断言为空
     * @param {*} value - 值
     * @param {string} message - 消息
     */
    assertNull: function (value, message) {
        if (value !== null) {
            throw new Error(message || `期望为null`);
        }
    },

    /**
     * 断言不为空
     * @param {*} value - 值
     * @param {string} message - 消息
     */
    assertNotNull: function (value, message) {
        if (value === null) {
            throw new Error(message || `期望不为null`);
        }
    },

    /**
     * 断言抛出异常
     * @param {Function} fn - 函数
     * @param {string} message - 消息
     */
    assertThrows: function (fn, message) {
        let thrown = false;

        try {
            fn();
        } catch (error) {
            thrown = true;
        }

        if (!thrown) {
            throw new Error(message || `期望抛出异常`);
        }
    },

    /**
     * 获取测试结果
     * @param {string} suiteName - 套件名称
     * @returns {Array} 测试结果
     */
    getTestResults: function (suiteName) {
        if (suiteName) {
            return this.testResults.filter(r => r.suiteName === suiteName);
        }

        return this.testResults;
    },

    /**
     * 获取测试统计信息
     * @returns {Object} 统计信息
     */
    getTestStats: function () {
        const totalResults = this.testResults.reduce((acc, result) => {
            return {
                totalTests: acc.totalTests + result.totalTests,
                passed: acc.passed + result.passed,
                failed: acc.failed + result.failed,
                skipped: acc.skipped + result.skipped
            };
        }, {
            totalTests: 0,
            passed: 0,
            failed: 0,
            skipped: 0
        });

        return {
            totalSuites: Object.keys(this.testSuites).length,
            totalTests: totalResults.totalTests,
            passed: totalResults.passed,
            failed: totalResults.failed,
            skipped: totalResults.skipped,
            passRate: totalResults.totalTests > 0 ? (totalResults.passed / totalResults.totalTests * 100).toFixed(2) + '%' : '0%',
            cacheSize: Object.keys(this.testCache).length
        };
    },

    /**
     * 清空测试缓存
     */
    clearCache: function () {
        this.testCache = {};
    },

    /**
     * 清空测试结果
     */
    clearResults: function () {
        this.testResults = [];
    },

    /**
     * 重置测试
     */
    reset: function () {
        this.clearCache();
        this.clearResults();
        this.testFixtures = {};
        this.testHooks = {};
    },

    /**
     * 导出测试报告
     * @param {string} format - 格式（json, html, csv）
     * @returns {string} 测试报告
     */
    exportTestReport: function (format) {
        const report = {
            timestamp: new Date().toISOString(),
            stats: this.getTestStats(),
            results: this.testResults
        };

        switch (format) {
            case 'json':
                return JSON.stringify(report, null, 2);

            case 'html':
                return this.generateHTMLReport(report);

            case 'csv':
                return this.generateCSVReport(report);

            default:
                return JSON.stringify(report, null, 2);
        }
    },

    /**
     * 生成HTML报告
     * @param {Object} report - 报告对象
     * @returns {string} HTML报告
     */
    generateHTMLReport: function (report) {
        let html = `<!DOCTYPE html>
<html>
<head>
    <title>测试报告</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1 { color: #6a0dad; }
        h2 { color: #4a2c7a; margin-top: 30px; }
        .stats { background: #f5f5f5; padding: 10px; border-radius: 5px; }
        .passed { color: green; }
        .failed { color: red; }
        .skipped { color: orange; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #6a0dad; color: white; }
    </style>
</head>
<body>
    <h1>测试报告</h1>
    <p>生成时间: ${report.timestamp}</p>
    
    <div class="stats">
        <h2>统计信息</h2>
        <p>总套件: ${report.stats.totalSuites}</p>
        <p>总测试: ${report.stats.totalTests}</p>
        <p class="passed">通过: ${report.stats.passed}</p>
        <p class="failed">失败: ${report.stats.failed}</p>
        <p class="skipped">跳过: ${report.stats.skipped}</p>
        <p>通过率: ${report.stats.passRate}</p>
    </div>
`;

        for (let i = 0; i < report.results.length; i++) {
            const result = report.results[i];
            html += `    <h2>${result.suiteName}</h2>\n`;
            html += `    <table>\n`;
            html += `        <tr>\n`;
            html += `            <th>测试名称</th>\n`;
            html += `            <th>状态</th>\n`;
            html += `            <th>持续时间</th>\n`;
            html += `            <th>错误</th>\n`;
            html += `        </tr>\n`;

            for (let j = 0; j < result.tests.length; j++) {
                const test = result.tests[j];
                html += `        <tr>\n`;
                html += `            <td>${test.testName}</td>\n`;
                html += `            <td class="${test.status}">${test.status}</td>\n`;
                html += `            <td>${test.duration.toFixed(2)}ms</td>\n`;
                html += `            <td>${test.error || ''}</td>\n`;
                html += `        </tr>\n`;
            }

            html += `    </table>\n`;
        }

        html += `</body>
</html>`;

        return html;
    },

    /**
     * 生成CSV报告
     * @param {Object} report - 报告对象
     * @returns {string} CSV报告
     */
    generateCSVReport: function (report) {
        let csv = '套件名称,测试名称,状态,持续时间,错误\n';

        for (let i = 0; i < report.results.length; i++) {
            const result = report.results[i];

            for (let j = 0; j < result.tests.length; j++) {
                const test = result.tests[j];
                csv += `${result.suiteName},${test.testName},${test.status},${test.duration.toFixed(2)},"${test.error || ''}"\n`;
            }
        }

        return csv;
    }
};

// 优化：游戏构建性能优化
const GameBuildOptimizer = {
    buildConfig: {},
    buildTasks: [],
    buildCache: {},
    buildHistory: [],
    maxHistorySize: 100,

    /**
     * 初始化游戏构建
     */
    init: function () {
        this.loadBuildConfig();
        this.loadBuildTasks();
    },

    /**
     * 加载构建配置
     */
    loadBuildConfig: function () {
        // 优化：加载默认构建配置
        this.buildConfig = {
            outputDir: './dist',
            minify: true,
            compress: true,
            sourceMap: true,
            cache: true,
            parallel: true,
            watch: false
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('buildConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.buildConfig = { ...this.buildConfig, ...config };
            } catch (error) {
                console.error('加载构建配置失败:', error);
            }
        }
    },

    /**
     * 保存构建配置
     */
    saveBuildConfig: function () {
        localStorage.setItem('buildConfig', JSON.stringify(this.buildConfig));
    },

    /**
     * 加载构建任务
     */
    loadBuildTasks: function () {
        // 优化：加载默认构建任务
        this.buildTasks = [
            {
                name: 'clean',
                description: '清理构建目录',
                callback: () => this.cleanBuildDir()
            },
            {
                name: 'copy',
                description: '复制文件',
                callback: () => this.copyFiles()
            },
            {
                name: 'minify',
                description: '压缩代码',
                callback: () => this.minifyCode()
            },
            {
                name: 'optimize',
                description: '优化资源',
                callback: () => this.optimizeAssets()
            },
            {
                name: 'generate-source-map',
                description: '生成源映射',
                callback: () => this.generateSourceMap()
            }
        ];
    },

    /**
     * 添加构建任务
     * @param {string} name - 任务名称
     * @param {string} description - 描述
     * @param {Function} callback - 回调函数
     */
    addBuildTask: function (name, description, callback) {
        this.buildTasks.push({
            name: name,
            description: description,
            callback: callback
        });
    },

    /**
     * 移除构建任务
     * @param {string} name - 任务名称
     */
    removeBuildTask: function (name) {
        this.buildTasks = this.buildTasks.filter(t => t.name !== name);
    },

    /**
     * 运行构建
     * @returns {Promise<Object>} 构建结果
     */
    build: function () {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const buildResult = {
                success: true,
                duration: 0,
                tasks: [],
                errors: []
            };

            // 优化：检查缓存
            if (this.buildConfig.cache && this.hasValidCache()) {
                const cachedBuild = this.getFromCache();
                buildResult.duration = performance.now() - startTime;
                buildResult.tasks = cachedBuild.tasks;
                resolve(buildResult);
                return;
            }

            // 优化：运行构建任务
            this.runBuildTasks().then(tasks => {
                buildResult.tasks = tasks;
                buildResult.duration = performance.now() - startTime;

                // 优化：保存到缓存
                if (this.buildConfig.cache) {
                    this.saveToCache(buildResult);
                }

                // 优化：保存历史记录
                this.saveBuildHistory(buildResult);

                resolve(buildResult);
            }).catch(error => {
                buildResult.success = false;
                buildResult.duration = performance.now() - startTime;
                buildResult.errors.push(error.message);

                // 优化：保存历史记录
                this.saveBuildHistory(buildResult);

                reject(buildResult);
            });
        });
    },

    /**
     * 运行构建任务
     * @returns {Promise<Array>} 任务结果
     */
    runBuildTasks: function () {
        return new Promise((resolve, reject) => {
            const taskResults = [];
            let currentIndex = 0;

            const runNextTask = () => {
                if (currentIndex >= this.buildTasks.length) {
                    resolve(taskResults);
                    return;
                }

                const task = this.buildTasks[currentIndex];
                const taskStartTime = performance.now();

                try {
                    const result = task.callback();

                    if (result instanceof Promise) {
                        result.then(() => {
                            taskResults.push({
                                name: task.name,
                                success: true,
                                duration: performance.now() - taskStartTime
                            });

                            currentIndex++;
                            runNextTask();
                        }).catch(error => {
                            taskResults.push({
                                name: task.name,
                                success: false,
                                duration: performance.now() - taskStartTime,
                                error: error.message
                            });

                            currentIndex++;
                            runNextTask();
                        });
                    } else {
                        taskResults.push({
                            name: task.name,
                            success: true,
                            duration: performance.now() - taskStartTime
                        });

                        currentIndex++;
                        runNextTask();
                    }
                } catch (error) {
                    taskResults.push({
                        name: task.name,
                        success: false,
                        duration: performance.now() - taskStartTime,
                        error: error.message
                    });

                    currentIndex++;
                    runNextTask();
                }
            };

            runNextTask();
        });
    },

    /**
     * 清理构建目录
     * @returns {Promise<void>}
     */
    cleanBuildDir: function () {
        return new Promise((resolve) => {
            // 优化：清理构建目录
            console.log('清理构建目录...');
            resolve();
        });
    },

    /**
     * 复制文件
     * @returns {Promise<void>}
     */
    copyFiles: function () {
        return new Promise((resolve) => {
            // 优化：复制文件
            console.log('复制文件...');
            resolve();
        });
    },

    /**
     * 压缩代码
     * @returns {Promise<void>}
     */
    minifyCode: function () {
        return new Promise((resolve) => {
            // 优化：压缩代码
            console.log('压缩代码...');
            resolve();
        });
    },

    /**
     * 优化资源
     * @returns {Promise<void>}
     */
    optimizeAssets: function () {
        return new Promise((resolve) => {
            // 优化：优化资源
            console.log('优化资源...');
            resolve();
        });
    },

    /**
     * 生成源映射
     * @returns {Promise<void>}
     */
    generateSourceMap: function () {
        return new Promise((resolve) => {
            // 优化：生成源映射
            console.log('生成源映射...');
            resolve();
        });
    },

    /**
     * 检查是否有有效缓存
     * @returns {boolean} 是否有有效缓存
     */
    hasValidCache: function () {
        const cache = this.buildCache['lastBuild'];

        if (!cache) {
            return false;
        }

        // 优化：检查缓存是否过期（1小时）
        const cacheAge = Date.now() - cache.timestamp;
        return cacheAge < 3600000;
    },

    /**
     * 从缓存获取
     * @returns {Object} 缓存数据
     */
    getFromCache: function () {
        return this.buildCache['lastBuild'];
    },

    /**
     * 保存到缓存
     * @param {Object} buildResult - 构建结果
     */
    saveToCache: function (buildResult) {
        this.buildCache['lastBuild'] = {
            timestamp: Date.now(),
            tasks: buildResult.tasks
        };
    },

    /**
     * 保存构建历史
     * @param {Object} buildResult - 构建结果
     */
    saveBuildHistory: function (buildResult) {
        this.buildHistory.push({
            timestamp: Date.now(),
            result: buildResult
        });

        // 优化：限制历史记录大小
        if (this.buildHistory.length > this.maxHistorySize) {
            this.buildHistory.shift();
        }
    },

    /**
     * 获取构建历史
     * @param {Object} options - 查询选项
     * @returns {Array} 构建历史
     */
    getBuildHistory: function (options) {
        let history = [...this.buildHistory];

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：按成功状态过滤
        if (options && options.success !== undefined) {
            history = history.filter(h => h.result.success === options.success);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置构建配置
     * @param {Object} config - 配置对象
     */
    setBuildConfig: function (config) {
        this.buildConfig = { ...this.buildConfig, ...config };
        this.saveBuildConfig();
    },

    /**
     * 获取构建配置
     * @returns {Object} 配置对象
     */
    getBuildConfig: function () {
        return this.buildConfig;
    },

    /**
     * 获取构建任务
     * @returns {Array} 任务列表
     */
    getBuildTasks: function () {
        return this.buildTasks;
    },

    /**
     * 清空构建缓存
     */
    clearCache: function () {
        this.buildCache = {};
    },

    /**
     * 清空构建历史
     */
    clearHistory: function () {
        this.buildHistory = [];
    },

    /**
     * 重置构建
     */
    reset: function () {
        this.clearCache();
        this.clearHistory();
    },

    /**
     * 获取构建统计信息
     * @returns {Object} 统计信息
     */
    getBuildStats: function () {
        const totalBuilds = this.buildHistory.length;
        const successfulBuilds = this.buildHistory.filter(h => h.result.success).length;
        const failedBuilds = totalBuilds - successfulBuilds;

        return {
            totalBuilds: totalBuilds,
            successfulBuilds: successfulBuilds,
            failedBuilds: failedBuilds,
            successRate: totalBuilds > 0 ? (successfulBuilds / totalBuilds * 100).toFixed(2) + '%' : '0%',
            totalTasks: this.buildTasks.length,
            cacheEnabled: this.buildConfig.cache,
            cacheSize: Object.keys(this.buildCache).length
        };
    }
};

// 优化：游戏部署性能优化
const GameDeploymentOptimizer = {
    deploymentConfig: {},
    deploymentHistory: [],
    maxHistorySize: 100,
    deploymentCache: {},

    /**
     * 初始化游戏部署
     */
    init: function () {
        this.loadDeploymentConfig();
    },

    /**
     * 加载部署配置
     */
    loadDeploymentConfig: function () {
        // 优化：加载默认部署配置
        this.deploymentConfig = {
            environment: 'production',
            cdnEnabled: true,
            compressionEnabled: true,
            cacheControl: 'max-age=31536000',
            httpsOnly: true,
            version: '1.0.0'
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('deploymentConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.deploymentConfig = { ...this.deploymentConfig, ...config };
            } catch (error) {
                console.error('加载部署配置失败:', error);
            }
        }
    },

    /**
     * 保存部署配置
     */
    saveDeploymentConfig: function () {
        localStorage.setItem('deploymentConfig', JSON.stringify(this.deploymentConfig));
    },

    /**
     * 部署游戏
     * @param {string} environment - 环境名称
     * @returns {Promise<Object>} 部署结果
     */
    deploy: function (environment) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const deploymentResult = {
                success: true,
                environment: environment || this.deploymentConfig.environment,
                version: this.deploymentConfig.version,
                duration: 0,
                steps: [],
                errors: []
            };

            // 优化：执行部署步骤
            this.executeDeploymentSteps(deploymentResult).then(() => {
                deploymentResult.duration = performance.now() - startTime;

                // 优化：保存部署历史
                this.saveDeploymentHistory(deploymentResult);

                resolve(deploymentResult);
            }).catch(error => {
                deploymentResult.success = false;
                deploymentResult.duration = performance.now() - startTime;
                deploymentResult.errors.push(error.message);

                // 优化：保存部署历史
                this.saveDeploymentHistory(deploymentResult);

                reject(deploymentResult);
            });
        });
    },

    /**
     * 执行部署步骤
     * @param {Object} deploymentResult - 部署结果
     * @returns {Promise<void>}
     */
    executeDeploymentSteps: function (deploymentResult) {
        return new Promise((resolve, reject) => {
            const steps = [
                {
                    name: 'validate',
                    description: '验证部署配置',
                    callback: () => this.validateDeploymentConfig()
                },
                {
                    name: 'prepare',
                    description: '准备部署文件',
                    callback: () => this.prepareDeploymentFiles()
                },
                {
                    name: 'compress',
                    description: '压缩资源',
                    callback: () => this.compressResources()
                },
                {
                    name: 'upload',
                    description: '上传文件',
                    callback: () => this.uploadFiles()
                },
                {
                    name: 'configure',
                    description: '配置CDN',
                    callback: () => this.configureCDN()
                },
                {
                    name: 'verify',
                    description: '验证部署',
                    callback: () => this.verifyDeployment()
                }
            ];

            let currentIndex = 0;

            const runNextStep = () => {
                if (currentIndex >= steps.length) {
                    resolve();
                    return;
                }

                const step = steps[currentIndex];
                const stepStartTime = performance.now();

                try {
                    const result = step.callback();

                    if (result instanceof Promise) {
                        result.then(() => {
                            deploymentResult.steps.push({
                                name: step.name,
                                description: step.description,
                                success: true,
                                duration: performance.now() - stepStartTime
                            });

                            currentIndex++;
                            runNextStep();
                        }).catch(error => {
                            deploymentResult.steps.push({
                                name: step.name,
                                description: step.description,
                                success: false,
                                duration: performance.now() - stepStartTime,
                                error: error.message
                            });

                            currentIndex++;
                            runNextStep();
                        });
                    } else {
                        deploymentResult.steps.push({
                            name: step.name,
                            description: step.description,
                            success: true,
                            duration: performance.now() - stepStartTime
                        });

                        currentIndex++;
                        runNextStep();
                    }
                } catch (error) {
                    deploymentResult.steps.push({
                        name: step.name,
                        description: step.description,
                        success: false,
                        duration: performance.now() - stepStartTime,
                        error: error.message
                    });

                    currentIndex++;
                    runNextStep();
                }
            };

            runNextStep();
        });
    },

    /**
     * 验证部署配置
     * @returns {Promise<void>}
     */
    validateDeploymentConfig: function () {
        return new Promise((resolve) => {
            // 优化：验证部署配置
            console.log('验证部署配置...');
            resolve();
        });
    },

    /**
     * 准备部署文件
     * @returns {Promise<void>}
     */
    prepareDeploymentFiles: function () {
        return new Promise((resolve) => {
            // 优化：准备部署文件
            console.log('准备部署文件...');
            resolve();
        });
    },

    /**
     * 压缩资源
     * @returns {Promise<void>}
     */
    compressResources: function () {
        return new Promise((resolve) => {
            // 优化：压缩资源
            console.log('压缩资源...');
            resolve();
        });
    },

    /**
     * 上传文件
     * @returns {Promise<void>}
     */
    uploadFiles: function () {
        return new Promise((resolve) => {
            // 优化：上传文件
            console.log('上传文件...');
            resolve();
        });
    },

    /**
     * 配置CDN
     * @returns {Promise<void>}
     */
    configureCDN: function () {
        return new Promise((resolve) => {
            // 优化：配置CDN
            console.log('配置CDN...');
            resolve();
        });
    },

    /**
     * 验证部署
     * @returns {Promise<void>}
     */
    verifyDeployment: function () {
        return new Promise((resolve) => {
            // 优化：验证部署
            console.log('验证部署...');
            resolve();
        });
    },

    /**
     * 回滚部署
     * @param {string} version - 版本号
     * @returns {Promise<Object>} 回滚结果
     */
    rollback: function (version) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const rollbackResult = {
                success: true,
                version: version,
                duration: 0,
                steps: [],
                errors: []
            };

            // 优化：执行回滚步骤
            this.executeRollbackSteps(version, rollbackResult).then(() => {
                rollbackResult.duration = performance.now() - startTime;
                resolve(rollbackResult);
            }).catch(error => {
                rollbackResult.success = false;
                rollbackResult.duration = performance.now() - startTime;
                rollbackResult.errors.push(error.message);
                reject(rollbackResult);
            });
        });
    },

    /**
     * 执行回滚步骤
     * @param {string} version - 版本号
     * @param {Object} rollbackResult - 回滚结果
     * @returns {Promise<void>}
     */
    executeRollbackSteps: function (version, rollbackResult) {
        return new Promise((resolve) => {
            // 优化：执行回滚步骤
            console.log(`回滚到版本 ${version}...`);
            resolve();
        });
    },

    /**
     * 保存部署历史
     * @param {Object} deploymentResult - 部署结果
     */
    saveDeploymentHistory: function (deploymentResult) {
        this.deploymentHistory.push({
            timestamp: Date.now(),
            result: deploymentResult
        });

        // 优化：限制历史记录大小
        if (this.deploymentHistory.length > this.maxHistorySize) {
            this.deploymentHistory.shift();
        }
    },

    /**
     * 获取部署历史
     * @param {Object} options - 查询选项
     * @returns {Array} 部署历史
     */
    getDeploymentHistory: function (options) {
        let history = [...this.deploymentHistory];

        // 优化：按环境过滤
        if (options && options.environment) {
            history = history.filter(h => h.result.environment === options.environment);
        }

        // 优化：按版本过滤
        if (options && options.version) {
            history = history.filter(h => h.result.version === options.version);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：按成功状态过滤
        if (options && options.success !== undefined) {
            history = history.filter(h => h.result.success === options.success);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置部署配置
     * @param {Object} config - 配置对象
     */
    setDeploymentConfig: function (config) {
        this.deploymentConfig = { ...this.deploymentConfig, ...config };
        this.saveDeploymentConfig();
    },

    /**
     * 获取部署配置
     * @returns {Object} 配置对象
     */
    getDeploymentConfig: function () {
        return this.deploymentConfig;
    },

    /**
     * 清空部署缓存
     */
    clearCache: function () {
        this.deploymentCache = {};
    },

    /**
     * 清空部署历史
     */
    clearHistory: function () {
        this.deploymentHistory = [];
    },

    /**
     * 重置部署
     */
    reset: function () {
        this.clearCache();
        this.clearHistory();
    },

    /**
     * 获取部署统计信息
     * @returns {Object} 统计信息
     */
    getDeploymentStats: function () {
        const totalDeployments = this.deploymentHistory.length;
        const successfulDeployments = this.deploymentHistory.filter(h => h.result.success).length;
        const failedDeployments = totalDeployments - successfulDeployments;

        return {
            totalDeployments: totalDeployments,
            successfulDeployments: successfulDeployments,
            failedDeployments: failedDeployments,
            successRate: totalDeployments > 0 ? (successfulDeployments / totalDeployments * 100).toFixed(2) + '%' : '0%',
            currentVersion: this.deploymentConfig.version,
            environment: this.deploymentConfig.environment,
            cacheSize: Object.keys(this.deploymentCache).length
        };
    }
};

// 优化：游戏运维性能优化
const GameOperationsOptimizer = {
    operationsConfig: {},
    operationsHistory: [],
    maxHistorySize: 1000,
    operationsCache: {},
    alerts: [],
    metrics: {},

    /**
     * 初始化游戏运维
     */
    init: function () {
        this.loadOperationsConfig();
        this.setupAlertSystem();
        this.startMetricsCollection();
    },

    /**
     * 加载运维配置
     */
    loadOperationsConfig: function () {
        // 优化：加载默认运维配置
        this.operationsConfig = {
            monitoringEnabled: true,
            alertingEnabled: true,
            autoScalingEnabled: false,
            backupEnabled: true,
            logRetentionDays: 30,
            metricsRetentionDays: 7
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('operationsConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.operationsConfig = { ...this.operationsConfig, ...config };
            } catch (error) {
                console.error('加载运维配置失败:', error);
            }
        }
    },

    /**
     * 保存运维配置
     */
    saveOperationsConfig: function () {
        localStorage.setItem('operationsConfig', JSON.stringify(this.operationsConfig));
    },

    /**
     * 设置警报系统
     */
    setupAlertSystem: function () {
        // 优化：设置警报规则
        this.alertRules = {
            highErrorRate: {
                threshold: 0.05,
                enabled: true
            },
            lowFPS: {
                threshold: 20,
                enabled: true
            },
            highMemoryUsage: {
                threshold: 150,
                enabled: true
            },
            longResponseTime: {
                threshold: 1000,
                enabled: true
            }
        };
    },

    /**
     * 开始指标收集
     */
    startMetricsCollection: function () {
        // 优化：开始收集指标
        setInterval(() => {
            this.collectMetrics();
        }, 60000); // 每分钟收集一次
    },

    /**
     * 收集指标
     */
    collectMetrics: function () {
        if (!this.operationsConfig.monitoringEnabled) {
            return;
        }

        // 优化：收集FPS指标
        this.metrics.fps = state.avgFPS || 0;

        // 优化：收集内存指标
        if (performance.memory) {
            this.metrics.memory = performance.memory.usedJSHeapSize / 1024 / 1024;
        }

        // 优化：收集错误率指标
        this.metrics.errorRate = this.calculateErrorRate();

        // 优化：收集响应时间指标
        this.metrics.responseTime = this.calculateResponseTime();

        // 优化：检查警报
        this.checkAlerts();

        // 优化：保存指标历史
        this.saveMetricsHistory();
    },

    /**
     * 计算错误率
     * @returns {number} 错误率
     */
    calculateErrorRate: function () {
        const errorCount = this.metrics.errorCount || 0;
        const totalRequests = this.metrics.totalRequests || 1;
        return errorCount / totalRequests;
    },

    /**
     * 计算响应时间
     * @returns {number} 响应时间
     */
    calculateResponseTime: function () {
        const responseTimes = this.metrics.responseTimes || [];
        if (responseTimes.length === 0) {
            return 0;
        }

        const sum = responseTimes.reduce((acc, time) => acc + time, 0);
        return sum / responseTimes.length;
    },

    /**
     * 检查警报
     */
    checkAlerts: function () {
        // 优化：检查错误率警报
        if (this.alertRules.highErrorRate.enabled && this.metrics.errorRate > this.alertRules.highErrorRate.threshold) {
            this.createAlert('highErrorRate', `错误率过高: ${this.metrics.errorRate.toFixed(2)}`);
        }

        // 优化：检查FPS警报
        if (this.alertRules.lowFPS.enabled && this.metrics.fps < this.alertRules.lowFPS.threshold) {
            this.createAlert('lowFPS', `FPS过低: ${this.metrics.fps.toFixed(2)}`);
        }

        // 优化：检查内存使用警报
        if (this.alertRules.highMemoryUsage.enabled && this.metrics.memory > this.alertRules.highMemoryUsage.threshold) {
            this.createAlert('highMemoryUsage', `内存使用过高: ${this.metrics.memory.toFixed(2)}MB`);
        }

        // 优化：检查响应时间警报
        if (this.alertRules.longResponseTime.enabled && this.metrics.responseTime > this.alertRules.longResponseTime.threshold) {
            this.createAlert('longResponseTime', `响应时间过长: ${this.metrics.responseTime.toFixed(2)}ms`);
        }
    },

    /**
     * 创建警报
     * @param {string} alertType - 警报类型
     * @param {string} message - 消息
     */
    createAlert: function (alertType, message) {
        const alert = {
            type: alertType,
            message: message,
            timestamp: Date.now(),
            acknowledged: false
        };

        this.alerts.push(alert);

        // 优化：限制警报数量
        if (this.alerts.length > 1000) {
            this.alerts.shift();
        }

        // 优化：输出警报
        console.warn(`运维警报: ${alertType} - ${message}`);
    },

    /**
     * 确认警报
     * @param {string} alertId - 警报ID
     */
    acknowledgeAlert: function (alertId) {
        const alert = this.alerts.find(a => a.timestamp === alertId);

        if (alert) {
            alert.acknowledged = true;
        }
    },

    /**
     * 保存指标历史
     */
    saveMetricsHistory: function () {
        const historyEntry = {
            timestamp: Date.now(),
            metrics: { ...this.metrics }
        };

        this.operationsHistory.push(historyEntry);

        // 优化：限制历史记录大小
        if (this.operationsHistory.length > this.maxHistorySize) {
            this.operationsHistory.shift();
        }
    },

    /**
     * 获取指标历史
     * @param {Object} options - 查询选项
     * @returns {Array} 指标历史
     */
    getMetricsHistory: function (options) {
        let history = [...this.operationsHistory];

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 获取警报
     * @param {Object} options - 查询选项
     * @returns {Array} 警报数组
     */
    getAlerts: function (options) {
        let alerts = [...this.alerts];

        // 优化：按类型过滤
        if (options && options.type) {
            alerts = alerts.filter(a => a.type === options.type);
        }

        // 优化：按确认状态过滤
        if (options && options.acknowledged !== undefined) {
            alerts = alerts.filter(a => a.acknowledged === options.acknowledged);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            alerts = alerts.filter(a => a.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            alerts = alerts.filter(a => a.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            alerts = alerts.slice(-options.limit);
        }

        return alerts;
    },

    /**
     * 备份数据
     * @returns {Promise<Object>} 备份结果
     */
    backupData: function () {
        return new Promise((resolve, reject) => {
            if (!this.operationsConfig.backupEnabled) {
                reject(new Error('备份功能未启用'));
                return;
            }

            const backupResult = {
                success: true,
                timestamp: Date.now(),
                size: 0,
                errors: []
            };

            try {
                // 优化：备份数据
                const data = {
                    state: state,
                    metrics: this.metrics,
                    alerts: this.alerts
                };

                const backupData = JSON.stringify(data);
                backupResult.size = backupData.length;

                // 优化：保存到本地存储
                localStorage.setItem('gameBackup', backupData);

                resolve(backupResult);
            } catch (error) {
                backupResult.success = false;
                backupResult.errors.push(error.message);
                reject(backupResult);
            }
        });
    },

    /**
     * 恢复数据
     * @returns {Promise<Object>} 恢复结果
     */
    restoreData: function () {
        return new Promise((resolve, reject) => {
            const restoreResult = {
                success: true,
                timestamp: Date.now(),
                errors: []
            };

            try {
                // 优化：从本地存储恢复数据
                const backupData = localStorage.getItem('gameBackup');

                if (!backupData) {
                    restoreResult.success = false;
                    restoreResult.errors.push('没有找到备份数据');
                    reject(restoreResult);
                    return;
                }

                const data = JSON.parse(backupData);

                // 优化：恢复状态
                Object.assign(state, data.state);

                // 优化：恢复指标
                this.metrics = data.metrics;

                // 优化：恢复警报
                this.alerts = data.alerts;

                resolve(restoreResult);
            } catch (error) {
                restoreResult.success = false;
                restoreResult.errors.push(error.message);
                reject(restoreResult);
            }
        });
    },

    /**
     * 清理日志
     * @returns {Promise<Object>} 清理结果
     */
    cleanupLogs: function () {
        return new Promise((resolve) => {
            const cleanupResult = {
                success: true,
                timestamp: Date.now(),
                deletedLogs: 0
            };

            // 优化：清理过期日志
            const retentionDate = Date.now() - (this.operationsConfig.logRetentionDays * 24 * 60 * 60 * 1000);

            const originalSize = this.operationsHistory.length;
            this.operationsHistory = this.operationsHistory.filter(h => h.timestamp > retentionDate);

            cleanupResult.deletedLogs = originalSize - this.operationsHistory.length;

            resolve(cleanupResult);
        });
    },

    /**
     * 设置运维配置
     * @param {Object} config - 配置对象
     */
    setOperationsConfig: function (config) {
        this.operationsConfig = { ...this.operationsConfig, ...config };
        this.saveOperationsConfig();
    },

    /**
     * 获取运维配置
     * @returns {Object} 配置对象
     */
    getOperationsConfig: function () {
        return this.operationsConfig;
    },

    /**
     * 获取当前指标
     * @returns {Object} 指标对象
     */
    getCurrentMetrics: function () {
        return this.metrics;
    },

    /**
     * 清空运维缓存
     */
    clearCache: function () {
        this.operationsCache = {};
    },

    /**
     * 清空警报
     */
    clearAlerts: function () {
        this.alerts = [];
    },

    /**
     * 清空运维历史
     */
    clearHistory: function () {
        this.operationsHistory = [];
    },

    /**
     * 重置运维
     */
    reset: function () {
        this.clearCache();
        this.clearAlerts();
        this.clearHistory();
        this.metrics = {};
    },

    /**
     * 获取运维统计信息
     * @returns {Object} 统计信息
     */
    getOperationsStats: function () {
        return {
            monitoringEnabled: this.operationsConfig.monitoringEnabled,
            alertingEnabled: this.operationsConfig.alertingEnabled,
            backupEnabled: this.operationsConfig.backupEnabled,
            totalAlerts: this.alerts.length,
            unacknowledgedAlerts: this.alerts.filter(a => !a.acknowledged).length,
            totalHistory: this.operationsHistory.length,
            maxHistorySize: this.maxHistorySize,
            cacheSize: Object.keys(this.operationsCache).length
        };
    }
};

// 优化：游戏维护性能优化
const GameMaintenanceOptimizer = {
    maintenanceConfig: {},
    maintenanceTasks: [],
    maintenanceHistory: [],
    maxHistorySize: 100,
    maintenanceCache: {},

    /**
     * 初始化游戏维护
     */
    init: function () {
        this.loadMaintenanceConfig();
        this.loadMaintenanceTasks();
    },

    /**
     * 加载维护配置
     */
    loadMaintenanceConfig: function () {
        // 优化：加载默认维护配置
        this.maintenanceConfig = {
            autoMaintenanceEnabled: true,
            maintenanceInterval: 86400000, // 24小时
            dataCleanupEnabled: true,
            cacheCleanupEnabled: true,
            logCleanupEnabled: true,
            backupEnabled: true
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('maintenanceConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.maintenanceConfig = { ...this.maintenanceConfig, ...config };
            } catch (error) {
                console.error('加载维护配置失败:', error);
            }
        }
    },

    /**
     * 保存维护配置
     */
    saveMaintenanceConfig: function () {
        localStorage.setItem('maintenanceConfig', JSON.stringify(this.maintenanceConfig));
    },

    /**
     * 加载维护任务
     */
    loadMaintenanceTasks: function () {
        // 优化：加载默认维护任务
        this.maintenanceTasks = [
            {
                name: 'cleanup-data',
                description: '清理过期数据',
                callback: () => this.cleanupData(),
                enabled: true
            },
            {
                name: 'cleanup-cache',
                description: '清理缓存',
                callback: () => this.cleanupCache(),
                enabled: true
            },
            {
                name: 'cleanup-logs',
                description: '清理日志',
                callback: () => this.cleanupLogs(),
                enabled: true
            },
            {
                name: 'optimize-database',
                description: '优化数据库',
                callback: () => this.optimizeDatabase(),
                enabled: true
            },
            {
                name: 'verify-integrity',
                description: '验证数据完整性',
                callback: () => this.verifyIntegrity(),
                enabled: true
            },
            {
                name: 'backup-data',
                description: '备份数据',
                callback: () => this.backupData(),
                enabled: true
            }
        ];
    },

    /**
     * 添加维护任务
     * @param {string} name - 任务名称
     * @param {string} description - 描述
     * @param {Function} callback - 回调函数
     */
    addMaintenanceTask: function (name, description, callback) {
        this.maintenanceTasks.push({
            name: name,
            description: description,
            callback: callback,
            enabled: true
        });
    },

    /**
     * 移除维护任务
     * @param {string} name - 任务名称
     */
    removeMaintenanceTask: function (name) {
        this.maintenanceTasks = this.maintenanceTasks.filter(t => t.name !== name);
    },

    /**
     * 运行维护
     * @returns {Promise<Object>} 维护结果
     */
    runMaintenance: function () {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const maintenanceResult = {
                success: true,
                duration: 0,
                tasks: [],
                errors: []
            };

            // 优化：运行维护任务
            this.runMaintenanceTasks(maintenanceResult).then(() => {
                maintenanceResult.duration = performance.now() - startTime;

                // 优化：保存维护历史
                this.saveMaintenanceHistory(maintenanceResult);

                resolve(maintenanceResult);
            }).catch(error => {
                maintenanceResult.success = false;
                maintenanceResult.duration = performance.now() - startTime;
                maintenanceResult.errors.push(error.message);

                // 优化：保存维护历史
                this.saveMaintenanceHistory(maintenanceResult);

                reject(maintenanceResult);
            });
        });
    },

    /**
     * 运行维护任务
     * @param {Object} maintenanceResult - 维护结果
     * @returns {Promise<void>}
     */
    runMaintenanceTasks: function (maintenanceResult) {
        return new Promise((resolve, reject) => {
            const enabledTasks = this.maintenanceTasks.filter(t => t.enabled);
            let currentIndex = 0;

            const runNextTask = () => {
                if (currentIndex >= enabledTasks.length) {
                    resolve();
                    return;
                }

                const task = enabledTasks[currentIndex];
                const taskStartTime = performance.now();

                try {
                    const result = task.callback();

                    if (result instanceof Promise) {
                        result.then(() => {
                            maintenanceResult.tasks.push({
                                name: task.name,
                                description: task.description,
                                success: true,
                                duration: performance.now() - taskStartTime
                            });

                            currentIndex++;
                            runNextTask();
                        }).catch(error => {
                            maintenanceResult.tasks.push({
                                name: task.name,
                                description: task.description,
                                success: false,
                                duration: performance.now() - taskStartTime,
                                error: error.message
                            });

                            currentIndex++;
                            runNextTask();
                        });
                    } else {
                        maintenanceResult.tasks.push({
                            name: task.name,
                            description: task.description,
                            success: true,
                            duration: performance.now() - taskStartTime
                        });

                        currentIndex++;
                        runNextTask();
                    }
                } catch (error) {
                    maintenanceResult.tasks.push({
                        name: task.name,
                        description: task.description,
                        success: false,
                        duration: performance.now() - taskStartTime,
                        error: error.message
                    });

                    currentIndex++;
                    runNextTask();
                }
            };

            runNextTask();
        });
    },

    /**
     * 清理数据
     * @returns {Promise<Object>} 清理结果
     */
    cleanupData: function () {
        return new Promise((resolve) => {
            const result = {
                deletedItems: 0,
                freedSpace: 0
            };

            // 优化：清理过期数据
            console.log('清理过期数据...');
            resolve(result);
        });
    },

    /**
     * 清理缓存
     * @returns {Promise<Object>} 清理结果
     */
    cleanupCache: function () {
        return new Promise((resolve) => {
            const result = {
                deletedItems: 0,
                freedSpace: 0
            };

            // 优化：清理缓存
            console.log('清理缓存...');
            resolve(result);
        });
    },

    /**
     * 清理日志
     * @returns {Promise<Object>} 清理结果
     */
    cleanupLogs: function () {
        return new Promise((resolve) => {
            const result = {
                deletedItems: 0,
                freedSpace: 0
            };

            // 优化：清理日志
            console.log('清理日志...');
            resolve(result);
        });
    },

    /**
     * 优化数据库
     * @returns {Promise<Object>} 优化结果
     */
    optimizeDatabase: function () {
        return new Promise((resolve) => {
            const result = {
                optimizedTables: 0,
                freedSpace: 0
            };

            // 优化：优化数据库
            console.log('优化数据库...');
            resolve(result);
        });
    },

    /**
     * 验证数据完整性
     * @returns {Promise<Object>} 验证结果
     */
    verifyIntegrity: function () {
        return new Promise((resolve) => {
            const result = {
                verifiedItems: 0,
                corruptedItems: 0,
                fixedItems: 0
            };

            // 优化：验证数据完整性
            console.log('验证数据完整性...');
            resolve(result);
        });
    },

    /**
     * 备份数据
     * @returns {Promise<Object>} 备份结果
     */
    backupData: function () {
        return new Promise((resolve) => {
            const result = {
                backupSize: 0,
                backupLocation: ''
            };

            // 优化：备份数据
            console.log('备份数据...');
            resolve(result);
        });
    },

    /**
     * 保存维护历史
     * @param {Object} maintenanceResult - 维护结果
     */
    saveMaintenanceHistory: function (maintenanceResult) {
        this.maintenanceHistory.push({
            timestamp: Date.now(),
            result: maintenanceResult
        });

        // 优化：限制历史记录大小
        if (this.maintenanceHistory.length > this.maxHistorySize) {
            this.maintenanceHistory.shift();
        }
    },

    /**
     * 获取维护历史
     * @param {Object} options - 查询选项
     * @returns {Array} 维护历史
     */
    getMaintenanceHistory: function (options) {
        let history = [...this.maintenanceHistory];

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：按成功状态过滤
        if (options && options.success !== undefined) {
            history = history.filter(h => h.result.success === options.success);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置维护配置
     * @param {Object} config - 配置对象
     */
    setMaintenanceConfig: function (config) {
        this.maintenanceConfig = { ...this.maintenanceConfig, ...config };
        this.saveMaintenanceConfig();
    },

    /**
     * 获取维护配置
     * @returns {Object} 配置对象
     */
    getMaintenanceConfig: function () {
        return this.maintenanceConfig;
    },

    /**
     * 获取维护任务
     * @returns {Array} 任务列表
     */
    getMaintenanceTasks: function () {
        return this.maintenanceTasks;
    },

    /**
     * 启用维护任务
     * @param {string} taskName - 任务名称
     */
    enableTask: function (taskName) {
        const task = this.maintenanceTasks.find(t => t.name === taskName);

        if (task) {
            task.enabled = true;
        }
    },

    /**
     * 禁用维护任务
     * @param {string} taskName - 任务名称
     */
    disableTask: function (taskName) {
        const task = this.maintenanceTasks.find(t => t.name === taskName);

        if (task) {
            task.enabled = false;
        }
    },

    /**
     * 清空维护缓存
     */
    clearCache: function () {
        this.maintenanceCache = {};
    },

    /**
     * 清空维护历史
     */
    clearHistory: function () {
        this.maintenanceHistory = [];
    },

    /**
     * 重置维护
     */
    reset: function () {
        this.clearCache();
        this.clearHistory();
    },

    /**
     * 获取维护统计信息
     * @returns {Object} 统计信息
     */
    getMaintenanceStats: function () {
        const totalMaintenances = this.maintenanceHistory.length;
        const successfulMaintenances = this.maintenanceHistory.filter(h => h.result.success).length;
        const failedMaintenances = totalMaintenances - successfulMaintenances;

        return {
            totalMaintenances: totalMaintenances,
            successfulMaintenances: successfulMaintenances,
            failedMaintenances: failedMaintenances,
            successRate: totalMaintenances > 0 ? (successfulMaintenances / totalMaintenances * 100).toFixed(2) + '%' : '0%',
            totalTasks: this.maintenanceTasks.length,
            enabledTasks: this.maintenanceTasks.filter(t => t.enabled).length,
            autoMaintenanceEnabled: this.maintenanceConfig.autoMaintenanceEnabled,
            cacheSize: Object.keys(this.maintenanceCache).length
        };
    }
};

// 优化：游戏更新性能优化
const GameUpdateOptimizer = {
    updateConfig: {},
    updateHistory: [],
    maxHistorySize: 100,
    updateCache: {},
    currentVersion: '1.0.0',
    latestVersion: '1.0.0',

    /**
     * 初始化游戏更新
     */
    init: function () {
        this.loadUpdateConfig();
        this.checkForUpdates();
    },

    /**
     * 加载更新配置
     */
    loadUpdateConfig: function () {
        // 优化：加载默认更新配置
        this.updateConfig = {
            autoCheckEnabled: true,
            autoUpdateEnabled: false,
            checkInterval: 86400000, // 24小时
            updateUrl: '',
            backupBeforeUpdate: true
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('updateConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.updateConfig = { ...this.updateConfig, ...config };
            } catch (error) {
                console.error('加载更新配置失败:', error);
            }
        }

        // 优化：从本地存储加载当前版本
        const currentVersion = localStorage.getItem('currentVersion');

        if (currentVersion) {
            this.currentVersion = currentVersion;
        }
    },

    /**
     * 保存更新配置
     */
    saveUpdateConfig: function () {
        localStorage.setItem('updateConfig', JSON.stringify(this.updateConfig));
    },

    /**
     * 保存当前版本
     */
    saveCurrentVersion: function () {
        localStorage.setItem('currentVersion', this.currentVersion);
    },

    /**
     * 检查更新
     * @returns {Promise<Object>} 检查结果
     */
    checkForUpdates: function () {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const checkResult = {
                hasUpdate: false,
                currentVersion: this.currentVersion,
                latestVersion: this.currentVersion,
                duration: 0,
                error: null
            };

            // 优化：检查更新
            console.log('检查更新...');

            // 优化：模拟检查更新
            setTimeout(() => {
                checkResult.duration = performance.now() - startTime;
                checkResult.latestVersion = this.currentVersion;
                checkResult.hasUpdate = false;

                resolve(checkResult);
            }, 1000);
        });
    },

    /**
     * 下载更新
     * @param {string} version - 版本号
     * @returns {Promise<Object>} 下载结果
     */
    downloadUpdate: function (version) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const downloadResult = {
                success: true,
                version: version,
                duration: 0,
                size: 0,
                error: null
            };

            // 优化：下载更新
            console.log(`下载更新 ${version}...`);

            // 优化：模拟下载更新
            setTimeout(() => {
                downloadResult.duration = performance.now() - startTime;
                downloadResult.size = 1024 * 1024; // 1MB

                resolve(downloadResult);
            }, 2000);
        });
    },

    /**
     * 安装更新
     * @param {string} version - 版本号
     * @param {*} updateData - 更新数据
     * @returns {Promise<Object>} 安装结果
     */
    installUpdate: function (version, updateData) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const installResult = {
                success: true,
                version: version,
                duration: 0,
                steps: [],
                errors: []
            };

            // 优化：执行安装步骤
            this.executeInstallSteps(version, installResult).then(() => {
                installResult.duration = performance.now() - startTime;

                // 优化：更新当前版本
                this.currentVersion = version;
                this.saveCurrentVersion();

                // 优化：保存更新历史
                this.saveUpdateHistory(installResult);

                resolve(installResult);
            }).catch(error => {
                installResult.success = false;
                installResult.duration = performance.now() - startTime;
                installResult.errors.push(error.message);

                // 优化：保存更新历史
                this.saveUpdateHistory(installResult);

                reject(installResult);
            });
        });
    },

    /**
     * 执行安装步骤
     * @param {string} version - 版本号
     * @param {Object} installResult - 安装结果
     * @returns {Promise<void>}
     */
    executeInstallSteps: function (version, installResult) {
        return new Promise((resolve, reject) => {
            const steps = [
                {
                    name: 'backup',
                    description: '备份当前版本',
                    callback: () => this.backupCurrentVersion()
                },
                {
                    name: 'validate',
                    description: '验证更新文件',
                    callback: () => this.validateUpdateFiles()
                },
                {
                    name: 'extract',
                    description: '解压更新文件',
                    callback: () => this.extractUpdateFiles()
                },
                {
                    name: 'install',
                    description: '安装更新文件',
                    callback: () => this.installUpdateFiles()
                },
                {
                    name: 'migrate',
                    description: '迁移数据',
                    callback: () => this.migrateData()
                },
                {
                    name: 'verify',
                    description: '验证安装',
                    callback: () => this.verifyInstallation()
                },
                {
                    name: 'cleanup',
                    description: '清理临时文件',
                    callback: () => this.cleanupTempFiles()
                }
            ];

            let currentIndex = 0;

            const runNextStep = () => {
                if (currentIndex >= steps.length) {
                    resolve();
                    return;
                }

                const step = steps[currentIndex];
                const stepStartTime = performance.now();

                try {
                    const result = step.callback();

                    if (result instanceof Promise) {
                        result.then(() => {
                            installResult.steps.push({
                                name: step.name,
                                description: step.description,
                                success: true,
                                duration: performance.now() - stepStartTime
                            });

                            currentIndex++;
                            runNextStep();
                        }).catch(error => {
                            installResult.steps.push({
                                name: step.name,
                                description: step.description,
                                success: false,
                                duration: performance.now() - stepStartTime,
                                error: error.message
                            });

                            currentIndex++;
                            runNextStep();
                        });
                    } else {
                        installResult.steps.push({
                            name: step.name,
                            description: step.description,
                            success: true,
                            duration: performance.now() - stepStartTime
                        });

                        currentIndex++;
                        runNextStep();
                    }
                } catch (error) {
                    installResult.steps.push({
                        name: step.name,
                        description: step.description,
                        success: false,
                        duration: performance.now() - stepStartTime,
                        error: error.message
                    });

                    currentIndex++;
                    runNextStep();
                }
            };

            runNextStep();
        });
    },

    /**
     * 备份当前版本
     * @returns {Promise<void>}
     */
    backupCurrentVersion: function () {
        return new Promise((resolve) => {
            // 优化：备份当前版本
            console.log('备份当前版本...');
            resolve();
        });
    },

    /**
     * 验证更新文件
     * @returns {Promise<void>}
     */
    validateUpdateFiles: function () {
        return new Promise((resolve) => {
            // 优化：验证更新文件
            console.log('验证更新文件...');
            resolve();
        });
    },

    /**
     * 解压更新文件
     * @returns {Promise<void>}
     */
    extractUpdateFiles: function () {
        return new Promise((resolve) => {
            // 优化：解压更新文件
            console.log('解压更新文件...');
            resolve();
        });
    },

    /**
     * 安装更新文件
     * @returns {Promise<void>}
     */
    installUpdateFiles: function () {
        return new Promise((resolve) => {
            // 优化：安装更新文件
            console.log('安装更新文件...');
            resolve();
        });
    },

    /**
     * 迁移数据
     * @returns {Promise<void>}
     */
    migrateData: function () {
        return new Promise((resolve) => {
            // 优化：迁移数据
            console.log('迁移数据...');
            resolve();
        });
    },

    /**
     * 验证安装
     * @returns {Promise<void>}
     */
    verifyInstallation: function () {
        return new Promise((resolve) => {
            // 优化：验证安装
            console.log('验证安装...');
            resolve();
        });
    },

    /**
     * 清理临时文件
     * @returns {Promise<void>}
     */
    cleanupTempFiles: function () {
        return new Promise((resolve) => {
            // 优化：清理临时文件
            console.log('清理临时文件...');
            resolve();
        });
    },

    /**
     * 回滚更新
     * @param {string} version - 版本号
     * @returns {Promise<Object>} 回滚结果
     */
    rollbackUpdate: function (version) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const rollbackResult = {
                success: true,
                version: version,
                duration: 0,
                steps: [],
                errors: []
            };

            // 优化：执行回滚步骤
            this.executeRollbackSteps(version, rollbackResult).then(() => {
                rollbackResult.duration = performance.now() - startTime;

                // 优化：更新当前版本
                this.currentVersion = version;
                this.saveCurrentVersion();

                resolve(rollbackResult);
            }).catch(error => {
                rollbackResult.success = false;
                rollbackResult.duration = performance.now() - startTime;
                rollbackResult.errors.push(error.message);
                reject(rollbackResult);
            });
        });
    },

    /**
     * 执行回滚步骤
     * @param {string} version - 版本号
     * @param {Object} rollbackResult - 回滚结果
     * @returns {Promise<void>}
     */
    executeRollbackSteps: function (version, rollbackResult) {
        return new Promise((resolve) => {
            // 优化：执行回滚步骤
            console.log(`回滚到版本 ${version}...`);
            resolve();
        });
    },

    /**
     * 保存更新历史
     * @param {Object} updateResult - 更新结果
     */
    saveUpdateHistory: function (updateResult) {
        this.updateHistory.push({
            timestamp: Date.now(),
            result: updateResult
        });

        // 优化：限制历史记录大小
        if (this.updateHistory.length > this.maxHistorySize) {
            this.updateHistory.shift();
        }
    },

    /**
     * 获取更新历史
     * @param {Object} options - 查询选项
     * @returns {Array} 更新历史
     */
    getUpdateHistory: function (options) {
        let history = [...this.updateHistory];

        // 优化：按版本过滤
        if (options && options.version) {
            history = history.filter(h => h.result.version === options.version);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：按成功状态过滤
        if (options && options.success !== undefined) {
            history = history.filter(h => h.result.success === options.success);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置更新配置
     * @param {Object} config - 配置对象
     */
    setUpdateConfig: function (config) {
        this.updateConfig = { ...this.updateConfig, ...config };
        this.saveUpdateConfig();
    },

    /**
     * 获取更新配置
     * @returns {Object} 配置对象
     */
    getUpdateConfig: function () {
        return this.updateConfig;
    },

    /**
     * 获取当前版本
     * @returns {string} 当前版本
     */
    getCurrentVersion: function () {
        return this.currentVersion;
    },

    /**
     * 获取最新版本
     * @returns {string} 最新版本
     */
    getLatestVersion: function () {
        return this.latestVersion;
    },

    /**
     * 清空更新缓存
     */
    clearCache: function () {
        this.updateCache = {};
    },

    /**
     * 清空更新历史
     */
    clearHistory: function () {
        this.updateHistory = [];
    },

    /**
     * 重置更新
     */
    reset: function () {
        this.clearCache();
        this.clearHistory();
    },

    /**
     * 获取更新统计信息
     * @returns {Object} 统计信息
     */
    getUpdateStats: function () {
        const totalUpdates = this.updateHistory.length;
        const successfulUpdates = this.updateHistory.filter(h => h.result.success).length;
        const failedUpdates = totalUpdates - successfulUpdates;

        return {
            totalUpdates: totalUpdates,
            successfulUpdates: successfulUpdates,
            failedUpdates: failedUpdates,
            successRate: totalUpdates > 0 ? (successfulUpdates / totalUpdates * 100).toFixed(2) + '%' : '0%',
            currentVersion: this.currentVersion,
            latestVersion: this.latestVersion,
            hasUpdate: this.currentVersion !== this.latestVersion,
            autoCheckEnabled: this.updateConfig.autoCheckEnabled,
            autoUpdateEnabled: this.updateConfig.autoUpdateEnabled,
            cacheSize: Object.keys(this.updateCache).length
        };
    }
};

// 优化：游戏升级性能优化
const GameUpgradeOptimizer = {
    upgradeConfig: {},
    upgradeHistory: [],
    maxHistorySize: 100,
    upgradeCache: {},
    currentLevel: 1,
    maxLevel: 100,

    /**
     * 初始化游戏升级
     */
    init: function () {
        this.loadUpgradeConfig();
        this.loadPlayerLevel();
    },

    /**
     * 加载升级配置
     */
    loadUpgradeConfig: function () {
        // 优化：加载默认升级配置
        this.upgradeConfig = {
            autoUpgradeEnabled: false,
            upgradeCostMultiplier: 1.5,
            upgradeRewardMultiplier: 1.2,
            maxLevel: 100
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('upgradeConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.upgradeConfig = { ...this.upgradeConfig, ...config };
            } catch (error) {
                console.error('加载升级配置失败:', error);
            }
        }
    },

    /**
     * 保存升级配置
     */
    saveUpgradeConfig: function () {
        localStorage.setItem('upgradeConfig', JSON.stringify(this.upgradeConfig));
    },

    /**
     * 加载玩家等级
     */
    loadPlayerLevel: function () {
        // 优化：从本地存储加载玩家等级
        const playerLevel = localStorage.getItem('playerLevel');

        if (playerLevel) {
            this.currentLevel = parseInt(playerLevel, 10);
        }
    },

    /**
     * 保存玩家等级
     */
    savePlayerLevel: function () {
        localStorage.setItem('playerLevel', this.currentLevel.toString());
    },

    /**
     * 计算升级所需经验
     * @param {number} level - 等级
     * @returns {number} 所需经验
     */
    calculateRequiredXP: function (level) {
        // 优化：计算升级所需经验
        return Math.floor(100 * Math.pow(this.upgradeConfig.upgradeCostMultiplier, level - 1));
    },

    /**
     * 计算升级奖励
     * @param {number} level - 等级
     * @returns {Object} 奖励对象
     */
    calculateUpgradeReward: function (level) {
        // 优化：计算升级奖励
        return {
            maxHealth: Math.floor(100 * Math.pow(this.upgradeConfig.upgradeRewardMultiplier, level - 1)),
            attack: Math.floor(10 * Math.pow(this.upgradeConfig.upgradeRewardMultiplier, level - 1)),
            defense: Math.floor(5 * Math.pow(this.upgradeConfig.upgradeRewardMultiplier, level - 1)),
            speed: Math.floor(2 * Math.pow(this.upgradeConfig.upgradeRewardMultiplier, level - 1))
        };
    },

    /**
     * 检查是否可以升级
     * @param {number} currentXP - 当前经验
     * @returns {boolean} 是否可以升级
     */
    canUpgrade: function (currentXP) {
        const requiredXP = this.calculateRequiredXP(this.currentLevel);
        return currentXP >= requiredXP && this.currentLevel < this.maxLevel;
    },

    /**
     * 升级
     * @param {number} currentXP - 当前经验
     * @returns {Promise<Object>} 升级结果
     */
    upgrade: function (currentXP) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const upgradeResult = {
                success: false,
                currentLevel: this.currentLevel,
                newLevel: this.currentLevel,
                requiredXP: 0,
                remainingXP: 0,
                rewards: {},
                duration: 0,
                error: null
            };

            // 优化：检查是否可以升级
            if (!this.canUpgrade(currentXP)) {
                upgradeResult.error = '经验不足或已达到最高等级';
                upgradeResult.duration = performance.now() - startTime;
                reject(upgradeResult);
                return;
            }

            // 优化：计算升级
            const requiredXP = this.calculateRequiredXP(this.currentLevel);
            const remainingXP = currentXP - requiredXP;

            // 优化：执行升级
            this.executeUpgrade().then(rewards => {
                upgradeResult.success = true;
                upgradeResult.newLevel = this.currentLevel;
                upgradeResult.requiredXP = requiredXP;
                upgradeResult.remainingXP = remainingXP;
                upgradeResult.rewards = rewards;
                upgradeResult.duration = performance.now() - startTime;

                // 优化：保存升级历史
                this.saveUpgradeHistory(upgradeResult);

                resolve(upgradeResult);
            }).catch(error => {
                upgradeResult.error = error.message;
                upgradeResult.duration = performance.now() - startTime;

                // 优化：保存升级历史
                this.saveUpgradeHistory(upgradeResult);

                reject(upgradeResult);
            });
        });
    },

    /**
     * 执行升级
     * @returns {Promise<Object>} 奖励对象
     */
    executeUpgrade: function () {
        return new Promise((resolve, reject) => {
            try {
                // 优化：增加等级
                this.currentLevel++;

                // 优化：检查是否超过最大等级
                if (this.currentLevel > this.maxLevel) {
                    this.currentLevel = this.maxLevel;
                }

                // 优化：计算奖励
                const rewards = this.calculateUpgradeReward(this.currentLevel);

                // 优化：保存玩家等级
                this.savePlayerLevel();

                // 优化：应用奖励
                this.applyRewards(rewards);

                resolve(rewards);
            } catch (error) {
                reject(error);
            }
        });
    },

    /**
     * 应用奖励
     * @param {Object} rewards - 奖励对象
     */
    applyRewards: function (rewards) {
        // 优化：应用奖励到玩家
        if (state.player) {
            state.player.maxHealth = rewards.maxHealth;
            state.player.attack = rewards.attack;
            state.player.defense = rewards.defense;
            state.player.speed = rewards.speed;
        }
    },

    /**
     * 批量升级
     * @param {number} currentXP - 当前经验
     * @returns {Promise<Object>} 升级结果
     */
    batchUpgrade: function (currentXP) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const batchUpgradeResult = {
                success: true,
                initialLevel: this.currentLevel,
                finalLevel: this.currentLevel,
                totalUpgrades: 0,
                totalRewards: {
                    maxHealth: 0,
                    attack: 0,
                    defense: 0,
                    speed: 0
                },
                duration: 0,
                errors: []
            };

            let xp = currentXP;
            let upgradeCount = 0;

            const upgradeLoop = () => {
                if (!this.canUpgrade(xp)) {
                    batchUpgradeResult.duration = performance.now() - startTime;

                    // 优化：保存升级历史
                    this.saveUpgradeHistory(batchUpgradeResult);

                    resolve(batchUpgradeResult);
                    return;
                }

                this.upgrade(xp).then(result => {
                    upgradeCount++;
                    batchUpgradeResult.totalUpgrades = upgradeCount;
                    batchUpgradeResult.finalLevel = result.newLevel;
                    batchUpgradeResult.totalRewards.maxHealth += result.rewards.maxHealth;
                    batchUpgradeResult.totalRewards.attack += result.rewards.attack;
                    batchUpgradeResult.totalRewards.defense += result.rewards.defense;
                    batchUpgradeResult.totalRewards.speed += result.rewards.speed;

                    xp = result.remainingXP;
                    upgradeLoop();
                }).catch(error => {
                    batchUpgradeResult.errors.push(error.message);
                    batchUpgradeResult.duration = performance.now() - startTime;

                    // 优化：保存升级历史
                    this.saveUpgradeHistory(batchUpgradeResult);

                    resolve(batchUpgradeResult);
                });
            };

            upgradeLoop();
        });
    },

    /**
     * 重置等级
     */
    resetLevel: function () {
        this.currentLevel = 1;
        this.savePlayerLevel();
    },

    /**
     * 保存升级历史
     * @param {Object} upgradeResult - 升级结果
     */
    saveUpgradeHistory: function (upgradeResult) {
        this.upgradeHistory.push({
            timestamp: Date.now(),
            result: upgradeResult
        });

        // 优化：限制历史记录大小
        if (this.upgradeHistory.length > this.maxHistorySize) {
            this.upgradeHistory.shift();
        }
    },

    /**
     * 获取升级历史
     * @param {Object} options - 查询选项
     * @returns {Array} 升级历史
     */
    getUpgradeHistory: function (options) {
        let history = [...this.upgradeHistory];

        // 优化：按等级过滤
        if (options && options.level) {
            history = history.filter(h => h.result.newLevel === options.level);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：按成功状态过滤
        if (options && options.success !== undefined) {
            history = history.filter(h => h.result.success === options.success);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置升级配置
     * @param {Object} config - 配置对象
     */
    setUpgradeConfig: function (config) {
        this.upgradeConfig = { ...this.upgradeConfig, ...config };
        this.saveUpgradeConfig();
    },

    /**
     * 获取升级配置
     * @returns {Object} 配置对象
     */
    getUpgradeConfig: function () {
        return this.upgradeConfig;
    },

    /**
     * 获取当前等级
     * @returns {number} 当前等级
     */
    getCurrentLevel: function () {
        return this.currentLevel;
    },

    /**
     * 获取最大等级
     * @returns {number} 最大等级
     */
    getMaxLevel: function () {
        return this.maxLevel;
    },

    /**
     * 获取下一级所需经验
     * @returns {number} 所需经验
     */
    getNextLevelXP: function () {
        return this.calculateRequiredXP(this.currentLevel);
    },

    /**
     * 清空升级缓存
     */
    clearCache: function () {
        this.upgradeCache = {};
    },

    /**
     * 清空升级历史
     */
    clearHistory: function () {
        this.upgradeHistory = [];
    },

    /**
     * 重置升级
     */
    reset: function () {
        this.clearCache();
        this.clearHistory();
        this.resetLevel();
    },

    /**
     * 获取升级统计信息
     * @returns {Object} 统计信息
     */
    getUpgradeStats: function () {
        const totalUpgrades = this.upgradeHistory.filter(h => h.result.success).length;
        const failedUpgrades = this.upgradeHistory.filter(h => !h.result.success).length;

        return {
            currentLevel: this.currentLevel,
            maxLevel: this.maxLevel,
            totalUpgrades: totalUpgrades,
            failedUpgrades: failedUpgrades,
            successRate: (totalUpgrades + failedUpgrades) > 0 ? (totalUpgrades / (totalUpgrades + failedUpgrades) * 100).toFixed(2) + '%' : '0%',
            nextLevelXP: this.getNextLevelXP(),
            autoUpgradeEnabled: this.upgradeConfig.autoUpgradeEnabled,
            cacheSize: Object.keys(this.upgradeCache).length
        };
    }
};

// 优化：游戏成就性能优化
const GameAchievementOptimizer = {
    achievements: {},
    achievementHistory: [],
    maxHistorySize: 1000,
    achievementCache: {},
    achievementProgress: {},

    /**
     * 初始化游戏成就
     */
    init: function () {
        this.loadAchievements();
        this.loadAchievementProgress();
    },

    /**
     * 加载成就
     */
    loadAchievements: function () {
        // 优化：加载默认成就
        this.achievements = {
            'first_blood': {
                id: 'first_blood',
                name: '初次击杀',
                description: '击败第一个敌人',
                icon: '⚔️',
                rarity: 'common',
                xpReward: 100,
                condition: {
                    type: 'kill_count',
                    target: 1
                }
            },
            'killer_10': {
                id: 'killer_10',
                name: '十杀',
                description: '击败10个敌人',
                icon: '💀',
                rarity: 'common',
                xpReward: 200,
                condition: {
                    type: 'kill_count',
                    target: 10
                }
            },
            'killer_100': {
                id: 'killer_100',
                name: '百杀',
                description: '击败100个敌人',
                icon: '☠️',
                rarity: 'rare',
                xpReward: 1000,
                condition: {
                    type: 'kill_count',
                    target: 100
                }
            },
            'survivor': {
                id: 'survivor',
                name: '生存者',
                description: '存活10分钟',
                icon: '🛡️',
                rarity: 'common',
                xpReward: 150,
                condition: {
                    type: 'survival_time',
                    target: 600
                }
            },
            'speed_demon': {
                id: 'speed_demon',
                name: '速度恶魔',
                description: '在1分钟内完成关卡',
                icon: '⚡',
                rarity: 'rare',
                xpReward: 500,
                condition: {
                    type: 'level_completion_time',
                    target: 60
                }
            },
            'perfect_level': {
                id: 'perfect_level',
                name: '完美通关',
                description: '无伤完成关卡',
                icon: '🏆',
                rarity: 'epic',
                xpReward: 2000,
                condition: {
                    type: 'perfect_level',
                    target: 1
                }
            },
            'combo_master': {
                id: 'combo_master',
                name: '连击大师',
                description: '达到50连击',
                icon: '🔥',
                rarity: 'rare',
                xpReward: 800,
                condition: {
                    type: 'combo_count',
                    target: 50
                }
            },
            'treasure_hunter': {
                id: 'treasure_hunter',
                name: '宝藏猎人',
                description: '收集100个道具',
                icon: '💎',
                rarity: 'rare',
                xpReward: 600,
                condition: {
                    type: 'item_collection',
                    target: 100
                }
            },
            'level_master': {
                id: 'level_master',
                name: '关卡大师',
                description: '完成所有关卡',
                icon: '👑',
                rarity: 'legendary',
                xpReward: 5000,
                condition: {
                    type: 'level_completion',
                    target: 'all'
                }
            },
            'millionaire': {
                id: 'millionaire',
                name: '百万富翁',
                description: '获得100万分',
                icon: '💰',
                rarity: 'epic',
                xpReward: 3000,
                condition: {
                    type: 'score',
                    target: 1000000
                }
            }
        };
    },

    /**
     * 加载成就进度
     */
    loadAchievementProgress: function () {
        // 优化：从本地存储加载成就进度
        const progress = localStorage.getItem('achievementProgress');

        if (progress) {
            try {
                this.achievementProgress = JSON.parse(progress);
            } catch (error) {
                console.error('加载成就进度失败:', error);
            }
        }
    },

    /**
     * 保存成就进度
     */
    saveAchievementProgress: function () {
        localStorage.setItem('achievementProgress', JSON.stringify(this.achievementProgress));
    },

    /**
     * 检查成就
     * @param {string} type - 事件类型
     * @param {*} data - 事件数据
     */
    checkAchievement: function (type, data) {
        // 优化：遍历所有成就
        for (const achievementId in this.achievements) {
            const achievement = this.achievements[achievementId];

            // 优化：检查成就是否已解锁
            if (this.isAchievementUnlocked(achievementId)) {
                continue;
            }

            // 优化：检查成就条件
            if (this.checkAchievementCondition(achievement, type, data)) {
                // 优化：解锁成就
                this.unlockAchievement(achievementId);
            }
        }
    },

    /**
     * 检查成就条件
     * @param {Object} achievement - 成就对象
     * @param {string} type - 事件类型
     * @param {*} data - 事件数据
     * @returns {boolean} 是否满足条件
     */
    checkAchievementCondition: function (achievement, type, data) {
        const condition = achievement.condition;

        switch (condition.type) {
            case 'kill_count':
                return type === 'kill' && (this.achievementProgress[achievement.id] || 0) + 1 >= condition.target;

            case 'survival_time':
                return type === 'survival_time' && data.time >= condition.target;

            case 'level_completion_time':
                return type === 'level_complete' && data.time <= condition.target;

            case 'perfect_level':
                return type === 'level_complete' && data.damageTaken === 0;

            case 'combo_count':
                return type === 'combo' && data.combo >= condition.target;

            case 'item_collection':
                return type === 'item_collect' && (this.achievementProgress[achievement.id] || 0) + 1 >= condition.target;

            case 'level_completion':
                return type === 'level_complete' && (condition.target === 'all' || data.level === condition.target);

            case 'score':
                return type === 'score' && data.score >= condition.target;

            default:
                return false;
        }
    },

    /**
     * 解锁成就
     * @param {string} achievementId - 成就ID
     */
    unlockAchievement: function (achievementId) {
        const achievement = this.achievements[achievementId];

        if (!achievement) {
            return;
        }

        // 优化：标记成就为已解锁
        this.achievementProgress[achievementId] = {
            unlocked: true,
            unlockedAt: Date.now()
        };

        // 优化：保存成就进度
        this.saveAchievementProgress();

        // 优化：保存成就历史
        this.saveAchievementHistory(achievementId);

        // 优化：显示成就通知
        this.showAchievementNotification(achievement);

        // 优化：奖励XP
        this.rewardXP(achievement.xpReward);
    },

    /**
     * 检查成就是否已解锁
     * @param {string} achievementId - 成就ID
     * @returns {boolean} 是否已解锁
     */
    isAchievementUnlocked: function (achievementId) {
        const progress = this.achievementProgress[achievementId];
        return progress && progress.unlocked;
    },

    /**
     * 更新成就进度
     * @param {string} achievementId - 成就ID
     * @param {number} progress - 进度值
     */
    updateAchievementProgress: function (achievementId, progress) {
        if (!this.achievementProgress[achievementId]) {
            this.achievementProgress[achievementId] = {
                progress: 0
            };
        }

        this.achievementProgress[achievementId].progress = progress;
        this.saveAchievementProgress();
    },

    /**
     * 保存成就历史
     * @param {string} achievementId - 成就ID
     */
    saveAchievementHistory: function (achievementId) {
        this.achievementHistory.push({
            timestamp: Date.now(),
            achievementId: achievementId
        });

        // 优化：限制历史记录大小
        if (this.achievementHistory.length > this.maxHistorySize) {
            this.achievementHistory.shift();
        }
    },

    /**
     * 显示成就通知
     * @param {Object} achievement - 成就对象
     */
    showAchievementNotification: function (achievement) {
        // 优化：显示成就通知
        console.log(`成就解锁: ${achievement.icon} ${achievement.name} - ${achievement.description}`);

        // 优化：可以在这里添加UI通知
        if (typeof messageBus !== 'undefined') {
            messageBus.emit('achievement_unlocked', achievement);
        }
    },

    /**
     * 奖励XP
     * @param {number} xp - XP值
     */
    rewardXP: function (xp) {
        // 优化：奖励XP
        if (typeof GameUpgradeOptimizer !== 'undefined') {
            GameUpgradeOptimizer.upgrade(xp);
        }
    },

    /**
     * 获取成就列表
     * @param {Object} options - 查询选项
     * @returns {Array} 成就列表
     */
    getAchievements: function (options) {
        let achievements = Object.values(this.achievements);

        // 优化：按稀有度过滤
        if (options && options.rarity) {
            achievements = achievements.filter(a => a.rarity === options.rarity);
        }

        // 优化：按解锁状态过滤
        if (options && options.unlocked !== undefined) {
            achievements = achievements.filter(a => this.isAchievementUnlocked(a.id) === options.unlocked);
        }

        // 优化：限制数量
        if (options && options.limit) {
            achievements = achievements.slice(0, options.limit);
        }

        return achievements;
    },

    /**
     * 获取成就进度
     * @param {string} achievementId - 成就ID
     * @returns {Object} 进度对象
     */
    getAchievementProgress: function (achievementId) {
        return this.achievementProgress[achievementId] || {
            progress: 0,
            unlocked: false
        };
    },

    /**
     * 获取成就历史
     * @param {Object} options - 查询选项
     * @returns {Array} 成就历史
     */
    getAchievementHistory: function (options) {
        let history = [...this.achievementHistory];

        // 优化：按成就ID过滤
        if (options && options.achievementId) {
            history = history.filter(h => h.achievementId === options.achievementId);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 获取已解锁成就数量
     * @returns {number} 已解锁成就数量
     */
    getUnlockedCount: function () {
        return Object.keys(this.achievements).filter(id => this.isAchievementUnlocked(id)).length;
    },

    /**
     * 获取总成就数量
     * @returns {number} 总成就数量
     */
    getTotalCount: function () {
        return Object.keys(this.achievements).length;
    },

    /**
     * 添加成就
     * @param {Object} achievement - 成就对象
     */
    addAchievement: function (achievement) {
        this.achievements[achievement.id] = achievement;
    },

    /**
     * 移除成就
     * @param {string} achievementId - 成就ID
     */
    removeAchievement: function (achievementId) {
        delete this.achievements[achievementId];
    },

    /**
     * 清空成就缓存
     */
    clearCache: function () {
        this.achievementCache = {};
    },

    /**
     * 清空成就历史
     */
    clearHistory: function () {
        this.achievementHistory = [];
    },

    /**
     * 重置成就
     */
    reset: function () {
        this.clearCache();
        this.clearHistory();
        this.achievementProgress = {};
        this.saveAchievementProgress();
    },

    /**
     * 获取成就统计信息
     * @returns {Object} 统计信息
     */
    getAchievementStats: function () {
        const achievements = Object.values(this.achievements);
        const unlockedCount = this.getUnlockedCount();

        return {
            totalCount: achievements.length,
            unlockedCount: unlockedCount,
            lockedCount: achievements.length - unlockedCount,
            completionRate: achievements.length > 0 ? (unlockedCount / achievements.length * 100).toFixed(2) + '%' : '0%',
            totalHistory: this.achievementHistory.length,
            maxHistorySize: this.maxHistorySize,
            cacheSize: Object.keys(this.achievementCache).length
        };
    }
};

// 优化：游戏排行榜性能优化
const GameLeaderboardOptimizer = {
    leaderboardConfig: {},
    leaderboards: {},
    leaderboardCache: {},
    leaderboardHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏排行榜
     */
    init: function () {
        this.loadLeaderboardConfig();
        this.loadLeaderboards();
    },

    /**
     * 加载排行榜配置
     */
    loadLeaderboardConfig: function () {
        // 优化：加载默认排行榜配置
        this.leaderboardConfig = {
            maxEntries: 100,
            updateInterval: 60000,
            autoRefresh: false
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('leaderboardConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.leaderboardConfig = { ...this.leaderboardConfig, ...config };
            } catch (error) {
                console.error('加载排行榜配置失败:', error);
            }
        }
    },

    /**
     * 保存排行榜配置
     */
    saveLeaderboardConfig: function () {
        localStorage.setItem('leaderboardConfig', JSON.stringify(this.leaderboardConfig));
    },

    /**
     * 加载排行榜
     */
    loadLeaderboards: function () {
        // 优化：加载默认排行榜
        this.leaderboards = {
            'daily': {
                name: '每日排行榜',
                type: 'daily',
                entries: []
            },
            'weekly': {
                name: '每周排行榜',
                type: 'weekly',
                entries: []
            },
            'monthly': {
                name: '每月排行榜',
                type: 'monthly',
                entries: []
            },
            'all_time': {
                name: '总排行榜',
                type: 'all_time',
                entries: []
            }
        };

        // 优化：从本地存储加载排行榜数据
        const savedLeaderboards = localStorage.getItem('leaderboards');

        if (savedLeaderboards) {
            try {
                const leaderboards = JSON.parse(savedLeaderboards);
                this.leaderboards = { ...this.leaderboards, ...leaderboards };
            } catch (error) {
                console.error('加载排行榜失败:', error);
            }
        }
    },

    /**
     * 保存排行榜
     */
    saveLeaderboards: function () {
        localStorage.setItem('leaderboards', JSON.stringify(this.leaderboards));
    },

    /**
     * 提交分数
     * @param {string} leaderboardId - 排行榜ID
     * @param {Object} entry - 分数条目
     * @returns {Promise<Object>} 提交结果
     */
    submitScore: function (leaderboardId, entry) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const submitResult = {
                success: true,
                leaderboardId: leaderboardId,
                entry: entry,
                rank: 0,
                duration: 0,
                error: null
            };

            // 优化：检查排行榜是否存在
            if (!this.leaderboards[leaderboardId]) {
                submitResult.success = false;
                submitResult.error = `排行榜 ${leaderboardId} 不存在`;
                submitResult.duration = performance.now() - startTime;
                reject(submitResult);
                return;
            }

            // 优化：添加分数条目
            const leaderboard = this.leaderboards[leaderboardId];
            leaderboard.entries.push(entry);

            // 优化：排序排行榜
            this.sortLeaderboard(leaderboard);

            // 优化：限制条目数量
            if (leaderboard.entries.length > this.leaderboardConfig.maxEntries) {
                leaderboard.entries = leaderboard.entries.slice(0, this.leaderboardConfig.maxEntries);
            }

            // 优化：保存排行榜
            this.saveLeaderboards();

            // 优化：计算排名
            submitResult.rank = this.getRank(leaderboardId, entry.playerId);
            submitResult.duration = performance.now() - startTime;

            // 优化：保存提交历史
            this.saveSubmitHistory(submitResult);

            resolve(submitResult);
        });
    },

    /**
     * 排序排行榜
     * @param {Object} leaderboard - 排行榜对象
     */
    sortLeaderboard: function (leaderboard) {
        // 优化：按分数降序排序
        leaderboard.entries.sort((a, b) => b.score - a.score);
    },

    /**
     * 获取排名
     * @param {string} leaderboardId - 排行榜ID
     * @param {string} playerId - 玩家ID
     * @returns {number} 排名
     */
    getRank: function (leaderboardId, playerId) {
        const leaderboard = this.leaderboards[leaderboardId];

        if (!leaderboard) {
            return -1;
        }

        const index = leaderboard.entries.findIndex(entry => entry.playerId === playerId);

        return index !== -1 ? index + 1 : -1;
    },

    /**
     * 获取排行榜
     * @param {string} leaderboardId - 排行榜ID
     * @param {Object} options - 查询选项
     * @returns {Array} 排行榜条目
     */
    getLeaderboard: function (leaderboardId, options) {
        const leaderboard = this.leaderboards[leaderboardId];

        if (!leaderboard) {
            return [];
        }

        let entries = [...leaderboard.entries];

        // 优化：按玩家ID过滤
        if (options && options.playerId) {
            entries = entries.filter(e => e.playerId === options.playerId);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            entries = entries.filter(e => e.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            entries = entries.filter(e => e.timestamp <= options.endTime);
        }

        // 优化：按分数范围过滤
        if (options && options.minScore) {
            entries = entries.filter(e => e.score >= options.minScore);
        }

        if (options && options.maxScore) {
            entries = entries.filter(e => e.score <= options.maxScore);
        }

        // 优化：限制数量
        if (options && options.limit) {
            entries = entries.slice(0, options.limit);
        }

        // 优化：偏移量
        if (options && options.offset) {
            entries = entries.slice(options.offset);
        }

        return entries;
    },

    /**
     * 获取所有排行榜
     * @returns {Object} 排行榜对象
     */
    getAllLeaderboards: function () {
        return this.leaderboards;
    },

    /**
     * 获取玩家排名
     * @param {string} playerId - 玩家ID
     * @returns {Object} 玩家排名对象
     */
    getPlayerRanks: function (playerId) {
        const ranks = {};

        for (const leaderboardId in this.leaderboards) {
            ranks[leaderboardId] = {
                name: this.leaderboards[leaderboardId].name,
                rank: this.getRank(leaderboardId, playerId),
                score: this.getPlayerScore(leaderboardId, playerId)
            };
        }

        return ranks;
    },

    /**
     * 获取玩家分数
     * @param {string} leaderboardId - 排行榜ID
     * @param {string} playerId - 玩家ID
     * @returns {number} 玩家分数
     */
    getPlayerScore: function (leaderboardId, playerId) {
        const leaderboard = this.leaderboards[leaderboardId];

        if (!leaderboard) {
            return 0;
        }

        const entry = leaderboard.entries.find(e => e.playerId === playerId);

        return entry ? entry.score : 0;
    },

    /**
     * 获取排行榜统计信息
     * @param {string} leaderboardId - 排行榜ID
     * @returns {Object} 统计信息
     */
    getLeaderboardStats: function (leaderboardId) {
        const leaderboard = this.leaderboards[leaderboardId];

        if (!leaderboard) {
            return null;
        }

        const entries = leaderboard.entries;

        if (entries.length === 0) {
            return {
                name: leaderboard.name,
                type: leaderboard.type,
                totalEntries: 0,
                highestScore: 0,
                lowestScore: 0,
                averageScore: 0,
                totalPlayers: 0
            };
        }

        const scores = entries.map(e => e.score);
        const totalScore = scores.reduce((acc, score) => acc + score, 0);

        return {
            name: leaderboard.name,
            type: leaderboard.type,
            totalEntries: entries.length,
            highestScore: Math.max(...scores),
            lowestScore: Math.min(...scores),
            averageScore: totalScore / scores.length,
            totalPlayers: new Set(entries.map(e => e.playerId)).size
        };
    },

    /**
     * 保存提交历史
     * @param {Object} submitResult - 提交结果
     */
    saveSubmitHistory: function (submitResult) {
        this.leaderboardHistory.push({
            timestamp: Date.now(),
            result: submitResult
        });

        // 优化：限制历史记录大小
        if (this.leaderboardHistory.length > this.maxHistorySize) {
            this.leaderboardHistory.shift();
        }
    },

    /**
     * 获取提交历史
     * @param {Object} options - 查询选项
     * @returns {Array} 提交历史
     */
    getSubmitHistory: function (options) {
        let history = [...this.leaderboardHistory];

        // 优化：按排行榜ID过滤
        if (options && options.leaderboardId) {
            history = history.filter(h => h.result.leaderboardId === options.leaderboardId);
        }

        // 优化：按玩家ID过滤
        if (options && options.playerId) {
            history = history.filter(h => h.result.entry.playerId === options.playerId);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：按成功状态过滤
        if (options && options.success !== undefined) {
            history = history.filter(h => h.result.success === options.success);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 添加排行榜
     * @param {string} leaderboardId - 排行榜ID
     * @param {Object} leaderboard - 排行榜对象
     */
    addLeaderboard: function (leaderboardId, leaderboard) {
        this.leaderboards[leaderboardId] = leaderboard;
        this.saveLeaderboards();
    },

    /**
     * 移除排行榜
     * @param {string} leaderboardId - 排行榜ID
     */
    removeLeaderboard: function (leaderboardId) {
        delete this.leaderboards[leaderboardId];
        this.saveLeaderboards();
    },

    /**
     * 清空排行榜
     * @param {string} leaderboardId - 排行榜ID
     */
    clearLeaderboard: function (leaderboardId) {
        if (this.leaderboards[leaderboardId]) {
            this.leaderboards[leaderboardId].entries = [];
            this.saveLeaderboards();
        }
    },

    /**
     * 设置排行榜配置
     * @param {Object} config - 配置对象
     */
    setLeaderboardConfig: function (config) {
        this.leaderboardConfig = { ...this.leaderboardConfig, ...config };
        this.saveLeaderboardConfig();
    },

    /**
     * 获取排行榜配置
     * @returns {Object} 配置对象
     */
    getLeaderboardConfig: function () {
        return this.leaderboardConfig;
    },

    /**
     * 清空排行榜缓存
     */
    clearCache: function () {
        this.leaderboardCache = {};
    },

    /**
     * 清空提交历史
     */
    clearHistory: function () {
        this.leaderboardHistory = [];
    },

    /**
     * 重置排行榜
     */
    reset: function () {
        this.clearCache();
        this.clearHistory();
        this.loadLeaderboards();
    },

    /**
     * 获取排行榜统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const totalLeaderboards = Object.keys(this.leaderboards).length;
        const totalEntries = Object.values(this.leaderboards).reduce((acc, lb) => acc + lb.entries.length, 0);

        return {
            totalLeaderboards: totalLeaderboards,
            totalEntries: totalEntries,
            maxEntries: this.leaderboardConfig.maxEntries,
            autoRefresh: this.leaderboardConfig.autoRefresh,
            totalHistory: this.leaderboardHistory.length,
            maxHistorySize: this.maxHistorySize,
            cacheSize: Object.keys(this.leaderboardCache).length
        };
    }
};

// 优化：游戏社交性能优化
const GameSocialOptimizer = {
    socialConfig: {},
    friends: {},
    friendRequests: {},
    socialCache: {},
    socialHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏社交
     */
    init: function () {
        this.loadSocialConfig();
        this.loadFriends();
        this.loadFriendRequests();
    },

    /**
     * 加载社交配置
     */
    loadSocialConfig: function () {
        // 优化：加载默认社交配置
        this.socialConfig = {
            maxFriends: 100,
            maxFriendRequests: 50,
            enableNotifications: true,
            enableAutoAccept: false
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('socialConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.socialConfig = { ...this.socialConfig, ...config };
            } catch (error) {
                console.error('加载社交配置失败:', error);
            }
        }
    },

    /**
     * 保存社交配置
     */
    saveSocialConfig: function () {
        localStorage.setItem('socialConfig', JSON.stringify(this.socialConfig));
    },

    /**
     * 加载好友列表
     */
    loadFriends: function () {
        // 优化：从本地存储加载好友列表
        const savedFriends = localStorage.getItem('friends');

        if (savedFriends) {
            try {
                this.friends = JSON.parse(savedFriends);
            } catch (error) {
                console.error('加载好友列表失败:', error);
            }
        }
    },

    /**
     * 保存好友列表
     */
    saveFriends: function () {
        localStorage.setItem('friends', JSON.stringify(this.friends));
    },

    /**
     * 加载好友请求
     */
    loadFriendRequests: function () {
        // 优化：从本地存储加载好友请求
        const savedRequests = localStorage.getItem('friendRequests');

        if (savedRequests) {
            try {
                this.friendRequests = JSON.parse(savedRequests);
            } catch (error) {
                console.error('加载好友请求失败:', error);
            }
        }
    },

    /**
     * 保存好友请求
     */
    saveFriendRequests: function () {
        localStorage.setItem('friendRequests', JSON.stringify(this.friendRequests));
    },

    /**
     * 发送好友请求
     * @param {string} playerId - 玩家ID
     * @param {string} playerName - 玩家名称
     * @returns {Promise<Object>} 请求结果
     */
    sendFriendRequest: function (playerId, playerName) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const requestResult = {
                success: true,
                playerId: playerId,
                playerName: playerName,
                requestId: this.generateRequestId(),
                timestamp: Date.now(),
                duration: 0,
                error: null
            };

            // 优化：检查好友数量限制
            if (Object.keys(this.friends).length >= this.socialConfig.maxFriends) {
                requestResult.success = false;
                requestResult.error = '好友数量已达上限';
                requestResult.duration = performance.now() - startTime;
                reject(requestResult);
                return;
            }

            // 优化：检查是否已经是好友
            if (this.friends[playerId]) {
                requestResult.success = false;
                requestResult.error = '已经是好友';
                requestResult.duration = performance.now() - startTime;
                reject(requestResult);
                return;
            }

            // 优化：检查是否已经发送过请求
            for (const requestId in this.friendRequests) {
                const request = this.friendRequests[requestId];
                if (request.playerId === playerId && request.status === 'pending') {
                    requestResult.success = false;
                    requestResult.error = '好友请求已发送';
                    requestResult.duration = performance.now() - startTime;
                    reject(requestResult);
                    return;
                }
            }

            // 优化：添加好友请求
            this.friendRequests[requestResult.requestId] = {
                playerId: playerId,
                playerName: playerName,
                status: 'pending',
                timestamp: requestResult.timestamp
            };

            // 优化：保存好友请求
            this.saveFriendRequests();

            // 优化：保存社交历史
            this.saveSocialHistory('friend_request_sent', {
                requestId: requestResult.requestId,
                playerId: playerId,
                playerName: playerName
            });

            requestResult.duration = performance.now() - startTime;
            resolve(requestResult);
        });
    },

    /**
     * 接受好友请求
     * @param {string} requestId - 请求ID
     * @returns {Promise<Object>} 请求结果
     */
    acceptFriendRequest: function (requestId) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const requestResult = {
                success: true,
                requestId: requestId,
                duration: 0,
                error: null
            };

            // 优化：检查请求是否存在
            const request = this.friendRequests[requestId];

            if (!request) {
                requestResult.success = false;
                requestResult.error = '好友请求不存在';
                requestResult.duration = performance.now() - startTime;
                reject(requestResult);
                return;
            }

            // 优化：检查好友数量限制
            if (Object.keys(this.friends).length >= this.socialConfig.maxFriends) {
                requestResult.success = false;
                requestResult.error = '好友数量已达上限';
                requestResult.duration = performance.now() - startTime;
                reject(requestResult);
                return;
            }

            // 优化：添加好友
            this.friends[request.playerId] = {
                name: request.playerName,
                addedAt: Date.now(),
                status: 'online'
            };

            // 优化：删除好友请求
            delete this.friendRequests[requestId];

            // 优化：保存好友列表
            this.saveFriends();

            // 优化：保存好友请求
            this.saveFriendRequests();

            // 优化：保存社交历史
            this.saveSocialHistory('friend_request_accepted', {
                requestId: requestId,
                playerId: request.playerId,
                playerName: request.playerName
            });

            requestResult.duration = performance.now() - startTime;
            resolve(requestResult);
        });
    },

    /**
     * 拒绝好友请求
     * @param {string} requestId - 请求ID
     * @returns {Promise<Object>} 请求结果
     */
    rejectFriendRequest: function (requestId) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const requestResult = {
                success: true,
                requestId: requestId,
                duration: 0,
                error: null
            };

            // 优化：检查请求是否存在
            const request = this.friendRequests[requestId];

            if (!request) {
                requestResult.success = false;
                requestResult.error = '好友请求不存在';
                requestResult.duration = performance.now() - startTime;
                reject(requestResult);
                return;
            }

            // 优化：删除好友请求
            delete this.friendRequests[requestId];

            // 优化：保存好友请求
            this.saveFriendRequests();

            // 优化：保存社交历史
            this.saveSocialHistory('friend_request_rejected', {
                requestId: requestId,
                playerId: request.playerId,
                playerName: request.playerName
            });

            requestResult.duration = performance.now() - startTime;
            resolve(requestResult);
        });
    },

    /**
     * 移除好友
     * @param {string} playerId - 玩家ID
     * @returns {Promise<Object>} 请求结果
     */
    removeFriend: function (playerId) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const requestResult = {
                success: true,
                playerId: playerId,
                duration: 0,
                error: null
            };

            // 优化：检查好友是否存在
            if (!this.friends[playerId]) {
                requestResult.success = false;
                requestResult.error = '好友不存在';
                requestResult.duration = performance.now() - startTime;
                reject(requestResult);
                return;
            }

            // 优化：移除好友
            delete this.friends[playerId];

            // 优化：保存好友列表
            this.saveFriends();

            // 优化：保存社交历史
            this.saveSocialHistory('friend_removed', {
                playerId: playerId,
                playerName: this.friends[playerId].name
            });

            requestResult.duration = performance.now() - startTime;
            resolve(requestResult);
        });
    },

    /**
     * 获取好友列表
     * @param {Object} options - 查询选项
     * @returns {Array} 好友列表
     */
    getFriends: function (options) {
        let friends = Object.keys(this.friends).map(playerId => ({
            playerId: playerId,
            ...this.friends[playerId]
        }));

        // 优化：按状态过滤
        if (options && options.status) {
            friends = friends.filter(f => f.status === options.status);
        }

        // 优化：按名称搜索
        if (options && options.search) {
            const search = options.search.toLowerCase();
            friends = friends.filter(f => f.name.toLowerCase().includes(search));
        }

        // 优化：按添加时间过滤
        if (options && options.startTime) {
            friends = friends.filter(f => f.addedAt >= options.startTime);
        }

        if (options && options.endTime) {
            friends = friends.filter(f => f.addedAt <= options.endTime);
        }

        // 优化：排序
        if (options && options.sortBy) {
            friends.sort((a, b) => {
                if (options.sortBy === 'name') {
                    return a.name.localeCompare(b.name);
                } else if (options.sortBy === 'addedAt') {
                    return b.addedAt - a.addedAt;
                }
                return 0;
            });
        }

        // 优化：限制数量
        if (options && options.limit) {
            friends = friends.slice(0, options.limit);
        }

        // 优化：偏移量
        if (options && options.offset) {
            friends = friends.slice(options.offset);
        }

        return friends;
    },

    /**
     * 获取好友请求列表
     * @param {Object} options - 查询选项
     * @returns {Array} 好友请求列表
     */
    getFriendRequests: function (options) {
        let requests = Object.keys(this.friendRequests).map(requestId => ({
            requestId: requestId,
            ...this.friendRequests[requestId]
        }));

        // 优化：按状态过滤
        if (options && options.status) {
            requests = requests.filter(r => r.status === options.status);
        }

        // 优化：按名称搜索
        if (options && options.search) {
            const search = options.search.toLowerCase();
            requests = requests.filter(r => r.playerName.toLowerCase().includes(search));
        }

        // 优化：按时间过滤
        if (options && options.startTime) {
            requests = requests.filter(r => r.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            requests = requests.filter(r => r.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            requests = requests.slice(0, options.limit);
        }

        return requests;
    },

    /**
     * 获取好友数量
     * @returns {number} 好友数量
     */
    getFriendCount: function () {
        return Object.keys(this.friends).length;
    },

    /**
     * 获取好友请求数量
     * @returns {number} 好友请求数量
     */
    getFriendRequestCount: function () {
        return Object.keys(this.friendRequests).length;
    },

    /**
     * 生成请求ID
     * @returns {string} 请求ID
     */
    generateRequestId: function () {
        return 'req_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    },

    /**
     * 保存社交历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveSocialHistory: function (action, data) {
        this.socialHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        // 优化：限制历史记录大小
        if (this.socialHistory.length > this.maxHistorySize) {
            this.socialHistory.shift();
        }
    },

    /**
     * 获取社交历史
     * @param {Object} options - 查询选项
     * @returns {Array} 社交历史
     */
    getSocialHistory: function (options) {
        let history = [...this.socialHistory];

        // 优化：按操作类型过滤
        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置社交配置
     * @param {Object} config - 配置对象
     */
    setSocialConfig: function (config) {
        this.socialConfig = { ...this.socialConfig, ...config };
        this.saveSocialConfig();
    },

    /**
     * 获取社交配置
     * @returns {Object} 配置对象
     */
    getSocialConfig: function () {
        return this.socialConfig;
    },

    /**
     * 清空社交缓存
     */
    clearCache: function () {
        this.socialCache = {};
    },

    /**
     * 清空社交历史
     */
    clearHistory: function () {
        this.socialHistory = [];
    },

    /**
     * 重置社交系统
     */
    reset: function () {
        this.clearCache();
        this.clearHistory();
        this.loadSocialConfig();
        this.loadFriends();
        this.loadFriendRequests();
    },

    /**
     * 获取社交统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            friendCount: this.getFriendCount(),
            friendRequestCount: this.getFriendRequestCount(),
            maxFriends: this.socialConfig.maxFriends,
            maxFriendRequests: this.socialConfig.maxFriendRequests,
            enableNotifications: this.socialConfig.enableNotifications,
            enableAutoAccept: this.socialConfig.enableAutoAccept,
            totalHistory: this.socialHistory.length,
            maxHistorySize: this.maxHistorySize,
            cacheSize: Object.keys(this.socialCache).size
        };
    }
};

// 优化：游戏通知性能优化
const GameNotificationOptimizer = {
    notificationConfig: {},
    notifications: {},
    notificationQueue: [],
    notificationHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏通知
     */
    init: function () {
        this.loadNotificationConfig();
        this.loadNotifications();
        this.checkNotificationPermission();
    },

    /**
     * 加载通知配置
     */
    loadNotificationConfig: function () {
        // 优化：加载默认通知配置
        this.notificationConfig = {
            enabled: true,
            soundEnabled: true,
            vibrationEnabled: true,
            desktopEnabled: false,
            maxQueueSize: 50,
            displayDuration: 3000,
            animationDuration: 300
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('notificationConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.notificationConfig = { ...this.notificationConfig, ...config };
            } catch (error) {
                console.error('加载通知配置失败:', error);
            }
        }
    },

    /**
     * 保存通知配置
     */
    saveNotificationConfig: function () {
        localStorage.setItem('notificationConfig', JSON.stringify(this.notificationConfig));
    },

    /**
     * 加载通知
     */
    loadNotifications: function () {
        // 优化：从本地存储加载通知
        const savedNotifications = localStorage.getItem('notifications');

        if (savedNotifications) {
            try {
                this.notifications = JSON.parse(savedNotifications);
            } catch (error) {
                console.error('加载通知失败:', error);
            }
        }
    },

    /**
     * 保存通知
     */
    saveNotifications: function () {
        localStorage.setItem('notifications', JSON.stringify(this.notifications));
    },

    /**
     * 检查通知权限
     */
    checkNotificationPermission: function () {
        // 优化：检查通知权限
        if ('Notification' in window) {
            if (Notification.permission === 'default') {
                // 优化：请求通知权限
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        console.log('通知权限已授予');
                    }
                });
            }
        }
    },

    /**
     * 发送通知
     * @param {string} type - 通知类型
     * @param {Object} data - 通知数据
     * @returns {Promise<Object>} 通知结果
     */
    sendNotification: function (type, data) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const notificationResult = {
                success: true,
                type: type,
                notificationId: this.generateNotificationId(),
                timestamp: Date.now(),
                duration: 0,
                error: null
            };

            // 优化：检查通知是否启用
            if (!this.notificationConfig.enabled) {
                notificationResult.success = false;
                notificationResult.error = '通知已禁用';
                notificationResult.duration = performance.now() - startTime;
                reject(notificationResult);
                return;
            }

            // 优化：创建通知
            const notification = {
                id: notificationResult.notificationId,
                type: type,
                title: data.title || '通知',
                message: data.message || '',
                icon: data.icon || '',
                priority: data.priority || 'normal',
                timestamp: notificationResult.timestamp,
                read: false
            };

            // 优化：添加通知到队列
            this.notificationQueue.push(notification);

            // 优化：限制队列大小
            if (this.notificationQueue.length > this.notificationConfig.maxQueueSize) {
                this.notificationQueue.shift();
            }

            // 优化：显示通知
            this.showNotification(notification);

            // 优化：保存通知
            this.notifications[notification.id] = notification;
            this.saveNotifications();

            // 优化：保存通知历史
            this.saveNotificationHistory(notification);

            notificationResult.duration = performance.now() - startTime;
            resolve(notificationResult);
        });
    },

    /**
     * 显示通知
     * @param {Object} notification - 通知对象
     */
    showNotification: function (notification) {
        // 优化：显示桌面通知
        if (this.notificationConfig.desktopEnabled && 'Notification' in window && Notification.permission === 'granted') {
            const desktopNotification = new Notification(notification.title, {
                body: notification.message,
                icon: notification.icon
            });

            // 优化：自动关闭通知
            setTimeout(() => {
                desktopNotification.close();
            }, this.notificationConfig.displayDuration);
        }

        // 优化：显示游戏内通知
        this.showInGameNotification(notification);

        // 优化：播放通知声音
        if (this.notificationConfig.soundEnabled) {
            this.playNotificationSound(notification.type);
        }

        // 优化：震动
        if (this.notificationConfig.vibrationEnabled && 'vibrate' in navigator) {
            navigator.vibrate(200);
        }
    },

    /**
     * 显示游戏内通知
     * @param {Object} notification - 通知对象
     */
    showInGameNotification: function (notification) {
        // 优化：显示游戏内通知
        console.log(`[${notification.type}] ${notification.title}: ${notification.message}`);

        // 优化：可以在这里添加游戏内UI通知
        if (typeof messageBus !== 'undefined') {
            messageBus.emit('notification_show', notification);
        }
    },

    /**
     * 播放通知声音
     * @param {string} type - 通知类型
     */
    playNotificationSound: function (type) {
        // 优化：播放通知声音
        // 可以根据通知类型播放不同的声音
    },

    /**
     * 标记通知为已读
     * @param {string} notificationId - 通知ID
     */
    markAsRead: function (notificationId) {
        if (this.notifications[notificationId]) {
            this.notifications[notificationId].read = true;
            this.saveNotifications();
        }
    },

    /**
     * 删除通知
     * @param {string} notificationId - 通知ID
     */
    deleteNotification: function (notificationId) {
        if (this.notifications[notificationId]) {
            delete this.notifications[notificationId];
            this.saveNotifications();
        }
    },

    /**
     * 清空所有通知
     */
    clearAllNotifications: function () {
        this.notifications = {};
        this.notificationQueue = [];
        this.saveNotifications();
    },

    /**
     * 获取通知
     * @param {string} notificationId - 通知ID
     * @returns {Object} 通知对象
     */
    getNotification: function (notificationId) {
        return this.notifications[notificationId] || null;
    },

    /**
     * 获取通知列表
     * @param {Object} options - 查询选项
     * @returns {Array} 通知列表
     */
    getNotifications: function (options) {
        let notifications = Object.values(this.notifications);

        // 优化：按类型过滤
        if (options && options.type) {
            notifications = notifications.filter(n => n.type === options.type);
        }

        // 优化：按已读状态过滤
        if (options && options.read !== undefined) {
            notifications = notifications.filter(n => n.read === options.read);
        }

        // 优化：按优先级过滤
        if (options && options.priority) {
            notifications = notifications.filter(n => n.priority === options.priority);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            notifications = notifications.filter(n => n.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            notifications = notifications.filter(n => n.timestamp <= options.endTime);
        }

        // 优化：排序
        if (options && options.sortBy) {
            notifications.sort((a, b) => {
                if (options.sortBy === 'timestamp') {
                    return b.timestamp - a.timestamp;
                } else if (options.sortBy === 'priority') {
                    const priorityOrder = { 'high': 3, 'normal': 2, 'low': 1 };
                    return priorityOrder[b.priority] - priorityOrder[a.priority];
                }
                return 0;
            });
        }

        // 优化：限制数量
        if (options && options.limit) {
            notifications = notifications.slice(0, options.limit);
        }

        // 优化：偏移量
        if (options && options.offset) {
            notifications = notifications.slice(options.offset);
        }

        return notifications;
    },

    /**
     * 获取未读通知数量
     * @returns {number} 未读通知数量
     */
    getUnreadCount: function () {
        return Object.values(this.notifications).filter(n => !n.read).length;
    },

    /**
     * 获取通知队列
     * @returns {Array} 通知队列
     */
    getNotificationQueue: function () {
        return this.notificationQueue;
    },

    /**
     * 处理通知队列
     */
    processNotificationQueue: function () {
        // 优化：处理通知队列
        while (this.notificationQueue.length > 0) {
            const notification = this.notificationQueue.shift();
            this.showNotification(notification);
        }
    },

    /**
     * 生成通知ID
     * @returns {string} 通知ID
     */
    generateNotificationId: function () {
        return 'notif_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    },

    /**
     * 保存通知历史
     * @param {Object} notification - 通知对象
     */
    saveNotificationHistory: function (notification) {
        this.notificationHistory.push({
            timestamp: Date.now(),
            notification: notification
        });

        // 优化：限制历史记录大小
        if (this.notificationHistory.length > this.maxHistorySize) {
            this.notificationHistory.shift();
        }
    },

    /**
     * 获取通知历史
     * @param {Object} options - 查询选项
     * @returns {Array} 通知历史
     */
    getNotificationHistory: function (options) {
        let history = [...this.notificationHistory];

        // 优化：按通知类型过滤
        if (options && options.type) {
            history = history.filter(h => h.notification.type === options.type);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置通知配置
     * @param {Object} config - 配置对象
     */
    setNotificationConfig: function (config) {
        this.notificationConfig = { ...this.notificationConfig, ...config };
        this.saveNotificationConfig();
    },

    /**
     * 获取通知配置
     * @returns {Object} 配置对象
     */
    getNotificationConfig: function () {
        return this.notificationConfig;
    },

    /**
     * 重置通知系统
     */
    reset: function () {
        this.notificationQueue = [];
        this.notificationHistory = [];
        this.loadNotificationConfig();
        this.loadNotifications();
    },

    /**
     * 获取通知统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const notifications = Object.values(this.notifications);
        const unreadCount = notifications.filter(n => !n.read).length;

        return {
            totalNotifications: notifications.length,
            unreadCount: unreadCount,
            readCount: notifications.length - unreadCount,
            queueSize: this.notificationQueue.length,
            maxQueueSize: this.notificationConfig.maxQueueSize,
            enabled: this.notificationConfig.enabled,
            soundEnabled: this.notificationConfig.soundEnabled,
            vibrationEnabled: this.notificationConfig.vibrationEnabled,
            desktopEnabled: this.notificationConfig.desktopEnabled,
            totalHistory: this.notificationHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏反馈性能优化
const GameFeedbackOptimizer = {
    feedbackConfig: {},
    feedbacks: {},
    feedbackQueue: [],
    feedbackHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏反馈
     */
    init: function () {
        this.loadFeedbackConfig();
        this.loadFeedbacks();
    },

    /**
     * 加载反馈配置
     */
    loadFeedbackConfig: function () {
        // 优化：加载默认反馈配置
        this.feedbackConfig = {
            enabled: true,
            autoSubmit: false,
            maxQueueSize: 50,
            submitInterval: 300000,
            feedbackTypes: ['bug', 'suggestion', 'complaint', 'praise', 'other']
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('feedbackConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.feedbackConfig = { ...this.feedbackConfig, ...config };
            } catch (error) {
                console.error('加载反馈配置失败:', error);
            }
        }
    },

    /**
     * 保存反馈配置
     */
    saveFeedbackConfig: function () {
        localStorage.setItem('feedbackConfig', JSON.stringify(this.feedbackConfig));
    },

    /**
     * 加载反馈
     */
    loadFeedbacks: function () {
        // 优化：从本地存储加载反馈
        const savedFeedbacks = localStorage.getItem('feedbacks');

        if (savedFeedbacks) {
            try {
                this.feedbacks = JSON.parse(savedFeedbacks);
            } catch (error) {
                console.error('加载反馈失败:', error);
            }
        }
    },

    /**
     * 保存反馈
     */
    saveFeedbacks: function () {
        localStorage.setItem('feedbacks', JSON.stringify(this.feedbacks));
    },

    /**
     * 提交反馈
     * @param {string} type - 反馈类型
     * @param {Object} data - 反馈数据
     * @returns {Promise<Object>} 反馈结果
     */
    submitFeedback: function (type, data) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const feedbackResult = {
                success: true,
                type: type,
                feedbackId: this.generateFeedbackId(),
                timestamp: Date.now(),
                duration: 0,
                error: null
            };

            // 优化：检查反馈是否启用
            if (!this.feedbackConfig.enabled) {
                feedbackResult.success = false;
                feedbackResult.error = '反馈已禁用';
                feedbackResult.duration = performance.now() - startTime;
                reject(feedbackResult);
                return;
            }

            // 优化：检查反馈类型
            if (!this.feedbackConfig.feedbackTypes.includes(type)) {
                feedbackResult.success = false;
                feedbackResult.error = '无效的反馈类型';
                feedbackResult.duration = performance.now() - startTime;
                reject(feedbackResult);
                return;
            }

            // 优化：创建反馈
            const feedback = {
                id: feedbackResult.feedbackId,
                type: type,
                title: data.title || '反馈',
                message: data.message || '',
                rating: data.rating || 0,
                attachments: data.attachments || [],
                platform: this.getPlatform(),
                browser: this.getBrowser(),
                timestamp: feedbackResult.timestamp,
                status: 'pending'
            };

            // 优化：添加反馈到队列
            this.feedbackQueue.push(feedback);

            // 优化：限制队列大小
            if (this.feedbackQueue.length > this.feedbackConfig.maxQueueSize) {
                this.feedbackQueue.shift();
            }

            // 优化：保存反馈
            this.feedbacks[feedback.id] = feedback;
            this.saveFeedbacks();

            // 优化：保存反馈历史
            this.saveFeedbackHistory(feedback);

            // 优化：自动提交反馈
            if (this.feedbackConfig.autoSubmit) {
                this.processFeedbackQueue();
            }

            feedbackResult.duration = performance.now() - startTime;
            resolve(feedbackResult);
        });
    },

    /**
     * 处理反馈队列
     * @returns {Promise<Object>} 处理结果
     */
    processFeedbackQueue: function () {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const processResult = {
                success: true,
                processedCount: 0,
                failedCount: 0,
                duration: 0,
                error: null
            };

            // 优化：处理反馈队列
            while (this.feedbackQueue.length > 0) {
                const feedback = this.feedbackQueue.shift();

                try {
                    // 优化：提交反馈到服务器
                    // 这里可以添加实际的API调用
                    console.log('提交反馈:', feedback);

                    // 优化：更新反馈状态
                    if (this.feedbacks[feedback.id]) {
                        this.feedbacks[feedback.id].status = 'submitted';
                        this.feedbacks[feedback.id].submittedAt = Date.now();
                    }

                    processResult.processedCount++;
                } catch (error) {
                    console.error('提交反馈失败:', error);
                    processResult.failedCount++;
                }
            }

            // 优化：保存反馈
            this.saveFeedbacks();

            processResult.duration = performance.now() - startTime;
            resolve(processResult);
        });
    },

    /**
     * 获取平台信息
     * @returns {string} 平台信息
     */
    getPlatform: function () {
        return navigator.platform || 'unknown';
    },

    /**
     * 获取浏览器信息
     * @returns {string} 浏览器信息
     */
    getBrowser: function () {
        const userAgent = navigator.userAgent;

        if (userAgent.includes('Chrome')) {
            return 'Chrome';
        } else if (userAgent.includes('Firefox')) {
            return 'Firefox';
        } else if (userAgent.includes('Safari')) {
            return 'Safari';
        } else if (userAgent.includes('Edge')) {
            return 'Edge';
        } else {
            return 'unknown';
        }
    },

    /**
     * 获取反馈
     * @param {string} feedbackId - 反馈ID
     * @returns {Object} 反馈对象
     */
    getFeedback: function (feedbackId) {
        return this.feedbacks[feedbackId] || null;
    },

    /**
     * 获取反馈列表
     * @param {Object} options - 查询选项
     * @returns {Array} 反馈列表
     */
    getFeedbacks: function (options) {
        let feedbacks = Object.values(this.feedbacks);

        // 优化：按类型过滤
        if (options && options.type) {
            feedbacks = feedbacks.filter(f => f.type === options.type);
        }

        // 优化：按状态过滤
        if (options && options.status) {
            feedbacks = feedbacks.filter(f => f.status === options.status);
        }

        // 优化：按评级过滤
        if (options && options.minRating) {
            feedbacks = feedbacks.filter(f => f.rating >= options.minRating);
        }

        if (options && options.maxRating) {
            feedbacks = feedbacks.filter(f => f.rating <= options.maxRating);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            feedbacks = feedbacks.filter(f => f.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            feedbacks = feedbacks.filter(f => f.timestamp <= options.endTime);
        }

        // 优化：排序
        if (options && options.sortBy) {
            feedbacks.sort((a, b) => {
                if (options.sortBy === 'timestamp') {
                    return b.timestamp - a.timestamp;
                } else if (options.sortBy === 'rating') {
                    return b.rating - a.rating;
                }
                return 0;
            });
        }

        // 优化：限制数量
        if (options && options.limit) {
            feedbacks = feedbacks.slice(0, options.limit);
        }

        // 优化：偏移量
        if (options && options.offset) {
            feedbacks = feedbacks.slice(options.offset);
        }

        return feedbacks;
    },

    /**
     * 获取反馈队列
     * @returns {Array} 反馈队列
     */
    getFeedbackQueue: function () {
        return this.feedbackQueue;
    },

    /**
     * 生成反馈ID
     * @returns {string} 反馈ID
     */
    generateFeedbackId: function () {
        return 'fb_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    },

    /**
     * 保存反馈历史
     * @param {Object} feedback - 反馈对象
     */
    saveFeedbackHistory: function (feedback) {
        this.feedbackHistory.push({
            timestamp: Date.now(),
            feedback: feedback
        });

        // 优化：限制历史记录大小
        if (this.feedbackHistory.length > this.maxHistorySize) {
            this.feedbackHistory.shift();
        }
    },

    /**
     * 获取反馈历史
     * @param {Object} options - 查询选项
     * @returns {Array} 反馈历史
     */
    getFeedbackHistory: function (options) {
        let history = [...this.feedbackHistory];

        // 优化：按反馈类型过滤
        if (options && options.type) {
            history = history.filter(h => h.feedback.type === options.type);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置反馈配置
     * @param {Object} config - 配置对象
     */
    setFeedbackConfig: function (config) {
        this.feedbackConfig = { ...this.feedbackConfig, ...config };
        this.saveFeedbackConfig();
    },

    /**
     * 获取反馈配置
     * @returns {Object} 配置对象
     */
    getFeedbackConfig: function () {
        return this.feedbackConfig;
    },

    /**
     * 清空反馈队列
     */
    clearFeedbackQueue: function () {
        this.feedbackQueue = [];
    },

    /**
     * 重置反馈系统
     */
    reset: function () {
        this.feedbackQueue = [];
        this.feedbackHistory = [];
        this.loadFeedbackConfig();
        this.loadFeedbacks();
    },

    /**
     * 获取反馈统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const feedbacks = Object.values(this.feedbacks);
        const typeStats = {};

        // 优化：按类型统计
        this.feedbackConfig.feedbackTypes.forEach(type => {
            typeStats[type] = feedbacks.filter(f => f.type === type).length;
        });

        const statusStats = {
            pending: feedbacks.filter(f => f.status === 'pending').length,
            submitted: feedbacks.filter(f => f.status === 'submitted').length
        };

        const ratings = feedbacks.filter(f => f.rating > 0).map(f => f.rating);
        const averageRating = ratings.length > 0 ? ratings.reduce((acc, r) => acc + r, 0) / ratings.length : 0;

        return {
            totalFeedbacks: feedbacks.length,
            typeStats: typeStats,
            statusStats: statusStats,
            averageRating: averageRating.toFixed(2),
            queueSize: this.feedbackQueue.length,
            maxQueueSize: this.feedbackConfig.maxQueueSize,
            enabled: this.feedbackConfig.enabled,
            autoSubmit: this.feedbackConfig.autoSubmit,
            totalHistory: this.feedbackHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏帮助性能优化
const GameHelpOptimizer = {
    helpConfig: {},
    helpTopics: {},
    helpHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏帮助
     */
    init: function () {
        this.loadHelpConfig();
        this.loadHelpTopics();
    },

    /**
     * 加载帮助配置
     */
    loadHelpConfig: function () {
        // 优化：加载默认帮助配置
        this.helpConfig = {
            enabled: true,
            autoShowTutorial: true,
            maxHistorySize: 1000,
            searchEnabled: true,
            favoritesEnabled: true
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('helpConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.helpConfig = { ...this.helpConfig, ...config };
            } catch (error) {
                console.error('加载帮助配置失败:', error);
            }
        }
    },

    /**
     * 保存帮助配置
     */
    saveHelpConfig: function () {
        localStorage.setItem('helpConfig', JSON.stringify(this.helpConfig));
    },

    /**
     * 加载帮助主题
     */
    loadHelpTopics: function () {
        // 优化：加载默认帮助主题
        this.helpTopics = {
            'getting_started': {
                id: 'getting_started',
                title: '开始游戏',
                category: 'basics',
                content: '欢迎来到火柴人冒险游戏！使用方向键或WASD移动，空格键跳跃。',
                icon: '🎮',
                order: 1,
                views: 0,
                favorite: false
            },
            'controls': {
                id: 'controls',
                title: '游戏控制',
                category: 'basics',
                content: '方向键/WASD：移动\n空格键：跳跃\nJ键：攻击\nK键：技能\nL键：道具',
                icon: '🎯',
                order: 2,
                views: 0,
                favorite: false
            },
            'combat': {
                id: 'combat',
                title: '战斗系统',
                category: 'gameplay',
                content: '使用J键攻击敌人，K键释放技能。击败敌人可以获得分数和经验值。',
                icon: '⚔️',
                order: 3,
                views: 0,
                favorite: false
            },
            'items': {
                id: 'items',
                title: '道具系统',
                category: 'gameplay',
                content: '游戏中会随机出现各种道具，收集它们可以获得不同的效果。',
                icon: '🎁',
                order: 4,
                views: 0,
                favorite: false
            },
            'enemies': {
                id: 'enemies',
                title: '敌人类型',
                category: 'gameplay',
                content: '游戏中会出现不同类型的敌人，每种敌人都有独特的攻击方式。',
                icon: '👾',
                order: 5,
                views: 0,
                favorite: false
            },
            'levels': {
                id: 'levels',
                title: '关卡系统',
                category: 'gameplay',
                content: '游戏包含多个关卡，每个关卡都有不同的挑战和奖励。',
                icon: '🏰',
                order: 6,
                views: 0,
                favorite: false
            },
            'achievements': {
                id: 'achievements',
                title: '成就系统',
                category: 'advanced',
                content: '完成特定任务可以解锁成就，获得奖励和荣誉。',
                icon: '🏆',
                order: 7,
                views: 0,
                favorite: false
            },
            'leaderboard': {
                id: 'leaderboard',
                title: '排行榜',
                category: 'advanced',
                content: '在排行榜上与其他玩家竞争，展示你的实力。',
                icon: '📊',
                order: 8,
                views: 0,
                favorite: false
            },
            'tips': {
                id: 'tips',
                title: '游戏技巧',
                category: 'tips',
                content: '1. 合理使用技能可以快速击败敌人\n2. 收集道具可以增强能力\n3. 注意躲避敌人的攻击',
                icon: '💡',
                order: 9,
                views: 0,
                favorite: false
            },
            'faq': {
                id: 'faq',
                title: '常见问题',
                category: 'support',
                content: 'Q: 如何暂停游戏？\nA: 按ESC键暂停游戏。\n\nQ: 如何重新开始？\nA: 按R键重新开始。',
                icon: '❓',
                order: 10,
                views: 0,
                favorite: false
            }
        };

        // 优化：从本地存储加载自定义帮助主题
        const savedTopics = localStorage.getItem('helpTopics');

        if (savedTopics) {
            try {
                const topics = JSON.parse(savedTopics);
                this.helpTopics = { ...this.helpTopics, ...topics };
            } catch (error) {
                console.error('加载帮助主题失败:', error);
            }
        }
    },

    /**
     * 保存帮助主题
     */
    saveHelpTopics: function () {
        localStorage.setItem('helpTopics', JSON.stringify(this.helpTopics));
    },

    /**
     * 获取帮助主题
     * @param {string} topicId - 主题ID
     * @returns {Object} 帮助主题
     */
    getHelpTopic: function (topicId) {
        return this.helpTopics[topicId] || null;
    },

    /**
     * 获取帮助主题列表
     * @param {Object} options - 查询选项
     * @returns {Array} 帮助主题列表
     */
    getHelpTopics: function (options) {
        let topics = Object.values(this.helpTopics);

        // 优化：按分类过滤
        if (options && options.category) {
            topics = topics.filter(t => t.category === options.category);
        }

        // 优化：按收藏过滤
        if (options && options.favorite !== undefined) {
            topics = topics.filter(t => t.favorite === options.favorite);
        }

        // 优化：按搜索过滤
        if (options && options.search) {
            const search = options.search.toLowerCase();
            topics = topics.filter(t =>
                t.title.toLowerCase().includes(search) ||
                t.content.toLowerCase().includes(search)
            );
        }

        // 优化：排序
        if (options && options.sortBy) {
            topics.sort((a, b) => {
                if (options.sortBy === 'order') {
                    return a.order - b.order;
                } else if (options.sortBy === 'views') {
                    return b.views - a.views;
                } else if (options.sortBy === 'title') {
                    return a.title.localeCompare(b.title);
                }
                return 0;
            });
        } else {
            // 优化：默认按顺序排序
            topics.sort((a, b) => a.order - b.order);
        }

        // 优化：限制数量
        if (options && options.limit) {
            topics = topics.slice(0, options.limit);
        }

        // 优化：偏移量
        if (options && options.offset) {
            topics = topics.slice(options.offset);
        }

        return topics;
    },

    /**
     * 搜索帮助主题
     * @param {string} query - 搜索查询
     * @returns {Array} 搜索结果
     */
    searchHelpTopics: function (query) {
        if (!this.helpConfig.searchEnabled) {
            return [];
        }

        const search = query.toLowerCase();
        const results = [];

        // 优化：搜索标题和内容
        for (const topicId in this.helpTopics) {
            const topic = this.helpTopics[topicId];

            if (topic.title.toLowerCase().includes(search) ||
                topic.content.toLowerCase().includes(search)) {
                results.push(topic);
            }
        }

        return results;
    },

    /**
     * 查看帮助主题
     * @param {string} topicId - 主题ID
     */
    viewHelpTopic: function (topicId) {
        const topic = this.helpTopics[topicId];

        if (topic) {
            // 优化：增加查看次数
            topic.views++;

            // 优化：保存帮助主题
            this.saveHelpTopics();

            // 优化：保存查看历史
            this.saveHelpHistory(topicId);
        }
    },

    /**
     * 添加帮助主题到收藏
     * @param {string} topicId - 主题ID
     */
    addFavorite: function (topicId) {
        if (!this.helpConfig.favoritesEnabled) {
            return;
        }

        const topic = this.helpTopics[topicId];

        if (topic) {
            topic.favorite = true;
            this.saveHelpTopics();
        }
    },

    /**
     * 从收藏中移除帮助主题
     * @param {string} topicId - 主题ID
     */
    removeFavorite: function (topicId) {
        const topic = this.helpTopics[topicId];

        if (topic) {
            topic.favorite = false;
            this.saveHelpTopics();
        }
    },

    /**
     * 获取收藏的帮助主题
     * @returns {Array} 收藏的帮助主题
     */
    getFavorites: function () {
        return Object.values(this.helpTopics).filter(t => t.favorite);
    },

    /**
     * 添加帮助主题
     * @param {Object} topic - 帮助主题
     */
    addHelpTopic: function (topic) {
        this.helpTopics[topic.id] = topic;
        this.saveHelpTopics();
    },

    /**
     * 移除帮助主题
     * @param {string} topicId - 主题ID
     */
    removeHelpTopic: function (topicId) {
        delete this.helpTopics[topicId];
        this.saveHelpTopics();
    },

    /**
     * 获取帮助分类
     * @returns {Array} 帮助分类
     */
    getCategories: function () {
        const categories = new Set();

        for (const topicId in this.helpTopics) {
            categories.add(this.helpTopics[topicId].category);
        }

        return Array.from(categories);
    },

    /**
     * 保存帮助历史
     * @param {string} topicId - 主题ID
     */
    saveHelpHistory: function (topicId) {
        this.helpHistory.push({
            timestamp: Date.now(),
            topicId: topicId
        });

        // 优化：限制历史记录大小
        if (this.helpHistory.length > this.maxHistorySize) {
            this.helpHistory.shift();
        }
    },

    /**
     * 获取帮助历史
     * @param {Object} options - 查询选项
     * @returns {Array} 帮助历史
     */
    getHelpHistory: function (options) {
        let history = [...this.helpHistory];

        // 优化：按主题ID过滤
        if (options && options.topicId) {
            history = history.filter(h => h.topicId === options.topicId);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置帮助配置
     * @param {Object} config - 配置对象
     */
    setHelpConfig: function (config) {
        this.helpConfig = { ...this.helpConfig, ...config };
        this.saveHelpConfig();
    },

    /**
     * 获取帮助配置
     * @returns {Object} 配置对象
     */
    getHelpConfig: function () {
        return this.helpConfig;
    },

    /**
     * 重置帮助系统
     */
    reset: function () {
        this.helpHistory = [];
        this.loadHelpConfig();
        this.loadHelpTopics();
    },

    /**
     * 获取帮助统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const topics = Object.values(this.helpTopics);
        const totalViews = topics.reduce((acc, t) => acc + t.views, 0);
        const favoriteCount = topics.filter(t => t.favorite).length;

        return {
            totalTopics: topics.length,
            totalViews: totalViews,
            favoriteCount: favoriteCount,
            categories: this.getCategories(),
            enabled: this.helpConfig.enabled,
            autoShowTutorial: this.helpConfig.autoShowTutorial,
            searchEnabled: this.helpConfig.searchEnabled,
            favoritesEnabled: this.helpConfig.favoritesEnabled,
            totalHistory: this.helpHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏教程性能优化
const GameTutorialOptimizer = {
    tutorialConfig: {},
    tutorials: {},
    tutorialProgress: {},
    tutorialHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏教程
     */
    init: function () {
        this.loadTutorialConfig();
        this.loadTutorials();
        this.loadTutorialProgress();
    },

    /**
     * 加载教程配置
     */
    loadTutorialConfig: function () {
        // 优化：加载默认教程配置
        this.tutorialConfig = {
            enabled: true,
            autoStart: true,
            skipEnabled: true,
            replayEnabled: true,
            maxHistorySize: 1000
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('tutorialConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.tutorialConfig = { ...this.tutorialConfig, ...config };
            } catch (error) {
                console.error('加载教程配置失败:', error);
            }
        }
    },

    /**
     * 保存教程配置
     */
    saveTutorialConfig: function () {
        localStorage.setItem('tutorialConfig', JSON.stringify(this.tutorialConfig));
    },

    /**
     * 加载教程
     */
    loadTutorials: function () {
        // 优化：加载默认教程
        this.tutorials = {
            'movement': {
                id: 'movement',
                name: '移动教程',
                description: '学习如何在游戏中移动',
                steps: [
                    {
                        id: 'step1',
                        title: '使用方向键',
                        content: '使用方向键或WASD来移动你的角色',
                        position: { x: 100, y: 100 },
                        action: 'move',
                        duration: 5000
                    },
                    {
                        id: 'step2',
                        title: '跳跃',
                        content: '按空格键跳跃',
                        position: { x: 100, y: 100 },
                        action: 'jump',
                        duration: 3000
                    }
                ],
                order: 1,
                required: true
            },
            'combat': {
                id: 'combat',
                name: '战斗教程',
                description: '学习如何战斗',
                steps: [
                    {
                        id: 'step1',
                        title: '攻击',
                        content: '按J键攻击敌人',
                        position: { x: 100, y: 100 },
                        action: 'attack',
                        duration: 5000
                    },
                    {
                        id: 'step2',
                        title: '使用技能',
                        content: '按K键释放技能',
                        position: { x: 100, y: 100 },
                        action: 'skill',
                        duration: 5000
                    }
                ],
                order: 2,
                required: true
            },
            'items': {
                id: 'items',
                name: '道具教程',
                description: '学习如何使用道具',
                steps: [
                    {
                        id: 'step1',
                        title: '收集道具',
                        content: '移动到道具上收集它们',
                        position: { x: 100, y: 100 },
                        action: 'collect',
                        duration: 5000
                    },
                    {
                        id: 'step2',
                        title: '使用道具',
                        content: '按L键使用道具',
                        position: { x: 100, y: 100 },
                        action: 'use',
                        duration: 5000
                    }
                ],
                order: 3,
                required: false
            },
            'menu': {
                id: 'menu',
                name: '菜单教程',
                description: '学习如何使用游戏菜单',
                steps: [
                    {
                        id: 'step1',
                        title: '打开菜单',
                        content: '按ESC键打开游戏菜单',
                        position: { x: 100, y: 100 },
                        action: 'menu',
                        duration: 5000
                    },
                    {
                        id: 'step2',
                        title: '暂停游戏',
                        content: '在菜单中选择暂停游戏',
                        position: { x: 100, y: 100 },
                        action: 'pause',
                        duration: 3000
                    }
                ],
                order: 4,
                required: false
            }
        };

        // 优化：从本地存储加载自定义教程
        const savedTutorials = localStorage.getItem('tutorials');

        if (savedTutorials) {
            try {
                const tutorials = JSON.parse(savedTutorials);
                this.tutorials = { ...this.tutorials, ...tutorials };
            } catch (error) {
                console.error('加载教程失败:', error);
            }
        }
    },

    /**
     * 保存教程
     */
    saveTutorials: function () {
        localStorage.setItem('tutorials', JSON.stringify(this.tutorials));
    },

    /**
     * 加载教程进度
     */
    loadTutorialProgress: function () {
        // 优化：从本地存储加载教程进度
        const savedProgress = localStorage.getItem('tutorialProgress');

        if (savedProgress) {
            try {
                this.tutorialProgress = JSON.parse(savedProgress);
            } catch (error) {
                console.error('加载教程进度失败:', error);
            }
        }
    },

    /**
     * 保存教程进度
     */
    saveTutorialProgress: function () {
        localStorage.setItem('tutorialProgress', JSON.stringify(this.tutorialProgress));
    },

    /**
     * 开始教程
     * @param {string} tutorialId - 教程ID
     * @returns {Promise<Object>} 教程结果
     */
    startTutorial: function (tutorialId) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const tutorialResult = {
                success: true,
                tutorialId: tutorialId,
                stepId: null,
                timestamp: Date.now(),
                duration: 0,
                error: null
            };

            // 优化：检查教程是否启用
            if (!this.tutorialConfig.enabled) {
                tutorialResult.success = false;
                tutorialResult.error = '教程已禁用';
                tutorialResult.duration = performance.now() - startTime;
                reject(tutorialResult);
                return;
            }

            // 优化：检查教程是否存在
            const tutorial = this.tutorials[tutorialId];

            if (!tutorial) {
                tutorialResult.success = false;
                tutorialResult.error = '教程不存在';
                tutorialResult.duration = performance.now() - startTime;
                reject(tutorialResult);
                return;
            }

            // 优化：初始化教程进度
            if (!this.tutorialProgress[tutorialId]) {
                this.tutorialProgress[tutorialId] = {
                    started: false,
                    completed: false,
                    currentStep: 0,
                    completedSteps: [],
                    startedAt: null,
                    completedAt: null
                };
            }

            // 优化：开始教程
            this.tutorialProgress[tutorialId].started = true;
            this.tutorialProgress[tutorialId].startedAt = Date.now();
            this.tutorialProgress[tutorialId].currentStep = 0;

            // 优化：保存教程进度
            this.saveTutorialProgress();

            // 优化：保存教程历史
            this.saveTutorialHistory('tutorial_started', {
                tutorialId: tutorialId,
                tutorialName: tutorial.name
            });

            // 优化：显示第一步
            this.showTutorialStep(tutorialId, 0);

            tutorialResult.stepId = tutorial.steps[0].id;
            tutorialResult.duration = performance.now() - startTime;
            resolve(tutorialResult);
        });
    },

    /**
     * 显示教程步骤
     * @param {string} tutorialId - 教程ID
     * @param {number} stepIndex - 步骤索引
     */
    showTutorialStep: function (tutorialId, stepIndex) {
        const tutorial = this.tutorials[tutorialId];

        if (!tutorial || !tutorial.steps[stepIndex]) {
            return;
        }

        const step = tutorial.steps[stepIndex];

        // 优化：显示教程步骤
        console.log(`[${tutorial.name}] ${step.title}: ${step.content}`);

        // 优化：可以在这里添加游戏内UI提示
        if (typeof messageBus !== 'undefined') {
            messageBus.emit('tutorial_step_show', {
                tutorialId: tutorialId,
                stepId: step.id,
                step: step
            });
        }

        // 优化：设置超时自动跳过
        setTimeout(() => {
            this.nextTutorialStep(tutorialId);
        }, step.duration);
    },

    /**
     * 下一个教程步骤
     * @param {string} tutorialId - 教程ID
     */
    nextTutorialStep: function (tutorialId) {
        const tutorial = this.tutorials[tutorialId];
        const progress = this.tutorialProgress[tutorialId];

        if (!tutorial || !progress) {
            return;
        }

        const currentStep = progress.currentStep;

        // 优化：检查是否是最后一步
        if (currentStep >= tutorial.steps.length - 1) {
            this.completeTutorial(tutorialId);
            return;
        }

        // 优化：移动到下一步
        progress.currentStep++;
        progress.completedSteps.push(tutorial.steps[currentStep].id);

        // 优化：保存教程进度
        this.saveTutorialProgress();

        // 优化：显示下一步
        this.showTutorialStep(tutorialId, progress.currentStep);
    },

    /**
     * 完成教程
     * @param {string} tutorialId - 教程ID
     */
    completeTutorial: function (tutorialId) {
        const tutorial = this.tutorials[tutorialId];
        const progress = this.tutorialProgress[tutorialId];

        if (!tutorial || !progress) {
            return;
        }

        // 优化：标记教程为已完成
        progress.completed = true;
        progress.completedAt = Date.now();

        // 优化：保存教程进度
        this.saveTutorialProgress();

        // 优化：保存教程历史
        this.saveTutorialHistory('tutorial_completed', {
            tutorialId: tutorialId,
            tutorialName: tutorial.name
        });

        // 优化：显示完成通知
        console.log(`教程 "${tutorial.name}" 已完成！`);

        // 优化：可以在这里添加游戏内UI通知
        if (typeof messageBus !== 'undefined') {
            messageBus.emit('tutorial_completed', {
                tutorialId: tutorialId,
                tutorial: tutorial
            });
        }
    },

    /**
     * 跳过教程
     * @param {string} tutorialId - 教程ID
     */
    skipTutorial: function (tutorialId) {
        if (!this.tutorialConfig.skipEnabled) {
            return;
        }

        const tutorial = this.tutorials[tutorialId];
        const progress = this.tutorialProgress[tutorialId];

        if (!tutorial || !progress) {
            return;
        }

        // 优化：保存教程历史
        this.saveTutorialHistory('tutorial_skipped', {
            tutorialId: tutorialId,
            tutorialName: tutorial.name
        });

        // 优化：显示跳过通知
        console.log(`教程 "${tutorial.name}" 已跳过`);

        // 优化：可以在这里添加游戏内UI通知
        if (typeof messageBus !== 'undefined') {
            messageBus.emit('tutorial_skipped', {
                tutorialId: tutorialId,
                tutorial: tutorial
            });
        }
    },

    /**
     * 重放教程
     * @param {string} tutorialId - 教程ID
     */
    replayTutorial: function (tutorialId) {
        if (!this.tutorialConfig.replayEnabled) {
            return;
        }

        // 优化：重置教程进度
        if (this.tutorialProgress[tutorialId]) {
            this.tutorialProgress[tutorialId].currentStep = 0;
            this.tutorialProgress[tutorialId].completed = false;
            this.tutorialProgress[tutorialId].completedSteps = [];
        }

        // 优化：重新开始教程
        this.startTutorial(tutorialId);
    },

    /**
     * 获取教程
     * @param {string} tutorialId - 教程ID
     * @returns {Object} 教程对象
     */
    getTutorial: function (tutorialId) {
        return this.tutorials[tutorialId] || null;
    },

    /**
     * 获取教程列表
     * @param {Object} options - 查询选项
     * @returns {Array} 教程列表
     */
    getTutorials: function (options) {
        let tutorials = Object.values(this.tutorials);

        // 优化：按必需状态过滤
        if (options && options.required !== undefined) {
            tutorials = tutorials.filter(t => t.required === options.required);
        }

        // 优化：按完成状态过滤
        if (options && options.completed !== undefined) {
            tutorials = tutorials.filter(t =>
                (this.tutorialProgress[t.id] && this.tutorialProgress[t.id].completed) === options.completed
            );
        }

        // 优化：排序
        tutorials.sort((a, b) => a.order - b.order);

        // 优化：限制数量
        if (options && options.limit) {
            tutorials = tutorials.slice(0, options.limit);
        }

        return tutorials;
    },

    /**
     * 获取教程进度
     * @param {string} tutorialId - 教程ID
     * @returns {Object} 进度对象
     */
    getTutorialProgress: function (tutorialId) {
        return this.tutorialProgress[tutorialId] || null;
    },

    /**
     * 保存教程历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveTutorialHistory: function (action, data) {
        this.tutorialHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        // 优化：限制历史记录大小
        if (this.tutorialHistory.length > this.maxHistorySize) {
            this.tutorialHistory.shift();
        }
    },

    /**
     * 获取教程历史
     * @param {Object} options - 查询选项
     * @returns {Array} 教程历史
     */
    getTutorialHistory: function (options) {
        let history = [...this.tutorialHistory];

        // 优化：按操作类型过滤
        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        // 优化：按教程ID过滤
        if (options && options.tutorialId) {
            history = history.filter(h => h.data.tutorialId === options.tutorialId);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置教程配置
     * @param {Object} config - 配置对象
     */
    setTutorialConfig: function (config) {
        this.tutorialConfig = { ...this.tutorialConfig, ...config };
        this.saveTutorialConfig();
    },

    /**
     * 获取教程配置
     * @returns {Object} 配置对象
     */
    getTutorialConfig: function () {
        return this.tutorialConfig;
    },

    /**
     * 重置教程系统
     */
    reset: function () {
        this.tutorialHistory = [];
        this.tutorialProgress = {};
        this.loadTutorialConfig();
        this.loadTutorials();
        this.loadTutorialProgress();
    },

    /**
     * 获取教程统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const tutorials = Object.values(this.tutorials);
        const completedCount = tutorials.filter(t =>
            this.tutorialProgress[t.id] && this.tutorialProgress[t.id].completed
        ).length;

        return {
            totalTutorials: tutorials.length,
            completedCount: completedCount,
            inProgressCount: tutorials.filter(t =>
                this.tutorialProgress[t.id] &&
                this.tutorialProgress[t.id].started &&
                !this.tutorialProgress[t.id].completed
            ).length,
            notStartedCount: tutorials.length - completedCount - tutorials.filter(t =>
                this.tutorialProgress[t.id] &&
                this.tutorialProgress[t.id].started
            ).length,
            enabled: this.tutorialConfig.enabled,
            autoStart: this.tutorialConfig.autoStart,
            skipEnabled: this.tutorialConfig.skipEnabled,
            replayEnabled: this.tutorialConfig.replayEnabled,
            totalHistory: this.tutorialHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏引导性能优化
const GameGuideOptimizer = {
    guideConfig: {},
    guides: {},
    guideHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏引导
     */
    init: function () {
        this.loadGuideConfig();
        this.loadGuides();
    },

    /**
     * 加载引导配置
     */
    loadGuideConfig: function () {
        // 优化：加载默认引导配置
        this.guideConfig = {
            enabled: true,
            autoShow: true,
            dismissible: true,
            maxHistorySize: 1000,
            priority: 'medium'
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('guideConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.guideConfig = { ...this.guideConfig, ...config };
            } catch (error) {
                console.error('加载引导配置失败:', error);
            }
        }
    },

    /**
     * 保存引导配置
     */
    saveGuideConfig: function () {
        localStorage.setItem('guideConfig', JSON.stringify(this.guideConfig));
    },

    /**
     * 加载引导
     */
    loadGuides: function () {
        // 优化：加载默认引导
        this.guides = {
            'welcome': {
                id: 'welcome',
                title: '欢迎来到火柴人冒险',
                content: '准备好开始你的冒险了吗？',
                type: 'tip',
                priority: 'high',
                trigger: 'first_start',
                dismissible: true,
                shown: false
            },
            'controls_hint': {
                id: 'controls_hint',
                title: '控制提示',
                content: '使用方向键移动，空格键跳跃',
                type: 'info',
                priority: 'medium',
                trigger: 'idle_5s',
                dismissible: true,
                shown: false
            },
            'enemy_warning': {
                id: 'enemy_warning',
                title: '敌人警告',
                content: '小心敌人！使用J键攻击',
                type: 'warning',
                priority: 'high',
                trigger: 'enemy_nearby',
                dismissible: true,
                shown: false
            },
            'item_hint': {
                id: 'item_hint',
                title: '道具提示',
                content: '收集道具可以获得特殊效果',
                type: 'info',
                priority: 'low',
                trigger: 'item_nearby',
                dismissible: true,
                shown: false
            },
            'boss_warning': {
                id: 'boss_warning',
                title: 'BOSS警告',
                content: '强大的BOSS出现了！小心应对！',
                type: 'warning',
                priority: 'high',
                trigger: 'boss_spawn',
                dismissible: false,
                shown: false
            },
            'level_complete': {
                id: 'level_complete',
                title: '关卡完成',
                content: '恭喜你完成了这个关卡！',
                type: 'success',
                priority: 'medium',
                trigger: 'level_complete',
                dismissible: true,
                shown: false
            },
            'death_tip': {
                id: 'death_tip',
                title: '死亡提示',
                content: '不要灰心，再试一次！',
                type: 'tip',
                priority: 'low',
                trigger: 'player_death',
                dismissible: true,
                shown: false
            },
            'combo_tip': {
                id: 'combo_tip',
                title: '连击提示',
                content: '保持连击可以获得额外分数！',
                type: 'tip',
                priority: 'low',
                trigger: 'combo_10',
                dismissible: true,
                shown: false
            }
        };

        // 优化：从本地存储加载自定义引导
        const savedGuides = localStorage.getItem('guides');

        if (savedGuides) {
            try {
                const guides = JSON.parse(savedGuides);
                this.guides = { ...this.guides, ...guides };
            } catch (error) {
                console.error('加载引导失败:', error);
            }
        }
    },

    /**
     * 保存引导
     */
    saveGuides: function () {
        localStorage.setItem('guides', JSON.stringify(this.guides));
    },

    /**
     * 显示引导
     * @param {string} guideId - 引导ID
     * @returns {Promise<Object>} 引导结果
     */
    showGuide: function (guideId) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const guideResult = {
                success: true,
                guideId: guideId,
                timestamp: Date.now(),
                duration: 0,
                error: null
            };

            // 优化：检查引导是否启用
            if (!this.guideConfig.enabled) {
                guideResult.success = false;
                guideResult.error = '引导已禁用';
                guideResult.duration = performance.now() - startTime;
                reject(guideResult);
                return;
            }

            // 优化：检查引导是否存在
            const guide = this.guides[guideId];

            if (!guide) {
                guideResult.success = false;
                guideResult.error = '引导不存在';
                guideResult.duration = performance.now() - startTime;
                reject(guideResult);
                return;
            }

            // 优化：检查引导是否已显示
            if (guide.shown) {
                guideResult.success = false;
                guideResult.error = '引导已显示';
                guideResult.duration = performance.now() - startTime;
                reject(guideResult);
                return;
            }

            // 优化：显示引导
            console.log(`[${guide.type}] ${guide.title}: ${guide.content}`);

            // 优化：可以在这里添加游戏内UI引导
            if (typeof messageBus !== 'undefined') {
                messageBus.emit('guide_show', guide);
            }

            // 优化：标记引导为已显示
            guide.shown = true;
            this.saveGuides();

            // 优化：保存引导历史
            this.saveGuideHistory('guide_shown', {
                guideId: guideId,
                guideTitle: guide.title,
                guideType: guide.type
            });

            guideResult.duration = performance.now() - startTime;
            resolve(guideResult);
        });
    },

    /**
     * 触发引导
     * @param {string} trigger - 触发器
     */
    triggerGuide: function (trigger) {
        // 优化：查找匹配的引导
        for (const guideId in this.guides) {
            const guide = this.guides[guideId];

            if (guide.trigger === trigger && !guide.shown) {
                this.showGuide(guideId);
                break;
            }
        }
    },

    /**
     * 关闭引导
     * @param {string} guideId - 引导ID
     */
    dismissGuide: function (guideId) {
        const guide = this.guides[guideId];

        if (!guide) {
            return;
        }

        // 优化：检查引导是否可关闭
        if (!guide.dismissible) {
            return;
        }

        // 优化：关闭引导
        if (typeof messageBus !== 'undefined') {
            messageBus.emit('guide_dismiss', guide);
        }

        // 优化：保存引导历史
        this.saveGuideHistory('guide_dismissed', {
            guideId: guideId,
            guideTitle: guide.title
        });
    },

    /**
     * 重置引导
     * @param {string} guideId - 引导ID
     */
    resetGuide: function (guideId) {
        const guide = this.guides[guideId];

        if (guide) {
            guide.shown = false;
            this.saveGuides();
        }
    },

    /**
     * 重置所有引导
     */
    resetAllGuides: function () {
        for (const guideId in this.guides) {
            this.guides[guideId].shown = false;
        }

        this.saveGuides();
    },

    /**
     * 获取引导
     * @param {string} guideId - 引导ID
     * @returns {Object} 引导对象
     */
    getGuide: function (guideId) {
        return this.guides[guideId] || null;
    },

    /**
     * 获取引导列表
     * @param {Object} options - 查询选项
     * @returns {Array} 引导列表
     */
    getGuides: function (options) {
        let guides = Object.values(this.guides);

        // 优化：按类型过滤
        if (options && options.type) {
            guides = guides.filter(g => g.type === options.type);
        }

        // 优化：按优先级过滤
        if (options && options.priority) {
            guides = guides.filter(g => g.priority === options.priority);
        }

        // 优化：按显示状态过滤
        if (options && options.shown !== undefined) {
            guides = guides.filter(g => g.shown === options.shown);
        }

        // 优化：按触发器过滤
        if (options && options.trigger) {
            guides = guides.filter(g => g.trigger === options.trigger);
        }

        // 优化：排序
        if (options && options.sortBy) {
            guides.sort((a, b) => {
                if (options.sortBy === 'priority') {
                    const priorityOrder = { 'high': 3, 'medium': 2, 'low': 1 };
                    return priorityOrder[b.priority] - priorityOrder[a.priority];
                }
                return 0;
            });
        }

        // 优化：限制数量
        if (options && options.limit) {
            guides = guides.slice(0, options.limit);
        }

        return guides;
    },

    /**
     * 获取未显示的引导
     * @returns {Array} 未显示的引导
     */
    getUnshownGuides: function () {
        return Object.values(this.guides).filter(g => !g.shown);
    },

    /**
     * 保存引导历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveGuideHistory: function (action, data) {
        this.guideHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        // 优化：限制历史记录大小
        if (this.guideHistory.length > this.maxHistorySize) {
            this.guideHistory.shift();
        }
    },

    /**
     * 获取引导历史
     * @param {Object} options - 查询选项
     * @returns {Array} 引导历史
     */
    getGuideHistory: function (options) {
        let history = [...this.guideHistory];

        // 优化：按操作类型过滤
        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        // 优化：按引导ID过滤
        if (options && options.guideId) {
            history = history.filter(h => h.data.guideId === options.guideId);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置引导配置
     * @param {Object} config - 配置对象
     */
    setGuideConfig: function (config) {
        this.guideConfig = { ...this.guideConfig, ...config };
        this.saveGuideConfig();
    },

    /**
     * 获取引导配置
     * @returns {Object} 配置对象
     */
    getGuideConfig: function () {
        return this.guideConfig;
    },

    /**
     * 重置引导系统
     */
    reset: function () {
        this.guideHistory = [];
        this.loadGuideConfig();
        this.loadGuides();
    },

    /**
     * 获取引导统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const guides = Object.values(this.guides);
        const shownCount = guides.filter(g => g.shown).length;

        const typeStats = {
            tip: guides.filter(g => g.type === 'tip').length,
            info: guides.filter(g => g.type === 'info').length,
            warning: guides.filter(g => g.type === 'warning').length,
            success: guides.filter(g => g.type === 'success').length
        };

        const priorityStats = {
            high: guides.filter(g => g.priority === 'high').length,
            medium: guides.filter(g => g.priority === 'medium').length,
            low: guides.filter(g => g.priority === 'low').length
        };

        return {
            totalGuides: guides.length,
            shownCount: shownCount,
            unshownCount: guides.length - shownCount,
            typeStats: typeStats,
            priorityStats: priorityStats,
            enabled: this.guideConfig.enabled,
            autoShow: this.guideConfig.autoShow,
            dismissible: this.guideConfig.dismissible,
            totalHistory: this.guideHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏提示性能优化
const GameTipOptimizer = {
    tipConfig: {},
    tips: {},
    tipHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏提示
     */
    init: function () {
        this.loadTipConfig();
        this.loadTips();
    },

    /**
     * 加载提示配置
     */
    loadTipConfig: function () {
        // 优化：加载默认提示配置
        this.tipConfig = {
            enabled: true,
            autoShow: true,
            showInterval: 60000,
            maxHistorySize: 1000,
            randomOrder: true
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('tipConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.tipConfig = { ...this.tipConfig, ...config };
            } catch (error) {
                console.error('加载提示配置失败:', error);
            }
        }
    },

    /**
     * 保存提示配置
     */
    saveTipConfig: function () {
        localStorage.setItem('tipConfig', JSON.stringify(this.tipConfig));
    },

    /**
     * 加载提示
     */
    loadTips: function () {
        // 优化：加载默认提示
        this.tips = {
            'tip1': {
                id: 'tip1',
                title: '移动技巧',
                content: '使用二段跳可以到达更高的地方！',
                category: 'movement',
                priority: 'low',
                shownCount: 0
            },
            'tip2': {
                id: 'tip2',
                title: '战斗技巧',
                content: '连击可以获得额外分数，尽量保持连击！',
                category: 'combat',
                priority: 'medium',
                shownCount: 0
            },
            'tip3': {
                id: 'tip3',
                title: '道具使用',
                content: '不同的道具有不同的效果，合理使用它们！',
                category: 'items',
                priority: 'low',
                shownCount: 0
            },
            'tip4': {
                id: 'tip4',
                title: '敌人弱点',
                content: '观察敌人的攻击模式，找到它们的弱点！',
                category: 'enemies',
                priority: 'medium',
                shownCount: 0
            },
            'tip5': {
                id: 'tip5',
                title: '技能释放',
                content: '技能有冷却时间，合理规划使用！',
                category: 'skills',
                priority: 'high',
                shownCount: 0
            },
            'tip6': {
                id: 'tip6',
                title: '关卡探索',
                content: '探索每个角落，可能隐藏着秘密！',
                category: 'exploration',
                priority: 'low',
                shownCount: 0
            },
            'tip7': {
                id: 'tip7',
                title: '分数提升',
                content: '快速完成关卡可以获得时间奖励！',
                category: 'scoring',
                priority: 'medium',
                shownCount: 0
            },
            'tip8': {
                id: 'tip8',
                title: '生存技巧',
                content: '保持移动可以避免被敌人击中！',
                category: 'survival',
                priority: 'high',
                shownCount: 0
            },
            'tip9': {
                id: 'tip9',
                title: '连击技巧',
                content: '使用技能可以延长连击时间！',
                category: 'combo',
                priority: 'medium',
                shownCount: 0
            },
            'tip10': {
                id: 'tip10',
                title: 'BOSS战斗',
                content: 'BOSS有多个阶段，注意观察它们的变化！',
                category: 'boss',
                priority: 'high',
                shownCount: 0
            }
        };

        // 优化：从本地存储加载自定义提示
        const savedTips = localStorage.getItem('tips');

        if (savedTips) {
            try {
                const tips = JSON.parse(savedTips);
                this.tips = { ...this.tips, ...tips };
            } catch (error) {
                console.error('加载提示失败:', error);
            }
        }
    },

    /**
     * 保存提示
     */
    saveTips: function () {
        localStorage.setItem('tips', JSON.stringify(this.tips));
    },

    /**
     * 显示提示
     * @param {string} tipId - 提示ID
     * @returns {Promise<Object>} 提示结果
     */
    showTip: function (tipId) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const tipResult = {
                success: true,
                tipId: tipId,
                timestamp: Date.now(),
                duration: 0,
                error: null
            };

            // 优化：检查提示是否启用
            if (!this.tipConfig.enabled) {
                tipResult.success = false;
                tipResult.error = '提示已禁用';
                tipResult.duration = performance.now() - startTime;
                reject(tipResult);
                return;
            }

            // 优化：检查提示是否存在
            const tip = this.tips[tipId];

            if (!tip) {
                tipResult.success = false;
                tipResult.error = '提示不存在';
                tipResult.duration = performance.now() - startTime;
                reject(tipResult);
                return;
            }

            // 优化：显示提示
            console.log(`💡 ${tip.title}: ${tip.content}`);

            // 优化：可以在这里添加游戏内UI提示
            if (typeof messageBus !== 'undefined') {
                messageBus.emit('tip_show', tip);
            }

            // 优化：增加显示次数
            tip.shownCount++;
            this.saveTips();

            // 优化：保存提示历史
            this.saveTipHistory('tip_shown', {
                tipId: tipId,
                tipTitle: tip.title,
                tipCategory: tip.category
            });

            tipResult.duration = performance.now() - startTime;
            resolve(tipResult);
        });
    },

    /**
     * 显示随机提示
     * @returns {Promise<Object>} 提示结果
     */
    showRandomTip: function () {
        const tipIds = Object.keys(this.tips);

        if (tipIds.length === 0) {
            return Promise.reject({
                success: false,
                error: '没有可用的提示'
            });
        }

        // 优化：随机选择一个提示
        const randomIndex = Math.floor(Math.random() * tipIds.length);
        const tipId = tipIds[randomIndex];

        return this.showTip(tipId);
    },

    /**
     * 显示分类提示
     * @param {string} category - 分类
     * @returns {Promise<Object>} 提示结果
     */
    showCategoryTip: function (category) {
        const tips = Object.values(this.tips).filter(t => t.category === category);

        if (tips.length === 0) {
            return Promise.reject({
                success: false,
                error: `分类 ${category} 没有可用的提示`
            });
        }

        // 优化：随机选择一个分类提示
        const randomIndex = Math.floor(Math.random() * tips.length);
        const tip = tips[randomIndex];

        return this.showTip(tip.id);
    },

    /**
     * 获取提示
     * @param {string} tipId - 提示ID
     * @returns {Object} 提示对象
     */
    getTip: function (tipId) {
        return this.tips[tipId] || null;
    },

    /**
     * 获取提示列表
     * @param {Object} options - 查询选项
     * @returns {Array} 提示列表
     */
    getTips: function (options) {
        let tips = Object.values(this.tips);

        // 优化：按分类过滤
        if (options && options.category) {
            tips = tips.filter(t => t.category === options.category);
        }

        // 优化：按优先级过滤
        if (options && options.priority) {
            tips = tips.filter(t => t.priority === options.priority);
        }

        // 优化：按显示次数过滤
        if (options && options.minShownCount) {
            tips = tips.filter(t => t.shownCount >= options.minShownCount);
        }

        if (options && options.maxShownCount) {
            tips = tips.filter(t => t.shownCount <= options.maxShownCount);
        }

        // 优化：排序
        if (options && options.sortBy) {
            tips.sort((a, b) => {
                if (options.sortBy === 'shownCount') {
                    return b.shownCount - a.shownCount;
                } else if (options.sortBy === 'priority') {
                    const priorityOrder = { 'high': 3, 'medium': 2, 'low': 1 };
                    return priorityOrder[b.priority] - priorityOrder[a.priority];
                }
                return 0;
            });
        } else if (this.tipConfig.randomOrder) {
            // 优化：随机排序
            tips.sort(() => Math.random() - 0.5);
        }

        // 优化：限制数量
        if (options && options.limit) {
            tips = tips.slice(0, options.limit);
        }

        return tips;
    },

    /**
     * 获取提示分类
     * @returns {Array} 提示分类
     */
    getCategories: function () {
        const categories = new Set();

        for (const tipId in this.tips) {
            categories.add(this.tips[tipId].category);
        }

        return Array.from(categories);
    },

    /**
     * 添加提示
     * @param {Object} tip - 提示对象
     */
    addTip: function (tip) {
        this.tips[tip.id] = tip;
        this.saveTips();
    },

    /**
     * 移除提示
     * @param {string} tipId - 提示ID
     */
    removeTip: function (tipId) {
        delete this.tips[tipId];
        this.saveTips();
    },

    /**
     * 保存提示历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveTipHistory: function (action, data) {
        this.tipHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        // 优化：限制历史记录大小
        if (this.tipHistory.length > this.maxHistorySize) {
            this.tipHistory.shift();
        }
    },

    /**
     * 获取提示历史
     * @param {Object} options - 查询选项
     * @returns {Array} 提示历史
     */
    getTipHistory: function (options) {
        let history = [...this.tipHistory];

        // 优化：按操作类型过滤
        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        // 优化：按提示ID过滤
        if (options && options.tipId) {
            history = history.filter(h => h.data.tipId === options.tipId);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置提示配置
     * @param {Object} config - 配置对象
     */
    setTipConfig: function (config) {
        this.tipConfig = { ...this.tipConfig, ...config };
        this.saveTipConfig();
    },

    /**
     * 获取提示配置
     * @returns {Object} 配置对象
     */
    getTipConfig: function () {
        return this.tipConfig;
    },

    /**
     * 重置提示系统
     */
    reset: function () {
        this.tipHistory = [];
        this.loadTipConfig();
        this.loadTips();
    },

    /**
     * 获取提示统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const tips = Object.values(this.tips);
        const totalShownCount = tips.reduce((acc, t) => acc + t.shownCount, 0);

        const categoryStats = {};
        for (const tipId in this.tips) {
            const category = this.tips[tipId].category;

            if (!categoryStats[category]) {
                categoryStats[category] = 0;
            }

            categoryStats[category]++;
        }

        return {
            totalTips: tips.length,
            totalShownCount: totalShownCount,
            averageShownCount: tips.length > 0 ? (totalShownCount / tips.length).toFixed(2) : 0,
            categoryStats: categoryStats,
            enabled: this.tipConfig.enabled,
            autoShow: this.tipConfig.autoShow,
            showInterval: this.tipConfig.showInterval,
            randomOrder: this.tipConfig.randomOrder,
            totalHistory: this.tipHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏建议性能优化
const GameSuggestionOptimizer = {
    suggestionConfig: {},
    suggestions: {},
    suggestionHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏建议
     */
    init: function () {
        this.loadSuggestionConfig();
        this.loadSuggestions();
    },

    /**
     * 加载建议配置
     */
    loadSuggestionConfig: function () {
        // 优化：加载默认建议配置
        this.suggestionConfig = {
            enabled: true,
            autoGenerate: true,
            maxHistorySize: 1000,
            generateInterval: 300000
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('suggestionConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.suggestionConfig = { ...this.suggestionConfig, ...config };
            } catch (error) {
                console.error('加载建议配置失败:', error);
            }
        }
    },

    /**
     * 保存建议配置
     */
    saveSuggestionConfig: function () {
        localStorage.setItem('suggestionConfig', JSON.stringify(this.suggestionConfig));
    },

    /**
     * 加载建议
     */
    loadSuggestions: function () {
        // 优化：从本地存储加载建议
        const savedSuggestions = localStorage.getItem('suggestions');

        if (savedSuggestions) {
            try {
                this.suggestions = JSON.parse(savedSuggestions);
            } catch (error) {
                console.error('加载建议失败:', error);
            }
        }
    },

    /**
     * 保存建议
     */
    saveSuggestions: function () {
        localStorage.setItem('suggestions', JSON.stringify(this.suggestions));
    },

    /**
     * 生成建议
     * @param {Object} gameData - 游戏数据
     * @returns {Promise<Object>} 建议结果
     */
    generateSuggestion: function (gameData) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const suggestionResult = {
                success: true,
                suggestionId: this.generateSuggestionId(),
                timestamp: Date.now(),
                duration: 0,
                error: null
            };

            // 优化：检查建议是否启用
            if (!this.suggestionConfig.enabled) {
                suggestionResult.success = false;
                suggestionResult.error = '建议已禁用';
                suggestionResult.duration = performance.now() - startTime;
                reject(suggestionResult);
                return;
            }

            // 优化：分析游戏数据并生成建议
            const suggestion = this.analyzeGameData(gameData);

            if (!suggestion) {
                suggestionResult.success = false;
                suggestionResult.error = '无法生成建议';
                suggestionResult.duration = performance.now() - startTime;
                reject(suggestionResult);
                return;
            }

            // 优化：保存建议
            this.suggestions[suggestionResult.suggestionId] = suggestion;
            this.saveSuggestions();

            // 优化：保存建议历史
            this.saveSuggestionHistory('suggestion_generated', {
                suggestionId: suggestionResult.suggestionId,
                suggestionType: suggestion.type,
                suggestionTitle: suggestion.title
            });

            suggestionResult.suggestion = suggestion;
            suggestionResult.duration = performance.now() - startTime;
            resolve(suggestionResult);
        });
    },

    /**
     * 分析游戏数据
     * @param {Object} gameData - 游戏数据
     * @returns {Object} 建议对象
     */
    analyzeGameData: function (gameData) {
        // 优化：根据游戏数据生成建议
        if (!gameData) {
            return null;
        }

        let suggestion = null;

        // 优化：分析死亡数据
        if (gameData.deathCount > 0 && gameData.deathCount % 5 === 0) {
            suggestion = {
                id: this.generateSuggestionId(),
                type: 'improvement',
                title: '提升建议',
                content: '你最近死亡次数较多，建议练习躲避技巧',
                priority: 'high',
                category: 'survival'
            };
        }

        // 优化：分析分数数据
        if (gameData.score > 0 && gameData.score % 10000 === 0) {
            suggestion = {
                id: this.generateSuggestionId(),
                type: 'encouragement',
                title: '鼓励建议',
                content: '你的分数很高！继续保持！',
                priority: 'medium',
                category: 'scoring'
            };
        }

        // 优化：分析连击数据
        if (gameData.maxCombo > 0 && gameData.maxCombo % 20 === 0) {
            suggestion = {
                id: this.generateSuggestionId(),
                type: 'tip',
                title: '连击建议',
                content: '你的连击很棒！尝试使用技能延长连击时间',
                priority: 'medium',
                category: 'combo'
            };
        }

        // 优化：分析关卡数据
        if (gameData.levelCompleted && gameData.levelCompleted % 3 === 0) {
            suggestion = {
                id: this.generateSuggestionId(),
                type: 'challenge',
                title: '挑战建议',
                content: '你已完成多个关卡，尝试挑战更高难度！',
                priority: 'low',
                category: 'progression'
            };
        }

        return suggestion;
    },

    /**
     * 获取建议
     * @param {string} suggestionId - 建议ID
     * @returns {Object} 建议对象
     */
    getSuggestion: function (suggestionId) {
        return this.suggestions[suggestionId] || null;
    },

    /**
     * 获取建议列表
     * @param {Object} options - 查询选项
     * @returns {Array} 建议列表
     */
    getSuggestions: function (options) {
        let suggestions = Object.values(this.suggestions);

        // 优化：按类型过滤
        if (options && options.type) {
            suggestions = suggestions.filter(s => s.type === options.type);
        }

        // 优化：按分类过滤
        if (options && options.category) {
            suggestions = suggestions.filter(s => s.category === options.category);
        }

        // 优化：按优先级过滤
        if (options && options.priority) {
            suggestions = suggestions.filter(s => s.priority === options.priority);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            suggestions = suggestions.filter(s => s.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            suggestions = suggestions.filter(s => s.timestamp <= options.endTime);
        }

        // 优化：排序
        if (options && options.sortBy) {
            suggestions.sort((a, b) => {
                if (options.sortBy === 'timestamp') {
                    return b.timestamp - a.timestamp;
                } else if (options.sortBy === 'priority') {
                    const priorityOrder = { 'high': 3, 'medium': 2, 'low': 1 };
                    return priorityOrder[b.priority] - priorityOrder[a.priority];
                }
                return 0;
            });
        }

        // 优化：限制数量
        if (options && options.limit) {
            suggestions = suggestions.slice(0, options.limit);
        }

        return suggestions;
    },

    /**
     * 获取最新建议
     * @param {number} limit - 限制数量
     * @returns {Array} 最新建议
     */
    getLatestSuggestions: function (limit) {
        const suggestions = Object.values(this.suggestions);

        // 优化：按时间排序
        suggestions.sort((a, b) => b.timestamp - a.timestamp);

        // 优化：限制数量
        if (limit) {
            suggestions.slice(0, limit);
        }

        return suggestions;
    },

    /**
     * 获取高优先级建议
     * @param {number} limit - 限制数量
     * @returns {Array} 高优先级建议
     */
    getHighPrioritySuggestions: function (limit) {
        const suggestions = Object.values(this.suggestions).filter(s => s.priority === 'high');

        // 优化：按时间排序
        suggestions.sort((a, b) => b.timestamp - a.timestamp);

        // 优化：限制数量
        if (limit) {
            suggestions.slice(0, limit);
        }

        return suggestions;
    },

    /**
     * 删除建议
     * @param {string} suggestionId - 建议ID
     */
    deleteSuggestion: function (suggestionId) {
        if (this.suggestions[suggestionId]) {
            delete this.suggestions[suggestionId];
            this.saveSuggestions();
        }
    },

    /**
     * 清空所有建议
     */
    clearAllSuggestions: function () {
        this.suggestions = {};
        this.saveSuggestions();
    },

    /**
     * 生成建议ID
     * @returns {string} 建议ID
     */
    generateSuggestionId: function () {
        return 'sug_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    },

    /**
     * 保存建议历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveSuggestionHistory: function (action, data) {
        this.suggestionHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        // 优化：限制历史记录大小
        if (this.suggestionHistory.length > this.maxHistorySize) {
            this.suggestionHistory.shift();
        }
    },

    /**
     * 获取建议历史
     * @param {Object} options - 查询选项
     * @returns {Array} 建议历史
     */
    getSuggestionHistory: function (options) {
        let history = [...this.suggestionHistory];

        // 优化：按操作类型过滤
        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        // 优化：按建议ID过滤
        if (options && options.suggestionId) {
            history = history.filter(h => h.data.suggestionId === options.suggestionId);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置建议配置
     * @param {Object} config - 配置对象
     */
    setSuggestionConfig: function (config) {
        this.suggestionConfig = { ...this.suggestionConfig, ...config };
        this.saveSuggestionConfig();
    },

    /**
     * 获取建议配置
     * @returns {Object} 配置对象
     */
    getSuggestionConfig: function () {
        return this.suggestionConfig;
    },

    /**
     * 重置建议系统
     */
    reset: function () {
        this.suggestionHistory = [];
        this.loadSuggestionConfig();
        this.loadSuggestions();
    },

    /**
     * 获取建议统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const suggestions = Object.values(this.suggestions);

        const typeStats = {
            improvement: suggestions.filter(s => s.type === 'improvement').length,
            encouragement: suggestions.filter(s => s.type === 'encouragement').length,
            tip: suggestions.filter(s => s.type === 'tip').length,
            challenge: suggestions.filter(s => s.type === 'challenge').length
        };

        const priorityStats = {
            high: suggestions.filter(s => s.priority === 'high').length,
            medium: suggestions.filter(s => s.priority === 'medium').length,
            low: suggestions.filter(s => s.priority === 'low').length
        };

        return {
            totalSuggestions: suggestions.length,
            typeStats: typeStats,
            priorityStats: priorityStats,
            enabled: this.suggestionConfig.enabled,
            autoGenerate: this.suggestionConfig.autoGenerate,
            generateInterval: this.suggestionConfig.generateInterval,
            totalHistory: this.suggestionHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏推荐性能优化
const GameRecommendationOptimizer = {
    recommendationConfig: {},
    recommendations: {},
    recommendationHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏推荐
     */
    init: function () {
        this.loadRecommendationConfig();
        this.loadRecommendations();
    },

    /**
     * 加载推荐配置
     */
    loadRecommendationConfig: function () {
        // 优化：加载默认推荐配置
        this.recommendationConfig = {
            enabled: true,
            autoGenerate: true,
            maxHistorySize: 1000,
            generateInterval: 600000,
            maxRecommendations: 20
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('recommendationConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.recommendationConfig = { ...this.recommendationConfig, ...config };
            } catch (error) {
                console.error('加载推荐配置失败:', error);
            }
        }
    },

    /**
     * 保存推荐配置
     */
    saveRecommendationConfig: function () {
        localStorage.setItem('recommendationConfig', JSON.stringify(this.recommendationConfig));
    },

    /**
     * 加载推荐
     */
    loadRecommendations: function () {
        // 优化：从本地存储加载推荐
        const savedRecommendations = localStorage.getItem('recommendations');

        if (savedRecommendations) {
            try {
                this.recommendations = JSON.parse(savedRecommendations);
            } catch (error) {
                console.error('加载推荐失败:', error);
            }
        }
    },

    /**
     * 保存推荐
     */
    saveRecommendations: function () {
        localStorage.setItem('recommendations', JSON.stringify(this.recommendations));
    },

    /**
     * 生成推荐
     * @param {Object} playerData - 玩家数据
     * @returns {Promise<Object>} 推荐结果
     */
    generateRecommendation: function (playerData) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const recommendationResult = {
                success: true,
                recommendationId: this.generateRecommendationId(),
                timestamp: Date.now(),
                duration: 0,
                error: null
            };

            // 优化：检查推荐是否启用
            if (!this.recommendationConfig.enabled) {
                recommendationResult.success = false;
                recommendationResult.error = '推荐已禁用';
                recommendationResult.duration = performance.now() - startTime;
                reject(recommendationResult);
                return;
            }

            // 优化：分析玩家数据并生成推荐
            const recommendation = this.analyzePlayerData(playerData);

            if (!recommendation) {
                recommendationResult.success = false;
                recommendationResult.error = '无法生成推荐';
                recommendationResult.duration = performance.now() - startTime;
                reject(recommendationResult);
                return;
            }

            // 优化：限制推荐数量
            const recommendations = Object.values(this.recommendations);

            if (recommendations.length >= this.recommendationConfig.maxRecommendations) {
                // 优化：删除最旧的推荐
                const oldestRecommendation = recommendations.sort((a, b) => a.timestamp - b.timestamp)[0];
                delete this.recommendations[oldestRecommendation.id];
            }

            // 优化：保存推荐
            this.recommendations[recommendationResult.recommendationId] = recommendation;
            this.saveRecommendations();

            // 优化：保存推荐历史
            this.saveRecommendationHistory('recommendation_generated', {
                recommendationId: recommendationResult.recommendationId,
                recommendationType: recommendation.type,
                recommendationTitle: recommendation.title
            });

            recommendationResult.recommendation = recommendation;
            recommendationResult.duration = performance.now() - startTime;
            resolve(recommendationResult);
        });
    },

    /**
     * 分析玩家数据
     * @param {Object} playerData - 玩家数据
     * @returns {Object} 推荐对象
     */
    analyzePlayerData: function (playerData) {
        // 优化：根据玩家数据生成推荐
        if (!playerData) {
            return null;
        }

        let recommendation = null;

        // 优化：分析游戏时间
        if (playerData.playTime > 3600000) {
            recommendation = {
                id: this.generateRecommendationId(),
                type: 'break',
                title: '休息建议',
                content: '你已经玩了很久了，建议休息一下',
                priority: 'high',
                category: 'health'
            };
        }

        // 优化：分析成就进度
        if (playerData.achievementProgress > 0.8) {
            recommendation = {
                id: this.generateRecommendationId(),
                type: 'challenge',
                title: '挑战建议',
                content: '你的成就进度很高，尝试完成剩余的成就！',
                priority: 'medium',
                category: 'achievement'
            };
        }

        // 优化：分析分数
        if (playerData.highScore > 0 && playerData.highScore < 10000) {
            recommendation = {
                id: this.generateRecommendationId(),
                type: 'goal',
                title: '目标建议',
                content: '尝试获得10000分！',
                priority: 'low',
                category: 'scoring'
            };
        }

        // 优化：分析关卡进度
        if (playerData.levelProgress > 0.5) {
            recommendation = {
                id: this.generateRecommendationId(),
                type: 'progress',
                title: '进度建议',
                content: '你已经完成了一半的关卡，继续加油！',
                priority: 'medium',
                category: 'progression'
            };
        }

        // 优化：分析社交活动
        if (playerData.friendCount > 0) {
            recommendation = {
                id: this.generateRecommendationId(),
                type: 'social',
                title: '社交建议',
                content: '邀请你的朋友一起玩游戏吧！',
                priority: 'low',
                category: 'social'
            };
        }

        return recommendation;
    },

    /**
     * 获取推荐
     * @param {string} recommendationId - 推荐ID
     * @returns {Object} 推荐对象
     */
    getRecommendation: function (recommendationId) {
        return this.recommendations[recommendationId] || null;
    },

    /**
     * 获取推荐列表
     * @param {Object} options - 查询选项
     * @returns {Array} 推荐列表
     */
    getRecommendations: function (options) {
        let recommendations = Object.values(this.recommendations);

        // 优化：按类型过滤
        if (options && options.type) {
            recommendations = recommendations.filter(r => r.type === options.type);
        }

        // 优化：按分类过滤
        if (options && options.category) {
            recommendations = recommendations.filter(r => r.category === options.category);
        }

        // 优化：按优先级过滤
        if (options && options.priority) {
            recommendations = recommendations.filter(r => r.priority === options.priority);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            recommendations = recommendations.filter(r => r.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            recommendations = recommendations.filter(r => r.timestamp <= options.endTime);
        }

        // 优化：排序
        if (options && options.sortBy) {
            recommendations.sort((a, b) => {
                if (options.sortBy === 'timestamp') {
                    return b.timestamp - a.timestamp;
                } else if (options.sortBy === 'priority') {
                    const priorityOrder = { 'high': 3, 'medium': 2, 'low': 1 };
                    return priorityOrder[b.priority] - priorityOrder[a.priority];
                }
                return 0;
            });
        }

        // 优化：限制数量
        if (options && options.limit) {
            recommendations = recommendations.slice(0, options.limit);
        }

        return recommendations;
    },

    /**
     * 获取最新推荐
     * @param {number} limit - 限制数量
     * @returns {Array} 最新推荐
     */
    getLatestRecommendations: function (limit) {
        const recommendations = Object.values(this.recommendations);

        // 优化：按时间排序
        recommendations.sort((a, b) => b.timestamp - a.timestamp);

        // 优化：限制数量
        if (limit) {
            recommendations.slice(0, limit);
        }

        return recommendations;
    },

    /**
     * 获取高优先级推荐
     * @param {number} limit - 限制数量
     * @returns {Array} 高优先级推荐
     */
    getHighPriorityRecommendations: function (limit) {
        const recommendations = Object.values(this.recommendations).filter(r => r.priority === 'high');

        // 优化：按时间排序
        recommendations.sort((a, b) => b.timestamp - a.timestamp);

        // 优化：限制数量
        if (limit) {
            recommendations.slice(0, limit);
        }

        return recommendations;
    },

    /**
     * 删除推荐
     * @param {string} recommendationId - 推荐ID
     */
    deleteRecommendation: function (recommendationId) {
        if (this.recommendations[recommendationId]) {
            delete this.recommendations[recommendationId];
            this.saveRecommendations();
        }
    },

    /**
     * 清空所有推荐
     */
    clearAllRecommendations: function () {
        this.recommendations = {};
        this.saveRecommendations();
    },

    /**
     * 生成推荐ID
     * @returns {string} 推荐ID
     */
    generateRecommendationId: function () {
        return 'rec_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    },

    /**
     * 保存推荐历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveRecommendationHistory: function (action, data) {
        this.recommendationHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        // 优化：限制历史记录大小
        if (this.recommendationHistory.length > this.maxHistorySize) {
            this.recommendationHistory.shift();
        }
    },

    /**
     * 获取推荐历史
     * @param {Object} options - 查询选项
     * @returns {Array} 推荐历史
     */
    getRecommendationHistory: function (options) {
        let history = [...this.recommendationHistory];

        // 优化：按操作类型过滤
        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        // 优化：按推荐ID过滤
        if (options && options.recommendationId) {
            history = history.filter(h => h.data.recommendationId === options.recommendationId);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置推荐配置
     * @param {Object} config - 配置对象
     */
    setRecommendationConfig: function (config) {
        this.recommendationConfig = { ...this.recommendationConfig, ...config };
        this.saveRecommendationConfig();
    },

    /**
     * 获取推荐配置
     * @returns {Object} 配置对象
     */
    getRecommendationConfig: function () {
        return this.recommendationConfig;
    },

    /**
     * 重置推荐系统
     */
    reset: function () {
        this.recommendationHistory = [];
        this.loadRecommendationConfig();
        this.loadRecommendations();
    },

    /**
     * 获取推荐统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const recommendations = Object.values(this.recommendations);

        const typeStats = {
            break: recommendations.filter(r => r.type === 'break').length,
            challenge: recommendations.filter(r => r.type === 'challenge').length,
            goal: recommendations.filter(r => r.type === 'goal').length,
            progress: recommendations.filter(r => r.type === 'progress').length,
            social: recommendations.filter(r => r.type === 'social').length
        };

        const priorityStats = {
            high: recommendations.filter(r => r.priority === 'high').length,
            medium: recommendations.filter(r => r.priority === 'medium').length,
            low: recommendations.filter(r => r.priority === 'low').length
        };

        return {
            totalRecommendations: recommendations.length,
            typeStats: typeStats,
            priorityStats: priorityStats,
            enabled: this.recommendationConfig.enabled,
            autoGenerate: this.recommendationConfig.autoGenerate,
            maxRecommendations: this.recommendationConfig.maxRecommendations,
            totalHistory: this.recommendationHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏个性化性能优化
const GamePersonalizationOptimizer = {
    personalizationConfig: {},
    playerProfile: {},
    personalizationHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏个性化
     */
    init: function () {
        this.loadPersonalizationConfig();
        this.loadPlayerProfile();
    },

    /**
     * 加载个性化配置
     */
    loadPersonalizationConfig: function () {
        // 优化：加载默认个性化配置
        this.personalizationConfig = {
            enabled: true,
            autoSave: true,
            saveInterval: 300000,
            maxHistorySize: 1000
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('personalizationConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.personalizationConfig = { ...this.personalizationConfig, ...config };
            } catch (error) {
                console.error('加载个性化配置失败:', error);
            }
        }
    },

    /**
     * 保存个性化配置
     */
    savePersonalizationConfig: function () {
        localStorage.setItem('personalizationConfig', JSON.stringify(this.personalizationConfig));
    },

    /**
     * 加载玩家档案
     */
    loadPlayerProfile: function () {
        // 优化：从本地存储加载玩家档案
        const savedProfile = localStorage.getItem('playerProfile');

        if (savedProfile) {
            try {
                this.playerProfile = JSON.parse(savedProfile);
            } catch (error) {
                console.error('加载玩家档案失败:', error);
            }
        }

        // 优化：初始化默认档案
        if (!this.playerProfile.playerId) {
            this.playerProfile = {
                playerId: this.generatePlayerId(),
                playerName: 'Player',
                avatar: '',
                preferences: {
                    difficulty: 'normal',
                    soundVolume: 0.7,
                    musicVolume: 0.5,
                    controls: 'keyboard',
                    language: 'zh',
                    theme: 'default'
                },
                stats: {
                    totalPlayTime: 0,
                    totalGames: 0,
                    highScore: 0,
                    totalKills: 0,
                    totalDeaths: 0,
                    achievementsUnlocked: 0
                },
                settings: {
                    autoSave: true,
                    showTips: true,
                    showNotifications: true,
                    enableVibration: true
                },
                createdAt: Date.now(),
                lastPlayedAt: Date.now()
            };

            this.savePlayerProfile();
        }
    },

    /**
     * 保存玩家档案
     */
    savePlayerProfile: function () {
        localStorage.setItem('playerProfile', JSON.stringify(this.playerProfile));
    },

    /**
     * 生成玩家ID
     * @returns {string} 玩家ID
     */
    generatePlayerId: function () {
        return 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    },

    /**
     * 更新玩家档案
     * @param {Object} updates - 更新数据
     */
    updatePlayerProfile: function (updates) {
        // 优化：合并更新数据
        this.playerProfile = { ...this.playerProfile, ...updates };
        this.playerProfile.lastPlayedAt = Date.now();

        // 优化：保存玩家档案
        this.savePlayerProfile();

        // 优化：保存个性化历史
        this.savePersonalizationHistory('profile_updated', updates);
    },

    /**
     * 更新玩家偏好
     * @param {Object} preferences - 偏好设置
     */
    updatePreferences: function (preferences) {
        // 优化：合并偏好设置
        this.playerProfile.preferences = { ...this.playerProfile.preferences, ...preferences };
        this.playerProfile.lastPlayedAt = Date.now();

        // 优化：保存玩家档案
        this.savePlayerProfile();

        // 优化：保存个性化历史
        this.savePersonalizationHistory('preferences_updated', preferences);
    },

    /**
     * 更新玩家统计
     * @param {Object} stats - 统计数据
     */
    updateStats: function (stats) {
        // 优化：合并统计数据
        this.playerProfile.stats = { ...this.playerProfile.stats, ...stats };
        this.playerProfile.lastPlayedAt = Date.now();

        // 优化：保存玩家档案
        this.savePlayerProfile();

        // 优化：保存个性化历史
        this.savePersonalizationHistory('stats_updated', stats);
    },

    /**
     * 更新玩家设置
     * @param {Object} settings - 设置
     */
    updateSettings: function (settings) {
        // 优化：合并设置
        this.playerProfile.settings = { ...this.playerProfile.settings, ...settings };
        this.playerProfile.lastPlayedAt = Date.now();

        // 优化：保存玩家档案
        this.savePlayerProfile();

        // 优化：保存个性化历史
        this.savePersonalizationHistory('settings_updated', settings);
    },

    /**
     * 获取玩家档案
     * @returns {Object} 玩家档案
     */
    getPlayerProfile: function () {
        return this.playerProfile;
    },

    /**
     * 获取玩家偏好
     * @returns {Object} 玩家偏好
     */
    getPreferences: function () {
        return this.playerProfile.preferences;
    },

    /**
     * 获取玩家统计
     * @returns {Object} 玩家统计
     */
    getStats: function () {
        return this.playerProfile.stats;
    },

    /**
     * 获取玩家设置
     * @returns {Object} 玩家设置
     */
    getSettings: function () {
        return this.playerProfile.settings;
    },

    /**
     * 重置玩家档案
     */
    resetPlayerProfile: function () {
        // 优化：重置为默认档案
        this.playerProfile = {
            playerId: this.generatePlayerId(),
            playerName: 'Player',
            avatar: '',
            preferences: {
                difficulty: 'normal',
                soundVolume: 0.7,
                musicVolume: 0.5,
                controls: 'keyboard',
                language: 'zh',
                theme: 'default'
            },
            stats: {
                totalPlayTime: 0,
                totalGames: 0,
                highScore: 0,
                totalKills: 0,
                totalDeaths: 0,
                achievementsUnlocked: 0
            },
            settings: {
                autoSave: true,
                showTips: true,
                showNotifications: true,
                enableVibration: true
            },
            createdAt: Date.now(),
            lastPlayedAt: Date.now()
        };

        // 优化：保存玩家档案
        this.savePlayerProfile();

        // 优化：保存个性化历史
        this.savePersonalizationHistory('profile_reset', {});
    },

    /**
     * 导出玩家档案
     * @returns {string} JSON字符串
     */
    exportPlayerProfile: function () {
        return JSON.stringify(this.playerProfile);
    },

    /**
     * 导入玩家档案
     * @param {string} profileJson - JSON字符串
     * @returns {boolean} 是否成功
     */
    importPlayerProfile: function (profileJson) {
        try {
            const profile = JSON.parse(profileJson);

            // 优化：验证档案格式
            if (!profile.playerId || !profile.preferences) {
                return false;
            }

            // 优化：导入档案
            this.playerProfile = profile;
            this.savePlayerProfile();

            // 优化：保存个性化历史
            this.savePersonalizationHistory('profile_imported', {
                playerId: profile.playerId
            });

            return true;
        } catch (error) {
            console.error('导入玩家档案失败:', error);
            return false;
        }
    },

    /**
     * 保存个性化历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    savePersonalizationHistory: function (action, data) {
        this.personalizationHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        // 优化：限制历史记录大小
        if (this.personalizationHistory.length > this.maxHistorySize) {
            this.personalizationHistory.shift();
        }
    },

    /**
     * 获取个性化历史
     * @param {Object} options - 查询选项
     * @returns {Array} 个性化历史
     */
    getPersonalizationHistory: function (options) {
        let history = [...this.personalizationHistory];

        // 优化：按操作类型过滤
        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置个性化配置
     * @param {Object} config - 配置对象
     */
    setPersonalizationConfig: function (config) {
        this.personalizationConfig = { ...this.personalizationConfig, ...config };
        this.savePersonalizationConfig();
    },

    /**
     * 获取个性化配置
     * @returns {Object} 配置对象
     */
    getPersonalizationConfig: function () {
        return this.personalizationConfig;
    },

    /**
     * 重置个性化系统
     */
    reset: function () {
        this.personalizationHistory = [];
        this.loadPersonalizationConfig();
        this.loadPlayerProfile();
    },

    /**
     * 获取个性化统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            playerId: this.playerProfile.playerId,
            playerName: this.playerProfile.playerName,
            totalPlayTime: this.playerProfile.stats.totalPlayTime,
            totalGames: this.playerProfile.stats.totalGames,
            highScore: this.playerProfile.stats.highScore,
            createdAt: new Date(this.playerProfile.createdAt).toLocaleString(),
            lastPlayedAt: new Date(this.playerProfile.lastPlayedAt).toLocaleString(),
            enabled: this.personalizationConfig.enabled,
            autoSave: this.personalizationConfig.autoSave,
            totalHistory: this.personalizationHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏自适应性能优化
const GameAdaptiveOptimizer = {
    adaptiveConfig: {},
    adaptiveSettings: {},
    adaptiveHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏自适应
     */
    init: function () {
        this.loadAdaptiveConfig();
        this.loadAdaptiveSettings();
        this.detectEnvironment();
    },

    /**
     * 加载自适应配置
     */
    loadAdaptiveConfig: function () {
        // 优化：加载默认自适应配置
        this.adaptiveConfig = {
            enabled: true,
            autoAdjustQuality: true,
            autoAdjustDifficulty: true,
            autoAdjustPerformance: true,
            maxHistorySize: 1000
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('adaptiveConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.adaptiveConfig = { ...this.adaptiveConfig, ...config };
            } catch (error) {
                console.error('加载自适应配置失败:', error);
            }
        }
    },

    /**
     * 保存自适应配置
     */
    saveAdaptiveConfig: function () {
        localStorage.setItem('adaptiveConfig', JSON.stringify(this.adaptiveConfig));
    },

    /**
     * 加载自适应设置
     */
    loadAdaptiveSettings: function () {
        // 优化：从本地存储加载自适应设置
        const savedSettings = localStorage.getItem('adaptiveSettings');

        if (savedSettings) {
            try {
                this.adaptiveSettings = JSON.parse(savedSettings);
            } catch (error) {
                console.error('加载自适应设置失败:', error);
            }
        }

        // 优化：初始化默认设置
        if (!this.adaptiveSettings.detectedAt) {
            this.adaptiveSettings = {
                detectedAt: Date.now(),
                deviceType: this.detectDeviceType(),
                screenResolution: this.detectScreenResolution(),
                performanceLevel: 'high',
                qualityLevel: 'high',
                difficultyLevel: 'normal'
            };

            this.saveAdaptiveSettings();
        }
    },

    /**
     * 保存自适应设置
     */
    saveAdaptiveSettings: function () {
        localStorage.setItem('adaptiveSettings', JSON.stringify(this.adaptiveSettings));
    },

    /**
     * 检测环境
     */
    detectEnvironment: function () {
        // 优化：检测设备类型
        this.adaptiveSettings.deviceType = this.detectDeviceType();

        // 优化：检测屏幕分辨率
        this.adaptiveSettings.screenResolution = this.detectScreenResolution();

        // 优化：检测性能水平
        this.adaptiveSettings.performanceLevel = this.detectPerformanceLevel();

        // 优化：保存自适应设置
        this.saveAdaptiveSettings();

        // 优化：保存自适应历史
        this.saveAdaptiveHistory('environment_detected', {
            deviceType: this.adaptiveSettings.deviceType,
            screenResolution: this.adaptiveSettings.screenResolution,
            performanceLevel: this.adaptiveSettings.performanceLevel
        });
    },

    /**
     * 检测设备类型
     * @returns {string} 设备类型
     */
    detectDeviceType: function () {
        const userAgent = navigator.userAgent;

        if (/Mobile|Android|iP(hone|od)|IEMobile|BlackBerry|Kindle|Silk-Accelerated/.test(userAgent)) {
            return 'mobile';
        } else if (/Tablet|iPad/.test(userAgent)) {
            return 'tablet';
        } else {
            return 'desktop';
        }
    },

    /**
     * 检测屏幕分辨率
     * @returns {Object} 屏幕分辨率
     */
    detectScreenResolution: function () {
        return {
            width: window.screen.width,
            height: window.screen.height,
            pixelRatio: window.devicePixelRatio || 1
        };
    },

    /**
     * 检测性能水平
     * @returns {string} 性能水平
     */
    detectPerformanceLevel: function () {
        // 优化：检测性能水平
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            return 'low';
        }

        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');

        if (debugInfo) {
            const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);

            if (renderer.includes('NVIDIA') || renderer.includes('AMD') || renderer.includes('Intel')) {
                return 'high';
            } else if (renderer.includes('Mali') || renderer.includes('Adreno')) {
                return 'medium';
            } else {
                return 'low';
            }
        }

        return 'medium';
    },

    /**
     * 调整质量
     * @param {string} qualityLevel - 质量级别
     */
    adjustQuality: function (qualityLevel) {
        if (!this.adaptiveConfig.autoAdjustQuality) {
            return;
        }

        // 优化：调整质量级别
        this.adaptiveSettings.qualityLevel = qualityLevel;
        this.saveAdaptiveSettings();

        // 优化：保存自适应历史
        this.saveAdaptiveHistory('quality_adjusted', {
            qualityLevel: qualityLevel
        });

        // 优化：应用质量设置
        this.applyQualitySettings(qualityLevel);
    },

    /**
     * 应用质量设置
     * @param {string} qualityLevel - 质量级别
     */
    applyQualitySettings: function (qualityLevel) {
        // 优化：根据质量级别应用设置
        const settings = {
            high: {
                particleCount: 100,
                shadowQuality: 'high',
                textureQuality: 'high',
                effectsEnabled: true
            },
            medium: {
                particleCount: 50,
                shadowQuality: 'medium',
                textureQuality: 'medium',
                effectsEnabled: true
            },
            low: {
                particleCount: 20,
                shadowQuality: 'low',
                textureQuality: 'low',
                effectsEnabled: false
            }
        };

        const qualitySettings = settings[qualityLevel] || settings.medium;

        // 优化：应用质量设置到游戏
        if (typeof messageBus !== 'undefined') {
            messageBus.emit('quality_settings_applied', qualitySettings);
        }
    },

    /**
     * 调整难度
     * @param {string} difficultyLevel - 难度级别
     */
    adjustDifficulty: function (difficultyLevel) {
        if (!this.adaptiveConfig.autoAdjustDifficulty) {
            return;
        }

        // 优化：调整难度级别
        this.adaptiveSettings.difficultyLevel = difficultyLevel;
        this.saveAdaptiveSettings();

        // 优化：保存自适应历史
        this.saveAdaptiveHistory('difficulty_adjusted', {
            difficultyLevel: difficultyLevel
        });

        // 优化：应用难度设置
        this.applyDifficultySettings(difficultyLevel);
    },

    /**
     * 应用难度设置
     * @param {string} difficultyLevel - 难度级别
     */
    applyDifficultySettings: function (difficultyLevel) {
        // 优化：根据难度级别应用设置
        const settings = {
            easy: {
                enemyHealth: 0.5,
                enemyDamage: 0.5,
                playerHealth: 2.0,
                spawnRate: 0.5
            },
            normal: {
                enemyHealth: 1.0,
                enemyDamage: 1.0,
                playerHealth: 1.0,
                spawnRate: 1.0
            },
            hard: {
                enemyHealth: 1.5,
                enemyDamage: 1.5,
                playerHealth: 0.75,
                spawnRate: 1.5
            }
        };

        const difficultySettings = settings[difficultyLevel] || settings.normal;

        // 优化：应用难度设置到游戏
        if (typeof messageBus !== 'undefined') {
            messageBus.emit('difficulty_settings_applied', difficultySettings);
        }
    },

    /**
     * 调整性能
     * @param {string} performanceLevel - 性能级别
     */
    adjustPerformance: function (performanceLevel) {
        if (!this.adaptiveConfig.autoAdjustPerformance) {
            return;
        }

        // 优化：调整性能级别
        this.adaptiveSettings.performanceLevel = performanceLevel;
        this.saveAdaptiveSettings();

        // 优化：保存自适应历史
        this.saveAdaptiveHistory('performance_adjusted', {
            performanceLevel: performanceLevel
        });

        // 优化：应用性能设置
        this.applyPerformanceSettings(performanceLevel);
    },

    /**
     * 应用性能设置
     * @param {string} performanceLevel - 性能级别
     */
    applyPerformanceSettings: function (performanceLevel) {
        // 优化：根据性能级别应用设置
        const settings = {
            high: {
                fpsLimit: 60,
                physicsSteps: 8,
                aiUpdateInterval: 16
            },
            medium: {
                fpsLimit: 30,
                physicsSteps: 4,
                aiUpdateInterval: 32
            },
            low: {
                fpsLimit: 15,
                physicsSteps: 2,
                aiUpdateInterval: 64
            }
        };

        const performanceSettings = settings[performanceLevel] || settings.medium;

        // 优化：应用性能设置到游戏
        if (typeof messageBus !== 'undefined') {
            messageBus.emit('performance_settings_applied', performanceSettings);
        }
    },

    /**
     * 自动调整
     * @param {Object} performanceData - 性能数据
     */
    autoAdjust: function (performanceData) {
        if (!this.adaptiveConfig.enabled) {
            return;
        }

        // 优化：根据性能数据自动调整
        const fps = performanceData.fps || 60;

        if (fps < 30) {
            this.adjustPerformance('low');
            this.adjustQuality('low');
        } else if (fps < 45) {
            this.adjustPerformance('medium');
            this.adjustQuality('medium');
        } else {
            this.adjustPerformance('high');
            this.adjustQuality('high');
        }
    },

    /**
     * 获取自适应设置
     * @returns {Object} 自适应设置
     */
    getAdaptiveSettings: function () {
        return this.adaptiveSettings;
    },

    /**
     * 获取设备类型
     * @returns {string} 设备类型
     */
    getDeviceType: function () {
        return this.adaptiveSettings.deviceType;
    },

    /**
     * 获取屏幕分辨率
     * @returns {Object} 屏幕分辨率
     */
    getScreenResolution: function () {
        return this.adaptiveSettings.screenResolution;
    },

    /**
     * 获取性能级别
     * @returns {string} 性能级别
     */
    getPerformanceLevel: function () {
        return this.adaptiveSettings.performanceLevel;
    },

    /**
     * 获取质量级别
     * @returns {string} 质量级别
     */
    getQualityLevel: function () {
        return this.adaptiveSettings.qualityLevel;
    },

    /**
     * 获取难度级别
     * @returns {string} 难度级别
     */
    getDifficultyLevel: function () {
        return this.adaptiveSettings.difficultyLevel;
    },

    /**
     * 保存自适应历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveAdaptiveHistory: function (action, data) {
        this.adaptiveHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        // 优化：限制历史记录大小
        if (this.adaptiveHistory.length > this.maxHistorySize) {
            this.adaptiveHistory.shift();
        }
    },

    /**
     * 获取自适应历史
     * @param {Object} options - 查询选项
     * @returns {Array} 自适应历史
     */
    getAdaptiveHistory: function (options) {
        let history = [...this.adaptiveHistory];

        // 优化：按操作类型过滤
        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置自适应配置
     * @param {Object} config - 配置对象
     */
    setAdaptiveConfig: function (config) {
        this.adaptiveConfig = { ...this.adaptiveConfig, ...config };
        this.saveAdaptiveConfig();
    },

    /**
     * 获取自适应配置
     * @returns {Object} 配置对象
     */
    getAdaptiveConfig: function () {
        return this.adaptiveConfig;
    },

    /**
     * 重置自适应系统
     */
    reset: function () {
        this.adaptiveHistory = [];
        this.loadAdaptiveConfig();
        this.loadAdaptiveSettings();
        this.detectEnvironment();
    },

    /**
     * 获取自适应统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            deviceType: this.adaptiveSettings.deviceType,
            screenResolution: this.adaptiveSettings.screenResolution,
            performanceLevel: this.adaptiveSettings.performanceLevel,
            qualityLevel: this.adaptiveSettings.qualityLevel,
            difficultyLevel: this.adaptiveSettings.difficultyLevel,
            detectedAt: new Date(this.adaptiveSettings.detectedAt).toLocaleString(),
            enabled: this.adaptiveConfig.enabled,
            autoAdjustQuality: this.adaptiveConfig.autoAdjustQuality,
            autoAdjustDifficulty: this.adaptiveConfig.autoAdjustDifficulty,
            autoAdjustPerformance: this.adaptiveConfig.autoAdjustPerformance,
            totalHistory: this.adaptiveHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏预测性能优化
const GamePredictionOptimizer = {
    predictionConfig: {},
    predictions: {},
    predictionHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏预测
     */
    init: function () {
        this.loadPredictionConfig();
        this.loadPredictions();
    },

    /**
     * 加载预测配置
     */
    loadPredictionConfig: function () {
        // 优化：加载默认预测配置
        this.predictionConfig = {
            enabled: true,
            autoPredict: true,
            maxHistorySize: 1000,
            predictionInterval: 60000,
            accuracyThreshold: 0.7
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('predictionConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.predictionConfig = { ...this.predictionConfig, ...config };
            } catch (error) {
                console.error('加载预测配置失败:', error);
            }
        }
    },

    /**
     * 保存预测配置
     */
    savePredictionConfig: function () {
        localStorage.setItem('predictionConfig', JSON.stringify(this.predictionConfig));
    },

    /**
     * 加载预测
     */
    loadPredictions: function () {
        // 优化：从本地存储加载预测
        const savedPredictions = localStorage.getItem('predictions');

        if (savedPredictions) {
            try {
                this.predictions = JSON.parse(savedPredictions);
            } catch (error) {
                console.error('加载预测失败:', error);
            }
        }
    },

    /**
     * 保存预测
     */
    savePredictions: function () {
        localStorage.setItem('predictions', JSON.stringify(this.predictions));
    },

    /**
     * 生成预测
     * @param {Object} gameData - 游戏数据
     * @returns {Promise<Object>} 预测结果
     */
    generatePrediction: function (gameData) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const predictionResult = {
                success: true,
                predictionId: this.generatePredictionId(),
                timestamp: Date.now(),
                duration: 0,
                error: null
            };

            // 优化：检查预测是否启用
            if (!this.predictionConfig.enabled) {
                predictionResult.success = false;
                predictionResult.error = '预测已禁用';
                predictionResult.duration = performance.now() - startTime;
                reject(predictionResult);
                return;
            }

            // 优化：分析游戏数据并生成预测
            const prediction = this.analyzeGameData(gameData);

            if (!prediction) {
                predictionResult.success = false;
                predictionResult.error = '无法生成预测';
                predictionResult.duration = performance.now() - startTime;
                reject(predictionResult);
                return;
            }

            // 优化：保存预测
            this.predictions[predictionResult.predictionId] = prediction;
            this.savePredictions();

            // 优化：保存预测历史
            this.savePredictionHistory('prediction_generated', {
                predictionId: predictionResult.predictionId,
                predictionType: prediction.type,
                predictionTitle: prediction.title
            });

            predictionResult.prediction = prediction;
            predictionResult.duration = performance.now() - startTime;
            resolve(predictionResult);
        });
    },

    /**
     * 分析游戏数据
     * @param {Object} gameData - 游戏数据
     * @returns {Object} 预测对象
     */
    analyzeGameData: function (gameData) {
        // 优化：根据游戏数据生成预测
        if (!gameData) {
            return null;
        }

        let prediction = null;

        // 优化：预测分数
        if (gameData.currentScore && gameData.timeRemaining) {
            const predictedScore = this.predictScore(gameData.currentScore, gameData.timeRemaining, gameData.scoreRate);

            prediction = {
                id: this.generatePredictionId(),
                type: 'score',
                title: '分数预测',
                content: `预计最终分数：${predictedScore}`,
                confidence: 0.8,
                data: {
                    currentScore: gameData.currentScore,
                    predictedScore: predictedScore,
                    timeRemaining: gameData.timeRemaining
                }
            };
        }

        // 优化：预测死亡
        if (gameData.playerHealth && gameData.enemyCount) {
            const deathProbability = this.predictDeath(gameData.playerHealth, gameData.enemyCount, gameData.difficulty);

            prediction = {
                id: this.generatePredictionId(),
                type: 'death',
                title: '死亡预测',
                content: `死亡概率：${(deathProbability * 100).toFixed(1)}%`,
                confidence: 0.7,
                data: {
                    deathProbability: deathProbability,
                    playerHealth: gameData.playerHealth,
                    enemyCount: gameData.enemyCount
                }
            };
        }

        // 优化：预测胜利
        if (gameData.levelProgress && gameData.difficulty) {
            const winProbability = this.predictWin(gameData.levelProgress, gameData.difficulty, gameData.playerSkill);

            prediction = {
                id: this.generatePredictionId(),
                type: 'win',
                title: '胜利预测',
                content: `胜利概率：${(winProbability * 100).toFixed(1)}%`,
                confidence: 0.75,
                data: {
                    winProbability: winProbability,
                    levelProgress: gameData.levelProgress,
                    difficulty: gameData.difficulty
                }
            };
        }

        return prediction;
    },

    /**
     * 预测分数
     * @param {number} currentScore - 当前分数
     * @param {number} timeRemaining - 剩余时间
     * @param {number} scoreRate - 分数速率
     * @returns {number} 预测分数
     */
    predictScore: function (currentScore, timeRemaining, scoreRate) {
        // 优化：预测最终分数
        const rate = scoreRate || 100;
        const predictedScore = currentScore + (timeRemaining / 1000) * rate;

        return Math.round(predictedScore);
    },

    /**
     * 预测死亡
     * @param {number} playerHealth - 玩家生命值
     * @param {number} enemyCount - 敌人数量
     * @param {string} difficulty - 难度
     * @returns {number} 死亡概率
     */
    predictDeath: function (playerHealth, enemyCount, difficulty) {
        // 优化：计算死亡概率
        const difficultyMultiplier = {
            'easy': 0.5,
            'normal': 1.0,
            'hard': 1.5
        };

        const multiplier = difficultyMultiplier[difficulty] || 1.0;
        const deathProbability = (1 - playerHealth / 100) * (enemyCount / 10) * multiplier;

        return Math.min(deathProbability, 1.0);
    },

    /**
     * 预测胜利
     * @param {number} levelProgress - 关卡进度
     * @param {string} difficulty - 难度
     * @param {number} playerSkill - 玩家技能
     * @returns {number} 胜利概率
     */
    predictWin: function (levelProgress, difficulty, playerSkill) {
        // 优化：计算胜利概率
        const difficultyMultiplier = {
            'easy': 1.5,
            'normal': 1.0,
            'hard': 0.5
        };

        const multiplier = difficultyMultiplier[difficulty] || 1.0;
        const winProbability = (levelProgress / 100) * (playerSkill / 100) * multiplier;

        return Math.min(winProbability, 1.0);
    },

    /**
     * 获取预测
     * @param {string} predictionId - 预测ID
     * @returns {Object} 预测对象
     */
    getPrediction: function (predictionId) {
        return this.predictions[predictionId] || null;
    },

    /**
     * 获取预测列表
     * @param {Object} options - 查询选项
     * @returns {Array} 预测列表
     */
    getPredictions: function (options) {
        let predictions = Object.values(this.predictions);

        // 优化：按类型过滤
        if (options && options.type) {
            predictions = predictions.filter(p => p.type === options.type);
        }

        // 优化：按置信度过滤
        if (options && options.minConfidence) {
            predictions = predictions.filter(p => p.confidence >= options.minConfidence);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            predictions = predictions.filter(p => p.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            predictions = predictions.filter(p => p.timestamp <= options.endTime);
        }

        // 优化：排序
        if (options && options.sortBy) {
            predictions.sort((a, b) => {
                if (options.sortBy === 'timestamp') {
                    return b.timestamp - a.timestamp;
                } else if (options.sortBy === 'confidence') {
                    return b.confidence - a.confidence;
                }
                return 0;
            });
        }

        // 优化：限制数量
        if (options && options.limit) {
            predictions = predictions.slice(0, options.limit);
        }

        return predictions;
    },

    /**
     * 获取最新预测
     * @param {number} limit - 限制数量
     * @returns {Array} 最新预测
     */
    getLatestPredictions: function (limit) {
        const predictions = Object.values(this.predictions);

        // 优化：按时间排序
        predictions.sort((a, b) => b.timestamp - a.timestamp);

        // 优化：限制数量
        if (limit) {
            predictions.slice(0, limit);
        }

        return predictions;
    },

    /**
     * 验证预测
     * @param {string} predictionId - 预测ID
     * @param {*} actualResult - 实际结果
     * @returns {Object} 验证结果
     */
    validatePrediction: function (predictionId, actualResult) {
        const prediction = this.predictions[predictionId];

        if (!prediction) {
            return {
                success: false,
                error: '预测不存在'
            };
        }

        // 优化：验证预测准确性
        let accuracy = 0;

        if (prediction.type === 'score') {
            const predictedScore = prediction.data.predictedScore;
            const actualScore = actualResult;
            const difference = Math.abs(predictedScore - actualScore);
            accuracy = Math.max(0, 1 - difference / predictedScore);
        } else if (prediction.type === 'death') {
            const predictedDeath = prediction.data.deathProbability > 0.5;
            const actualDeath = actualResult;
            accuracy = predictedDeath === actualDeath ? 1 : 0;
        } else if (prediction.type === 'win') {
            const predictedWin = prediction.data.winProbability > 0.5;
            const actualWin = actualResult;
            accuracy = predictedWin === actualWin ? 1 : 0;
        }

        // 优化：更新预测置信度
        prediction.confidence = (prediction.confidence + accuracy) / 2;
        this.savePredictions();

        // 优化：保存预测历史
        this.savePredictionHistory('prediction_validated', {
            predictionId: predictionId,
            predictionType: prediction.type,
            accuracy: accuracy
        });

        return {
            success: true,
            accuracy: accuracy
        };
    },

    /**
     * 删除预测
     * @param {string} predictionId - 预测ID
     */
    deletePrediction: function (predictionId) {
        if (this.predictions[predictionId]) {
            delete this.predictions[predictionId];
            this.savePredictions();
        }
    },

    /**
     * 清空所有预测
     */
    clearAllPredictions: function () {
        this.predictions = {};
        this.savePredictions();
    },

    /**
     * 生成预测ID
     * @returns {string} 预测ID
     */
    generatePredictionId: function () {
        return 'pred_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    },

    /**
     * 保存预测历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    savePredictionHistory: function (action, data) {
        this.predictionHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        // 优化：限制历史记录大小
        if (this.predictionHistory.length > this.maxHistorySize) {
            this.predictionHistory.shift();
        }
    },

    /**
     * 获取预测历史
     * @param {Object} options - 查询选项
     * @returns {Array} 预测历史
     */
    getPredictionHistory: function (options) {
        let history = [...this.predictionHistory];

        // 优化：按操作类型过滤
        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        // 优化：按预测ID过滤
        if (options && options.predictionId) {
            history = history.filter(h => h.data.predictionId === options.predictionId);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置预测配置
     * @param {Object} config - 配置对象
     */
    setPredictionConfig: function (config) {
        this.predictionConfig = { ...this.predictionConfig, ...config };
        this.savePredictionConfig();
    },

    /**
     * 获取预测配置
     * @returns {Object} 配置对象
     */
    getPredictionConfig: function () {
        return this.predictionConfig;
    },

    /**
     * 重置预测系统
     */
    reset: function () {
        this.predictionHistory = [];
        this.loadPredictionConfig();
        this.loadPredictions();
    },

    /**
     * 获取预测统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const predictions = Object.values(this.predictions);

        const typeStats = {
            score: predictions.filter(p => p.type === 'score').length,
            death: predictions.filter(p => p.type === 'death').length,
            win: predictions.filter(p => p.type === 'win').length
        };

        const averageConfidence = predictions.length > 0
            ? predictions.reduce((acc, p) => acc + p.confidence, 0) / predictions.length
            : 0;

        return {
            totalPredictions: predictions.length,
            typeStats: typeStats,
            averageConfidence: averageConfidence.toFixed(2),
            enabled: this.predictionConfig.enabled,
            autoPredict: this.predictionConfig.autoPredict,
            accuracyThreshold: this.predictionConfig.accuracyThreshold,
            totalHistory: this.predictionHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏智能性能优化
const GameIntelligenceOptimizer = {
    intelligenceConfig: {},
    intelligenceData: {},
    intelligenceHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏智能
     */
    init: function () {
        this.loadIntelligenceConfig();
        this.loadIntelligenceData();
    },

    /**
     * 加载智能配置
     */
    loadIntelligenceConfig: function () {
        // 优化：加载默认智能配置
        this.intelligenceConfig = {
            enabled: true,
            learningEnabled: true,
            adaptationEnabled: true,
            maxHistorySize: 1000,
            learningRate: 0.1,
            adaptationThreshold: 0.8
        };

        // 优化：从本地存储加载自定义配置
        const customConfig = localStorage.getItem('intelligenceConfig');

        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.intelligenceConfig = { ...this.intelligenceConfig, ...config };
            } catch (error) {
                console.error('加载智能配置失败:', error);
            }
        }
    },

    /**
     * 保存智能配置
     */
    saveIntelligenceConfig: function () {
        localStorage.setItem('intelligenceConfig', JSON.stringify(this.intelligenceConfig));
    },

    /**
     * 加载智能数据
     */
    loadIntelligenceData: function () {
        // 优化：从本地存储加载智能数据
        const savedData = localStorage.getItem('intelligenceData');

        if (savedData) {
            try {
                this.intelligenceData = JSON.parse(savedData);
            } catch (error) {
                console.error('加载智能数据失败:', error);
            }
        }

        // 优化：初始化默认数据
        if (!this.intelligenceData.playerBehavior) {
            this.intelligenceData = {
                playerBehavior: {
                    movementPatterns: {},
                    attackPatterns: {},
                    reactionTimes: {},
                    decisionPatterns: {}
                },
                gameKnowledge: {
                    enemyWeaknesses: {},
                    levelSecrets: {},
                    optimalStrategies: {}
                },
                performanceMetrics: {
                    averageScore: 0,
                    averageTime: 0,
                    winRate: 0,
                    efficiency: 0
                },
                adaptationState: {
                    difficulty: 'normal',
                    assistanceLevel: 0,
                    hintFrequency: 0
                }
            };

            this.saveIntelligenceData();
        }
    },

    /**
     * 保存智能数据
     */
    saveIntelligenceData: function () {
        localStorage.setItem('intelligenceData', JSON.stringify(this.intelligenceData));
    },

    /**
     * 记录玩家行为
     * @param {string} actionType - 行为类型
     * @param {Object} data - 行为数据
     */
    recordPlayerBehavior: function (actionType, data) {
        if (!this.intelligenceConfig.enabled || !this.intelligenceConfig.learningEnabled) {
            return;
        }

        // 优化：记录玩家行为
        const behavior = {
            timestamp: Date.now(),
            actionType: actionType,
            data: data
        };

        // 优化：存储行为模式
        if (!this.intelligenceData.playerBehavior[actionType]) {
            this.intelligenceData.playerBehavior[actionType] = [];
        }

        this.intelligenceData.playerBehavior[actionType].push(behavior);

        // 优化：限制历史记录大小
        if (this.intelligenceData.playerBehavior[actionType].length > 100) {
            this.intelligenceData.playerBehavior[actionType].shift();
        }

        // 优化：保存智能数据
        this.saveIntelligenceData();

        // 优化：保存智能历史
        this.saveIntelligenceHistory('behavior_recorded', {
            actionType: actionType
        });
    },

    /**
     * 分析玩家行为
     * @param {string} actionType - 行为类型
     * @returns {Object} 分析结果
     */
    analyzePlayerBehavior: function (actionType) {
        const behaviors = this.intelligenceData.playerBehavior[actionType];

        if (!behaviors || behaviors.length === 0) {
            return null;
        }

        // 优化：分析行为模式
        const analysis = {
            actionType: actionType,
            frequency: behaviors.length,
            averageTime: behaviors.reduce((acc, b) => acc + (b.data.duration || 0), 0) / behaviors.length,
            successRate: behaviors.filter(b => b.data.success).length / behaviors.length,
            patterns: this.detectPatterns(behaviors)
        };

        return analysis;
    },

    /**
     * 检测模式
     * @param {Array} behaviors - 行为列表
     * @returns {Array} 模式列表
     */
    detectPatterns: function (behaviors) {
        const patterns = [];

        // 优化：检测重复模式
        const patternMap = {};

        for (let i = 0; i < behaviors.length - 1; i++) {
            for (let j = i + 1; j < behaviors.length; j++) {
                const similarity = this.calculateSimilarity(behaviors[i], behaviors[j]);

                if (similarity > 0.8) {
                    const patternKey = `${i}-${j}`;

                    if (!patternMap[patternKey]) {
                        patternMap[patternKey] = [];
                    }

                    patternMap[patternKey].push(behaviors[i], behaviors[j]);
                }
            }
        }

        // 优化：生成模式描述
        for (const key in patternMap) {
            const patternBehaviors = patternMap[key];

            patterns.push({
                pattern: patternBehaviors[0],
                count: patternBehaviors.length,
                confidence: Math.min(patternBehaviors.length / behaviors.length * 2, 1)
            });
        }

        return patterns;
    },

    /**
     * 计算相似度
     * @param {Object} behavior1 - 行为1
     * @param {Object} behavior2 - 行为2
     * @returns {number} 相似度
     */
    calculateSimilarity: function (behavior1, behavior2) {
        let similarity = 0;

        // 优化：比较行为数据
        const data1 = behavior1.data;
        const const data2 = behavior2.data;

        // 优化：比较位置
        if (data1.position && data2.position) {
            const distance = Math.sqrt(
                Math.pow(data1.position.x - data2.position.x, 2) +
                Math.pow(data1.position.y - data2.position.y, 2)
            );

            if (distance < 50) {
                similarity += 0.3;
            }
        }

        // 优化：比较时长
        if (data1.duration && data2.duration) {
            const durationDiff = Math.abs(data1.duration - data2.duration);
            const avgDuration = (data1.duration + data2.duration) / 2;

            if (durationDiff < avgDuration * 0.2) {
                similarity += 0.3;
            }
        }

        // 优化：比较结果
        if (data1.success === data2.success) {
            similarity += 0.4;
        }

        return similarity;
    },

    /**
     * 学习游戏知识
     * @param {string} knowledgeType - 知识类型
     * @param {Object} knowledge - 知识对象
     */
    learnKnowledge: function (knowledgeType, knowledge) {
        if (!this.intelligenceConfig.enabled || !this.intelligenceConfig.learningEnabled) {
            return;
        }

        // 优化：学习游戏知识
        if (!this.intelligenceData.gameKnowledge[knowledgeType]) {
            this.intelligenceData.gameKnowledge[knowledgeType] = {};
        }

        this.intelligenceData.gameKnowledge[knowledgeType][knowledge.id] = knowledge;

        // 优化：保存智能数据
        this.saveIntelligenceData();

        // 优化：保存智能历史
        this.saveIntelligenceHistory('knowledge_learned', {
            knowledgeType: knowledgeType,
            knowledgeId: knowledge.id
        });
    },

    /**
     * 获取游戏知识
     * @param {string} knowledgeType - 知识类型
     * @returns {Object} 游戏知识
     */
    getGameKnowledge: function (knowledgeType) {
        return this.intelligenceData.gameKnowledge[knowledgeType] || {};
    },

    /**
     * 更新性能指标
     * @param {Object} metrics - 性能指标
     */
    updatePerformanceMetrics: function (metrics) {
        if (!this.intelligenceConfig.enabled) {
            return;
        }

        // 优化：更新性能指标
        this.intelligenceData.performanceMetrics = {
            ...this.intelligenceData.performanceMetrics,
            ...metrics
        };

        // 优化：保存智能数据
        this.saveIntelligenceData();

        // 优化：保存智能历史
        this.saveIntelligenceHistory('metrics_updated', metrics);
    },

    /**
     * 获取性能指标
     * @returns {Object} 性能指标
     */
    getPerformanceMetrics: function () {
        return this.intelligenceData.performanceMetrics;
    },

    /**
     * 适应游戏
     * @param {Object} gameState - 游戏状态
     * @returns {Object} 适应结果
     */
    adaptGame: function (gameState) {
        if (!this.intelligenceConfig.enabled || !this.intelligenceConfig.adaptationEnabled) {
            return null;
        }

        // 优化：根据玩家表现适应游戏
        const adaptation = {
            timestamp: Date.now(),
            changes: []
        };

        // 优化：调整难度
        const metrics = this.intelligenceData.performanceMetrics;

        if (metrics.winRate < 0.3) {
            adaptation.changes.push({
                type: 'difficulty',
                from: this.intelligenceData.adaptationState.difficulty,
                to: 'easy'
            });

            this.intelligenceData.adaptationState.difficulty = 'easy';
        } else if (metrics.winRate > 0.8) {
            adaptation.changes.push({
                type: 'difficulty',
                from: this.intelligenceData.adaptationState.difficulty,
                to: 'hard'
            });

            this.intelligenceData.adaptationState.difficulty = 'hard';
        }

        // 优化：调整辅助级别
        const deathRate = 1 - metrics.winRate;

        if (deathRate > 0.5) {
            adaptation.changes.push({
                type: 'assistance',
                from: this.intelligenceData.adaptationState.assistanceLevel,
                to: Math.min(this.intelligenceData.adaptationState.assistanceLevel + 0.2, 1.0)
            });

            this.intelligenceData.adaptationState.assistanceLevel = Math.min(
                this.intelligenceData.adaptationState.assistanceLevel + 0.2,
                1.0
            );
        }

        // 优化：保存智能数据
        this.saveIntelligenceData();

        // 优化：保存智能历史
        this.saveIntelligenceHistory('game_adapted', adaptation);

        return adaptation;
    },

    /**
     * 获取适应状态
     * @returns {Object} 适应状态
     */
    getAdaptationState: function () {
        return this.intelligenceData.adaptationState;
    },

    /**
     * 设置适应状态
     * @param {Object} adaptationState - 适应状态
     */
    setAdaptationState: function (adaptationState) {
        this.intelligenceData.adaptationState = adaptationState;
        this.saveIntelligenceData();
    },

    /**
     * 保存智能历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveIntelligenceHistory: function (action, data) {
        this.intelligenceHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        // 优化：限制历史记录大小
        if (this.intelligenceHistory.length > this.maxHistorySize) {
            this.intelligenceHistory.shift();
        }
    },

    /**
     * 获取智能历史
     * @param {Object} options - 查询选项
     * @returns {Array} 智能历史
     */
    getIntelligenceHistory: function (options) {
        let history = [...this.intelligenceHistory];

        // 优化：按操作类型过滤
        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        // 优化：按时间范围过滤
        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        // 优化：限制数量
        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置智能配置
     * @param {Object} config - 配置对象
     */
    setIntelligenceConfig: function (config) {
        this.intelligenceConfig = { ...this.intelligenceConfig, ...config };
        this.saveIntelligenceConfig();
    },

    /**
     * 获取智能配置
     * @returns {Object} 配置对象
     */
    getIntelligenceConfig: function () {
        return this.intelligenceConfig;
    },

    /**
     * 重置智能系统
     */
    reset: function () {
        this.intelligenceHistory = [];
        this.loadIntelligenceConfig();
        this.loadIntelligenceData();
    },

    /**
     * 获取智能统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const behaviorTypes = Object.keys(this.intelligenceData.playerBehavior);
        const knowledgeTypes = Object.keys(this.intelligenceData.gameKnowledge);

        return {
            enabled: this.intelligenceConfig.enabled,
            learningEnabled: this.intelligenceConfig.learningEnabled,
            adaptationEnabled: this.intelligenceConfig.adaptationEnabled,
            learningRate: this.intelligenceConfig.learningRate,
            adaptationThreshold: this.intelligenceConfig.adaptationThreshold,
            behaviorTypes: behaviorTypes,
            knowledgeTypes: knowledgeTypes,
            performanceMetrics: this.intelligenceData.performanceMetrics,
            adaptationState: this.intelligenceData.adaptationState,
            totalHistory: this.intelligenceHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏机器学习优化
const GameMachineLearningOptimizer = {
    mlConfig: {},
    mlModels: {},
    mlHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏机器学习
     */
    init: function () {
        this.loadMLConfig();
        this.loadMLModels();
    },

    /**
     * 加载机器学习配置
     */
    loadMLConfig: function () {
        this.mlConfig = {
            enabled: true,
            autoTrain: true,
            maxHistorySize: 1000,
            learningRate: 0.01,
            batchSize: 32,
            epochs: 10
        };

        const customConfig = localStorage.getItem('mlConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.mlConfig = { ...this.mlConfig, ...config };
            } catch (error) {
                console.error('加载机器学习配置失败:', error);
            }
        }
    },

    /**
     * 保存机器学习配置
     */
    saveMLConfig: function () {
        localStorage.setItem('mlConfig', JSON.stringify(this.mlConfig));
    },

    /**
     * 加载机器学习模型
     */
    loadMLModels: function () {
        const savedModels = localStorage.getItem('mlModels');
        if (savedModels) {
            try {
                this.mlModels = JSON.parse(savedModels);
            } catch (error) {
                console.error('加载机器学习模型失败:', error);
            }
        }

        if (!this.mlModels.playerBehavior) {
            this.mlModels = {
                playerBehavior: {
                    weights: [],
                    biases: [],
                    trained: false
                },
                enemyAI: {
                    weights: [],
                    biases: [],
                    trained: false
                },
                difficultyPrediction: {
                    weights: [],
                    biases: [],
                    trained: false
                }
            };

            this.saveMLModels();
        }
    },

    /**
     * 保存机器学习模型
     */
    saveMLModels: function () {
        localStorage.setItem('mlModels', JSON.stringify(this.mlModels));
    },

    /**
     * 训练模型
     * @param {string} modelType - 模型类型
     * @param {Array} trainingData - 训练数据
     * @returns {Promise<Object>} 训练结果
     */
    trainModel: function (modelType, trainingData) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const result = {
                success: true,
                modelType: modelType,
                timestamp: Date.now(),
                duration: 0,
                error: null
            };

            if (!this.mlConfig.enabled) {
                result.success = false;
                result.error = '机器学习已禁用';
                result.duration = performance.now() - startTime;
                reject(result);
                return;
            }

            if (!trainingData || trainingData.length === 0) {
                result.success = false;
                result.error = '训练数据为空';
                result.duration = performance.now() - startTime;
                reject(result);
                return;
            }

            try {
                const model = this.mlModels[modelType];

                if (!model) {
                    result.success = false;
                    result.error = '模型不存在';
                    result.duration = performance.now() - startTime;
                    reject(result);
                    return;
                }

                for (let epoch = 0; epoch < this.mlConfig.epochs; epoch++) {
                    for (let i = 0; i < trainingData.length; i++) {
                        const data = trainingData[i];
                        this.updateWeights(model, data);
                    }
                }

                model.trained = true;
                this.saveMLModels();

                this.saveMLHistory('model_trained', {
                    modelType: modelType,
                    dataSize: trainingData.length
                });

                result.duration = performance.now() - startTime;
                resolve(result);
            } catch (error) {
                result.success = false;
                result.error = error.message;
                result.duration = performance.now() - startTime;
                reject(result);
            }
        });
    },

    /**
     * 更新权重
     * @param {Object} model - 模型
     * @param {Object} data - 数据
     */
    updateWeights: function (model, data) {
        const learningRate = this.mlConfig.learningRate;

        for (let i = 0; i < model.weights.length; i++) {
            model.weights[i] += learningRate * (data.target - data.input[i]);
        }

        for (let i = 0; i < model.biases.length; i++) {
            model.biases[i] += learningRate * (data.target - data.input[i]);
        }
    },

    /**
     * 预测
     * @param {string} modelType - 模型类型
     * @param {Array} input - 输入数据
     * @returns {number} 预测结果
     */
    predict: function (modelType, input) {
        const model = this.mlModels[modelType];

        if (!model || !model.trained) {
            return null;
        }

        let prediction = 0;

        for (let i = 0; i < model.weights.length; i++) {
            prediction += model.weights[i] * (input[i] || 0);
        }

        for (let i = 0; i < model.biases.length; i++) {
            prediction += model.biases[i];
        }

        return prediction;
    },

    /**
     * 评估模型
     * @param {string} modelType - 模型类型
     * @param {Array} testData - 测试数据
     * @returns {Object} 评估结果
     */
    evaluateModel: function (modelType, testData) {
        const model = this.mlModels[modelType];

        if (!model || !model.trained) {
            return {
                success: false,
                error: '模型未训练'
            };
        }

        let totalError = 0;

        for (let i = 0; i < testData.length; i++) {
            const prediction = this.predict(modelType, testData[i].input);
            const error = Math.abs(prediction - testData[i].target);
            totalError += error;
        }

        const averageError = totalError / testData.length;
        const accuracy = 1 - Math.min(averageError, 1);

        return {
            success: true,
            averageError: averageError,
            accuracy: accuracy
        };
    },

    /**
     * 获取模型
     * @param {string} modelType - 模型类型
     * @returns {Object} 模型对象
     */
    getModel: function (modelType) {
        return this.mlModels[modelType] || null;
    },

    /**
     * 获取所有模型
     * @returns {Object} 所有模型
     */
    getAllModels: function () {
        return this.mlModels;
    },

    /**
     * 删除模型
     * @param {string} modelType - 模型类型
     */
    deleteModel: function (modelType) {
        if (this.mlModels[modelType]) {
            delete this.mlModels[modelType];
            this.saveMLModels();
        }
    },

    /**
     * 清空所有模型
     */
    clearAllModels: function () {
        this.mlModels = {};
        this.saveMLModels();
    },

    /**
     * 保存机器学习历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveMLHistory: function (action, data) {
        this.mlHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.mlHistory.length > this.maxHistorySize) {
            this.mlHistory.shift();
        }
    },

    /**
     * 获取机器学习历史
     * @param {Object} options - 查询选项
     * @returns {Array} 机器学习历史
     */
    getMLHistory: function (options) {
        let history = [...this.mlHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置机器学习配置
     * @param {Object} config - 配置对象
     */
    setMLConfig: function (config) {
        this.mlConfig = { ...this.mlConfig, ...config };
        this.saveMLConfig();
    },

    /**
     * 获取机器学习配置
     * @returns {Object} 配置对象
     */
    getMLConfig: function () {
        return this.mlConfig;
    },

    /**
     * 重置机器学习系统
     */
    reset: function () {
        this.mlHistory = [];
        this.loadMLConfig();
        this.loadMLModels();
    },

    /**
     * 获取机器学习统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const models = Object.keys(this.mlModels);
        const trainedModels = models.filter(m => this.mlModels[m].trained);

        return {
            totalModels: models.length,
            trainedModels: trainedModels.length,
            enabled: this.mlConfig.enabled,
            autoTrain: this.mlConfig.autoTrain,
            learningRate: this.mlConfig.learningRate,
            batchSize: this.mlConfig.batchSize,
            epochs: this.mlConfig.epochs,
            totalHistory: this.mlHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏神经网络优化
const GameNeuralNetworkOptimizer = {
    nnConfig: {},
    neuralNetworks: {},
    nnHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏神经网络
     */
    init: function () {
        this.loadNNConfig();
        this.loadNeuralNetworks();
    },

    /**
     * 加载神经网络配置
     */
    loadNNConfig: function () {
        this.nnConfig = {
            enabled: true,
            autoTrain: true,
            maxHistorySize: 1000,
            learningRate: 0.1,
            activationFunction: 'sigmoid',
            hiddenLayers: [8, 8]
        };

        const customConfig = localStorage.getItem('nnConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.nnConfig = { ...this.nnConfig, ...config };
            } catch (error) {
                console.error('加载神经网络配置失败:', error);
            }
        }
    },

    /**
     * 保存神经网络配置
     */
    saveNNConfig: function () {
        localStorage.setItem('nnConfig', JSON.stringify(this.nnConfig));
    },

    /**
     * 加载神经网络
     */
    loadNeuralNetworks: function () {
        const savedNetworks = localStorage.getItem('neuralNetworks');
        if (savedNetworks) {
            try {
                this.neuralNetworks = JSON.parse(savedNetworks);
            } catch (error) {
                console.error('加载神经网络失败:', error);
            }
        }

        if (!this.neuralNetworks.playerPrediction) {
            this.neuralNetworks = {
                playerPrediction: {
                    layers: this.createLayers([4, 8, 8, 1]),
                    trained: false
                },
                enemyBehavior: {
                    layers: this.createLayers([6, 8, 8, 2]),
                    trained: false
                },
                difficultyEstimation: {
                    layers: this.createLayers([5, 8, 8, 1]),
                    trained: false
                }
            };

            this.saveNeuralNetworks();
        }
    },

    /**
     * 保存神经网络
     */
    saveNeuralNetworks: function () {
        localStorage.setItem('neuralNetworks', JSON.stringify(this.neuralNetworks));
    },

    /**
     * 创建网络层
     * @param {Array} layerSizes - 层大小数组
     * @returns {Array} 网络层
     */
    createLayers: function (layerSizes) {
        const layers = [];

        for (let i = 0; i < layerSizes.length - 1; i++) {
            const weights = [];
            const biases = [];

            for (let j = 0; j < layerSizes[i + 1]; j++) {
                const layerWeights = [];
                for (let k = 0; k < layerSizes[i]; k++) {
                    layerWeights.push(Math.random() * 2 - 1);
                }
                weights.push(layerWeights);
                biases.push(Math.random() * 2 - 1);
            }

            layers.push({
                weights: weights,
                biases: biases
            });
        }

        return layers;
    },

    /**
     * 前向传播
     * @param {Array} input - 输入数据
     * @param {Array} layers - 网络层
     * @returns {Array} 输出数据
     */
    forward: function (input, layers) {
        let output = input;

        for (let i = 0; i < layers.length; i++) {
            const layer = layers[i];
            const newOutput = [];

            for (let j = 0; j < layer.weights.length; j++) {
                let sum = layer.biases[j];

                for (let k = 0; k < layer.weights[j].length; k++) {
                    sum += output[k] * layer.weights[j][k];
                }

                newOutput.push(this.activate(sum));
            }

            output = newOutput;
        }

        return output;
    },

    /**
     * 激活函数
     * @param {number} x - 输入值
     * @returns {number} 激活值
     */
    activate: function (x) {
        switch (this.nnConfig.activationFunction) {
            case 'sigmoid':
                return 1 / (1 + Math.exp(-x));
            case 'tanh':
                return Math.tanh(x);
            case 'relu':
                return Math.max(0, x);
            default:
                return 1 / (1 + Math.exp(-x));
        }
    },

    /**
     * 激活函数导数
     * @param {number} x - 输入值
     * @returns {number} 导数值
     */
    activateDerivative: function (x) {
        switch (this.nnConfig.activationFunction) {
            case 'sigmoid':
                const s = this.activate(x);
                return s * (1 - s);
            case 'tanh':
                return 1 - Math.pow(Math.tanh(x), 2);
            case 'relu':
                return x > 0 ? 1 : 0;
            default:
                const s2 = this.activate(x);
                return s2 * (1 - s2);
        }
    },

    /**
     * 训练神经网络
     * @param {string} networkType - 网络类型
     * @param {Array} trainingData - 训练数据
     * @returns {Promise<Object>} 训练结果
     */
    trainNetwork: function (networkType, trainingData) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const result = {
                success: true,
                networkType: networkType,
                timestamp: Date.now(),
                duration: 0,
                error: null
            };

            if (!this.nnConfig.enabled) {
                result.success = false;
                result.error = '神经网络已禁用';
                result.duration = performance.now() - startTime;
                reject(result);
                return;
            }

            if (!trainingData || trainingData.length === 0) {
                result.success = false;
                result.error = '训练数据为空';
                result.duration = performance.now() - startTime;
                reject(result);
                return;
            }

            try {
                const network = this.neuralNetworks[networkType];

                if (!network) {
                    result.success = false;
                    result.error = '神经网络不存在';
                    result.duration = performance.now() - startTime;
                    reject(result);
                    return;
                }

                for (let epoch = 0; epoch < 10; epoch++) {
                    for (let i = 0; i < trainingData.length; i++) {
                        this.backpropagate(network, trainingData[i]);
                    }
                }

                network.trained = true;
                this.saveNeuralNetworks();

                this.saveNNHistory('network_trained', {
                    networkType: networkType,
                    dataSize: trainingData.length
                });

                result.duration = performance.now() - startTime;
                resolve(result);
            } catch (error) {
                result.success = false;
                result.error = error.message;
                result.duration = performance.now() - startTime;
                reject(result);
            }
        });
    },

    /**
     * 反向传播
     * @param {Object} network - 神经网络
     * @param {Object} data - 训练数据
     */
    backpropagate: function (network, data) {
        const learningRate = this.nnConfig.learningRate;

        const forwardOutputs = [];
        let output = data.input;
        forwardOutputs.push(output);

        for (let i = 0; i < network.layers.length; i++) {
            const layer = network.layers[i];
            const newOutput = [];

            for (let j = 0; j < layer.weights.length; j++) {
                let sum = layer.biases[j];

                for (let k = 0; k < layer.weights[j].length; k++) {
                    sum += output[k] * layer.weights[j][k];
                }

                newOutput.push(this.activate(sum));
            }

            output = newOutput;
            forwardOutputs.push(output);
        }

        const errors = [];

        for (let i = 0; i < output.length; i++) {
            errors.push(data.target[i] - output[i]);
        }

        for (let i = network.layers.length - 1; i >= 0; i--) {
            const layer = network.layers[i];
            const newErrors = [];

            for (let j = 0; j < layer.weights.length; j++) {
                const delta = errors[j] * this.activateDerivative(forwardOutputs[i + 1][j]);

                for (let k = 0; k < layer.weights[j].length; k++) {
                    layer.weights[j][k] += learningRate * delta * forwardOutputs[i][k];

                    if (i > 0) {
                        if (!newErrors[k]) {
                            newErrors[k] = 0;
                        }
                        newErrors[k] += delta * layer.weights[j][k];
                    }
                }

                layer.biases[j] += learningRate * delta;
            }

            for (let j = 0; j < newErrors.length; j++) {
                errors[j] = newErrors[j];
            }
        }
    },

    /**
     * 预测
     * @param {string} networkType - 网络类型
     * @param {Array} input - 输入数据
     * @returns {Array} 预测结果
     */
    predict: function (networkType, input) {
        const network = this.neuralNetworks[networkType];

        if (!network || !network.trained) {
            return null;
        }

        return this.forward(input, network.layers);
    },

    /**
     * 获取神经网络
     * @param {string} networkType - 网络类型
     * @returns {Object} 神经网络
     */
    getNetwork: function (networkType) {
        return this.neuralNetworks[networkType] || null;
    },

    /**
     * 获取所有神经网络
     * @returns {Object} 所有神经网络
     */
    getAllNetworks: function () {
        return this.neuralNetworks;
    },

    /**
     * 删除神经网络
     * @param {string} networkType - 网络类型
     */
    deleteNetwork: function (networkType) {
        if (this.neuralNetworks[networkType]) {
            delete this.neuralNetworks[networkType];
            this.saveNeuralNetworks();
        }
    },

    /**
     * 清空所有神经网络
     */
    clearAllNetworks: function () {
        this.neuralNetworks = {};
        this.saveNeuralNetworks();
    },

    /**
     * 保存神经网络历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveNNHistory: function (action, data) {
        this.nnHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.nnHistory.length > this.maxHistorySize) {
            this.nnHistory.shift();
        }
    },

    /**
     * 获取神经网络历史
     * @param {Object} options - 查询选项
     * @returns {Array} 神经网络历史
     */
    getNNHistory: function (options) {
        let history = [...this.nnHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置神经网络配置
     * @param {Object} config - 配置对象
     */
    setNNConfig: function (config) {
        this.nnConfig = { ...this.nnConfig, ...config };
        this.saveNNConfig();
    },

    /**
     * 获取神经网络配置
     * @returns {Object} 配置对象
     */
    getNNConfig: function () {
        return this.nnConfig;
    },

    /**
     * 重置神经网络系统
     */
    reset: function () {
        this.nnHistory = [];
        this.loadNNConfig();
        this.loadNeuralNetworks();
    },

    /**
     * 获取神经网络统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const networks = Object.keys(this.neuralNetworks);
        const trainedNetworks = networks.filter(n => this.neuralNetworks[n].trained);

        return {
            totalNetworks: networks.length,
            trainedNetworks: trainedNetworks.length,
            enabled: this.nnConfig.enabled,
            autoTrain: this.nnConfig.autoTrain,
            learningRate: this.nnConfig.learningRate,
            activationFunction: this.nnConfig.activationFunction,
            hiddenLayers: this.nnConfig.hiddenLayers,
            totalHistory: this.nnHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏深度学习优化
const GameDeepLearningOptimizer = {
    dlConfig: {},
    deepModels: {},
    dlHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏深度学习
     */
    init: function () {
        this.loadDLConfig();
        this.loadDeepModels();
    },

    /**
     * 加载深度学习配置
     */
    loadDLConfig: function () {
        this.dlConfig = {
            enabled: true,
            autoTrain: true,
            maxHistorySize: 1000,
            learningRate: 0.001,
            batchSize: 64,
            epochs: 20,
            dropoutRate: 0.5,
            optimizer: 'adam'
        };

        const customConfig = localStorage.getItem('dlConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.dlConfig = { ...this.dlConfig, ...config };
            } catch (error) {
                console.error('加载深度学习配置失败:', error);
            }
        }
    },

    /**
     * 保存深度学习配置
     */
    saveDLConfig: function () {
        localStorage.setItem('dlConfig', JSON.stringify(this.dlConfig));
    },

    /**
     * 加载深度模型
     */
    loadDeepModels: function () {
        const savedModels = localStorage.getItem('deepModels');
        if (savedModels) {
            try {
                this.deepModels = JSON.parse(savedModels);
            } catch (error) {
                console.error('加载深度模型失败:', error);
            }
        }

        if (!this.deepModels.playerBehaviorModel) {
            this.deepModels = {
                playerBehaviorModel: {
                    layers: this.createDeepLayers([10, 64, 128, 64, 1]),
                    trained: false,
                    accuracy: 0
                },
                enemyAIPredictionModel: {
                    layers: this.createDeepLayers([12, 64, 128, 64, 2]),
                    trained: false,
                    accuracy: 0
                },
                gameDifficultyModel: {
                    layers: this.createDeepLayers([8, 64, 128, 64, 1]),
                    trained: false,
                    accuracy: 0
                }
            };

            this.saveDeepModels();
        }
    },

    /**
     * 保存深度模型
     */
    saveDeepModels: function () {
        localStorage.setItem('deepModels', JSON.stringify(this.deepModels));
    },

    /**
     * 创建深度网络层
     * @param {Array} layerSizes - 层大小数组
     * @returns {Array} 深度网络层
     */
    createDeepLayers: function (layerSizes) {
        const layers = [];

        for (let i = 0; i < layerSizes.length - 1; i++) {
            const weights = [];
            const biases = [];

            for (let j = 0; j < layerSizes[i + 1]; j++) {
                const layerWeights = [];
                for (let k = 0; k < layerSizes[i]; k++) {
                    layerWeights.push((Math.random() * 2 - 1) * Math.sqrt(2 / layerSizes[i]));
                }
                weights.push(layerWeights);
                biases.push(0);
            }

            layers.push({
                weights: weights,
                biases: biases,
                type: i === layerSizes.length - 2 ? 'output' : 'hidden'
            });
        }

        return layers;
    },

    /**
     * 深度前向传播
     * @param {Array} input - 输入数据
     * @param {Array} layers - 网络层
     * @returns {Object} 前向传播结果
     */
    deepForward: function (input, layers) {
        let output = input;
        const activations = [input];

        for (let i = 0; i < layers.length; i++) {
            const layer = layers[i];
            const newOutput = [];

            for (let j = 0; j < layer.weights.length; j++) {
                let sum = layer.biases[j];

                for (let k = 0; k < layer.weights[j].length; k++) {
                    sum += output[k] * layer.weights[j][k];
                }

                if (layer.type === 'output') {
                    newOutput.push(this.activate(sum));
                } else {
                    newOutput.push(this.deepActivate(sum));
                }
            }

            output = newOutput;
            activations.push(output);
        }

        return {
            output: output,
            activations: activations
        };
    },

    /**
     * 深度激活函数
     * @param {number} x - 输入值
     * @returns {number} 激活值
     */
    deepActivate: function (x) {
        return Math.max(0, x);
    },

    /**
     * 深度激活函数导数
     * @param {number} x - 输入值
     * @returns {number} 导数值
     */
    deepActivateDerivative: function (x) {
        return x > 0 ? 1 : 0;
    },

    /**
     * 训练深度模型
     * @param {string} modelType - 模型类型
     * @param {Array} trainingData - 训练数据
     * @returns {Promise<Object>} 训练结果
     */
    trainDeepModel: function (modelType, trainingData) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const result = {
                success: true,
                modelType: modelType,
                timestamp: Date.now(),
                duration: 0,
                error: null,
                accuracy: 0
            };

            if (!this.dlConfig.enabled) {
                result.success = false;
                result.error = '深度学习已禁用';
                result.duration = performance.now() - startTime;
                reject(result);
                return;
            }

            if (!trainingData || trainingData.length === 0) {
                result.success = false;
                result.error = '训练数据为空';
                result.duration = performance.now() - startTime;
                reject(result);
                return;
            }

            try {
                const model = this.deepModels[modelType];

                if (!model) {
                    result.success = false;
                    result.error = '深度模型不存在';
                    result.duration = performance.now() - startTime;
                    reject(result);
                    return;
                }

                let totalLoss = 0;

                for (let epoch = 0; epoch < this.dlConfig.epochs; epoch++) {
                    for (let i = 0; i < trainingData.length; i++) {
                        const loss = this.deepBackpropagate(model, trainingData[i]);
                        totalLoss += loss;
                    }
                }

                const averageLoss = totalLoss / (this.dlConfig.epochs * trainingData.length);
                model.accuracy = Math.max(0, 1 - averageLoss);
                model.trained = true;

                this.saveDeepModels();

                this.saveDLHistory('deep_model_trained', {
                    modelType: modelType,
                    dataSize: trainingData.length,
                    accuracy: model.accuracy
                });

                result.accuracy = model.accuracy;
                result.duration = performance.now() - startTime;
                resolve(result);
            } catch (error) {
                result.success = false;
                result.error = error.message;
                result.duration = performance.now() - startTime;
                reject(result);
            }
        });
    },

    /**
     * 深度反向传播
     * @param {Object} model - 深度模型
     * @param {Object} data - 训练数据
     * @returns {number} 损失值
     */
    deepBackpropagate: function (model, data) {
        const learningRate = this.dlConfig.learningRate;
        const forwardResult = this.deepForward(data.input, model.layers);
        const output = forwardResult.output;
        const activations = forwardResult.activations;

        const errors = [];
        let loss = 0;

        for (let i = 0; i < output.length; i++) {
            const error = data.target[i] - output[i];
            errors.push(error);
            loss += Math.pow(error, 2);
        }

        for (let i = model.layers.length - 1; i >= 0; i--) {
            const layer = model.layers[i];
            const newErrors = [];

            for (let j = 0; j < layer.weights.length; j++) {
                let delta;

                if (layer.type === 'output') {
                    delta = errors[j] * this.activateDerivative(activations[i + 1][j]);
                } else {
                    delta = errors[j] * this.deepActivateDerivative(activations[i + 1][j]);
                }

                for (let k = 0; k < layer.weights[j].length; k++) {
                    layer.weights[j][k] += learningRate * delta * activations[i][k];

                    if (i > 0) {
                        if (!newErrors[k]) {
                            newErrors[k] = 0;
                        }
                        newErrors[k] += delta * layer.weights[j][k];
                    }
                }

                layer.biases[j] += learningRate * delta;
            }

            for (let j = 0; j < newErrors.length; j++) {
                errors[j] = newErrors[j];
            }
        }

        return loss / output.length;
    },

    /**
     * 深度预测
     * @param {string} modelType - 模型类型
     * @param {Array} input - 输入数据
     * @returns {Array} 预测结果
     */
    deepPredict: function (modelType, input) {
        const model = this.deepModels[modelType];

        if (!model || !model.trained) {
            return null;
        }

        const result = this.deepForward(input, model.layers);
        return result.output;
    },

    /**
     * 评估深度模型
     * @param {string} modelType - 模型类型
     * @param {Array} testData - 测试数据
     * @returns {Object} 评估结果
     */
    evaluateDeepModel: function (modelType, testData) {
        const model = this.deepModels[modelType];

        if (!model || !model.trained) {
            return {
                success: false,
                error: '模型未训练'
            };
        }

        let correct = 0;

        for (let i = 0; i < testData.length; i++) {
            const prediction = this.deepPredict(modelType, testData[i].input);
            const actual = testData[i].target;

            if (Math.abs(prediction[0] - actual[0]) < 0.5) {
                correct++;
            }
        }

        const accuracy = correct / testData.length;

        return {
            success: true,
            accuracy: accuracy,
            correct: correct,
            total: testData.length
        };
    },

    /**
     * 获取深度模型
     * @param {string} modelType - 模型类型
     * @returns {Object} 深度模型
     */
    getDeepModel: function (modelType) {
        return this.deepModels[modelType] || null;
    },

    /**
     * 获取所有深度模型
     * @returns {Object} 所有深度模型
     */
    getAllDeepModels: function () {
        return this.deepModels;
    },

    /**
     * 删除深度模型
     * @param {string} modelType - 模型类型
     */
    deleteDeepModel: function (modelType) {
        if (this.deepModels[modelType]) {
            delete this.deepModels[modelType];
            this.saveDeepModels();
        }
    },

    /**
     * 清空所有深度模型
     */
    clearAllDeepModels: function () {
        this.deepModels = {};
        this.saveDeepModels();
    },

    /**
     * 保存深度学习历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveDLHistory: function (action, data) {
        this.dlHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.dlHistory.length > this.maxHistorySize) {
            this.dlHistory.shift();
        }
    },

    /**
     * 获取深度学习历史
     * @param {Object} options - 查询选项
     * @returns {Array} 深度学习历史
     */
    getDLHistory: function (options) {
        let history = [...this.dlHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置深度学习配置
     * @param {Object} config - 配置对象
     */
    setDLConfig: function (config) {
        this.dlConfig = { ...this.dlConfig, ...config };
        this.saveDLConfig();
    },

    /**
     * 获取深度学习配置
     * @returns {Object} 配置对象
     */
    getDLConfig: function () {
        return this.dlConfig;
    },

    /**
     * 重置深度学习系统
     */
    reset: function () {
        this.dlHistory = [];
        this.loadDLConfig();
        this.loadDeepModels();
    },

    /**
     * 获取深度学习统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const models = Object.keys(this.deepModels);
        const trainedModels = models.filter(m => this.deepModels[m].trained);

        const averageAccuracy = trainedModels.length > 0
            ? trainedModels.reduce((acc, m) => acc + this.deepModels[m].accuracy, 0) / trainedModels.length
            : 0;

        return {
            totalModels: models.length,
            trainedModels: trainedModels.length,
            averageAccuracy: averageAccuracy.toFixed(4),
            enabled: this.dlConfig.enabled,
            autoTrain: this.dlConfig.autoTrain,
            learningRate: this.dlConfig.learningRate,
            batchSize: this.dlConfig.batchSize,
            epochs: this.dlConfig.epochs,
            dropoutRate: this.dlConfig.dropoutRate,
            optimizer: this.dlConfig.optimizer,
            totalHistory: this.dlHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏强化学习优化
const GameReinforcementLearningOptimizer = {
    rlConfig: {},
    rlAgents: {},
    rlHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏强化学习
     */
    init: function () {
        this.loadRLConfig();
        this.loadRLAgents();
    },

    /**
     * 加载强化学习配置
     */
    loadRLConfig: function () {
        this.rlConfig = {
            enabled: true,
            autoTrain: true,
            maxHistorySize: 1000,
            learningRate: 0.1,
            discountFactor: 0.95,
            explorationRate: 0.1,
            batchSize: 32,
            targetUpdateFrequency: 100
        };

        const customConfig = localStorage.getItem('rlConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.rlConfig = { ...this.rlConfig, ...config };
            } catch (error) {
                console.error('加载强化学习配置失败:', error);
            }
        }
    },

    /**
     * 保存强化学习配置
     */
    saveRLConfig: function () {
        localStorage.setItem('rlConfig', JSON.stringify(this.rlConfig));
    },

    /**
     * 加载强化学习智能体
     */
    loadRLAgents: function () {
        const savedAgents = localStorage.getItem('rlAgents');
        if (savedAgents) {
            try {
                this.rlAgents = JSON.parse(savedAgents);
            } catch (error) {
                console.error('加载强化学习智能体失败:', error);
            }
        }

        if (!this.rlAgents.playerAgent) {
            this.rlAgents = {
                playerAgent: {
                    qTable: {},
                    episode: 0,
                    totalReward: 0,
                    averageReward: 0
                },
                enemyAgent: {
                    qTable: {},
                    episode: 0,
                    totalReward: 0,
                    averageReward: 0
                },
                difficultyAgent: {
                    qTable: {},
                    episode: 0,
                    totalReward: 0,
                    averageReward: 0
                }
            };

            this.saveRLAgents();
        }
    },

    /**
     * 保存强化学习智能体
     */
    saveRLAgents: function () {
        localStorage.setItem('rlAgents', JSON.stringify(this.rlAgents));
    },

    /**
     * 获取状态键
     * @param {Object} state - 状态对象
     * @returns {string} 状态键
     */
    getStateKey: function (state) {
        return JSON.stringify(state);
    },

    /**
     * 获取动作
     * @param {string} agentType - 智能体类型
     * @param {Object} state - 状态
     * @param {Array} actions - 可用动作
     * @returns {string} 动作
     */
    getAction: function (agentType, state, actions) {
        const agent = this.rlAgents[agentType];

        if (!agent) {
            return actions[Math.floor(Math.random() * actions.length)];
        }

        const stateKey = this.getStateKey(state);

        if (!agent.qTable[stateKey]) {
            agent.qTable[stateKey] = {};

            for (let i = 0; i < actions.length; i++) {
                agent.qTable[stateKey][actions[i]] = 0;
            }
        }

        if (Math.random() < this.rlConfig.explorationRate) {
            return actions[Math.floor(Math.random() * actions.length)];
        }

        let bestAction = actions[0];
        let bestValue = agent.qTable[stateKey][bestAction];

        for (let i = 1; i < actions.length; i++) {
            const value = agent.qTable[stateKey][actions[i]];

            if (value > bestValue) {
                bestValue = value;
                bestAction = actions[i];
            }
        }

        return bestAction;
    },

    /**
     * 更新Q值
     * @param {string} agentType - 智能体类型
     * @param {Object} state - 当前状态
     * @param {string} action - 动作
     * @param {number} reward - 奖励
     * @param {Object} nextState - 下一状态
     * @param {Array} actions - 可用动作
     */
    updateQValue: function (agentType, state, action, reward, nextState, actions) {
        const agent = this.rlAgents[agentType];

        if (!agent) {
            return;
        }

        const stateKey = this.getStateKey(state);
        const nextStateKey = this.getStateKey(nextState);

        if (!agent.qTable[stateKey]) {
            agent.qTable[stateKey] = {};

            for (let i = 0; i < actions.length; i++) {
                agent.qTable[stateKey][actions[i]] = 0;
            }
        }

        if (!agent.qTable[nextStateKey]) {
            agent.qTable[nextStateKey] = {};

            for (let i = 0; i < actions.length; i++) {
                agent.qTable[nextStateKey][actions[i]] = 0;
            }
        }

        let maxNextQ = -Infinity;

        for (let i = 0; i < actions.length; i++) {
            const value = agent.qTable[nextStateKey][actions[i]];

            if (value > maxNextQ) {
                maxNextQ = value;
            }
        }

        if (maxNextQ === -Infinity) {
            maxNextQ = 0;
        }

        const currentQ = agent.qTable[stateKey][action];
        const newQ = currentQ + this.rlConfig.learningRate * (reward + this.rlConfig.discountFactor * maxNextQ - currentQ);

        agent.qTable[stateKey][action] = newQ;
        agent.totalReward += reward;
    },

    /**
     * 训练智能体
     * @param {string} agentType - 智能体类型
     * @param {Array} episodes - 训练回合
     * @returns {Promise<Object>} 训练结果
     */
    trainAgent: function (agentType, episodes) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const result = {
                success: true,
                agentType: agentType,
                timestamp: Date.now(),
                duration: 0,
                error: null,
                totalReward: 0,
                averageReward: 0
            };

            if (!this.rlConfig.enabled) {
                result.success = false;
                result.error = '强化学习已禁用';
                result.duration = performance.now() - startTime;
                reject(result);
                return;
            }

            if (!episodes || episodes.length === 0) {
                result.success = false;
                result.error = '训练回合为空';
                result.duration = performance.now() - startTime;
                reject(result);
                return;
            }

            try {
                const agent = this.rlAgents[agentType];

                if (!agent) {
                    result.success = false;
                    result.error = '智能体不存在';
                    result.duration = performance.now() - startTime;
                    reject(result);
                    return;
                }

                let totalReward = 0;

                for (let i = 0; i < episodes.length; i++) {
                    const episode = episodes[i];

                    for (let j = 0; j < episode.transitions.length; j++) {
                        const transition = episode.transitions[j];
                        this.updateQValue(
                            agentType,
                            transition.state,
                            transition.action,
                            transition.reward,
                            transition.nextState,
                            transition.actions
                        );
                    }

                    totalReward += episode.totalReward;
                    agent.episode++;
                }

                agent.averageReward = agent.totalReward / agent.episode;
                this.saveRLAgents();

                this.saveRLHistory('agent_trained', {
                    agentType: agentType,
                    episodes: episodes.length,
                    totalReward: totalReward
                });

                result.totalReward = totalReward;
                result.averageReward = totalReward / episodes.length;
                result.duration = performance.now() - startTime;
                resolve(result);
            } catch (error) {
                result.success = false;
                result.error = error.message;
                result.duration = performance.now() - startTime;
                reject(result);
            }
        });
    },

    /**
     * 获取智能体
     * @param {string} agentType - 智能体类型
     * @returns {Object} 智能体
     */
    getAgent: function (agentType) {
        return this.rlAgents[agentType] || null;
    },

    /**
     * 获取所有智能体
     * @returns {Object} 所有智能体
     */
    getAllAgents: function () {
        return this.rlAgents;
    },

    /**
     * 重置智能体
     * @param {string} agentType - 智能体类型
     */
    resetAgent: function (agentType) {
        if (this.rlAgents[agentType]) {
            this.rlAgents[agentType].qTable = {};
            this.rlAgents[agentType].episode = 0;
            this.rlAgents[agentType].totalReward = 0;
            this.rlAgents[agentType].averageReward = 0;
            this.saveRLAgents();
        }
    },

    /**
     * 删除智能体
     * @param {string} agentType - 智能体类型
     */
    deleteAgent: function (agentType) {
        if (this.rlAgents[agentType]) {
            delete this.rlAgents[agentType];
            this.saveRLAgents();
        }
    },

    /**
     * 清空所有智能体
     */
    clearAllAgents: function () {
        this.rlAgents = {};
        this.saveRLAgents();
    },

    /**
     * 保存强化学习历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveRLHistory: function (action, data) {
        this.rlHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.rlHistory.length > this.maxHistorySize) {
            this.rlHistory.shift();
        }
    },

    /**
     * 获取强化学习历史
     * @param {Object} options - 查询选项
     * @returns {Array} 强化学习历史
     */
    getRLHistory: function (options) {
        let history = [...this.rlHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置强化学习配置
     * @param {Object} config - 配置对象
     */
    setRLConfig: function (config) {
        this.rlConfig = { ...this.rlConfig, ...config };
        this.saveRLConfig();
    },

    /**
     * 获取强化学习配置
     * @returns {Object} 配置对象
     */
    getRLConfig: function () {
        return this.rlConfig;
    },

    /**
     * 重置强化学习系统
     */
    reset: function () {
        this.rlHistory = [];
        this.loadRLConfig();
        this.loadRLAgents();
    },

    /**
     * 获取强化学习统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const agents = Object.keys(this.rlAgents);

        let totalEpisodes = 0;
        let totalReward = 0;

        for (const agentType of agents) {
            const agent = this.rlAgents[agentType];
            totalEpisodes += agent.episode;
            totalReward += agent.totalReward;
        }

        const averageReward = totalEpisodes > 0 ? totalReward / totalEpisodes : 0;

        return {
            totalAgents: agents.length,
            totalEpisodes: totalEpisodes,
            totalReward: totalReward,
            averageReward: averageReward.toFixed(2),
            enabled: this.rlConfig.enabled,
            autoTrain: this.rlConfig.autoTrain,
            learningRate: this.rlConfig.learningRate,
            discountFactor: this.rlConfig.discountFactor,
            explorationRate: this.rlConfig.explorationRate,
            batchSize: this.rlConfig.batchSize,
            targetUpdateFrequency: this.rlConfig.targetUpdateFrequency,
            totalHistory: this.rlHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏遗传算法优化
const GameGeneticAlgorithmOptimizer = {
    gaConfig: {},
    populations: {},
    gaHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏遗传算法
     */
    init: function () {
        this.loadGAConfig();
        this.loadPopulations();
    },

    /**
     * 加载遗传算法配置
     */
    loadGAConfig: function () {
        this.gaConfig = {
            enabled: true,
            autoEvolve: true,
            maxHistorySize: 1000,
            populationSize: 50,
            mutationRate: 0.01,
            crossoverRate: 0.7,
            selectionMethod: 'tournament',
            elitismCount: 2
        };

        const customConfig = localStorage.getItem('gaConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.gaConfig = { ...this.gaConfig, ...config };
            } catch (error) {
                console.error('加载遗传算法配置失败:', error);
            }
        }
    },

    /**
     * 保存遗传算法配置
     */
    saveGAConfig: function () {
        localStorage.setItem('gaConfig', JSON.stringify(this.gaConfig));
    },

    /**
     * 加载种群
     */
    loadPopulations: function () {
        const savedPopulations = localStorage.getItem('gaPopulations');
        if (savedPopulations) {
            try {
                this.populations = JSON.parse(savedPopulations);
            } catch (error) {
                console.error('加载种群失败:', error);
            }
        }

        if (!this.populations.playerPopulation) {
            this.populations = {
                playerPopulation: {
                    individuals: [],
                    generation: 0,
                    bestFitness: 0,
                    averageFitness: 0
                },
                enemyPopulation: {
                    individuals: [],
                    generation: 0,
                    bestFitness: 0,
                    averageFitness: 0
                },
                levelPopulation: {
                    individuals: [],
                    generation: 0,
                    bestFitness: 0,
                    averageFitness: 0
                }
            };

            this.savePopulations();
        }
    },

    /**
     * 保存种群
     */
    savePopulations: function () {
        localStorage.setItem('gaPopulations', JSON.stringify(this.populations));
    },

    /**
     * 初始化种群
     * @param {string} populationType - 种群类型
     * @param {Object} genomeTemplate - 基因组模板
     */
    initializePopulation: function (populationType, genomeTemplate) {
        const population = this.populations[populationType];

        if (!population) {
            return;
        }

        population.individuals = [];

        for (let i = 0; i < this.gaConfig.populationSize; i++) {
            const genome = this.createRandomGenome(genomeTemplate);
            population.individuals.push({
                genome: genome,
                fitness: 0
            });
        }

        population.generation = 0;
        population.bestFitness = 0;
        population.averageFitness = 0;

        this.savePopulations();

        this.saveGAHistory('population_initialized', {
            populationType: populationType,
            size: population.individuals.length
        });
    },

    /**
     * 创建随机基因组
     * @param {Object} template - 基因组模板
     * @returns {Object} 基因组
     */
    createRandomGenome: function (template) {
        const genome = {};

        for (const key in template) {
            const gene = template[key];

            if (typeof gene === 'number') {
                genome[key] = Math.random() * gene;
            } else if (Array.isArray(gene)) {
                genome[key] = gene.map(() => Math.random());
            } else if (typeof gene === 'object') {
                genome[key] = this.createRandomGenome(gene);
            } else {
                genome[key] = gene;
            }
        }

        return genome;
    },

    /**
     * 评估适应度
     * @param {string} populationType - 种群类型
     * @param {Function} fitnessFunction - 适应度函数
     */
    evaluateFitness: function (populationType, fitnessFunction) {
        const population = this.populations[populationType];

        if (!population) {
            return;
        }

        let totalFitness = 0;
        let bestFitness = 0;

        for (let i = 0; i < population.individuals.length; i++) {
            const individual = population.individuals[i];
            individual.fitness = fitnessFunction(individual.genome);
            totalFitness += individual.fitness;

            if (individual.fitness > bestFitness) {
                bestFitness = individual.fitness;
            }
        }

        population.bestFitness = bestFitness;
        population.averageFitness = totalFitness / population.individuals.length;

        this.savePopulations();
    },

    /**
     * 选择
     * @param {Array} population - 种群
     * @returns {Object} 选中的个体
     */
    select: function (population) {
        switch (this.gaConfig.selectionMethod) {
            case 'tournament':
                return this.tournamentSelection(population);
            case 'roulette':
                return this.rouletteSelection(population);
            case 'rank':
                return this.rankSelection(population);
            default:
                return this.tournamentSelection(population);
        }
    },

    /**
     * 锦标赛选择
     * @param {Array} population - 种群
     * @returns {Object} 选中的个体
     */
    tournamentSelection: function (population) {
        const tournamentSize = 3;
        let best = null;

        for (let i = 0; i < tournamentSize; i++) {
            const index = Math.floor(Math.random() * population.length);
            const individual = population[index];

            if (!best || individual.fitness > best.fitness) {
                best = individual;
            }
        }

        return best;
    },

    /**
     * 轮盘赌选择
     * @param {Array} population - 种群
     * @returns {Object} 选中的个体
     */
    rouletteSelection: function (population) {
        const totalFitness = population.reduce((acc, ind) => acc + ind.fitness, 0);
        let random = Math.random() * totalFitness;

        for (let i = 0; i < population.length; i++) {
            random -= population[i].fitness;

            if (random <= 0) {
                return population[i];
            }
        }

        return population[population.length - 1];
    },

    /**
     * 排序选择
     * @param {Array} population - 种群
     * @returns {Object} 选中的个体
     */
    rankSelection: function (population) {
        const sorted = [...population].sort((a, b) => b.fitness - a.fitness);
        const totalRank = sorted.length * (sorted.length + 1) / 2;
        let random = Math.random() * totalRank;

        for (let i = 0; i < sorted.length; i++) {
            random -= (sorted.length - i);

            if (random <= 0) {
                return sorted[i];
            }
        }

        return sorted[sorted.length - 1];
    },

    /**
     * 交叉
     * @param {Object} parent1 - 父代1
     * @param {Object} parent2 - 父代2
     * @returns {Object} 子代
     */
    crossover: function (parent1, parent2) {
        const child = {};

        for (const key in parent1) {
            if (Math.random() < this.gaConfig.crossoverRate) {
                child[key] = parent1[key];
            } else {
                child[key] = parent2[key];
            }
        }

        return child;
    },

    /**
     * 变异
     * @param {Object} genome - 基因组
     * @returns {Object} 变异后的基因组
     */
    mutate: function (genome) {
        const mutated = {};

        for (const key in genome) {
            if (Math.random() < this.gaConfig.mutationRate) {
                if (typeof genome[key] === 'number') {
                    mutated[key] = genome[key] * (1 + (Math.random() - 0.5) * 0.2);
                } else if (Array.isArray(genome[key])) {
                    mutated[key] = genome[key].map(g => g * (1 + (Math.random() - 0.5) * 0.2));
                } else if (typeof genome[key] === 'object') {
                    mutated[key] = this.mutate(genome[key]);
                } else {
                    mutated[key] = genome[key];
                }
            } else {
                mutated[key] = genome[key];
            }
        }

        return mutated;
    },

    /**
     * 进化
     * @param {string} populationType - 种群类型
     * @param {Function} fitnessFunction - 适应度函数
     * @returns {Promise<Object>} 进化结果
     */
    evolve: function (populationType, fitnessFunction) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const result = {
                success: true,
                populationType: populationType,
                timestamp: Date.now(),
                duration: 0,
                error: null,
                generation: 0,
                bestFitness: 0,
                averageFitness: 0
            };

            if (!this.gaConfig.enabled) {
                result.success = false;
                result.error = '遗传算法已禁用';
                result.duration = performance.now() - startTime;
                reject(result);
                return;
            }

            try {
                const population = this.populations[populationType];

                if (!population || population.individuals.length === 0) {
                    result.success = false;
                    result.error = '种群不存在或为空';
                    result.duration = performance.now() - startTime;
                    reject(result);
                    return;
                }

                this.evaluateFitness(populationType, fitnessFunction);

                const sorted = [...population.individuals].sort((a, b) => b.fitness - a.fitness);
                const newIndividuals = [];

                for (let i = 0; i < this.gaConfig.elitismCount; i++) {
                    newIndividuals.push({
                        genome: { ...sorted[i].genome },
                        fitness: sorted[i].fitness
                    });
                }

                while (newIndividuals.length < this.gaConfig.populationSize) {
                    const parent1 = this.select(sorted);
                    const parent2 = this.select(sorted);
                    const childGenome = this.crossover(parent1.genome, parent2.genome);
                    const mutatedGenome = this.mutate(childGenome);

                    newIndividuals.push({
                        genome: mutatedGenome,
                        fitness: 0
                    });
                }

                population.individuals = newIndividuals;
                population.generation++;

                this.savePopulations();

                this.saveGAHistory('population_evolved', {
                    populationType: populationType,
                    generation: population.generation,
                    bestFitness: population.bestFitness,
                    averageFitness: population.averageFitness
                });

                result.generation = population.generation;
                result.bestFitness = population.bestFitness;
                result.averageFitness = population.averageFitness;
                result.duration = performance.now() - startTime;
                resolve(result);
            } catch (error) {
                result.success = false;
                result.error = error.message;
                result.duration = performance.now() - startTime;
                reject(result);
            }
        });
    },

    /**
     * 获取种群
     * @param {string} populationType - 种群类型
     * @returns {Object} 种群
     */
    getPopulation: function (populationType) {
        return this.populations[populationType] || null;
    },

    /**
     * 获取所有种群
     * @returns {Object} 所有种群
     */
    getAllPopulations: function () {
        return this.populations;
    },

    /**
     * 获取最佳个体
     * @param {string} populationType - 种群类型
     * @returns {Object} 最佳个体
     */
    getBestIndividual: function (populationType) {
        const population = this.populations[populationType];

        if (!population || population.individuals.length === 0) {
            return null;
        }

        return population.individuals.reduce((best, current) =>
            current.fitness > best.fitness ? current : best
        );
    },

    /**
     * 删除种群
     * @param {string} populationType - 种群类型
     */
    deletePopulation: function (populationType) {
        if (this.populations[populationType]) {
            delete this.populations[populationType];
            this.savePopulations();
        }
    },

    /**
     * 清空所有种群
     */
    clearAllPopulations: function () {
        this.populations = {};
        this.savePopulations();
    },

    /**
     * 保存遗传算法历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveGAHistory: function (action, data) {
        this.gaHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.gaHistory.length > this.maxHistorySize) {
            this.gaHistory.shift();
        }
    },

    /**
     * 获取遗传算法历史
     * @param {Object} options - 查询选项
     * @returns {Array} 遗传算法历史
     */
    getGAHistory: function (options) {
        let history = [...this.gaHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置遗传算法配置
     * @param {Object} config - 配置对象
     */
    setGAConfig: function (config) {
        this.gaConfig = { ...this.gaConfig, ...config };
        this.saveGAConfig();
    },

    /**
     * 获取遗传算法配置
     * @returns {Object} 配置对象
     */
    getGAConfig: function () {
        return this.gaConfig;
    },

    /**
     * 重置遗传算法系统
     */
    reset: function () {
        this.gaHistory = [];
        this.loadGAConfig();
        this.loadPopulations();
    },

    /**
     * 获取遗传算法统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const populations = Object.keys(this.populations);

        let totalGenerations = 0;
        let totalIndividuals = 0;
        let bestOverallFitness = 0;

        for (const populationType of populations) {
            const population = this.populations[populationType];
            totalGenerations += population.generation;
            totalIndividuals += population.individuals.length;

            if (population.bestFitness > bestOverallFitness) {
                bestOverallFitness = population.bestFitness;
            }
        }

        return {
            totalPopulations: populations.length,
            totalGenerations: totalGenerations,
            totalIndividuals: totalIndividuals,
            bestOverallFitness: bestOverallFitness,
            enabled: this.gaConfig.enabled,
            autoEvolve: this.gaConfig.autoEvolve,
            populationSize: this.gaConfig.populationSize,
            mutationRate: this.gaConfig.mutationRate,
            crossoverRate: this.gaConfig.crossoverRate,
            selectionMethod: this.gaConfig.selectionMethod,
            elitismCount: this.gaConfig.elitismCount,
            totalHistory: this.gaHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏进化算法优化
const GameEvolutionaryAlgorithmOptimizer = {
    eaConfig: {},
    ecosystems: {},
    eaHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏进化算法
     */
    init: function () {
        this.loadEAConfig();
        this.loadEcosystems();
    },

    /**
     * 加载进化算法配置
     */
    loadEAConfig: function () {
        this.eaConfig = {
            enabled: true,
            autoEvolve: true,
            maxHistorySize: 1000,
            populationSize: 100,
            speciesCount: 5,
            mutationRate: 0.02,
            crossoverRate: 0.8,
            speciationThreshold: 0.3,
            compatibilityThreshold: 0.5
        };

        const customConfig = localStorage.getItem('eaConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.eaConfig = { ...this.eaConfig, ...config };
            } catch (error) {
                console.error('加载进化算法配置失败:', error);
            }
        }
    },

    /**
     * 保存进化算法配置
     */
    saveEAConfig: function () {
        localStorage.setItem('eaConfig', JSON.stringify(this.eaConfig));
    },

    /**
     * 加载生态系统
     */
    loadEcosystems: function () {
        const savedEcosystems = localStorage.getItem('eaEcosystems');
        if (savedEcosystems) {
            try {
                this.ecosystems = JSON.parse(savedEcosystems);
            } catch (error) {
                console.error('加载生态系统失败:', error);
            }
        }

        if (!this.ecosystems.gameEcosystem) {
            this.ecosystems = {
                gameEcosystem: {
                    species: [],
                    generation: 0,
                    bestFitness: 0,
                    diversity: 0
                }
            };

            this.saveEcosystems();
        }
    },

    /**
     * 保存生态系统
     */
    saveEcosystems: function () {
        localStorage.setItem('eaEcosystems', JSON.stringify(this.ecosystems));
    },

    /**
     * 初始化生态系统
     * @param {string} ecosystemType - 生态系统类型
     * @param {Object} organismTemplate - 生物模板
     */
    initializeEcosystem: function (ecosystemType, organismTemplate) {
        const ecosystem = this.ecosystems[ecosystemType];

        if (!ecosystem) {
            return;
        }

        ecosystem.species = [];

        for (let i = 0; i < this.eaConfig.speciesCount; i++) {
            const species = {
                id: i,
                organisms: [],
                representative: null,
                fitness: 0,
                age: 0
            };

            const organismCount = Math.floor(this.eaConfig.populationSize / this.eaConfig.speciesCount);

            for (let j = 0; j < organismCount; j++) {
                const genome = this.createRandomGenome(organismTemplate);
                species.organisms.push({
                    genome: genome,
                    fitness: 0,
                    speciesId: i
                });
            }

            ecosystem.species.push(species);
        }

        ecosystem.generation = 0;
        ecosystem.bestFitness = 0;
        ecosystem.diversity = this.calculateDiversity(ecosystem);

        this.saveEcosystems();

        this.saveEAHistory('ecosystem_initialized', {
            ecosystemType: ecosystemType,
            speciesCount: ecosystem.species.length,
            totalOrganisms: this.eaConfig.populationSize
        });
    },

    /**
     * 创建随机基因组
     * @param {Object} template - 基因组模板
     * @returns {Object} 基因组
     */
    createRandomGenome: function (template) {
        const genome = {};

        for (const key in template) {
            const gene = template[key];

            if (typeof gene === 'number') {
                genome[key] = Math.random() * gene;
            } else if (Array.isArray(gene)) {
                genome[key] = gene.map(() => Math.random());
            } else if (typeof gene === 'object') {
                genome[key] = this.createRandomGenome(gene);
            } else {
                genome[key] = gene;
            }
        }

        return genome;
    },

    /**
     * 计算多样性
     * @param {Object} ecosystem - 生态系统
     * @returns {number} 多样性指数
     */
    calculateDiversity: function (ecosystem) {
        const totalOrganisms = ecosystem.species.reduce((acc, s) => acc + s.organisms.length, 0);

        if (totalOrganisms === 0) {
            return 0;
        }

        let shannonIndex = 0;

        for (const species of ecosystem.species) {
            const proportion = species.organisms.length / totalOrganisms;
            shannonIndex -= proportion * Math.log(proportion);
        }

        return shannonIndex;
    },

    /**
     * 计算兼容性
     * @param {Object} genome1 - 基因组1
     * @param {Object} genome2 - 基因组2
     * @returns {number} 兼容性距离
     */
    calculateCompatibility: function (genome1, genome2) {
        let distance = 0;
        let count = 0;

        for (const key in genome1) {
            if (genome2[key] !== undefined) {
                if (typeof genome1[key] === 'number' && typeof genome2[key] === 'number') {
                    distance += Math.abs(genome1[key] - genome2[key]);
                    count++;
                } else if (Array.isArray(genome1[key]) && Array.isArray(genome2[key])) {
                    for (let i = 0; i < Math.min(genome1[key].length, genome2[key].length); i++) {
                        distance += Math.abs(genome1[key][i] - genome2[key][i]);
                        count++;
                    }
                }
            }
        }

        return count > 0 ? distance / count : 1;
    },

    /**
     * 物种形成
     * @param {Object} ecosystem - 生态系统
     */
    speciate: function (ecosystem) {
        const allOrganisms = [];

        for (const species of ecosystem.species) {
            allOrganisms.push(...species.organisms);
        }

        ecosystem.species = [];

        for (const organism of allOrganisms) {
            let assigned = false;

            for (const species of ecosystem.species) {
                if (species.representative) {
                    const distance = this.calculateCompatibility(organism.genome, species.representative);

                    if (distance < this.eaConfig.speciationThreshold) {
                        organism.speciesId = species.id;
                        species.organisms.push(organism);
                        assigned = true;
                        break;
                    }
                }
            }

            if (!assigned) {
                const newSpecies = {
                    id: ecosystem.species.length,
                    organisms: [organism],
                    representative: organism.genome,
                    fitness: 0,
                    age: 0
                };

                organism.speciesId = newSpecies.id;
                ecosystem.species.push(newSpecies);
            }
        }

        for (const species of ecosystem.species) {
            if (species.organisms.length > 0) {
                const randomIndex = Math.floor(Math.random() * species.organisms.length);
                species.representative = species.organisms[randomIndex].genome;
            }
        }
    },

    /**
     * 评估适应度
     * @param {string} ecosystemType - 生态系统类型
     * @param {Function} fitnessFunction - 适应度函数
     */
    evaluateFitness: function (ecosystemType, fitnessFunction) {
        const ecosystem = this.ecosystems[ecosystemType];

        if (!ecosystem) {
            return;
        }

        let bestFitness = 0;

        for (const species of ecosystem.species) {
            let speciesFitness = 0;

            for (const organism of species.organisms) {
                organism.fitness = fitnessFunction(organism.genome);
                speciesFitness += organism.fitness;

                if (organism.fitness > bestFitness) {
                    bestFitness = organism.fitness;
                }
            }

            species.fitness = speciesFitness / species.organisms.length;
        }

        ecosystem.bestFitness = bestFitness;
        ecosystem.diversity = this.calculateDiversity(ecosystem);

        this.saveEcosystems();
    },

    /**
     * 进化
     * @param {string} ecosystemType - 生态系统类型
     * @param {Function} fitnessFunction - 适应度函数
     * @returns {Promise<Object>} 进化结果
     */
    evolve: function (ecosystemType, fitnessFunction) {
        return new Promise((resolve, reject) => {
            const startTime = performance.now();
            const result = {
                success: true,
                ecosystemType: ecosystemType,
                timestamp: Date.now(),
                duration: 0,
                error: null,
                generation: 0,
                bestFitness: 0,
                diversity: 0,
                speciesCount: 0
            };

            if (!this.eaConfig.enabled) {
                result.success = false;
                result.error = '进化算法已禁用';
                result.duration = performance.now() - startTime;
                reject(result);
                return;
            }

            try {
                const ecosystem = this.ecosystems[ecosystemType];

                if (!ecosystem || ecosystem.species.length === 0) {
                    result.success = false;
                    result.error = '生态系统不存在或为空';
                    result.duration = performance.now() - startTime;
                    reject(result);
                    return;
                }

                this.evaluateFitness(ecosystemType, fitnessFunction);
                this.speciate(ecosystem);

                for (const species of ecosystem.species) {
                    const sorted = [...species.organisms].sort((a, b) => b.fitness - a.fitness);
                    const newOrganisms = [];

                    const eliteCount = Math.max(1, Math.floor(sorted.length * 0.1));

                    for (let i = 0; i < eliteCount; i++) {
                        newOrganisms.push({
                            genome: { ...sorted[i].genome },
                            fitness: sorted[i].fitness,
                            speciesId: species.id
                        });
                    }

                    while (newOrganisms.length < sorted.length) {
                        const parent1 = this.select(sorted);
                        const parent2 = this.select(sorted);
                        const childGenome = this.crossover(parent1.genome, parent2.genome);
                        const mutatedGenome = this.mutate(childGenome);

                        newOrganisms.push({
                            genome: mutatedGenome,
                            fitness: 0,
                            speciesId: species.id
                        });
                    }

                    species.organisms = newOrganisms;
                    species.age++;
                }

                ecosystem.generation++;
                this.saveEcosystems();

                this.saveEAHistory('ecosystem_evolved', {
                    ecosystemType: ecosystemType,
                    generation: ecosystem.generation,
                    bestFitness: ecosystem.bestFitness,
                    diversity: ecosystem.diversity,
                    speciesCount: ecosystem.species.length
                });

                result.generation = ecosystem.generation;
                result.bestFitness = ecosystem.bestFitness;
                result.diversity = ecosystem.diversity;
                result.speciesCount = ecosystem.species.length;
                result.duration = performance.now() - startTime;
                resolve(result);
            } catch (error) {
                result.success = false;
                result.error = error.message;
                result.duration = performance.now() - startTime;
                reject(result);
            }
        });
    },

    /**
     * 选择
     * @param {Array} organisms - 生物列表
     * @returns {Object} 选中的生物
     */
    select: function (organisms) {
        const tournamentSize = 3;
        let best = null;

        for (let i = 0; i < tournamentSize; i++) {
            const index = Math.floor(Math.random() * organisms.length);
            const organism = organisms[index];

            if (!best || organism.fitness > best.fitness) {
                best = organism;
            }
        }

        return best;
    },

    /**
     * 交叉
     * @param {Object} parent1 - 父代1
     * @param {Object} parent2 - 父代2
     * @returns {Object} 子代
     */
    crossover: function (parent1, parent2) {
        const child = {};

        for (const key in parent1) {
            if (Math.random() < this.eaConfig.crossoverRate) {
                child[key] = parent1[key];
            } else {
                child[key] = parent2[key];
            }
        }

        return child;
    },

    /**
     * 变异
     * @param {Object} genome - 基因组
     * @returns {Object} 变异后的基因组
     */
    mutate: function (genome) {
        const mutated = {};

        for (const key in genome) {
            if (Math.random() < this.eaConfig.mutationRate) {
                if (typeof genome[key] === 'number') {
                    mutated[key] = genome[key] * (1 + (Math.random() - 0.5) * 0.3);
                } else if (Array.isArray(genome[key])) {
                    mutated[key] = genome[key].map(g => g * (1 + (Math.random() - 0.5) * 0.3));
                } else if (typeof genome[key] === 'object') {
                    mutated[key] = this.mutate(genome[key]);
                } else {
                    mutated[key] = genome[key];
                }
            } else {
                mutated[key] = genome[key];
            }
        }

        return mutated;
    },

    /**
     * 获取生态系统
     * @param {string} ecosystemType - 生态系统类型
     * @returns {Object} 生态系统
     */
    getEcosystem: function (ecosystemType) {
        return this.ecosystems[ecosystemType] || null;
    },

    /**
     * 获取所有生态系统
     * @returns {Object} 所有生态系统
     */
    getAllEcosystems: function () {
        return this.ecosystems;
    },

    /**
     * 获取最佳生物
     * @param {string} ecosystemType - 生态系统类型
     * @returns {Object} 最佳生物
     */
    getBestOrganism: function (ecosystemType) {
        const ecosystem = this.ecosystems[ecosystemType];

        if (!ecosystem || ecosystem.species.length === 0) {
            return null;
        }

        let best = null;

        for (const species of ecosystem.species) {
            for (const organism of species.organisms) {
                if (!best || organism.fitness > best.fitness) {
                    best = organism;
                }
            }
        }

        return best;
    },

    /**
     * 删除生态系统
     * @param {string} ecosystemType - 生态系统类型
     */
    deleteEcosystem: function (ecosystemType) {
        if (this.ecosystems[ecosystemType]) {
            delete this.ecosystems[ecosystemType];
            this.saveEcosystems();
        }
    },

    /**
     * 清空所有生态系统
     */
    clearAllEcosystems: function () {
        this.ecosystems = {};
        this.saveEcosystems();
    },

    /**
     * 保存进化算法历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveEAHistory: function (action, data) {
        this.eaHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.eaHistory.length > this.maxHistorySize) {
            this.eaHistory.shift();
        }
    },

    /**
     * 获取进化算法历史
     * @param {Object} options - 查询选项
     * @returns {Array} 进化算法历史
     */
    getEAHistory: function (options) {
        let history = [...this.eaHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置进化算法配置
     * @param {Object} config - 配置对象
     */
    setEAConfig: function (config) {
        this.eaConfig = { ...this.eaConfig, ...config };
        this.saveEAConfig();
    },

    /**
     * 获取进化算法配置
     * @returns {Object} 配置对象
     */
    getEAConfig: function () {
        return this.eaConfig;
    },

    /**
     * 重置进化算法系统
     */
    reset: function () {
        this.eaHistory = [];
        this.loadEAConfig();
        this.loadEcosystems();
    },

    /**
     * 获取进化算法统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const ecosystems = Object.keys(this.ecosystems);

        let totalGenerations = 0;
        let totalSpecies = 0;
        let totalOrganisms = 0;
        let bestOverallFitness = 0;
        let averageDiversity = 0;

        for (const ecosystemType of ecosystems) {
            const ecosystem = this.ecosystems[ecosystemType];
            totalGenerations += ecosystem.generation;
            totalSpecies += ecosystem.species.length;
            totalOrganisms += ecosystem.species.reduce((acc, s) => acc + s.organisms.length, 0);
            averageDiversity += ecosystem.diversity;

            if (ecosystem.bestFitness > bestOverallFitness) {
                bestOverallFitness = ecosystem.bestFitness;
            }
        }

        averageDiversity = ecosystems.length > 0 ? averageDiversity / ecosystems.length : 0;

        return {
            totalEcosystems: ecosystems.length,
            totalGenerations: totalGenerations,
            totalSpecies: totalSpecies,
            totalOrganisms: totalOrganisms,
            bestOverallFitness: bestOverallFitness,
            averageDiversity: averageDiversity.toFixed(4),
            enabled: this.eaConfig.enabled,
            autoEvolve: this.eaConfig.autoEvolve,
            populationSize: this.eaConfig.populationSize,
            speciesCount: this.eaConfig.speciesCount,
            mutationRate: this.eaConfig.mutationRate,
            crossoverRate: this.eaConfig.crossoverRate,
            speciationThreshold: this.eaConfig.speciationThreshold,
            compatibilityThreshold: this.eaConfig.compatibilityThreshold,
            totalHistory: this.eaHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏模糊逻辑优化
const GameFuzzyLogicOptimizer = {
    flConfig: {},
    fuzzySystems: {},
    flHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏模糊逻辑
     */
    init: function () {
        this.loadFLConfig();
        this.loadFuzzySystems();
    },

    /**
     * 加载模糊逻辑配置
     */
    loadFLConfig: function () {
        this.flConfig = {
            enabled: true,
            maxHistorySize: 1000,
            inferenceMethod: 'mamdani',
            defuzzificationMethod: 'centroid',
            aggregationMethod: 'max'
        };

        const customConfig = localStorage.getItem('flConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.flConfig = { ...this.flConfig, ...config };
            } catch (error) {
                console.error('加载模糊逻辑配置失败:', error);
            }
        }
    },

    /**
     * 保存模糊逻辑配置
     */
    saveFLConfig: function () {
        localStorage.setItem('flConfig', JSON.stringify(this.flConfig));
    },

    /**
     * 加载模糊系统
     */
    loadFuzzySystems: function () {
        const savedSystems = localStorage.getItem('fuzzySystems');
        if (savedSystems) {
            try {
                this.fuzzySystems = JSON.parse(savedSystems);
            } catch (error) {
                console.error('加载模糊系统失败:', error);
            }
        }

        if (!this.fuzzySystems.difficultySystem) {
            this.fuzzySystems = {
                difficultySystem: {
                    variables: {},
                    rules: [],
                    outputs: {}
                },
                aiBehaviorSystem: {
                    variables: {},
                    rules: [],
                    outputs: {}
                },
                gameBalanceSystem: {
                    variables: {},
                    rules: [],
                    outputs: {}
                }
            };

            this.saveFuzzySystems();
        }
    },

    /**
     * 保存模糊系统
     */
    saveFuzzySystems: function () {
        localStorage.setItem('fuzzySystems', JSON.stringify(this.fuzzySystems));
    },

    /**
     * 创建模糊变量
     * @param {string} systemType - 系统类型
     * @param {string} variableName - 变量名称
     * @param {Object} config - 配置对象
     */
    createFuzzyVariable: function (systemType, variableName, config) {
        const system = this.fuzzySystems[systemType];

        if (!system) {
            return;
        }

        system.variables[variableName] = {
            name: variableName,
            min: config.min || 0,
            max: config.max || 100,
            membershipFunctions: config.membershipFunctions || {}
        };

        this.saveFuzzySystems();

        this.saveFLHistory('variable_created', {
            systemType: systemType,
            variableName: variableName
        });
    },

    /**
     * 创建隶属度函数
     * @param {string} systemType - 系统类型
     * @param {string} variableName - 变量名称
     * @param {string} functionName - 函数名称
     * @param {string} type - 函数类型
     * @param {Array} params - 参数数组
     */
    createMembershipFunction: function (systemType, variableName, functionName, type, params) {
        const system = this.fuzzySystems[systemType];

        if (!system || !system.variables[variableName]) {
            return;
        }

        system.variables[variableName].membershipFunctions[functionName] = {
            name: functionName,
            type: type,
            params: params
        };

        this.saveFuzzySystems();
    },

    /**
     * 计算隶属度
     * @param {number} value - 输入值
     * @param {Object} membershipFunction - 隶属度函数
     * @returns {number} 隶属度
     */
    calculateMembership: function (value, membershipFunction) {
        const type = membershipFunction.type;
        const params = membershipFunction.params;

        switch (type) {
            case 'triangle':
                const [a, b, c] = params;
                if (value <= a || value >= c) return 0;
                if (value === b) return 1;
                if (value < b) return (value - a) / (b - a);
                return (c - value) / (c - b);

            case 'trapezoid':
                const [t1, t2, t3, t4] = params;
                if (value <= t1 || value >= t4) return 0;
                if (value >= t2 && value <= t3) return 1;
                if (value < t2) return (value - t1) / (t2 - t1);
                return (t4 - value) / (t4 - t3);

            case 'gaussian':
                const [mean, sigma] = params;
                return Math.exp(-Math.pow(value - mean, 2) / (2 * Math.pow(sigma, 2)));

            case 'sigmoid':
                const [s_center, s_width] = params;
                return 1 / (1 + Math.exp(-s_width * (value - s_center)));

            default:
                return 0;
        }
    },

    /**
     * 模糊化
     * @param {string} systemType - 系统类型
     * @param {string} variableName - 变量名称
     * @param {number} value - 输入值
     * @returns {Object} 模糊化结果
     */
    fuzzify: function (systemType, variableName, value) {
        const system = this.fuzzySystems[systemType];

        if (!system || !system.variables[variableName]) {
            return null;
        }

        const variable = system.variables[variableName];
        const result = {};

        for (const functionName in variable.membershipFunctions) {
            const membershipFunction = variable.membershipFunctions[functionName];
            result[functionName] = this.calculateMembership(value, membershipFunction);
        }

        return result;
    },

    /**
     * 添加模糊规则
     * @param {string} systemType - 系统类型
     * @param {Array} antecedents - 前件
     * @param {Array} consequents - 后件
     */
    addFuzzyRule: function (systemType, antecedents, consequents) {
        const system = this.fuzzySystems[systemType];

        if (!system) {
            return;
        }

        system.rules.push({
            antecedents: antecedents,
            consequents: consequents,
            weight: 1
        });

        this.saveFuzzySystems();

        this.saveFLHistory('rule_added', {
            systemType: systemType,
            ruleCount: system.rules.length
        });
    },

    /**
     * 模糊推理
     * @param {string} systemType - 系统类型
     * @param {Object} inputs - 输入值
     * @returns {Object} 推理结果
     */
    infer: function (systemType, inputs) {
        const system = this.fuzzySystems[systemType];

        if (!system) {
            return null;
        }

        const fuzzyInputs = {};

        for (const variableName in inputs) {
            fuzzyInputs[variableName] = this.fuzzify(systemType, variableName, inputs[variableName]);
        }

        const ruleResults = [];

        for (const rule of system.rules) {
            let ruleStrength = 1;

            for (const antecedent of rule.antecedents) {
                const variableName = antecedent.variable;
                const functionName = antecedent.function;
                const membership = fuzzyInputs[variableName][functionName];

                if (antecedent.operator === 'AND') {
                    ruleStrength = Math.min(ruleStrength, membership);
                } else if (antecedent.operator === 'OR') {
                    ruleStrength = Math.max(ruleStrength, membership);
                } else {
                    ruleStrength = membership;
                }
            }

            for (const consequent of rule.consequents) {
                ruleResults.push({
                    variable: consequent.variable,
                    function: consequent.function,
                    strength: ruleStrength * rule.weight
                });
            }
        }

        return ruleResults;
    },

    /**
     * 去模糊化
     * @param {string} systemType - 系统类型
     * @param {string} outputVariable - 输出变量
     * @param {Array} ruleResults - 规则结果
     * @returns {number} 去模糊化结果
     */
    defuzzify: function (systemType, outputVariable, ruleResults) {
        const system = this.fuzzySystems[systemType];

        if (!system || !system.variables[outputVariable]) {
            return 0;
        }

        const variable = system.variables[outputVariable];
        const method = this.flConfig.defuzzificationMethod;

        switch (method) {
            case 'centroid':
                return this.centroidDefuzzification(variable, ruleResults);

            case 'bisector':
                return this.bisectorDefuzzification(variable, ruleResults);

            case 'mom':
                return this.meanOfMaximumDefuzzification(variable, ruleResults);

            case 'som':
                return this.smallestOfMaximumDefuzzification(variable, ruleResults);

            case 'lom':
                return this.largestOfMaximumDefuzzification(variable, ruleResults);

            default:
                return this.centroidDefuzzification(variable, ruleResults);
        }
    },

    /**
     * 重心法去模糊化
     * @param {Object} variable - 变量
     * @param {Array} ruleResults - 规则结果
     * @returns {number} 去模糊化结果
     */
    centroidDefuzzification: function (variable, ruleResults) {
        const step = 0.01;
        let numerator = 0;
        let denominator = 0;

        for (let x = variable.min; x <= variable.max; x += step) {
            let maxMembership = 0;

            for (const result of ruleResults) {
                if (result.variable === variable.name) {
                    const membershipFunction = variable.membershipFunctions[result.function];
                    const membership = this.calculateMembership(x, membershipFunction);
                    maxMembership = Math.max(maxMembership, Math.min(membership, result.strength));
                }
            }

            numerator += x * maxMembership;
            denominator += maxMembership;
        }

        return denominator > 0 ? numerator / denominator : 0;
    },

    /**
     * 平分法去模糊化
     * @param {Object} variable - 变量
     * @param {Array} ruleResults - 规则结果
     * @returns {number} 去模糊化结果
     */
    bisectorDefuzzification: function (variable, ruleResults) {
        const step = 0.01;
        const aggregated = [];

        for (let x = variable.min; x <= variable.max; x += step) {
            let maxMembership = 0;

            for (const result of ruleResults) {
                if (result.variable === variable.name) {
                    const membershipFunction = variable.membershipFunctions[result.function];
                    const membership = this.calculateMembership(x, membershipFunction);
                    maxMembership = Math.max(maxMembership, Math.min(membership, result.strength));
                }
            }

            aggregated.push({ x: x, membership: maxMembership });
        }

        let totalArea = 0;

        for (let i = 0; i < aggregated.length - 1; i++) {
            totalArea += (aggregated[i].membership + aggregated[i + 1].membership) / 2 * step;
        }

        let currentArea = 0;

        for (let i = 0; i < aggregated.length - 1; i++) {
            const area = (aggregated[i].membership + aggregated[i + 1].membership) / 2 * step;

            if (currentArea + area >= totalArea / 2) {
                return aggregated[i].x;
            }

            currentArea += area;
        }

        return 0;
    },

    /**
     * 最大平均值去模糊化
     * @param {Object} variable - 变量
     * @param {Array} ruleResults - 规则结果
     * @returns {number} 去模糊化结果
     */
    meanOfMaximumDefuzzification: function (variable, ruleResults) {
        const step = 0.01;
        let maxMembership = 0;
        const maxPoints = [];

        for (let x = variable.min; x <= variable.max; x += step) {
            let currentMembership = 0;

            for (const result of ruleResults) {
                if (result.variable === variable.name) {
                    const membershipFunction = variable.membershipFunctions[result.function];
                    const membership = this.calculateMembership(x, membershipFunction);
                    currentMembership = Math.max(currentMembership, Math.min(membership, result.strength));
                }
            }

            if (currentMembership > maxMembership) {
                maxMembership = currentMembership;
                maxPoints.length = 0;
                maxPoints.push(x);
            } else if (currentMembership === maxMembership) {
                maxPoints.push(x);
            }
        }

        if (maxPoints.length === 0) {
            return 0;
        }

        return maxPoints.reduce((sum, x) => sum + x, 0) / maxPoints.length;
    },

    /**
     * 最小最大值去模糊化
     * @param {Object} variable - 变量
     * @param {Array} ruleResults - 规则结果
     * @returns {number} 去模糊化结果
     */
    smallestOfMaximumDefuzzification: function (variable, ruleResults) {
        const step = 0.01;
        let maxMembership = 0;
        let smallestMax = Infinity;

        for (let x = variable.min; x <= variable.max; x += step) {
            let currentMembership = 0;

            for (const result of ruleResults) {
                if (result.variable === variable.name) {
                    const membershipFunction = variable.membershipFunctions[result.function];
                    const membership = this.calculateMembership(x, membershipFunction);
                    currentMembership = Math.max(currentMembership, Math.min(membership, result.strength));
                }
            }

            if (currentMembership > maxMembership) {
                maxMembership = currentMembership;
                smallestMax = x;
            } else if (currentMembership === maxMembership && x < smallestMax) {
                smallestMax = x;
            }
        }

        return smallestMax !== Infinity ? smallestMax : 0;
    },

    /**
     * 最大最大值去模糊化
     * @param {Object} variable - 变量
     * @param {Array} ruleResults - 规则结果
     * @returns {number} 去模糊化结果
     */
    largestOfMaximumDefuzzification: function (variable, ruleResults) {
        const step = 0.01;
        let maxMembership = 0;
        let largestMax = -Infinity;

        for (let x = variable.min; x <= variable.max; x += step) {
            let currentMembership = 0;

            for (const result of ruleResults) {
                if (result.variable === variable.name) {
                    const membershipFunction = variable.membershipFunctions[result.function];
                    const membership = this.calculateMembership(x, membershipFunction);
                    currentMembership = Math.max(currentMembership, Math.min(membership, result.strength));
                }
            }

            if (currentMembership > maxMembership) {
                maxMembership = currentMembership;
                largestMax = x;
            } else if (currentMembership === maxMembership && x > largestMax) {
                largestMax = x;
            }
        }

        return largestMax !== -Infinity ? largestMax : 0;
    },

    /**
     * 获取模糊系统
     * @param {string} systemType - 系统类型
     * @returns {Object} 模糊系统
     */
    getFuzzySystem: function (systemType) {
        return this.fuzzySystems[systemType] || null;
    },

    /**
     * 获取所有模糊系统
     * @returns {Object} 所有模糊系统
     */
    getAllFuzzySystems: function () {
        return this.fuzzySystems;
    },

    /**
     * 删除模糊系统
     * @param {string} systemType - 系统类型
     */
    deleteFuzzySystem: function (systemType) {
        if (this.fuzzySystems[systemType]) {
            delete this.fuzzySystems[systemType];
            this.saveFuzzySystems();
        }
    },

    /**
     * 清空所有模糊系统
     */
    clearAllFuzzySystems: function () {
        this.fuzzySystems = {};
        this.saveFuzzySystems();
    },

    /**
     * 保存模糊逻辑历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveFLHistory: function (action, data) {
        this.flHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.flHistory.length > this.maxHistorySize) {
            this.flHistory.shift();
        }
    },

    /**
     * 获取模糊逻辑历史
     * @param {Object} options - 查询选项
     * @returns {Array} 模糊逻辑历史
     */
    getFLHistory: function (options) {
        let history = [...this.flHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置模糊逻辑配置
     * @param {Object} config - 配置对象
     */
    setFLConfig: function (config) {
        this.flConfig = { ...this.flConfig, ...config };
        this.saveFLConfig();
    },

    /**
     * 获取模糊逻辑配置
     * @returns {Object} 配置对象
     */
    getFLConfig: function () {
        return this.flConfig;
    },

    /**
     * 重置模糊逻辑系统
     */
    reset: function () {
        this.flHistory = [];
        this.loadFLConfig();
        this.loadFuzzySystems();
    },

    /**
     * 获取模糊逻辑统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const systems = Object.keys(this.fuzzySystems);

        let totalVariables = 0;
        let totalRules = 0;

        for (const systemType of systems) {
            const system = this.fuzzySystems[systemType];
            totalVariables += Object.keys(system.variables).length;
            totalRules += system.rules.length;
        }

        return {
            totalSystems: systems.length,
            totalVariables: totalVariables,
            totalRules: totalRules,
            enabled: this.flConfig.enabled,
            inferenceMethod: this.flConfig.inferenceMethod,
            defuzzificationMethod: this.flConfig.defuzzificationMethod,
            aggregationMethod: this.flConfig.aggregationMethod,
            totalHistory: this.flHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏专家系统优化
const GameExpertSystemOptimizer = {
    esConfig: {},
    expertSystems: {},
    esHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏专家系统
     */
    init: function () {
        this.loadESConfig();
        this.loadExpertSystems();
    },

    /**
     * 加载专家系统配置
     */
    loadESConfig: function () {
        this.esConfig = {
            enabled: true,
            maxHistorySize: 1000,
            inferenceEngine: 'forward',
            conflictResolution: 'priority',
            certaintyFactor: true
        };

        const customConfig = localStorage.getItem('esConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.esConfig = { ...this.esConfig, ...config };
            } catch (error) {
                console.error('加载专家系统配置失败:', error);
            }
        }
    },

    /**
     * 保存专家系统配置
     */
    saveESConfig: function () {
        localStorage.setItem('esConfig', JSON.stringify(this.esConfig));
    },

    /**
     * 加载专家系统
     */
    loadExpertSystems: function () {
        const savedSystems = localStorage.getItem('expertSystems');
        if (savedSystems) {
            try {
                this.expertSystems = JSON.parse(savedSystems);
            } catch (error) {
                console.error('加载专家系统失败:', error);
            }
        }

        if (!this.expertSystems.gameStrategySystem) {
            this.expertSystems = {
                gameStrategySystem: {
                    facts: {},
                    rules: [],
                    goals: []
                },
                playerAdviceSystem: {
                    facts: {},
                    rules: [],
                    goals: []
                },
                difficultyAdjustmentSystem: {
                    facts: {},
                    rules: [],
                    goals: []
                }
            };

            this.saveExpertSystems();
        }
    },

    /**
     * 保存专家系统
     */
    saveExpertSystems: function () {
        localStorage.setItem('expertSystems', JSON.stringify(this.expertSystems));
    },

    /**
     * 添加事实
     * @param {string} systemType - 系统类型
     * @param {string} factName - 事实名称
     * @param {*} value - 事实值
     * @param {number} certainty - 确定性因子
     */
    addFact: function (systemType, factName, value, certainty) {
        const system = this.expertSystems[systemType];

        if (!system) {
            return;
        }

        system.facts[factName] = {
            name: factName,
            value: value,
            certainty: certainty || 1.0,
            timestamp: Date.now()
        };

        this.saveExpertSystems();

        this.saveESHistory('fact_added', {
            systemType: systemType,
            factName: factName
        });
    },

    /**
     * 获取事实
     * @param {string} systemType - 系统类型
     * @param {string} factName - 事实名称
     * @returns {Object} 事实对象
     */
    getFact: function (systemType, factName) {
        const system = this.expertSystems[systemType];

        if (!system || !system.facts[factName]) {
            return null;
        }

        return system.facts[factName];
    },

    /**
     * 删除事实
     * @param {string} systemType - 系统类型
     * @param {string} factName - 事实名称
     */
    removeFact: function (systemType, factName) {
        const system = this.expertSystems[systemType];

        if (system && system.facts[factName]) {
            delete system.facts[factName];
            this.saveExpertSystems();
        }
    },

    /**
     * 添加规则
     * @param {string} systemType - 系统类型
     * @param {string} ruleName - 规则名称
     * @param {Array} conditions - 条件数组
     * @param {Array} actions - 动作数组
     * @param {number} priority - 优先级
     */
    addRule: function (systemType, ruleName, conditions, actions, priority) {
        const system = this.expertSystems[systemType];

        if (!system) {
            return;
        }

        system.rules.push({
            name: ruleName,
            conditions: conditions,
            actions: actions,
            priority: priority || 0,
            fired: false,
            fireCount: 0
        });

        this.saveExpertSystems();

        this.saveESHistory('rule_added', {
            systemType: systemType,
            ruleName: ruleName
        });
    },

    /**
     * 检查条件
     * @param {Object} condition - 条件对象
     * @param {Object} facts - 事实集合
     * @returns {boolean} 条件是否满足
     */
    checkCondition: function (condition, facts) {
        const fact = facts[condition.fact];

        if (!fact) {
            return false;
        }

        const value = fact.value;
        const operator = condition.operator;
        const target = condition.value;

        switch (operator) {
            case '==':
                return value == target;
            case '!=':
                return value != target;
            case '>':
                return value > target;
            case '<':
                return value < target;
            case '>=':
                return value >= target;
            case '<=':
                return value <= target;
            case 'contains':
                return Array.isArray(value) && value.includes(target);
            case 'in':
                return Array.isArray(target) && target.includes(value);
            default:
                return false;
        }
    },

    /**
     * 执行动作
     * @param {Object} action - 动作对象
     * @param {Object} facts - 事实集合
     */
    executeAction: function (action, facts) {
        switch (action.type) {
            case 'add_fact':
                facts[action.fact] = {
                    name: action.fact,
                    value: action.value,
                    certainty: action.certainty || 1.0,
                    timestamp: Date.now()
                };
                break;

            case 'remove_fact':
                if (facts[action.fact]) {
                    delete facts[action.fact];
                }
                break;

            case 'modify_fact':
                if (facts[action.fact]) {
                    facts[action.fact].value = action.value;
                    facts[action.fact].timestamp = Date.now();
                }
                break;

            case 'set_goal':
                if (typeof this.setGoal === 'function') {
                    this.setGoal(action.systemType, action.goal, action.priority);
                }
                break;

            case 'trigger_event':
                if (typeof messageBus !== 'undefined') {
                    messageBus.emit(action.event, action.data);
                }
                break;
        }
    },

    /**
     * 前向推理
     * @param {string} systemType - 系统类型
     * @returns {Array} 推理结果
     */
    forwardChain: function (systemType) {
        const system = this.expertSystems[systemType];

        if (!system) {
            return [];
        }

        const results = [];
        let changed = true;

        while (changed) {
            changed = false;

            for (const rule of system.rules) {
                if (rule.fired) {
                    continue;
                }

                let allConditionsMet = true;

                for (const condition of rule.conditions) {
                    if (!this.checkCondition(condition, system.facts)) {
                        allConditionsMet = false;
                        break;
                    }
                }

                if (allConditionsMet) {
                    for (const action of rule.actions) {
                        this.executeAction(action, system.facts);
                    }

                    rule.fired = true;
                    rule.fireCount++;
                    changed = true;

                    results.push({
                        rule: rule.name,
                        actions: rule.actions,
                        timestamp: Date.now()
                    });
                }
            }
        }

        this.saveExpertSystems();

        this.saveESHistory('forward_chain_completed', {
            systemType: systemType,
            rulesFired: results.length
        });

        return results;
    },

    /**
     * 后向推理
     * @param {string} systemType - 系统类型
     * @param {string} goal - 目标
     * @returns {Array} 推理结果
     */
    backwardChain: function (systemType, goal) {
        const system = this.expertSystems[systemType];

        if (!system) {
            return [];
        }

        const results = [];
        const visitedRules = new Set();

        const prove = function (factName) {
            if (system.facts[factName]) {
                return true;
            }

            for (const rule of system.rules) {
                if (visitedRules.has(rule.name)) {
                    continue;
                }

                visitedRules.add(rule.name);

                const conclusionAction = rule.actions.find(a => a.type === 'add_fact' && a.fact === factName);

                if (!conclusionAction) {
                    continue;
                }

                let allConditionsProved = true;

                for (const condition of rule.conditions) {
                    if (!prove(condition.fact)) {
                        allConditionsProved = false;
                        break;
                    }
                }

                if (allConditionsProved) {
                    for (const action of rule.actions) {
                        this.executeAction(action, system.facts);
                    }

                    results.push({
                        rule: rule.name,
                        actions: rule.actions,
                        timestamp: Date.now()
                    });

                    return true;
                }
            }

            return false;
        }.bind(this);

        prove(goal);

        this.saveExpertSystems();

        this.saveESHistory('backward_chain_completed', {
            systemType: systemType,
            goal: goal,
            rulesFired: results.length
        });

        return results;
    },

    /**
     * 设置目标
     * @param {string} systemType - 系统类型
     * @param {string} goal - 目标
     * @param {number} priority - 优先级
     */
    setGoal: function (systemType, goal, priority) {
        const system = this.expertSystems[systemType];

        if (!system) {
            return;
        }

        system.goals.push({
            name: goal,
            priority: priority || 0,
            achieved: false,
            timestamp: Date.now()
        });

        this.saveExpertSystems();
    },

    /**
     * 获取目标
     * @param {string} systemType - 系统类型
     * @returns {Array} 目标列表
     */
    getGoals: function (systemType) {
        const system = this.expertSystems[systemType];

        if (!system) {
            return [];
        }

        return system.goals;
    },

    /**
     * 获取专家系统
     * @param {string} systemType - 系统类型
     * @returns {Object} 专家系统
     */
    getExpertSystem: function (systemType) {
        return this.expertSystems[systemType] || null;
    },

    /**
     * 获取所有专家系统
     * @returns {Object} 所有专家系统
     */
    getAllExpertSystems: function () {
        return this.expertSystems;
    },

    /**
     * 删除专家系统
     * @param {string} systemType - 系统类型
     */
    deleteExpertSystem: function (systemType) {
        if (this.expertSystems[systemType]) {
            delete this.expertSystems[systemType];
            this.saveExpertSystems();
        }
    },

    /**
     * 清空所有专家系统
     */
    clearAllExpertSystems: function () {
        this.expertSystems = {};
        this.saveExpertSystems();
    },

    /**
     * 重置系统状态
     * @param {string} systemType - 系统类型
     */
    resetSystem: function (systemType) {
        const system = this.expertSystems[systemType];

        if (!system) {
            return;
        }

        for (const rule of system.rules) {
            rule.fired = false;
        }

        this.saveExpertSystems();
    },

    /**
     * 保存专家系统历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveESHistory: function (action, data) {
        this.esHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.esHistory.length > this.maxHistorySize) {
            this.esHistory.shift();
        }
    },

    /**
     * 获取专家系统历史
     * @param {Object} options - 查询选项
     * @returns {Array} 专家系统历史
     */
    getESHistory: function (options) {
        let history = [...this.esHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置专家系统配置
     * @param {Object} config - 配置对象
     */
    setESConfig: function (config) {
        this.esConfig = { ...this.esConfig, ...config };
        this.saveESConfig();
    },

    /**
     * 获取专家系统配置
     * @returns {Object} 配置对象
     */
    getESConfig: function () {
        return this.esConfig;
    },

    /**
     * 重置专家系统
     */
    reset: function () {
        this.esHistory = [];
        this.loadESConfig();
        this.loadExpertSystems();
    },

    /**
     * 获取专家系统统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const systems = Object.keys(this.expertSystems);

        let totalFacts = 0;
        let totalRules = 0;
        let totalGoals = 0;
        let totalFiredRules = 0;

        for (const systemType of systems) {
            const system = this.expertSystems[systemType];
            totalFacts += Object.keys(system.facts).length;
            totalRules += system.rules.length;
            totalGoals += system.goals.length;

            for (const rule of system.rules) {
                totalFiredRules += rule.fireCount;
            }
        }

        return {
            totalSystems: systems.length,
            totalFacts: totalFacts,
            totalRules: totalRules,
            totalGoals: totalGoals,
            totalFiredRules: totalFiredRules,
            enabled: this.esConfig.enabled,
            inferenceEngine: this.esConfig.inferenceEngine,
            conflictResolution: this.esConfig.conflictResolution,
            certaintyFactor: this.esConfig.certaintyFactor,
            totalHistory: this.esHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏知识图谱优化
const GameKnowledgeGraphOptimizer = {
    kgConfig: {},
    knowledgeGraphs: {},
    kgHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏知识图谱
     */
    init: function () {
        this.loadKGConfig();
        this.loadKnowledgeGraphs();
    },

    /**
     * 加载知识图谱配置
     */
    loadKGConfig: function () {
        this.kgConfig = {
            enabled: true,
            maxHistorySize: 1000,
            autoUpdate: true,
            reasoningEnabled: true,
            similarityThreshold: 0.7
        };

        const customConfig = localStorage.getItem('kgConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.kgConfig = { ...this.kgConfig, ...config };
            } catch (error) {
                console.error('加载知识图谱配置失败:', error);
            }
        }
    },

    /**
     * 保存知识图谱配置
     */
    saveKGConfig: function () {
        localStorage.setItem('kgConfig', JSON.stringify(this.kgConfig));
    },

    /**
     * 加载知识图谱
     */
    loadKnowledgeGraphs: function () {
        const savedGraphs = localStorage.getItem('knowledgeGraphs');
        if (savedGraphs) {
            try {
                this.knowledgeGraphs = JSON.parse(savedGraphs);
            } catch (error) {
                console.error('加载知识图谱失败:', error);
            }
        }

        if (!this.knowledgeGraphs.gameKnowledgeGraph) {
            this.knowledgeGraphs = {
                gameKnowledgeGraph: {
                    nodes: {},
                    edges: []
                },
                playerKnowledgeGraph: {
                    nodes: {},
                    edges: []
                },
                worldKnowledgeGraph: {
                    nodes: {},
                    edges: []
                }
            };

            this.saveKnowledgeGraphs();
        }
    },

    /**
     * 保存知识图谱
     */
    saveKnowledgeGraphs: function () {
        localStorage.setItem('knowledgeGraphs', JSON.stringify(this.knowledgeGraphs));
    },

    /**
     * 添加节点
     * @param {string} graphType - 图谱类型
     * @param {string} nodeId - 节点ID
     * @param {Object} properties - 属性对象
     */
    addNode: function (graphType, nodeId, properties) {
        const graph = this.knowledgeGraphs[graphType];

        if (!graph) {
            return;
        }

        graph.nodes[nodeId] = {
            id: nodeId,
            properties: properties || {},
            createdAt: Date.now(),
            updatedAt: Date.now()
        };

        this.saveKnowledgeGraphs();

        this.saveKGHistory('node_added', {
            graphType: graphType,
            nodeId: nodeId
        });
    },

    /**
     * 获取节点
     * @param {string} graphType - 图谱类型
     * @param {string} nodeId - 节点ID
     * @returns {Object} 节点对象
     */
    getNode: function (graphType, nodeId) {
        const graph = this.knowledgeGraphs[graphType];

        if (!graph || !graph.nodes[nodeId]) {
            return null;
        }

        return graph.nodes[nodeId];
    },

    /**
     * 更新节点
     * @param {string} graphType - 图谱类型
     * @param {string} nodeId - 节点ID
     * @param {Object} properties - 属性对象
     */
    updateNode: function (graphType, nodeId, properties) {
        const graph = this.knowledgeGraphs[graphType];

        if (!graph || !graph.nodes[nodeId]) {
            return;
        }

        graph.nodes[nodeId].properties = { ...graph.nodes[nodeId].properties, ...properties };
        graph.nodes[nodeId].updatedAt = Date.now();

        this.saveKnowledgeGraphs();
    },

    /**
     * 删除节点
     * @param {string} graphType - 图谱类型
     * @param {string} nodeId - 节点ID
     */
    deleteNode: function (graphType, nodeId) {
        const graph = this.knowledgeGraphs[graphType];

        if (!graph) {
            return;
        }

        if (graph.nodes[nodeId]) {
            delete graph.nodes[nodeId];
        }

        graph.edges = graph.edges.filter(edge => edge.source !== nodeId && edge.target !== nodeId);

        this.saveKnowledgeGraphs();
    },

    /**
     * 添加边
     * @param {string} graphType - 图谱类型
     * @param {string} sourceId - 源节点ID
     * @param {string} targetId - 目标节点ID
     * @param {string} relation - 关系
     * @param {Object} properties - 属性对象
     */
    addEdge: function (graphType, sourceId, targetId, relation, properties) {
        const graph = this.knowledgeGraphs[graphType];

        if (!graph) {
            return;
        }

        if (!graph.nodes[sourceId] || !graph.nodes[targetId]) {
            return;
        }

        graph.edges.push({
            id: `${sourceId}-${relation}-${targetId}`,
            source: sourceId,
            target: targetId,
            relation: relation,
            properties: properties || {},
            createdAt: Date.now()
        });

        this.saveKnowledgeGraphs();

        this.saveKGHistory('edge_added', {
            graphType: graphType,
            sourceId: sourceId,
            targetId: targetId,
            relation: relation
        });
    },

    /**
     * 获取边
     * @param {string} graphType - 图谱类型
     * @param {string} sourceId - 源节点ID
     * @param {string} targetId - 目标节点ID
     * @returns {Array} 边列表
     */
    getEdges: function (graphType, sourceId, targetId) {
        const graph = this.knowledgeGraphs[graphType];

        if (!graph) {
            return [];
        }

        return graph.edges.filter(edge => {
            if (sourceId && edge.source !== sourceId) {
                return false;
            }
            if (targetId && edge.target !== targetId) {
                return false;
            }
            return true;
        });
    },

    /**
     * 删除边
     * @param {string} graphType - 图谱类型
     * @param {string} edgeId - 边ID
     */
    deleteEdge: function (graphType, edgeId) {
        const graph = this.knowledgeGraphs[graphType];

        if (!graph) {
            return;
        }

        graph.edges = graph.edges.filter(edge => edge.id !== edgeId);

        this.saveKnowledgeGraphs();
    },

    /**
     * 查询节点
     * @param {string} graphType - 图谱类型
     * @param {Object} query - 查询对象
     * @returns {Array} 节点列表
     */
    queryNodes: function (graphType, query) {
        const graph = this.knowledgeGraphs[graphType];

        if (!graph) {
            return [];
        }

        return Object.values(graph.nodes).filter(node => {
            for (const key in query) {
                if (node.properties[key] !== query[key]) {
                    return false;
                }
            }
            return true;
        });
    },

    /**
     * 查询边
     * @param {string} graphType - 图谱类型
     * @param {Object} query - 查询对象
     * @returns {Array} 边列表
     */
    queryEdges: function (graphType, query) {
        const graph = this.knowledgeGraphs[graphType];

        if (!graph) {
            return [];
        }

        return graph.edges.filter(edge => {
            for (const key in query) {
                if (edge[key] !== query[key]) {
                    return false;
                }
            }
            return true;
        });
    },

    /**
     * 获取邻居节点
     * @param {string} graphType - 图谱类型
     * @param {string} nodeId - 节点ID
     * @param {number} depth - 深度
     * @returns {Array} 邻居节点列表
     */
    getNeighbors: function (graphType, nodeId, depth) {
        const graph = this.knowledgeGraphs[graphType];

        if (!graph || !graph.nodes[nodeId]) {
            return [];
        }

        const neighbors = [];
        const visited = new Set([nodeId]);
        const queue = [{ id: nodeId, currentDepth: 0 }];

        while (queue.length > 0) {
            const current = queue.shift();

            if (current.currentDepth >= depth) {
                continue;
            }

            const edges = graph.edges.filter(edge =>
                edge.source === current.id || edge.target === current.id
            );

            for (const edge of edges) {
                const neighborId = edge.source === current.id ? edge.target : edge.source;

                if (!visited.has(neighborId)) {
                    visited.add(neighborId);
                    neighbors.push({
                        id: neighborId,
                        node: graph.nodes[neighborId],
                        edge: edge,
                        depth: current.currentDepth + 1
                    });

                    queue.push({
                        id: neighborId,
                        currentDepth: current.currentDepth + 1
                    });
                }
            }
        }

        return neighbors;
    },

    /**
     * 查找路径
     * @param {string} graphType - 图谱类型
     * @param {string} startId - 起始节点ID
     * @param {string} endId - 结束节点ID
     * @returns {Array} 路径列表
     */
    findPath: function (graphType, startId, endId) {
        const graph = this.knowledgeGraphs[graphType];

        if (!graph || !graph.nodes[startId] || !graph.nodes[endId]) {
            return [];
        }

        const visited = new Set();
        const queue = [{ id: startId, path: [startId] }];

        while (queue.length > 0) {
            const current = queue.shift();

            if (current.id === endId) {
                return current.path;
            }

            if (visited.has(current.id)) {
                continue;
            }

            visited.add(current.id);

            const edges = graph.edges.filter(edge => edge.source === current.id);

            for (const edge of edges) {
                if (!visited.has(edge.target)) {
                    queue.push({
                        id: edge.target,
                        path: [...current.path, edge.target]
                    });
                }
            }
        }

        return [];
    },

    /**
     * 计算相似度
     * @param {string} graphType - 图谱类型
     * @param {string} nodeId1 - 节点ID1
     * @param {string} nodeId2 - 节点ID2
     * @returns {number} 相似度
     */
    calculateSimilarity: function (graphType, nodeId1, nodeId2) {
        const graph = this.knowledgeGraphs[graphType];

        if (!graph || !graph.nodes[nodeId1] || !graph.nodes[nodeId2]) {
            return 0;
        }

        const node1 = graph.nodes[nodeId1];
        const node2 = graph.nodes[nodeId2];

        const neighbors1 = this.getNeighbors(graphType, nodeId1, 1);
        const neighbors2 = this.getNeighbors(graphType, nodeId2, 1);

        const neighborIds1 = new Set(neighbors1.map(n => n.id));
        const neighborIds2 = new Set(neighbors2.map(n => n.id));

        const intersection = new Set([...neighborIds1].filter(id => neighborIds2.has(id)));
        const union = new Set([...neighborIds1, ...neighborIds2]);

        const jaccardSimilarity = union.size > 0 ? intersection.size / union.size : 0;

        let propertySimilarity = 0;
        let propertyCount = 0;

        for (const key in node1.properties) {
            if (node2.properties[key] !== undefined) {
                if (node1.properties[key] === node2.properties[key]) {
                    propertySimilarity++;
                }
                propertyCount++;
            }
        }

        propertySimilarity = propertyCount > 0 ? propertySimilarity / propertyCount : 0;

        return (jaccardSimilarity + propertySimilarity) / 2;
    },

    /**
     * 推荐相关节点
     * @param {string} graphType - 图谱类型
     * @param {string} nodeId - 节点ID
     * @param {number} limit - 限制数量
     * @returns {Array} 推荐节点列表
     */
    recommendNodes: function (graphType, nodeId, limit) {
        const graph = this.knowledgeGraphs[graphType];

        if (!graph || !graph.nodes[nodeId]) {
            return [];
        }

        const recommendations = [];

        for (const otherNodeId in graph.nodes) {
            if (otherNodeId === nodeId) {
                continue;
            }

            const similarity = this.calculateSimilarity(graphType, nodeId, otherNodeId);

            if (similarity >= this.kgConfig.similarityThreshold) {
                recommendations.push({
                    id: otherNodeId,
                    node: graph.nodes[otherNodeId],
                    similarity: similarity
                });
            }
        }

        recommendations.sort((a, b) => b.similarity - a.similarity);

        if (limit) {
            recommendations.slice(0, limit);
        }

        return recommendations;
    },

    /**
     * 获取知识图谱
     * @param {string} graphType - 图谱类型
     * @returns {Object} 知识图谱
     */
    getKnowledgeGraph: function (graphType) {
        return this.knowledgeGraphs[graphType] || null;
    },

    /**
     * 获取所有知识图谱
     * @returns {Object} 所有的知识图谱
     */
    getAllKnowledgeGraphs: function () {
        return this.knowledgeGraphs;
    },

    /**
     * 删除知识图谱
     * @param {string} graphType - 图谱类型
     */
    deleteKnowledgeGraph: function (graphType) {
        if (this.knowledgeGraphs[graphType]) {
            delete this.knowledgeGraphs[graphType];
            this.saveKnowledgeGraphs();
        }
    },

    /**
     * 清空所有知识图谱
     */
    clearAllKnowledgeGraphs: function () {
        this.knowledgeGraphs = {};
        this.saveKnowledgeGraphs();
    },

    /**
     * 保存知识图谱历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveKGHistory: function (action, data) {
        this.kgHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.kgHistory.length > this.maxHistorySize) {
            this.kgHistory.shift();
        }
    },

    /**
     * 获取知识图谱历史
     * @param {Object} options - 查询选项
     * @returns {Array} 知识图谱历史
     */
    getKGHistory: function (options) {
        let history = [...this.kgHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置知识图谱配置
     * @param {Object} config - 配置对象
     */
    setKGConfig: function (config) {
        this.kgConfig = { ...this.kgConfig, ...config };
        this.saveKGConfig();
    },

    /**
     * 获取知识图谱配置
     * @returns {Object} 配置对象
     */
    getKGConfig: function () {
        return this.kgConfig;
    },

    /**
     * 重置知识图谱系统
     */
    reset: function () {
        this.kgHistory = [];
        this.loadKGConfig();
        this.loadKnowledgeGraphs();
    },

    /**
     * 获取知识图谱统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const graphs = Object.keys(this.knowledgeGraphs);

        let totalNodes = 0;
        let totalEdges = 0;

        for (const graphType of graphs) {
            const graph = this.knowledgeGraphs[graphType];
            totalNodes += Object.keys(graph.nodes).length;
            totalEdges += graph.edges.length;
        }

        return {
            totalGraphs: graphs.length,
            totalNodes: totalNodes,
            totalEdges: totalEdges,
            enabled: this.kgConfig.enabled,
            autoUpdate: this.kgConfig.autoUpdate,
            reasoningEnabled: this.kgConfig.reasoningEnabled,
            similarityThreshold: this.kgConfig.similarityThreshold,
            totalHistory: this.kgHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏自然语言处理优化
const GameNLPOptimizer = {
    nlpConfig: {},
    nlpModels: {},
    nlpHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏自然语言处理
     */
    init: function () {
        this.loadNLPConfig();
        this.loadNLPModels();
    },

    /**
     * 加载自然语言处理配置
     */
    loadNLPConfig: function () {
        this.nlpConfig = {
            enabled: true,
            maxHistorySize: 1000,
            language: 'zh-CN',
            autoDetectLanguage: true,
            sentimentAnalysis: true,
            entityRecognition: true
        };

        const customConfig = localStorage.getItem('nlpConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.nlpConfig = { ...this.nlpConfig, ...config };
            } catch (error) {
                console.error('加载自然语言处理配置失败:', error);
            }
        }
    },

    /**
     * 保存自然语言处理配置
     */
    saveNLPConfig: function () {
        localStorage.setItem('nlpConfig', JSON.stringify(this.nlpConfig));
    },

    /**
     * 加载自然语言处理模型
     */
    loadNLPModels: function () {
        const savedModels = localStorage.getItem('nlpModels');
        if (savedModels) {
            try {
                this.nlpModels = JSON.parse(savedModels);
            } catch (error) {
                console.error('加载自然语言处理模型失败:', error);
            }
        }

        if (!this.nlpModels.tokenizer) {
            this.nlpModels = {
                tokenizer: {
                    vocabulary: {},
                    patterns: []
                },
                sentimentAnalyzer: {
                    positiveWords: ['好', '棒', '优秀', '喜欢', '爱', '厉害', '强', '高', '快', '美', '赞'],
                    negativeWords: ['差', '坏', '糟糕', '讨厌', '恨', '弱', '低', '慢', '丑', '烂']
                },
                entityRecognizer: {
                    patterns: [],
                    entities: {}
                },
                intentClassifier: {
                    intents: {},
                    patterns: []
                }
            };

            this.saveNLPModels();
        }
    },

    /**
     * 保存自然语言处理模型
     */
    saveNLPModels: function () {
        localStorage.setItem('nlpModels', JSON.stringify(this.nlpModels));
    },

    /**
     * 分词
     * @param {string} text - 文本
     * @returns {Array} 词列表
     */
    tokenize: function (text) {
        if (!text) {
            return [];
        }

        const tokens = [];
        const patterns = this.nlpModels.tokenizer.patterns;

        for (const pattern of patterns) {
            const matches = text.match(new RegExp(pattern.regex, 'g'));

            if (matches) {
                for (const match of matches) {
                    tokens.push({
                        text: match,
                        type: pattern.type,
                        position: text.indexOf(match)
                    });
                }
            }
        }

        if (tokens.length === 0) {
            const words = text.split(/[\s,，.。!！?？;；:：""''（）()]/);

            for (const word of words) {
                if (word.trim()) {
                    tokens.push({
                        text: word.trim(),
                        type: 'word',
                        position: text.indexOf(word)
                    });
                }
            }
        }

        return tokens;
    },

    /**
     * 情感分析
     * @param {string} text - 文本
     * @returns {Object} 情感分析结果
     */
    analyzeSentiment: function (text) {
        if (!this.nlpConfig.sentimentAnalysis) {
            return null;
        }

        const tokens = this.tokenize(text);
        const sentimentAnalyzer = this.nlpModels.sentimentAnalyzer;

        let positiveScore = 0;
        let negativeScore = 0;

        for (const token of tokens) {
            const word = token.text.toLowerCase();

            if (sentimentAnalyzer.positiveWords.includes(word)) {
                positiveScore++;
            }

            if (sentimentAnalyzer.negativeWords.includes(word)) {
                negativeScore++;
            }
        }

        const totalScore = positiveScore + negativeScore;

        let sentiment = 'neutral';
        let confidence = 0;

        if (totalScore > 0) {
            confidence = Math.max(positiveScore, negativeScore) / totalScore;

            if (positiveScore > negativeScore) {
                sentiment = 'positive';
            } else if (negativeScore > positiveScore) {
                sentiment = 'negative';
            }
        }

        return {
            sentiment: sentiment,
            confidence: confidence,
            positiveScore: positiveScore,
            negativeScore: negativeScore,
            tokens: tokens
        };
    },

    /**
     * 实体识别
     * @param {string} text - 文本
     * @returns {Array} 实体列表
     */
    recognizeEntities: function (text) {
        if (!this.nlpConfig.entityRecognition) {
            return [];
        }

        const entities = [];
        const entityRecognizer = this.nlpModels.entityRecognizer;

        for (const pattern of entityRecognizer.patterns) {
            const matches = text.match(new RegExp(pattern.regex, 'g'));

            if (matches) {
                for (const match of matches) {
                    entities.push({
                        text: match,
                        type: pattern.type,
                        confidence: pattern.confidence || 0.8
                    });
                }
            }
        }

        return entities;
    },

    /**
     * 意图分类
     * @param {string} text - 文本
     * @returns {Object} 意图分类结果
     */
    classifyIntent: function (text) {
        const tokens = this.tokenize(text);
        const intentClassifier = this.nlpModels.intentClassifier;

        let bestIntent = 'unknown';
        let bestScore = 0;

        for (const intentName in intentClassifier.intents) {
            const intent = intentClassifier.intents[intentName];
            let score = 0;

            for (const keyword of intent.keywords) {
                for (const token of tokens) {
                    if (token.text.toLowerCase().includes(keyword.toLowerCase())) {
                        score += keyword.weight || 1;
                    }
                }
            }

            if (score > bestScore) {
                bestScore = score;
                bestIntent = intentName;
            }
        }

        return {
            intent: bestIntent,
            confidence: Math.min(bestScore / tokens.length, 1),
            tokens: tokens
        };
    },

    /**
     * 添加意图
     * @param {string} intentName - 意图名称
     * @param {Array} keywords - 关键词列表
     */
    addIntent: function (intentName, keywords) {
        this.nlpModels.intentClassifier.intents[intentName] = {
            name: intentName,
            keywords: keywords
        };

        this.saveNLPModels();
    },

    /**
     * 添加实体模式
     * @param {string} entityType - 实体类型
     * @param {string} regex - 正则表达式
     * @param {number} confidence - 置信度
     */
    addEntityPattern: function (entityType, regex, confidence) {
        this.nlpModels.entityRecognizer.patterns.push({
            type: entityType,
            regex: regex,
            confidence: confidence || 0.8
        });

        this.saveNLPModels();
    },

    /**
     * 添加分词模式
     * @param {string} tokenType - 词类型
     * @param {string} regex - 正则表达式
     */
    addTokenPattern: function (tokenType, regex) {
        this.nlpModels.tokenizer.patterns.push({
            type: tokenType,
            regex: regex
        });

        this.saveNLPModels();
    },

    /**
     * 文本相似度计算
     * @param {string} text1 - 文本1
     * @param {string} text2 - 文本2
     * @returns {number} 相似度
     */
    calculateSimilarity: function (text1, text2) {
        const tokens1 = this.tokenize(text1);
        const tokens2 = this.tokenize(text2);

        const words1 = new Set(tokens1.map(t => t.text.toLowerCase()));
        const words2 = new Set(tokens2.map(t => t.text.toLowerCase()));

        const intersection = new Set([...words1].filter(w => words2.has(w)));
        const union = new Set([...words1, ...words2]);

        return union.size > 0 ? intersection.size / union.size : 0;
    },

    /**
     * 文本摘要
     * @param {string} text - 文本
     * @param {number} maxLength - 最大长度
     * @returns {string} 摘要
     */
    summarize: function (text, maxLength) {
        const sentences = text.split(/[。！？.!?]/);

        if (sentences.length <= 2) {
            return text;
        }

        const scores = sentences.map(sentence => {
            const tokens = this.tokenize(sentence);
            return tokens.length;
        });

        const sorted = sentences.map((sentence, index) => ({
            sentence: sentence,
            score: scores[index],
            index: index
        })).sort((a, b) => b.score - a.score);

        const topSentences = sorted.slice(0, Math.ceil(sentences.length / 3));
        topSentences.sort((a, b) => a.index - b.index);

        let summary = topSentences.map(s => s.sentence).join('。');

        if (maxLength && summary.length > maxLength) {
            summary = summary.substring(0, maxLength) + '...';
        }

        return summary;
    },

    /**
     * 关键词提取
     * @param {string} text - 文本
     * @param {number} limit - 限制数量
     * @returns {Array} 关键词列表
     */
    extractKeywords: function (text, limit) {
        const tokens = this.tokenize(text);
        const frequency = {};

        for (const token of tokens) {
            const word = token.text.toLowerCase();

            if (word.length > 1) {
                frequency[word] = (frequency[word] || 0) + 1;
            }
        }

        const keywords = Object.entries(frequency)
            .map(([word, count]) => ({ word, count }))
            .sort((a, b) => b.count - a.count);

        if (limit) {
            keywords.slice(0, limit);
        }

        return keywords;
    },

    /**
     * 获取自然语言处理模型
     * @param {string} modelType - 模型类型
     * @returns {Object} 模型对象
     */
    getNLPModel: function (modelType) {
        return this.nlpModels[modelType] || null;
    },

    /**
     * 获取所有自然语言处理模型
     * @returns {Object} 所有模型
     */
    getAllNLPModels: function () {
        return this.nlpModels;
    },

    /**
     * 删除自然语言处理模型
     * @param {string} modelType - 模型类型
     */
    deleteNLPModel: function (modelType) {
        if (this.nlpModels[modelType]) {
            delete this.nlpModels[modelType];
            this.saveNLPModels();
        }
    },

    /**
     * 清空所有自然语言处理模型
     */
    clearAllNLPModels: function () {
        this.nlpModels = {};
        this.saveNLPModels();
    },

    /**
     * 保存自然语言处理历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveNLPHistory: function (action, data) {
        this.nlpHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.nlpHistory.length > this.maxHistorySize) {
            this.nlpHistory.shift();
        }
    },

    /**
     * 获取自然语言处理历史
     * @param {Object} options - 查询选项
     * @returns {Array} 自然语言处理历史
     */
    getNLPHistory: function (options) {
        let history = [...this.nlpHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置自然语言处理配置
     * @param {Object} config - 配置对象
     */
    setNLPConfig: function (config) {
        this.nlpConfig = { ...this.nlpConfig, ...config };
        this.saveNLPConfig();
    },

    /**
     * 获取自然语言处理配置
     * @returns {Object} 配置对象
     */
    getNLPConfig: function () {
        return this.nlpConfig;
    },

    /**
     * 重置自然语言处理系统
     */
    reset: function () {
        this.nlpHistory = [];
        this.loadNLPConfig();
        this.loadNLPModels();
    },

    /**
     * 获取自然语言处理统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const models = Object.keys(this.nlpModels);

        let totalIntents = 0;
        let totalEntityPatterns = 0;
        let totalTokenPatterns = 0;

        if (this.nlpModels.intentClassifier.intents) {
            totalIntents = Object.keys(this.nlpModels.intentClassifier.intents).length;
        }

        if (this.nlpModels.entityRecognizer.patterns) {
            totalEntityPatterns = this.nlpModels.entityRecognizer.patterns.length;
        }

        if (this.nlpModels.tokenizer.patterns) {
            totalTokenPatterns = this.nlpModels.tokenizer.patterns.length;
        }

        return {
            totalModels: models.length,
            totalIntents: totalIntents,
            totalEntityPatterns: totalEntityPatterns,
            totalTokenPatterns: totalTokenPatterns,
            enabled: this.nlpConfig.enabled,
            language: this.nlpConfig.language,
            autoDetectLanguage: this.nlpConfig.autoDetectLanguage,
            sentimentAnalysis: this.nlpConfig.sentimentAnalysis,
            entityRecognition: this.nlpConfig.entityRecognition,
            totalHistory: this.nlpHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏计算机视觉优化
const GameComputerVisionOptimizer = {
    cvConfig: {},
    cvModels: {},
    cvHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏计算机视觉
     */
    init: function () {
        this.loadCVConfig();
        this.loadCVModels();
    },

    /**
     * 加载计算机视觉配置
     */
    loadCVConfig: function () {
        this.cvConfig = {
            enabled: true,
            maxHistorySize: 1000,
            objectDetection: true,
            faceDetection: true,
            motionDetection: true,
            colorTracking: true
        };

        const customConfig = localStorage.getItem('cvConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.cvConfig = { ...this.cvConfig, ...config };
            } catch (error) {
                console.error('加载计算机视觉配置失败:', error);
            }
        }
    },

    /**
     * 保存计算机视觉配置
     */
    saveCVConfig: function () {
        localStorage.setItem('cvConfig', JSON.stringify(this.cvConfig));
    },

    /**
     * 加载计算机视觉模型
     */
    loadCVModels: function () {
        const savedModels = localStorage.getItem('cvModels');
        if (savedModels) {
            try {
                this.cvModels = JSON.parse(savedModels);
            } catch (error) {
                console.error('加载计算机视觉模型失败:', error);
            }
        }

        if (!this.cvModels.objectDetector) {
            this.cvModels = {
                objectDetector: {
                    objects: {},
                    thresholds: {}
                },
                faceDetector: {
                    faces: {},
                    landmarks: {}
                },
                motionDetector: {
                    previousFrame: null,
                    motionRegions: []
                },
                colorTracker: {
                    colors: {},
                    trackedRegions: []
                }
            };

            this.saveCVModels();
        }
    },

    /**
     * 保存计算机视觉模型
     */
    saveCVModels: function () {
        localStorage.setItem('cvModels', JSON.stringify(this.cvModels));
    },

    /**
     * 检测对象
     * @param {HTMLCanvasElement|HTMLImageElement} image - 图像
     * @returns {Array} 对象列表
     */
    detectObjects: function (image) {
        if (!this.cvConfig.objectDetection) {
            return [];
        }

        const objects = [];
        const objectDetector = this.cvModels.objectDetector;

        for (const objectId in objectDetector.objects) {
            const object = objectDetector.objects[objectId];
            const threshold = objectDetector.thresholds[objectId] || 0.5;

            const detected = this.detectObjectPattern(image, object.pattern, threshold);

            if (detected) {
                objects.push({
                    id: objectId,
                    name: object.name,
                    confidence: detected.confidence,
                    boundingBox: detected.boundingBox
                });
            }
        }

        this.saveCVHistory('objects_detected', {
            count: objects.length
        });

        return objects;
    },

    /**
     * 检测对象模式
     * @param {HTMLCanvasElement|HTMLImageElement} image - 图像
     * @param {Object} pattern - 模式对象
     * @param {number} threshold - 阈值
     * @returns {Object} 检测结果
     */
    detectObjectPattern: function (image, pattern, threshold) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = image.width;
        canvas.height = image.height;
        ctx.drawImage(image, 0, 0);

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        let matchCount = 0;
        let totalPixels = data.length / 4;

        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];

            if (this.colorMatch(r, g, b, pattern.color, threshold)) {
                matchCount++;
            }
        }

        const confidence = matchCount / totalPixels;

        if (confidence >= threshold) {
            return {
                confidence: confidence,
                boundingBox: {
                    x: 0,
                    y: 0,
                    width: canvas.width,
                    height: canvas.height
                }
            };
        }

        return null;
    },

    /**
     * 颜色匹配
     * @param {number} r1 - 红色1
     * @param {number} g1 - 绿色1
     * @param {number} b1 - 蓝色1
     * @param {Array} color2 - 颜色2
     * @param {number} threshold - 阈值
     * @returns {boolean} 是否匹配
     */
    colorMatch: function (r1, g1, b1, color2, threshold) {
        const r2 = color2[0];
        const g2 = color2[1];
        const b2 = color2[2];

        const distance = Math.sqrt(
            Math.pow(r1 - r2, 2) +
            Math.pow(g1 - g2, 2) +
            Math.pow(b1 - b2, 2)
        );

        const maxDistance = Math.sqrt(3 * Math.pow(255, 2));

        return distance / maxDistance <= (1 - threshold);
    },

    /**
     * 检测人脸
     * @param {HTMLCanvasElement|HTMLImageElement} image - 图像
     * @returns {Array} 人脸列表
     */
    detectFaces: function (image) {
        if (!this.cvConfig.faceDetection) {
            return [];
        }

        const faces = [];
        const faceDetector = this.cvModels.faceDetector;

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = image.width;
        canvas.height = image.height;
        ctx.drawImage(image, 0, 0);

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        const skinRegions = this.detectSkinRegions(data, canvas.width, canvas.height);

        for (const region of skinRegions) {
            if (region.area > 1000) {
                faces.push({
                    boundingBox: region.boundingBox,
                    confidence: Math.min(region.area / 5000, 1),
                    landmarks: this.detectFaceLandmarks(region)
                });
            }
        }

        this.saveCVHistory('faces_detected', {
            count: faces.length
        });

        return faces;
    },

    /**
     * 检测皮肤区域
     * @param {Uint8ClampedArray} data - 图像数据
     * @param {number} width - 宽度
     * @param {number} height - 高度
     * @returns {Array} 皮肤区域列表
     */
    detectSkinRegions: function (data, width, height) {
        const regions = [];
        const visited = new Set();

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const index = (y * width + x) * 4;
                const r = data[index];
                const g = data[index + 1];
                const b = data[index + 2];

                if (this.isSkinColor(r, g, b) && !visited.has(`${x},${y}`)) {
                    const region = this.growRegion(data, x, y, width, height, visited);

                    if (region.area > 0) {
                        regions.push(region);
                    }
                }
            }
        }

        return regions;
    },

    /**
     * 判断是否为皮肤颜色
     * @param {number} r - 红色
     * @param {number} g - 绿色
     * @param {number} b - 蓝色
     * @returns {boolean} 是否为皮肤颜色
     */
    isSkinColor: function (r, g, b) {
        return r > 95 && g > 40 && b > 20 &&
            r > g && r > b &&
            Math.abs(r - g) > 15 &&
            r - g > 15;
    },

    /**
     * 生长区域
     * @param {Uint8ClampedArray} data - 图像数据
     * @param {number} startX - 起始X
     * @param {number} startY - 起始Y
     * @param {number} width - 宽度
     * @param {number} height - 高度
     * @param {Set} visited - 已访问集合
     * @returns {Object} 区域对象
     */
    growRegion: function (data, startX, startY, width, height, visited) {
        const region = {
            pixels: [],
            area: 0,
            minX: startX,
            minY: startY,
            maxX: startX,
            maxY: startY
        };

        const stack = [{ x: startX, y: startY }];

        while (stack.length > 0) {
            const { x, y } = stack.pop();
            const key = `${x},${y}`;

            if (visited.has(key)) {
                continue;
            }

            visited.add(key);

            const index = (y * width + x) * 4;
            const r = data[index];
            const g = data[index + 1];
            const b = data[index + 2];

            if (this.isSkinColor(r, g, b)) {
                region.pixels.push({ x, y });
                region.area++;

                region.minX = Math.min(region.minX, x);
                region.minY = Math.min(region.minY, y);
                region.maxX = Math.max(region.maxX, x);
                region.maxY = Math.max(region.maxY, y);

                if (x > 0) stack.push({ x: x - 1, y });
                if (x < width - 1) stack.push({ x: x + 1, y });
                if (y > 0) stack.push({ x, y: y - 1 });
                if (y < height - 1) stack.push({ x, y: y + 1 });
            }
        }

        region.boundingBox = {
            x: region.minX,
            y: region.minY,
            width: region.maxX - region.minX,
            height: region.maxY - region.minY
        };

        return region;
    },

    /**
     * 检测人脸特征点
     * @param {Object} region - 区域对象
     * @returns {Object} 特征点对象
     */
    detectFaceLandmarks: function (region) {
        return {
            leftEye: {
                x: region.boundingBox.x + region.boundingBox.width * 0.3,
                y: region.boundingBox.y + region.boundingBox.height * 0.4
            },
            rightEye: {
                x: region.boundingBox.x + region.boundingBox.width * 0.7,
                y: region.boundingBox.y + region.boundingBox.height * 0.4
            },
            nose: {
                x: region.boundingBox.x + region.boundingBox.width * 0.5,
                y: region.boundingBox.y + region.boundingBox.height * 0.6
            },
            mouth: {
                x: region.boundingBox.x + region.boundingBox.width * 0.5,
                y: region.boundingBox.y + region.boundingBox.height * 0.8
            }
        };
    },

    /**
     * 检测运动
     * @param {HTMLCanvasElement|HTMLImageElement} currentFrame - 当前帧
     * @returns {Array} 运动区域列表
     */
    detectMotion: function (currentFrame) {
        if (!this.cvConfig.motionDetection) {
            return [];
        }

        const motionDetector = this.cvModels.motionDetector;

        if (!motionDetector.previousFrame) {
            motionDetector.previousFrame = currentFrame;
            return [];
        }

        const motionRegions = [];
        const previousData = this.getImageData(motionDetector.previousFrame);
        const currentData = this.getImageData(currentFrame);

        const width = currentData.width;
        const height = currentData.height;

        const blockSize = 16;

        for (let y = 0; y < height; y += blockSize) {
            for (let x = 0; x < width; x += blockSize) {
                const motion = this.calculateMotion(previousData, currentData, x, y, blockSize);

                if (motion > 0.1) {
                    motionRegions.push({
                        boundingBox: {
                            x: x,
                            y: y,
                            width: blockSize,
                            height: blockSize
                        },
                        intensity: motion
                    });
                }
            }
        }

        motionDetector.previousFrame = currentFrame;
        motionDetector.motionRegions = motionRegions;

        this.saveCVHistory('motion_detected', {
            regions: motionRegions.length
        });

        return motionRegions;
    },

    /**
     * 获取图像数据
     * @param {HTMLCanvasElement|HTMLImageElement} image - 图像
     * @returns {ImageData} 图像数据
     */
    getImageData: function (image) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = image.width;
        canvas.height = image.height;
        ctx.drawImage(image, 0, 0);

        return ctx.getImageData(0, 0, canvas.width, canvas.height);
    },

    /**
     * 计算运动
     * @param {ImageData} previousData - 前一帧数据
     * @param {ImageData} currentData - 当前帧数据
     * @param {number} startX - 起始X
     * @param {number} startY - 起始Y
     * @param {number} blockSize - 块大小
     * @returns {number} 运动强度
     */
    calculateMotion: function (previousData, currentData, startX, startY, blockSize) {
        let motionSum = 0;
        let count = 0;

        for (let y = startY; y < startY + blockSize && y < currentData.height; y++) {
            for (let x = startX; x < startX + blockSize && x < currentData.width; x++) {
                const index = (y * currentData.width + x) * 4;

                const rDiff = Math.abs(currentData.data[index] - previousData.data[index]);
                const gDiff = Math.abs(currentData.data[index + 1] - previousData.data[index + 1]);
                const bDiff = Math.abs(currentData.data[index + 2] - previousData.data[index + 2]);

                motionSum += (rDiff + gDiff + bDiff) / 3;
                count++;
            }
        }

        return count > 0 ? motionSum / (count * 255) : 0;
    },

    /**
     * 跟踪颜色
     * @param {HTMLCanvasElement|HTMLImageElement} image - 图像
     * @param {Array} targetColor - 目标颜色
     * @returns {Array} 跟踪区域列表
     */
    trackColor: function (image, targetColor) {
        if (!this.cvConfig.colorTracking) {
            return [];
        }

        const colorTracker = this.cvModels.colorTracker;
        const threshold = 0.7;

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = image.width;
        canvas.height = image.height;
        ctx.drawImage(image, 0, 0);

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        const matchedPixels = [];

        for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
                const index = (y * canvas.width + x) * 4;
                const r = data[index];
                const g = data[index + 1];
                const b = data[index + 2];

                if (this.colorMatch(r, g, b, targetColor, threshold)) {
                    matchedPixels.push({ x, y });
                }
            }
        }

        const regions = this.groupPixelsIntoRegions(matchedPixels);
        colorTracker.trackedRegions = regions;

        this.saveCVHistory('color_tracked', {
            regions: regions.length
        });

        return regions;
    },

    /**
     * 将像素分组为区域
     * @param {Array} pixels - 像素列表
     * @returns {Array} 区域列表
     */
    groupPixelsIntoRegions: function (pixels) {
        if (pixels.length === 0) {
            return [];
        }

        const regions = [];
        const visited = new Set();

        for (const pixel of pixels) {
            const key = `${pixel.x},${pixel.y}`;

            if (visited.has(key)) {
                continue;
            }

            const region = {
                pixels: [],
                minX: pixel.x,
                minY: pixel.y,
                maxX: pixel.x,
                maxY: pixel.y
            };

            const stack = [pixel];

            while (stack.length > 0) {
                const current = stack.pop();
                const currentKey = `${current.x},${current.y}`;

                if (visited.has(currentKey)) {
                    continue;
                }

                visited.add(currentKey);
                region.pixels.push(current);

                region.minX = Math.min(region.minX, current.x);
                region.minY = Math.min(region.minY, current.y);
                region.maxX = Math.max(region.maxX, current.x);
                region.maxY = Math.max(region.maxY, current.y);

                for (const other of pixels) {
                    const otherKey = `${other.x},${other.y}`;

                    if (!visited.has(otherKey) && this.isAdjacent(current, other)) {
                        stack.push(other);
                    }
                }
            }

            region.boundingBox = {
                x: region.minX,
                y: region.minY,
                width: region.maxX - region.minX + 1,
                height: region.maxY - region.minY + 1
            };

            region.area = region.pixels.length;

            if (region.area > 10) {
                regions.push(region);
            }
        }

        return regions;
    },

    /**
     * 判断是否相邻
     * @param {Object} pixel1 - 像素1
     * @param {Object} pixel2 - 像素2
     * @returns {boolean} 是否相邻
     */
    isAdjacent: function (pixel1, pixel2) {
        const dx = Math.abs(pixel1.x - pixel2.x);
        const dy = Math.abs(pixel1.y - pixel2.y);

        return dx <= 1 && dy <= 1;
    },

    /**
     * 获取计算机视觉模型
     * @param {string} modelType - 模型类型
     * @returns {Object} 模型对象
     */
    getCVModel: function (modelType) {
        return this.cvModels[modelType] || null;
    },

    /**
     * 获取所有计算机视觉模型
     * @returns {Object} 所有模型
     */
    getAllCVModels: function () {
        return this.cvModels;
    },

    /**
     * 删除计算机视觉模型
     * @param {string} modelType - 模型类型
     */
    deleteCVModel: function (modelType) {
        if (this.cvModels[modelType]) {
            delete this.cvModels[modelType];
            this.saveCVModels();
        }
    },

    /**
     * 清空所有计算机视觉模型
     */
    clearAllCVModels: function () {
        this.cvModels = {};
        this.saveCVModels();
    },

    /**
     * 保存计算机视觉历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveCVHistory: function (action, data) {
        this.cvHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.cvHistory.length > this.maxHistorySize) {
            this.cvHistory.shift();
        }
    },

    /**
     * 获取计算机视觉历史
     * @param {Object} options - 查询选项
     * @returns {Array} 计算机视觉历史
     */
    getCVHistory: function (options) {
        let history = [...this.cvHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置计算机视觉配置
     * @param {Object} config - 配置对象
     */
    setCVConfig: function (config) {
        this.cvConfig = { ...this.cvConfig, ...config };
        this.saveCVConfig();
    },

    /**
     * 获取计算机视觉配置
     * @returns {Object} 配置对象
     */
    getCVConfig: function () {
        return this.cvConfig;
    },

    /**
     * 重置计算机视觉系统
     */
    reset: function () {
        this.cvHistory = [];
        this.loadCVConfig();
        this.loadCVModels();
    },

    /**
     * 获取计算机视觉统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const models = Object.keys(this.cvModels);

        return {
            totalModels: models.length,
            enabled: this.cvConfig.enabled,
            objectDetection: this.cvConfig.objectDetection,
            faceDetection: this.cvConfig.faceDetection,
            motionDetection: this.cvConfig.motionDetection,
            colorTracking: this.cvConfig.colorTracking,
            totalHistory: this.cvHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏语音识别优化
const GameSpeechRecognitionOptimizer = {
    srConfig: {},
    srModels: {},
    srHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏语音识别
     */
    init: function () {
        this.loadSRConfig();
        this.loadSRModels();
    },

    /**
     * 加载语音识别配置
     */
    loadSRConfig: function () {
        this.srConfig = {
            enabled: true,
            maxHistorySize: 1000,
            language: 'zh-CN',
            continuous: false,
            interimResults: true,
            maxAlternatives: 1
        };

        const customConfig = localStorage.getItem('srConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.srConfig = { ...this.srConfig, ...config };
            } catch (error) {
                console.error('加载语音识别配置失败:', error);
            }
        }
    },

    /**
     * 保存语音识别配置
     */
    saveSRConfig: function () {
        localStorage.setItem('srConfig', JSON.stringify(this.srConfig));
    },

    /**
     * 加载语音识别模型
     */
    loadSRModels: function () {
        const savedModels = localStorage.getItem('srModels');
        if (savedModels) {
            try {
                this.srModels = JSON.parse(savedModels);
            } catch (error) {
                console.error('加载语音识别模型失败:', error);
            }
        }

        if (!this.srModels.vocabulary) {
            this.srModels = {
                vocabulary: {},
                phonemes: {},
                languageModel: {},
                acousticModel: {}
            };

            this.saveSRModels();
        }
    },

    /**
     * 保存语音识别模型
     */
    saveSRModels: function () {
        localStorage.setItem('srModels', JSON.stringify(this.srModels));
    },

    /**
     * 开始语音识别
     * @returns {Promise<Object>} 识别结果
     */
    startRecognition: function () {
        return new Promise((resolve, reject) => {
            if (!this.srConfig.enabled) {
                reject({
                    success: false,
                    error: '语音识别已禁用'
                });
                return;
            }

            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                reject({
                    success: false,
                    error: '浏览器不支持语音识别'
                });
                return;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();

            recognition.lang = this.srConfig.language;
            recognition.continuous = this.srConfig.continuous;
            recognition.interimResults = this.srConfig.interimResults;
            recognition.maxAlternatives = this.srConfig.maxAlternatives;

            recognition.onresult = (event) => {
                const results = [];

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const result = event.results[i];

                    for (let j = 0; j < result.length; j++) {
                        results.push({
                            transcript: result[j].transcript,
                            confidence: result[j].confidence,
                            isFinal: result.isFinal
                        });
                    }
                }

                this.saveSRHistory('recognition_result', {
                    results: results
                });

                resolve({
                    success: true,
                    results: results
                });
            };

            recognition.onerror = (event) => {
                reject({
                    success: false,
                    error: event.error
                });
            };

            recognition.onend = () => {
                if (results.length === 0) {
                    reject({
                        success: false,
                        error: '未检测到语音'
                    });
                }
            };

            recognition.start();

            this.saveSRHistory('recognition_started', {
                language: this.srConfig.language
            });
        });
    },

    /**
     * 停止语音识别
     */
    stopRecognition: function () {
        if (this.recognition) {
            this.recognition.stop();
            this.recognition = null;

            this.saveSRHistory('recognition_stopped', {});
        }
    },

    /**
     * 添加词汇
     * @param {string} word - 单词
     * @param {string} phoneme - 音标
     */
    addVocabulary: function (word, phoneme) {
        this.srModels.vocabulary[word] = {
            word: word,
            phoneme: phoneme || this.generatePhoneme(word),
            frequency: 0
        };

        this.saveSRModels();
    },

    /**
     * 生成音标
     * @param {string} word - 单词
     * @returns {string} 音标
     */
    generatePhoneme: function (word) {
        const phonemeMap = {
            'a': 'a', 'e': 'e', 'i': 'i', 'o': 'o', 'u': 'u',
            'b': 'b', 'p': 'p', 'm': 'm', 'f': 'f',
            'd': 'd', 't': 't', 'n': 'n', 'l': 'l',
            'g': 'g', 'k': 'k', 'h': 'h',
            'j': 'j', 'q': 'q', 'x': 'x',
            'zh': 'zh', 'ch': 'ch', 'sh': 'sh', 'r': 'r',
            'z': 'z', 'c': 'c', 's': 's',
            'y': 'y', 'w': 'w'
        };

        let phoneme = '';

        for (let i = 0; i < word.length; i++) {
            const char = word[i];
            phoneme += phonemeMap[char] || char;
        }

        return phoneme;
    },

    /**
     * 获取词汇
     * @param {string} word - 单词
     * @returns {Object} 词汇对象
     */
    getVocabulary: function (word) {
        return this.srModels.vocabulary[word] || null;
    },

    /**
     * 搜索词汇
     * @param {string} pattern - 模式
     * @returns {Array} 词汇列表
     */
    searchVocabulary: function (pattern) {
        const results = [];

        for (const word in this.srModels.vocabulary) {
            if (word.includes(pattern)) {
                results.push(this.srModels.vocabulary[word]);
            }
        }

        return results;
    },

    /**
     * 添加音素
     * @param {string} phoneme - 音素
     * @param {Array} features - 特征数组
     */
    addPhoneme: function (phoneme, features) {
        this.srModels.phonemes[phoneme] = {
            phoneme: phoneme,
            features: features || []
        };

        this.saveSRModels();
    },

    /**
     * 添加语言模型规则
     * @param {string} rule - 规则
     * @param {number} probability - 概率
     */
    addLanguageModelRule: function (rule, probability) {
        this.srModels.languageModel[rule] = {
            rule: rule,
            probability: probability || 0.5
        };

        this.saveSRModels();
    },

    /**
     * 添加声学模型
     * @param {string} phoneme - 音素
     * @param {Array} features - 特征数组
     */
    addAcousticModel: function (phoneme, features) {
        this.srModels.acousticModel[phoneme] = {
            phoneme: phoneme,
            features: features || []
        };

        this.saveSRModels();
    },

    /**
     * 分析音频特征
     * @param {AudioBuffer} audioBuffer - 音频缓冲区
     * @returns {Object} 音频特征
     */
    analyzeAudioFeatures: function (audioBuffer) {
        const channelData = audioBuffer.getChannelData(0);
        const sampleRate = audioBuffer.sampleRate;

        const mfcc = this.calculateMFCC(channelData, sampleRate);
        const pitch = this.calculatePitch(channelData, sampleRate);
        const energy = this.calculateEnergy(channelData);
        const zeroCrossingRate = this.calculateZeroCrossingRate(channelData);

        return {
            mfcc: mfcc,
            pitch: pitch,
            energy: energy,
            zeroCrossingRate: zeroCrossingRate,
            duration: audioBuffer.duration
        };
    },

    /**
     * 计算MFCC
     * @param {Float32Array} channelData - 通道数据
     * @param {number} sampleRate - 采样率
     * @returns {Array} MFCC系数
     */
    calculateMFCC: function (channelData, sampleRate) {
        const frameSize = 512;
        const hopSize = 256;
        const numCoefficients = 13;

        const mfccs = [];

        for (let i = 0; i < channelData.length - frameSize; i += hopSize) {
            const frame = channelData.slice(i, i + frameSize);
            const spectrum = this.calculateSpectrum(frame);
            const melSpectrum = this.applyMelFilterbank(spectrum, sampleRate);
            const logMelSpectrum = melSpectrum.map(x => Math.log(x));
            const mfcc = this.applyDCT(logMelSpectrum);

            mfccs.push(mfcc.slice(0, numCoefficients));
        }

        return mfccs;
    },

    /**
     * 计算频谱
     * @param {Float32Array} frame - 帧数据
     * @returns {Array} 频谱
     */
    calculateSpectrum: function (frame) {
        const N = frame.length;
        const spectrum = new Array(N / 2);

        for (let k = 0; k < N / 2; k++) {
            let real = 0;
            let imag = 0;

            for (let n = 0; n < N; n++) {
                const angle = 2 * Math.PI * k * n / N;
                real += frame[n] * Math.cos(angle);
                imag -= frame[n] * Math.sin(angle);
            }

            spectrum[k] = Math.sqrt(real * real + imag * imag);
        }

        return spectrum;
    },

    /**
     * 应用Mel滤波器组
     * @param {Array} spectrum - 频谱
     * @param {number} sampleRate - 采样率
     * @returns {Array} Mel频谱
     */
    applyMelFilterbank: function (spectrum, sampleRate) {
        const numFilters = 26;
        const melSpectrum = new Array(numFilters);

        for (let m = 0; m < numFilters; m++) {
            let sum = 0;

            for (let k = 0; k < spectrum.length; k++) {
                const frequency = k * sampleRate / spectrum.length;
                const mel = 1127 * Math.log(1 + frequency / 700);
                const melMin = 1127 * Math.log(1 + (m * sampleRate / (numFilters * 2)) / 700);
                const melMax = 1127 * Math.log(1 + ((m + 2) * sampleRate / (numFilters * 2)) / 700);

                if (mel >= melMin && mel <= melMax) {
                    sum += spectrum[k];
                }
            }

            melSpectrum[m] = sum;
        }

        return melSpectrum;
    },

    /**
     * 应用DCT
     * @param {Array} spectrum - 频谱
     * @returns {Array} DCT系数
     */
    applyDCT: function (spectrum) {
        const N = spectrum.length;
        const dct = new Array(N);

        for (let k = 0; k < N; k++) {
            let sum = 0;

            for (let n = 0; n < N; n++) {
                sum += spectrum[n] * Math.cos(Math.PI * k * (2 * n + 1) / (2 * N));
            }

            dct[k] = sum * Math.sqrt(2 / N);
        }

        return dct;
    },

    /**
     * 计算音高
     * @param {Float32Array} channelData - 通道数据
     * @param {number} sampleRate - 采样率
     * @returns {number} 音高
     */
    calculatePitch: function (channelData, sampleRate) {
        const frameSize = 1024;
        const autocorrelation = new Array(frameSize);

        for (let lag = 0; lag < frameSize; lag++) {
            let sum = 0;

            for (let i = 0; i < channelData.length - lag; i++) {
                sum += channelData[i] * channelData[i + lag];
            }

            autocorrelation[lag] = sum;
        }

        let maxLag = 0;
        let maxValue = 0;

        for (let lag = 1; lag < frameSize; lag++) {
            if (autocorrelation[lag] > maxValue) {
                maxValue = autocorrelation[lag];
                maxLag = lag;
            }
        }

        return sampleRate / maxLag;
    },

    /**
     * 计算能量
     * @param {Float32Array} channelData - 通道数据
     * @returns {number} 能量
     */
    calculateEnergy: function (channelData) {
        let sum = 0;

        for (let i = 0; i < channelData.length; i++) {
            sum += channelData[i] * channelData[i];
        }

        return sum / channelData.length;
    },

    /**
     * 计算过零率
     * @param {Float32Array} channelData - 通道数据
     * @returns {number} 过零率
     */
    calculateZeroCrossingRate: function (channelData) {
        let crossings = 0;

        for (let i = 1; i < channelData.length; i++) {
            if ((channelData[i] >= 0 && channelData[i - 1] < 0) ||
                (channelData[i] < 0 && channelData[i - 1] >= 0)) {
                crossings++;
            }
        }

        return crossings / channelData.length;
    },

    /**
     * 获取语音识别模型
     * @param {string} modelType - 模型类型
     * @returns {Object} 模型对象
     */
    getSRModel: function (modelType) {
        return this.srModels[modelType] || null;
    },

    /**
     * 获取所有语音识别模型
     * @returns {Object} 所有模型
     */
    getAllSRModels: function () {
        return this.srModels;
    },

    /**
     * 删除语音识别模型
     * @param {string} modelType - 模型类型
     */
    deleteSRModel: function (modelType) {
        if (this.srModels[modelType]) {
            delete this.srModels[modelType];
            this.saveSRModels();
        }
    },

    /**
     * 清空所有语音识别模型
     */
    clearAllSRModels: function () {
        this.srModels = {};
        this.saveSRModels();
    },

    /**
     * 保存语音识别历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveSRHistory: function (action, data) {
        this.srHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.srHistory.length > this.maxHistorySize) {
            this.srHistory.shift();
        }
    },

    /**
     * 获取语音识别历史
     * @param {Object} options - 查询选项
     * @returns {Array} 语音识别历史
     */
    getSRHistory: function (options) {
        let history = [...this.srHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置语音识别配置
     * @param {Object} config - 配置对象
     */
    setSRConfig: function (config) {
        this.srConfig = { ...this.srConfig, ...config };
        this.saveSRConfig();
    },

    /**
     * 获取语音识别配置
     * @returns {Object} 配置对象
     */
    getSRConfig: function () {
        return this.srConfig;
    },

    /**
     * 重置语音识别系统
     */
    reset: function () {
        this.srHistory = [];
        this.loadSRConfig();
        this.loadSRModels();
    },

    /**
     * 获取语音识别统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const models = Object.keys(this.srModels);

        let totalVocabulary = 0;
        let totalPhonemes = 0;
        let totalLanguageRules = 0;

        if (this.srModels.vocabulary) {
            totalVocabulary = Object.keys(this.srModels.vocabulary).length;
        }

        if (this.srModels.phonemes) {
            totalPhonemes = Object.keys(this.srModels.phonemes).length;
        }

        if (this.srModels.languageModel) {
            totalLanguageRules = Object.keys(this.srModels.languageModel).length;
        }

        return {
            totalModels: models.length,
            totalVocabulary: totalVocabulary,
            totalPhonemes: totalPhonemes,
            totalLanguageRules: totalLanguageRules,
            enabled: this.srConfig.enabled,
            language: this.srConfig.language,
            continuous: this.srConfig.continuous,
            interimResults: this.srConfig.interimResults,
            maxAlternatives: this.srConfig.maxAlternatives,
            totalHistory: this.srHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏语音合成优化
const GameSpeechSynthesisOptimizer = {
    ssConfig: {},
    ssModels: {},
    ssHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏语音合成
     */
    init: function () {
        this.loadSSConfig();
        this.loadSSModels();
    },

    /**
     * 加载语音合成配置
     */
    loadSSConfig: function () {
        this.ssConfig = {
            enabled: true,
            maxHistorySize: 1000,
            language: 'zh-CN',
            voice: null,
            rate: 1,
            pitch: 1,
            volume: 1
        };

        const customConfig = localStorage.getItem('ssConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.ssConfig = { ...this.ssConfig, ...config };
            } catch (error) {
                console.error('加载语音合成配置失败:', error);
            }
        }
    },

    /**
     * 保存语音合成配置
     */
    saveSSConfig: function () {
        localStorage.setItem('ssConfig', JSON.stringify(this.ssConfig));
    },

    /**
     * 加载语音合成模型
     */
    loadSSModels: function () {
        const savedModels = localStorage.getItem('ssModels');
        if (savedModels) {
            try {
                this.ssModels = JSON.parse(savedModels);
            } catch (error) {
                console.error('加载语音合成模型失败:', error);
            }
        }

        if (!this.ssModels.phonemeLibrary) {
            this.ssModels = {
                phonemeLibrary: {},
                voiceProfiles: {},
                prosodyRules: {},
                audioEffects: {}
            };

            this.saveSSModels();
        }
    },

    /**
     * 保存语音合成模型
     */
    saveSSModels: function () {
        localStorage.setItem('ssModels', JSON.stringify(this.ssModels));
    },

    /**
     * 合成语音
     * @param {string} text - 文本
     * @returns {Promise<Object>} 合成结果
     */
    synthesize: function (text) {
        return new Promise((resolve, reject) => {
            if (!this.ssConfig.enabled) {
                reject({
                    success: false,
                    error: '语音合成已禁用'
                });
                return;
            }

            if (!('speechSynthesis' in window)) {
                reject({
                    success: false,
                    error: '浏览器不支持语音合成'
                });
                return;
            }

            const utterance = new SpeechSynthesisUtterance(text);

            utterance.lang = this.ssConfig.language;
            utterance.rate = this.ssConfig.rate;
            utterance.pitch = this.ssConfig.pitch;
            utterance.volume = this.ssConfig.volume;

            if (this.ssConfig.voice) {
                utterance.voice = this.ssConfig.voice;
            }

            utterance.onend = () => {
                this.saveSSHistory('synthesis_completed', {
                    text: text
                });

                resolve({
                    success: true,
                    text: text
                });
            };

            utterance.onerror = (event) => {
                reject({
                    success: false,
                    error: event.error
                });
            };

            speechSynthesis.speak(utterance);

            this.saveSSHistory('synthesis_started', {
                text: text
            });
        });
    },

    /**
     * 获取可用语音
     * @returns {Array} 语音列表
     */
    getVoices: function () {
        if (!('speechSynthesis' in window)) {
            return [];
        }

        return speechSynthesis.getVoices();
    },

    /**
     * 设置语音
     * @param {SpeechSynthesisVoice} voice - 语音对象
     */
    setVoice: function (voice) {
        this.ssConfig.voice = voice;
        this.saveSSConfig();
    },

    /**
     * 设置语速
     * @param {number} rate - 语速
     */
    setRate: function (rate) {
        this.ssConfig.rate = rate;
        this.saveSSConfig();
    },

    /**
     * 设置音高
     * @param {number} pitch - 音高
     */
    setPitch: function (pitch) {
        this.ssConfig.pitch = pitch;
        this.saveSSConfig();
    },

    /**
     * 设置音量
     * @param {number} volume - 音量
     */
    setVolume: function (volume) {
        this.ssConfig.volume = volume;
        this.saveSSConfig();
    },

    /**
     * 取消语音合成
     */
    cancel: function () {
        if ('speechSynthesis' in window) {
            speechSynthesis.cancel();

            this.saveSSHistory('synthesis_cancelled', {});
        }
    },

    /**
     * 暂停语音合成
     */
    pause: function () {
        if ('speechSynthesis' in window) {
            speechSynthesis.pause();

            this.saveSSHistory('synthesis_paused', {});
        }
    },

    /**
     * 恢复语音合成
     */
    resume: function () {
        if ('speechSynthesis' in window) {
            speechSynthesis.resume();

            this.saveSSHistory('synthesis_resumed', {});
        }
    },

    /**
     * 添加音素
     * @param {string} phoneme - 音素
     * @param {Object} audioData - 音频数据
     */
    addPhoneme: function (phoneme, audioData) {
        this.ssModels.phonemeLibrary[phoneme] = {
            phoneme: phoneme,
            audioData: audioData,
            duration: audioData.duration || 0.1
        };

        this.saveSSModels();
    },

    /**
     * 获取音素
     * @param {string} phoneme - 音素
     * @returns {Object} 音素对象
     */
    getPhoneme: function (phoneme) {
        return this.ssModels.phonemeLibrary[phoneme] || null;
    },

    /**
     * 添加语音配置文件
     * @param {string} profileName - 配置文件名称
     * @param {Object} profile - 配置对象
     */
    addVoiceProfile: function (profileName, profile) {
        this.ssModels.voiceProfiles[profileName] = {
            name: profileName,
            rate: profile.rate || 1,
            pitch: profile.pitch || 1,
            volume: profile.volume || 1,
            voice: profile.voice || null
        };

        this.saveSSModels();
    },

    /**
     * 获取语音配置文件
     * @param {string} profileName - 配置文件名称
     * @returns {Object} 配置文件对象
     */
    getVoiceProfile: function (profileName) {
        return this.ssModels.voiceProfiles[profileName] || null;
    },

    /**
     * 应用语音配置文件
     * @param {string} profileName - 配置文件名称
     */
    applyVoiceProfile: function (profileName) {
        const profile = this.getVoiceProfile(profileName);

        if (profile) {
            this.ssConfig.rate = profile.rate;
            this.ssConfig.pitch = profile.pitch;
            this.ssConfig.volume = profile.volume;
            this.ssConfig.voice = profile.voice;

            this.saveSSConfig();
        }
    },

    /**
     * 添加韵律规则
     * @param {string} ruleName - 规则名称
     * @param {Object} rule - 规则对象
     */
    addProsodyRule: function (ruleName, rule) {
        this.ssModels.prosodyRules[ruleName] = {
            name: ruleName,
            pattern: rule.pattern,
            pitchAdjustment: rule.pitchAdjustment || 0,
            durationAdjustment: rule.durationAdjustment || 1,
            emphasis: rule.emphasis || false
        };

        this.saveSSModels();
    },

    /**
     * 应用韵律规则
     * @param {string} text - 文本
     * @returns {string} 应用韵律后的文本
     */
    applyProsodyRules: function (text) {
        let processedText = text;

        for (const ruleName in this.ssModels.prosodyRules) {
            const rule = this.ssModels.prosodyRules[ruleName];
            processedText = processedText.replace(new RegExp(rule.pattern, 'g'), (match) => {
                let result = match;

                if (rule.pitchAdjustment !== 0) {
                    result = `<prosody pitch="${rule.pitchAdjustment > 0 ? '+' + rule.pitchAdjustment : rule.pitchAdjustment}Hz">${result}</prosody>`;
                }

                if (rule.durationAdjustment !== 1) {
                    result = `<prosody rate="${rule.durationAdjustment}">${result}</prosody>`;
                }

                if (rule.emphasis) {
                    result = `<emphasis>${result}</emphasis>`;
                }

                return result;
            });
        }

        return processedText;
    },

    /**
     * 添加音频效果
     * @param {string} effectName - 效果名称
     * @param {Object} effect - 效果对象
     */
    addAudioEffect: function (effectName, effect) {
        this.ssModels.audioEffects[effectName] = {
            name: effectName,
            type: effect.type,
            parameters: effect.parameters || {}
        };

        this.saveSSModels();
    },

    /**
     * 应用音频效果
     * @param {AudioBuffer} audioBuffer - 音频缓冲区
     * @param {string} effectName - 效果名称
     * @returns {AudioBuffer} 应用效果后的音频缓冲区
     */
    applyAudioEffect: function (audioBuffer, effectName) {
        const effect = this.ssModels.audioEffects[effectName];

        if (!effect) {
            return audioBuffer;
        }

        const outputBuffer = audioBuffer;
        const channelData = outputBuffer.getChannelData(0);

        switch (effect.type) {
            case 'reverb':
                this.applyReverb(channelData, effect.parameters);
                break;
            case 'echo':
                this.applyEcho(channelData, effect.parameters);
                break;
            case 'distortion':
                this.applyDistortion(channelData, effect.parameters);
                break;
            case 'filter':
                this.applyFilter(channelData, effect.parameters);
                break;
        }

        return outputBuffer;
    },

    /**
     * 应用混响效果
     * @param {Float32Array} channelData - 通道数据
     * @param {Object} parameters - 参数对象
     */
    applyReverb: function (channelData, parameters) {
        const decay = parameters.decay || 0.5;
        const delay = parameters.delay || 0.1;
        const mix = parameters.mix || 0.3;

        const sampleRate = 44100;
        const delaySamples = Math.floor(delay * sampleRate);

        const output = new Float32Array(channelData.length);

        for (let i = 0; i < channelData.length; i++) {
            output[i] = channelData[i];

            if (i >= delaySamples) {
                output[i] += channelData[i - delaySamples] * decay * mix;
            }
        }

        for (let i = 0; i < channelData.length; i++) {
            channelData[i] = output[i];
        }
    },

    /**
     * 应用回声效果
     * @param {Float32Array} channelData - 通道数据
     * @param {Object} parameters - 参数对象
     */
    applyEcho: function (channelData, parameters) {
        const delay = parameters.delay || 0.2;
        const feedback = parameters.feedback || 0.5;
        const mix = parameters.mix || 0.5;

        const sampleRate = 44100;
        const delaySamples = Math.floor(delay * sampleRate);

        const output = new Float32Array(channelData.length);

        for (let i = 0; i < channelData.length; i++) {
            output[i] = channelData[i];

            if (i >= delaySamples) {
                output[i] += output[i - delaySamples] * feedback * mix;
            }
        }

        for (let i = 0; i < channelData.length; i++) {
            channelData[i] = output[i];
        }
    },

    /**
     * 应用失真效果
     * @param {Float32Array} channelData - 通道数据
     * @param {Object} parameters - 参数对象
     */
    applyDistortion: function (channelData, parameters) {
        const amount = parameters.amount || 0.5;

        for (let i = 0; i < channelData.length; i++) {
            const input = channelData[i];
            const distorted = Math.tanh(input * (1 + amount * 10));
            channelData[i] = distorted;
        }
    },

    /**
     * 应用滤波器效果
     * @param {Float32Array} channelData - 通道数据
     * @param {Object} parameters - 参数对象
     */
    applyFilter: function (channelData, parameters) {
        const type = parameters.type || 'lowpass';
        const frequency = parameters.frequency || 1000;
        const Q = parameters.Q || 1;

        const sampleRate = 44100;
        const omega = 2 * Math.PI * frequency / sampleRate;
        const alpha = Math.sin(omega) / (2 * Q);

        let b0, b1, b2, a0, a1, a2;

        switch (type) {
            case 'lowpass':
                b0 = (1 - Math.cos(omega)) / 2;
                b1 = 1 - Math.cos(omega);
                b2 = (1 - Math.cos(omega)) / 2;
                a0 = 1 + alpha;
                a1 = -2 * Math.cos(omega);
                a2 = 1 - alpha;
                break;
            case 'highpass':
                b0 = (1 + Math.cos(omega)) / 2;
                b1 = -(1 + Math.cos(omega));
                b2 = (1 + Math.cos(omega)) / 2;
                a0 = 1 + alpha;
                a1 = -2 * Math.cos(omega);
                a2 = 1 - alpha;
                break;
            default:
                return;
        }

        const x1 = 0, x2 = 0, y1 = 0, y2 = 0;

        for (let i = 0; i < channelData.length; i++) {
            const input = channelData[i];
            const output = (b0 * input + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2) / a0;

            channelData[i] = output;
        }
    },

    /**
     * 获取语音合成模型
     * @param {string} modelType - 模型类型
     * @returns {Object} 模型对象
     */
    getSSModel: function (modelType) {
        return this.ssModels[modelType] || null;
    },

    /**
     * 获取所有语音合成模型
     * @returns {Object} 所有模型
     */
    getAllSSModels: function () {
        return this.ssModels;
    },

    /**
     * 删除语音合成模型
     * @param {string} modelType - 模型类型
     */
    deleteSSModel: function (modelType) {
        if (this.ssModels[modelType]) {
            delete this.ssModels[modelType];
            this.saveSSModels();
        }
    },

    /**
     * 清空所有语音合成模型
     */
    clearAllSSModels: function () {
        this.ssModels = {};
        this.saveSSModels();
    },

    /**
     * 保存语音合成历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveSSHistory: function (action, data) {
        this.ssHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.ssHistory.length > this.maxHistorySize) {
            this.ssHistory.shift();
        }
    },

    /**
     * 获取语音合成历史
     * @param {Object} options - 查询选项
     * @returns {Array} 语音合成历史
     */
    getSSHistory: function (options) {
        let history = [...this.ssHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置语音合成配置
     * @param {Object} config - 配置对象
     */
    setSSConfig: function (config) {
        this.ssConfig = { ...this.ssConfig, ...config };
        this.saveSSConfig();
    },

    /**
     * 获取语音合成配置
     * @returns {Object} 配置对象
     */
    getSSConfig: function () {
        return this.ssConfig;
    },

    /**
     * 重置语音合成系统
     */
    reset: function () {
        this.ssHistory = [];
        this.loadSSConfig();
        this.loadSSModels();
    },

    /**
     * 获取语音合成统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const models = Object.keys(this.ssModels);

        let totalPhonemes = 0;
        let totalVoiceProfiles = 0;
        let totalProsodyRules = 0;
        let totalAudioEffects = 0;

        if (this.ssModels.phonemeLibrary) {
            totalPhonemes = Object.keys(this.ssModels.phonemeLibrary).length;
        }

        if (this.ssModels.voiceProfiles) {
            totalVoiceProfiles = Object.keys(this.ssModels.voiceProfiles).length;
        }

        if (this.ssModels.prosodyRules) {
            totalProsodyRules = Object.keys(this.ssModels.prosodyRules).length;
        }

        if (this.ssModels.audioEffects) {
            totalAudioEffects = Object.keys(this.ssModels.audioEffects).length;
        }

        return {
            totalModels: models.length,
            totalPhonemes: totalPhonemes,
            totalVoiceProfiles: totalVoiceProfiles,
            totalProsodyRules: totalProsodyRules,
            totalAudioEffects: totalAudioEffects,
            enabled: this.ssConfig.enabled,
            language: this.ssConfig.language,
            rate: this.ssConfig.rate,
            pitch: this.ssConfig.pitch,
            volume: this.ssConfig.volume,
            totalHistory: this.ssHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏图像处理优化
const GameImageProcessingOptimizer = {
    ipConfig: {},
    ipFilters: {},
    ipHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏图像处理
     */
    init: function () {
        this.loadIPConfig();
        this.loadIPFilters();
    },

    /**
     * 加载图像处理配置
     */
    loadIPConfig: function () {
        this.ipConfig = {
            enabled: true,
            maxHistorySize: 1000,
            defaultQuality: 0.8,
            cacheEnabled: true,
            maxCacheSize: 50
        };

        const customConfig = localStorage.getItem('ipConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.ipConfig = { ...this.ipConfig, ...config };
            } catch (error) {
                console.error('加载图像处理配置失败:', error);
            }
        }
    },

    /**
     * 保存图像处理配置
     */
    saveIPConfig: function () {
        localStorage.setItem('ipConfig', JSON.stringify(this.ipConfig));
    },

    /**
     * 加载图像处理滤镜
     */
    loadIPFilters: function () {
        const savedFilters = localStorage.getItem('ipFilters');
        if (savedFilters) {
            try {
                this.ipFilters = JSON.parse(savedFilters);
            } catch (error) {
                console.error('加载图像处理滤镜失败:', error);
            }
        }

        if (!this.ipFilters.brightness) {
            this.ipFilters = {
                brightness: { value: 0, enabled: false },
                contrast: { value: 0, enabled: false },
                saturation: { value: 0, enabled: false },
                hue: { value: 0, enabled: false },
                blur: { value: 0, enabled: false },
                sharpen: { value: 0, enabled: false },
                grayscale: { value: 0, enabled: false },
                sepia: { value: 0, enabled: false },
                invert: { value: 0, enabled: false },
                noise: { value: 0, enabled: false }
            };

            this.saveIPFilters();
        }
    },

    /**
     * 保存图像处理滤镜
     */
    saveIPFilters: function () {
        localStorage.setItem('ipFilters', JSON.stringify(this.ipFilters));
    },

    /**
     * 应用滤镜
     * @param {HTMLCanvasElement|HTMLImageElement} image - 图像
     * @returns {HTMLCanvasElement} 处理后的图像
     */
    applyFilters: function (image) {
        if (!this.ipConfig.enabled) {
            return image;
        }

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = image.width;
        canvas.height = image.height;
        ctx.drawImage(image, 0, 0);

        let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        if (this.ipFilters.brightness.enabled) {
            imageData = this.applyBrightness(imageData, this.ipFilters.brightness.value);
        }

        if (this.ipFilters.contrast.enabled) {
            imageData = this.applyContrast(imageData, this.ipFilters.contrast.value);
        }

        if (this.ipFilters.saturation.enabled) {
            imageData = this.applySaturation(imageData, this.ipFilters.saturation.value);
        }

        if (this.ipFilters.hue.enabled) {
            imageData = this.applyHue(imageData, this.ipFilters.hue.value);
        }

        if (this.ipFilters.grayscale.enabled) {
            imageData = this.applyGrayscale(imageData, this.ipFilters.grayscale.value);
        }

        if (this.ipFilters.sepia.enabled) {
            imageData = this.applySepia(imageData, this.ipFilters.sepia.value);
        }

        if (this.ipFilters.invert.enabled) {
            imageData = this.applyInvert(imageData, this.ipFilters.invert.value);
        }

        if (this.ipFilters.noise.enabled) {
            imageData = this.applyNoise(imageData, this.ipFilters.noise.value);
        }

        ctx.putImageData(imageData, 0, 0);

        if (this.ipFilters.blur.enabled) {
            this.applyBlur(ctx, canvas, this.ipFilters.blur.value);
        }

        if (this.ipFilters.sharpen.enabled) {
            this.applySharpen(ctx, canvas, this.ipFilters.sharpen.value);
        }

        this.saveIPHistory('filters_applied', {
            filters: Object.keys(this.ipFilters).filter(f => this.ipFilters[f].enabled)
        });

        return canvas;
    },

    /**
     * 应用亮度
     * @param {ImageData} imageData - 图像数据
     * @param {number} value - 亮度值
     * @returns {ImageData} 处理后的图像数据
     */
    applyBrightness: function (imageData, value) {
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            data[i] += value;
            data[i + 1] += value;
            data[i + 2] += value;
        }

        return imageData;
    },

    /**
     * 应用对比度
     * @param {ImageData} imageData - 图像数据
     * @param {number} value - 对比值
     * @returns {ImageData} 处理后的图像数据
     */
    applyContrast: function (imageData, value) {
        const data = imageData.data;
        const factor = (259 * (value + 255)) / (255 * (259 - value));

        for (let i = 0; i < data.length; i += 4) {
            data[i] = factor * (data[i] - 128) + 128;
            data[i + 1] = factor * (data[i + 1] - 128) + 128;
            data[i + 2] = factor * (data[i + 2] - 128) + 128;
        }

        return imageData;
    },

    /**
     * 应用饱和度
     * @param {ImageData} imageData - 图像数据
     * @param {number} value - 饱和度值
     * @returns {ImageData} 处理后的图像数据
     */
    applySaturation: function (imageData, value) {
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            const gray = 0.2989 * data[i] + 0.5870 * data[i + 1] + 0.1140 * data[i + 2];

            data[i] = gray + value * (data[i] - gray);
            data[i + 1] = gray + value * (data[i + 1] - gray);
            data[i + 2] = gray + value * (data[i + 2] - gray);
        }

        return imageData;
    },

    /**
     * 应用色相
     * @param {ImageData} imageData - 图像数据
     * @param {number} value - 色相值
     * @returns {ImageData} 处理后的图像数据
     */
    applyHue: function (imageData, value) {
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            const [h, s, l] = this.rgbToHsl(data[i], data[i + 1], data[i + 2]);
            const [r, g, b] = this.hslToRgb((h + value) % 360, s, l);

            data[i] = r;
            data[i + 1] = g;
            data[i + 2] = b;
        }

        return imageData;
    },

    /**
     * RGB转HSL
     * @param {number} r - 红色
     * @param {number} g - 绿色
     * @param {number} b - 蓝色
     * @returns {Array} HSL数组
     */
    rgbToHsl: function (r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

            switch (max) {
                case r:
                    h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                    break;
                case g:
                    h = ((b - r) / d + 2) / 6;
                    break;
                case b:
                    h = ((r - g) / d + 4) / 6;
                    break;
            }
        }

        return [h * 360, s, l];
    },

    /**
     * HSL转RGB
     * @param {number} h - 色相
     * @param {number} s - 饱和度
     * @param {number} l - 亮度
     * @returns {Array} RGB数组
     */
    hslToRgb: function (h, s, l) {
        h /= 360;

        let r, g, b;

        if (s === 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };

            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;

            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }

        return [r * 255, g * 255, b * 255];
    },

    /**
     * 应用灰度
     * @param {ImageData} imageData - 图像数据
     * @param {number} value - 灰度值
     * @returns {ImageData} 处理后的图像数据
     */
    applyGrayscale: function (imageData, value) {
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            const gray = 0.2989 * data[i] + 0.5870 * data[i + 1] + 0.1140 * data[i + 2];

            data[i] = data[i] + value * (gray - data[i]);
            data[i + 1] = data[i + 1] + value * (gray - data[i + 1]);
            data[i + 2] = data[i + 2] + value * (gray - data[i + 2]);
        }

        return imageData;
    },

    /**
     * 应用褐色
     * @param {ImageData} imageData - 图像数据
     * @param {number} value - 褐色值
     * @returns {ImageData} 处理后的图像数据
     */
    applySepia: function (imageData, value) {
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];

            data[i] = r + value * (0.393 * r + 0.769 * g + 0.189 * b - r);
            data[i + 1] = g + value * (0.349 * r + 0.686 * g + 0.168 * b - g);
            data[i + 2] = b + value * (0.272 * r + 0.534 * g + 0.131 * b - b);
        }

        return imageData;
    },

    /**
     * 应用反色
     * @param {ImageData} imageData - 图像数据
     * @param {number} value - 反色值
     * @returns {ImageData} 处理后的图像数据
     */
    applyInvert: function (imageData, value) {
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            data[i] = data[i] + value * (255 - 2 * data[i]);
            data[i + 1] = data[i + 1] + value * (255 - 2 * data[i + 1]);
            data[i + 2] = data[i + 2] + value * (255 - 2 * data[i + 2]);
        }

        return imageData;
    },

    /**
     * 应用噪点
     * @param {ImageData} imageData - 图像数据
     * @param {number} value - 噪点值
     * @returns {ImageData} 处理后的图像数据
     */
    applyNoise: function (imageData, value) {
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            const noise = (Math.random() - 0.5) * value * 255;

            data[i] += noise;
            data[i + 1] += noise;
            data[i + 2] += noise;
        }

        return imageData;
    },

    /**
     * 应用模糊
     * @param {CanvasRenderingContext2D} ctx - 画布上下文
     * @param {HTMLCanvasElement} canvas - 画布
     * @param {number} value - 模糊值
     */
    applyBlur: function (ctx, canvas, value) {
        const radius = Math.abs(value);

        if (radius === 0) {
            return;
        }

        ctx.filter = `blur(${radius}px)`;
        ctx.drawImage(canvas, 0, 0);
        ctx.filter = 'none';
    },

    /**
     * 应用锐化
     * @param {CanvasRenderingContext2D} ctx - 画布上下文
     * @param {HTMLCanvasElement} canvas - 画布
     * @param {number} value - 锐化值
     */
    applySharpen: function (ctx, canvas, value) {
        const amount = value;

        if (amount === 0) {
            return;
        }

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const width = canvas.width;
        const height = canvas.height;

        const output = ctx.createImageData(width, height);
        const outputData = output.data;

        const kernel = [
            0, -amount, 0,
            -amount, 1 + 4 * amount, -amount,
            0, -amount, 0
        ];

        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                for (let c = 0; c < 3; c++) {
                    let sum = 0;

                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const index = ((y + ky) * width + (x + kx)) * 4 + c;
                            sum += data[index] * kernel[(ky + 1) * 3 + (kx + 1)];
                        }
                    }

                    outputData[(y * width + x) * 4 + c] = sum;
                }

                outputData[(y * width + x) * 4 + 3] = data[(y * width + x) * 4 + 3];
            }
        }

        ctx.putImageData(output, 0, 0);
    },

    /**
     * 调整大小
     * @param {HTMLCanvasElement|HTMLImageElement} image - 图像
     * @param {number} width - 宽度
     * @param {number} height - 高度
     * @returns {HTMLCanvasElement} 调整大小后的图像
     */
    resize: function (image, width, height) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = width;
        canvas.height = height;

        ctx.drawImage(image, 0, 0, width, height);

        return canvas;
    },

    /**
     * 裁剪
     * @param {HTMLCanvasElement|HTMLImageElement} image - 图像
     * @param {number} x - X坐标
     * @param {number} y - Y坐标
     * @param {number} width - 宽度
     * @param {number} height - 高度
     * @returns {HTMLCanvasElement} 裁剪后的图像
     */
    crop: function (image, x, y, width, height) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = width;
        canvas.height = height;

        ctx.drawImage(image, x, y, width, height, 0, 0, width, height);

        return canvas;
    },

    /**
     * 旋转
     * @param {HTMLCanvasElement|HTMLImageElement} image - 图像
     * @param {number} angle - 角度
     * @returns {HTMLCanvasElement} 旋转后的图像
     */
    rotate: function (image, angle) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        const radians = angle * Math.PI / 180;
        const sin = Math.abs(Math.sin(radians));
        const cos = Math.abs(Math.cos(radians));

        canvas.width = image.width * cos + image.height * sin;
        canvas.height = image.width * sin + image.height * cos;

        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate(radians);
        ctx.drawImage(image, -image.width / 2, -image.height / 2);

        return canvas;
    },

    /**
     * 翻转
     * @param {HTMLCanvasElement|HTMLImageElement} image - 图像
     * @param {string} direction - 方向
     * @returns {HTMLCanvasElement} 翻转后的图像
     */
    flip: function (image, direction) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = image.width;
        canvas.height = image.height;

        if (direction === 'horizontal') {
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
        } else if (direction === 'vertical') {
            ctx.translate(0, canvas.height);
            ctx.scale(1, -1);
        }

        ctx.drawImage(image, 0, 0);

        return canvas;
    },

    /**
     * 设置滤镜
     * @param {string} filterName - 滤镜名称
     * @param {number} value - 滤镜值
     * @param {boolean} enabled - 是否启用
     */
    setFilter: function (filterName, value, enabled) {
        if (this.ipFilters[filterName]) {
            this.ipFilters[filterName].value = value;
            this.ipFilters[filterName].enabled = enabled;
            this.saveIPFilters();
        }
    },

    /**
     * 获取滤镜
     * @param {string} filterName - 滤镜名称
     * @returns {Object} 滤镜对象
     */
    getFilter: function (filterName) {
        return this.ipFilters[filterName] || null;
    },

    /**
     * 重置所有滤镜
     */
    resetFilters: function () {
        for (const filterName in this.ipFilters) {
            this.ipFilters[filterName].value = 0;
            this.ipFilters[filterName].enabled = false;
        }

        this.saveIPFilters();
    },

    /**
     * 保存图像处理历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveIPHistory: function (action, data) {
        this.ipHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.ipHistory.length > this.maxHistorySize) {
            this.ipHistory.shift();
        }
    },

    /**
     * 获取图像处理历史
     * @param {Object} options - 查询选项
     * @returns {Array} 图像处理历史
     */
    getIPHistory: function (options) {
        let history = [...this.ipHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置图像处理配置
     * @param {Object} config - 配置对象
     */
    setIPConfig: function (config) {
        this.ipConfig = { ...this.ipConfig, ...config };
        this.saveIPConfig();
    },

    /**
     * 获取图像处理配置
     * @returns {Object} 配置对象
     */
    getIPConfig: function () {
        return this.ipConfig;
    },

    /**
     * 重置图像处理系统
     */
    reset: function () {
        this.ipHistory = [];
        this.loadIPConfig();
        this.loadIPFilters();
    },

    /**
     * 获取图像处理统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const filters = Object.keys(this.ipFilters);
        const enabledFilters = filters.filter(f => this.ipFilters[f].enabled);

        return {
            totalFilters: filters.length,
            enabledFilters: enabledFilters.length,
            enabled: this.ipConfig.enabled,
            defaultQuality: this.ipConfig.defaultQuality,
            cacheEnabled: this.ipConfig.cacheEnabled,
            maxCacheSize: this.ipConfig.maxCacheSize,
            totalHistory: this.ipHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏视频处理优化
const GameVideoProcessingOptimizer = {
    vpConfig: {},
    vpEffects: {},
    vpHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏视频处理
     */
    init: function () {
        this.loadVPConfig();
        this.loadVPEffects();
    },

    /**
     * 加载视频处理配置
     */
    loadVPConfig: function () {
        this.vpConfig = {
            enabled: true,
            maxHistorySize: 1000,
            defaultFrameRate: 30,
            defaultQuality: 0.8,
            autoPlay: true,
            loop: true,
            muted: false
        };

        const customConfig = localStorage.getItem('vpConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.vpConfig = { ...this.vpConfig, ...config };
            } catch (error) {
                console.error('加载视频处理配置失败:', error);
            }
        }
    },

    /**
     * 保存视频处理配置
     */
    saveVPConfig: function () {
        localStorage.setItem('vpConfig', JSON.stringify(this.vpConfig));
    },

    /**
     * 加载视频处理效果
     */
    loadVPEffects: function () {
        const savedEffects = localStorage.getItem('vpEffects');
        if (savedEffects) {
            try {
                this.vpEffects = JSON.parse(savedEffects);
            } catch (error) {
                console.error('加载视频处理效果失败:', error);
            }
        }

        if (!this.vpEffects.brightness) {
            this.vpEffects = {
                brightness: { value: 0, enabled: false },
                contrast: { value: 0, enabled: false },
                saturation: { value: 0, enabled: false },
                hue: { value: 0, enabled: false },
                blur: { value: 0, enabled: false },
                sharpen: { value: 0, enabled: false },
                grayscale: { value: 0, enabled: false },
                sepia: { value: 0, enabled: false },
                invert: { value: 0, enabled: false },
                noise: { value: 0, enabled: false },
                vignette: { value: 0, enabled: false },
                glitch: { value: 0, enabled: false }
            };

            this.saveVPEffects();
        }
    },

    /**
     * 保存视频处理效果
     */
    saveVPEffects: function () {
        localStorage.setItem('vpEffects', JSON.stringify(this.vpEffects));
    },

    /**
     * 创建视频播放器
     * @param {string} src - 视频源
     * @param {Object} options - 选项对象
     * @returns {HTMLVideoElement} 视频元素
     */
    createVideoPlayer: function (src, options) {
        const video = document.createElement('video');

        video.src = src;
        video.autoplay = options.autoPlay !== undefined ? options.autoPlay : this.vpConfig.autoPlay;
        video.loop = options.loop !== undefined ? options.loop : this.vpConfig.loop;
        video.muted = options.muted !== undefined ? options.muted : this.vpConfig.muted;
        video.controls = options.controls !== undefined ? options.controls : true;

        if (options.width) {
            video.width = options.width;
        }

        if (options.height) {
            video.height = options.height;
        }

        if (options.frameRate) {
            video.setAttribute('data-frame-rate', options.frameRate);
        }

        this.saveVPHistory('video_player_created', {
            src: src
        });

        return video;
    },

    /**
     * 播放视频
     * @param {HTMLVideoElement} video - 视频元素
     * @returns {Promise<Object>} 播放结果
     */
    playVideo: function (video) {
        return new Promise((resolve, reject) => {
            if (!this.vpConfig.enabled) {
                reject({
                    success: false,
                    error: '视频处理已禁用'
                });
                return;
            }

            video.play()
                .then(() => {
                    this.saveVPHistory('video_played', {
                        src: video.src
                    });

                    resolve({
                        success: true
                    });
                })
                .catch((error) => {
                    reject({
                        success: false,
                        error: error.message
                    });
                });
        });
    },

    /**
     * 暂停视频
     * @param {HTMLVideoElement} video - 视频元素
     */
    pauseVideo: function (video) {
        video.pause();

        this.saveVPHistory('video_paused', {
            src: video.src,
            currentTime: video.currentTime
        });
    },

    /**
     * 停止视频
     * @param {HTMLVideoElement} video - 视频元素
     */
    stopVideo: function (video) {
        video.pause();
        video.currentTime = 0;

        this.saveVPHistory('video_stopped', {
            src: video.src
        });
    },

    /**
     * 跳转到指定时间
     * @param {HTMLVideoElement} video - 视频元素
     * @param {number} time - 时间
     */
    seekTo: function (video, time) {
        video.currentTime = time;

        this.saveVPHistory('video_seeked', {
            src: video.src,
            time: time
        });
    },

    /**
     * 设置播放速度
     * @param {HTMLVideoElement} video - 视频元素
     * @param {number} speed - 速度
     */
    setPlaybackRate: function (video, speed) {
        video.playbackRate = speed;

        this.saveVPHistory('playback_rate_set', {
            src: video.src,
            speed: speed
        });
    },

    /**
     * 设置音量
     * @param {HTMLVideoElement} video - 视频元素
     * @param {number} volume - 音量
     */
    setVolume: function (video, volume) {
        video.volume = volume;

        this.saveVPHistory('volume_set', {
            src: video.src,
            volume: volume
        });
    },

    /**
     * 获取视频帧
     * @param {HTMLVideoElement} video - 视频元素
     * @param {number} time - 时间
     * @returns {HTMLCanvasElement} 帧画布
     */
    getFrame: function (video, time) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;

        if (time !== undefined) {
            video.currentTime = time;
        }

        ctx.drawImage(video, 0, 0);

        return canvas;
    },

    /**
     * 提取视频帧
     * @param {HTMLVideoElement} video - 视频元素
     * @param {number} interval - 间隔
     * @param {Function} callback - 回调函数
     */
    extractFrames: function (video, interval, callback) {
        const frameRate = video.getAttribute('data-frame-rate') || this.vpConfig.defaultFrameRate;
        const frameInterval = 1000 / frameRate;

        const extractFrame = () => {
            if (video.paused || video.ended) {
                return;
            }

            const frame = this.getFrame(video);
            callback(frame);

            setTimeout(extractFrame, interval || frameInterval);
        };

        extractFrame();
    },

    /**
     * 应用效果
     * @param {HTMLVideoElement} video - 视频元素
     * @param {HTMLCanvasElement} canvas - 画布
     * @returns {Function} 清除函数
     */
    applyEffects: function (video, canvas) {
        const ctx = canvas.getContext('2d');

        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;

        const render = () => {
            if (video.paused || video.ended) {
                return;
            }

            ctx.drawImage(video, 0, 0);

            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

            if (this.vpEffects.brightness.enabled) {
                imageData = this.applyBrightness(imageData, this.vpEffects.brightness.value);
            }

            if (this.vpEffects.contrast.enabled) {
                imageData = this.applyContrast(imageData, this.vpEffects.contrast.value);
            }

            if (this.vpEffects.saturation.enabled) {
                imageData = this.applySaturation(imageData, this.vpEffects.saturation.value);
            }

            if (this.vpEffects.hue.enabled) {
                imageData = this.applyHue(imageData, this.vpEffects.hue.value);
            }

            if (this.vpEffects.grayscale.enabled) {
                imageData = this.applyGrayscale(imageData, this.vpEffects.grayscale.value);
            }

            if (this.vpEffects.sepia.enabled) {
                imageData = this.applySepia(imageData, this.vpEffects.sepia.value);
            }

            if (this.vpEffects.invert.enabled) {
                imageData = this.applyInvert(imageData, this.vpEffects.invert.value);
            }

            if (this.vpEffects.noise.enabled) {
                imageData = this.applyNoise(imageData, this.vpEffects.noise.value);
            }

            ctx.putImageData(imageData, 0, 0);

            if (this.vpEffects.vignette.enabled) {
                this.applyVignette(ctx, canvas, this.vpEffects.vignette.value);
            }

            if (this.vpEffects.glitch.enabled) {
                this.applyGlitch(ctx, canvas, this.vpEffects.glitch.value);
            }

            if (this.vpEffects.blur.enabled) {
                this.applyBlur(ctx, canvas, this.vpEffects.blur.value);
            }

            if (this.vpEffects.sharpen.enabled) {
                this.applySharpen(ctx, canvas, this.vpEffects.sharpen.value);
            }

            requestAnimationFrame(render);
        };

        render();

        this.saveVPHistory('effects_applied', {
            src: video.src
        });

        return () => {
            // 清除函数
        };
    },

    /**
     * 应用亮度
     * @param {ImageData} imageData - 图像数据
     * @param {number} value - 亮度值
     * @returns {ImageData} 处理后的图像数据
     */
    applyBrightness: function (imageData, value) {
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            data[i] += value;
            data[i + 1] += value;
            data[i + 2] += value;
        }

        return imageData;
    },

    /**
     * 应用对比度
     * @param {ImageData} imageData - 图像数据
     * @param {number} value - 对比值
     * @returns {ImageData} 处理后的图像数据
     */
    applyContrast: function (imageData, value) {
        const data = imageData.data;
        const factor = (259 * (value + 255)) / (255 * (259 - value));

        for (let i = 0; i < data.length; i += 4) {
            data[i] = factor * (data[i] - 128) + 128;
            data[i + 1] = factor * (data[i + 1] - 128) + 128;
            data[i + 2] = factor * (data[i + 2] - 128) + 128;
        }

        return imageData;
    },

    /**
     * 应用饱和度
     * @param {ImageData} imageData - 图像数据
     * @param {number} value - 饱和度值
     * @returns {ImageData} 处理后的图像数据
     */
    applySaturation: function (imageData, value) {
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            const gray = 0.2989 * data[i] + 0.5870 * data[i + 1] + 0.1140 * data[i + 2];

            data[i] = gray + value * (data[i] - gray);
            data[i + 1] = gray + value * (data[i + 1] - gray);
            data[i + 2] = gray + value * (data[i + 2] - gray);
        }

        return imageData;
    },

    /**
     * 应用色相
     * @param {ImageData} imageData - 图像数据
     * @param {number} value - 色相值
     * @returns {ImageData} 处理后的图像数据
     */
    applyHue: function (imageData, value) {
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            const [h, s, l] = this.rgbToHsl(data[i], data[i + 1], data[i + 2]);
            const [r, g, b] = this.hslToRgb((h + value) % 360, s, l);

            data[i] = r;
            data[i + 1] = g;
            data[i + 2] = b;
        }

        return imageData;
    },

    /**
     * RGB转HSL
     * @param {number} r - 红色
     * @param {number} g - 绿色
     * @param {number} b - 蓝色
     * @returns {Array} HSL数组
     */
    rgbToHsl: function (r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0;
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

            switch (max) {
                case r:
                    h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
                    break;
                case g:
                    h = ((b - r) / d + 2) / 6;
                    break;
                case b:
                    h = ((r - g) / d + 4) / 6;
                    break;
            }
        }

        return [h * 360, s, l];
    },

    /**
     * HSL转RGB
     * @param {number} h - 色相
     * @param {number} s - 饱和度
     * @param {number} l - 亮度
     * @returns {Array} RGB数组
     */
    hslToRgb: function (h, s, l) {
        h /= 360;

        let r, g, b;

        if (s === 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };

            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;

            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }

        return [r * 255, g * 255, b * 255];
    },

    /**
     * 应用灰度
     * @param {ImageData} imageData - 图像数据
     * @param {number} value - 灰度值
     * @returns {ImageData} 处理后的图像数据
     */
    applyGrayscale: function (imageData, value) {
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            const gray = 0.2989 * data[i] + 0.5870 * data[i + 1] + 0.1140 * data[i + 2];

            data[i] = data[i] + value * (gray - data[i]);
            data[i + 1] = data[i + 1] + value * (gray - data[i + 1]);
            data[i + 2] = data[i + 2] + value * (gray - data[i + 2]);
        }

        return imageData;
    },

    /**
     * 应用褐色
     * @param {ImageData} imageData - 图像数据
     * @param {number} value - 褐色值
     * @returns {ImageData} 处理后的图像数据
     */
    applySepia: function (imageData, value) {
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];

            data[i] = r + value * (0.393 * r + 0.769 * g + 0.189 * b - r);
            data[i + 1] = g + value * (0.349 * r + 0.686 * g + 0.168 * b - g);
            data[i + 2] = b + value * (0.272 * r + 0.534 * g + 0.131 * b - b);
        }

        return imageData;
    },

    /**
     * 应用反色
     * @param {ImageData} imageData - 图像数据
     * @param {number} value - 反色值
     * @returns {ImageData} 处理后的图像数据
     */
    applyInvert: function (imageData, value) {
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            data[i] = data[i] + value * (255 - 2 * data[i]);
            data[i + 1] = data[i + 1] + value * (255 - 2 * data[i + 1]);
            data[i + 2] = data[i + 2] + value * (255 - 2 * data[i + 2]);
        }

        return imageData;
    },

    /**
     * 应用噪点
     * @param {ImageData} imageData - 图像数据
     * @param {number} value - 噪点值
     * @returns {ImageData} 处理后的图像数据
     */
    applyNoise: function (imageData, value) {
        const data = imageData.data;

        for (let i = 0; i < data.length; i += 4) {
            const noise = (Math.random() - 0.5) * value * 255;

            data[i] += noise;
            data[i + 1] += noise;
            data[i + 2] += noise;
        }

        return imageData;
    },

    /**
     * 应用暗角
     * @param {CanvasRenderingContext2D} ctx - 画布上下文
     * @param {HTMLCanvasElement} canvas - 画布
     * @param {number} value - 暗角值
     */
    applyVignette: function (ctx, canvas, value) {
        const gradient = ctx.createRadialGradient(
            canvas.width / 2,
            canvas.height / 2,
            0,
            canvas.width / 2,
            canvas.height / 2,
            Math.max(canvas.width, canvas.height) / 2
        );

        gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
        gradient.addColorStop(1, `rgba(0, 0, 0, ${value})`);

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    },

    /**
     * 应用故障效果
     * @param {CanvasRenderingContext2D} ctx - 画布上下文
     * @param {HTMLCanvasElement} canvas - 画布
     * @param {number} value - 故障值
     */
    applyGlitch: function (ctx, canvas, value) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        const shift = Math.floor(value * 50);

        for (let y = 0; y < canvas.height; y++) {
            if (Math.random() < 0.1) {
                const rowOffset = Math.floor((Math.random() - 0.5) * shift);

                for (let x = 0; x < canvas.width; x++) {
                    const sourceIndex = (y * canvas.width + x) * 4;
                    const targetX = x + rowOffset;

                    if (targetX >= 0 && targetX < canvas.width) {
                        const targetIndex = (y * canvas.width + targetX) * 4;

                        data[targetIndex] = data[sourceIndex];
                        data[targetIndex + 1] = data[sourceIndex + 1];
                        data[targetIndex + 2] = data[sourceIndex + 2];
                    }
                }
            }
        }

        // 随机颜色通道分离
        for (let i = 0; i < data.length; i += 4) {
            if (Math.random() < 0.05 * value) {
                const channel = Math.floor(Math.random() * 3);
                data[i + channel] = data[i + (channel + 1) % 3];
            }
        }

        ctx.putImageData(imageData, 0, 0);
    },

    /**
     * 应用模糊
     * @param {CanvasRenderingContext2D} ctx - 画布上下文
     * @param {HTMLCanvasElement} canvas - 画布
     * @param {number} value - 模糊值
     */
    applyBlur: function (ctx, canvas, value) {
        const radius = Math.abs(value);

        if (radius === 0) {
            return;
        }

        ctx.filter = `blur(${radius}px)`;
        ctx.drawImage(canvas, 0, 0);
        ctx.filter = 'none';
    },

    /**
     * 应用锐化
     * @param {CanvasRenderingContext2D} ctx - 画布上下文
     * @param {HTMLCanvasElement} canvas - 画布
     * @param {number} value - 锐化值
     */
    applySharpen: function (ctx, canvas, value) {
        const amount = value;

        if (amount === 0) {
            return;
        }

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const width = canvas.width;
        const height = canvas.height;

        const output = ctx.createImageData(width, height);
        const outputData = output.data;

        const kernel = [
            0, -amount, 0,
            -amount, 1 + 4 * amount, -amount,
            0, -amount, 0
        ];

        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                for (let c = 0; c < 3; c++) {
                    let sum = 0;

                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const index = ((y + ky) * width + (x + kx)) * 4 + c;
                            sum += data[index] * kernel[(ky + 1) * 3 + (kx + 1)];
                        }
                    }

                    outputData[(y * width + x) * 4 + c] = sum;
                }

                outputData[(y * width + x) * 4 + 3] = data[(y * width + x) * 4 + 3];
            }
        }

        ctx.putImageData(output, 0, 0);
    },

    /**
     * 设置效果
     * @param {string} effectName - 效果名称
     * @param {number} value - 效果值
     * @param {boolean} enabled - 是否启用
     */
    setEffect: function (effectName, value, enabled) {
        if (this.vpEffects[effectName]) {
            this.vpEffects[effectName].value = value;
            this.vpEffects[effectName].enabled = enabled;
            this.saveVPEffects();
        }
    },

    /**
     * 获取效果
     * @param {string} effectName - 效果名称
     * @returns {Object} 效果对象
     */
    getEffect: function (effectName) {
        return this.vpEffects[effectName] || null;
    },

    /**
     * 重置所有效果
     */
    resetEffects: function () {
        for (const effectName in this.vpEffects) {
            this.vpEffects[effectName].value = 0;
            this.vpEffects[effectName].enabled = false;
        }

        this.saveVPEffects();
    },

    /**
     * 保存视频处理历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveVPHistory: function (action, data) {
        this.vpHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.vpHistory.length > this.maxHistorySize) {
            this.vpHistory.shift();
        }
    },

    /**
     * 获取视频处理历史
     * @param {Object} options - 查询选项
     * @returns {Array} 视频处理历史
     */
    getVPHistory: function (options) {
        let history = [...this.vpHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置视频处理配置
     * @param {Object} config - 配置对象
     */
    setVPConfig: function (config) {
        this.vpConfig = { ...this.vpConfig, ...config };
        this.saveVPConfig();
    },

    /**
     * 获取视频处理配置
     * @returns {Object} 配置对象
     */
    getVPConfig: function () {
        return this.vpConfig;
    },

    /**
     * 重置视频处理系统
     */
    reset: function () {
        this.vpHistory = [];
        this.loadVPConfig();
        this.loadVPEffects();
    },

    /**
     * 获取视频处理统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const effects = Object.keys(this.vpEffects);
        const enabledEffects = effects.filter(e => this.vpEffects[e].enabled);

        return {
            totalEffects: effects.length,
            enabledEffects: enabledEffects.length,
            enabled: this.vpConfig.enabled,
            defaultFrameRate: this.vpConfig.defaultFrameRate,
            defaultQuality: this.vpConfig.defaultQuality,
            autoPlay: this.vpConfig.autoPlay,
            loop: this.vpConfig.loop,
            muted: this.vpConfig.muted,
            totalHistory: this.vpHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏音频分析优化
const GameAudioAnalysisOptimizer = {
    aaConfig: {},
    aaFeatures: {},
    aaHistory: [],
    maxHistorySize: 1000,
    audioContext: null,
    analyser: null,

    /**
     * 初始化游戏音频分析
     */
    init: function () {
        this.loadAAConfig();
        this.loadAAFeatures();
        this.initAudioContext();
    },

    /**
     * 初始化音频上下文
     */
    initAudioContext: function () {
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.analyser = this.audioContext.createAnalyser();
            this.analyser.fftSize = 2048;
        } catch (error) {
            console.error('初始化音频上下文失败:', error);
        }
    },

    /**
     * 加载音频分析配置
     */
    loadAAConfig: function () {
        this.aaConfig = {
            enabled: true,
            maxHistorySize: 1000,
            fftSize: 2048,
            smoothingTimeConstant: 0.8,
            minDecibels: -90,
            maxDecibels: -10,
            analysisInterval: 100
        };

        const customConfig = localStorage.getItem('aaConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.aaConfig = { ...this.aaConfig, ...config };
            } catch (error) {
                console.error('加载音频分析配置失败:', error);
            }
        }

        if (this.analyser) {
            this.analyser.fftSize = this.aaConfig.fftSize;
            this.analyser.smoothingTimeConstant = this.aaConfig.smoothingTimeConstant;
            this.analyser.minDecibels = this.aaConfig.minDecibels;
            this.analyser.maxDecibels = this.aaConfig.maxDecibels;
        }
    },

    /**
     * 保存音频分析配置
     */
    saveAAConfig: function () {
        localStorage.setItem('aaConfig', JSON.stringify(this.aaConfig));
    },

    /**
     * 加载音频分析特征
     */
    loadAAFeatures: function () {
        const savedFeatures = localStorage.getItem('aaFeatures');
        if (savedFeatures) {
            try {
                this.aaFeatures = JSON.parse(savedFeatures);
            } catch (error) {
                console.error('加载音频分析特征失败:', error);
            }
        }

        if (!this.aaFeatures.spectrum) {
            this.aaFeatures = {
                spectrum: [],
                waveform: [],
                frequencyData: [],
                timeDomainData: [],
                beatDetection: {
                    enabled: false,
                    threshold: 0.5,
                    bpm: 0
                },
                pitchDetection: {
                    enabled: false,
                    frequency: 0,
                    note: ''
                },
                energyAnalysis: {
                    enabled: false,
                    low: 0,
                    mid: 0,
                    high: 0
                }
            };

            this.saveAAFeatures();
        }
    },

    /**
     * 保存音频分析特征
     */
    saveAAFeatures: function () {
        localStorage.setItem('aaFeatures', JSON.stringify(this.aaFeatures));
    },

    /**
     * 分析音频
     * @param {HTMLAudioElement|HTMLVideoElement} audio - 音频元素
     * @returns {Object} 分析结果
     */
    analyzeAudio: function (audio) {
        if (!this.aaConfig.enabled || !this.analyser) {
            return null;
        }

        const source = this.audioContext.createMediaElementSource(audio);
        source.connect(this.analyser);
        this.analyser.connect(this.audioContext.destination);

        const bufferLength = this.analyser.frequencyBinCount;
        const frequencyData = new Uint8Array(bufferLength);
        const timeDomainData = new Uint8Array(bufferLength);

        this.analyser.getByteFrequencyData(frequencyData);
        this.analyser.getByteTimeDomainData(timeDomainData);

        this.aaFeatures.frequencyData = Array.from(frequencyData);
        this.aaFeatures.timeDomainData = Array.from(timeDomainData);

        this.aaFeatures.spectrum = this.calculateSpectrum(frequencyData);
        this.aaFeatures.waveform = this.calculateWaveform(timeDomainData);

        if (this.aaFeatures.beatDetection.enabled) {
            this.detectBeat(frequencyData);
        }

        if (this.aaFeatures.pitchDetection.enabled) {
            this.detectPitch(frequencyData);
        }

        if (this.aaFeatures.energyAnalysis.enabled) {
            this.analyzeEnergy(frequencyData);
        }

        this.saveAAFeatures();

        this.saveAAHistory('audio_analyzed', {
            src: audio.src
        });

        return {
            spectrum: this.aaFeatures.spectrum,
            waveform: this.aaFeatures.waveform,
            frequencyData: this.aaFeatures.frequencyData,
            timeDomainData: this.aaFeatures.timeDomainData,
            beatDetection: this.aaFeatures.beatDetection,
            pitchDetection: this.aaFeatures.pitchDetection,
            energyAnalysis: this.aaFeatures.energyAnalysis
        };
    },

    /**
     * 计算频谱
     * @param {Uint8Array} frequencyData - 频率数据
     * @returns {Array} 频谱数组
     */
    calculateSpectrum: function (frequencyData) {
        const spectrum = [];

        for (let i = 0; i < frequencyData.length; i++) {
            spectrum.push({
                frequency: i * this.audioContext.sampleRate / this.analyser.fftSize,
                amplitude: frequencyData[i] / 255
            });
        }

        return spectrum;
    },

    /**
     * 计算波形
     * @param {Uint8Array} timeDomainData - 时域数据
     * @returns {Array} 波形数组
     */
    calculateWaveform: function (timeDomainData) {
        const waveform = [];

        for (let i = 0; i < timeDomainData.length; i++) {
            waveform.push({
                time: i / this.audioContext.sampleRate,
                amplitude: (timeDomainData[i] - 128) / 128
            });
        }

        return waveform;
    },

    /**
     * 检测节拍
     * @param {Uint8Array} frequencyData - 频率数据
     */
    detectBeat: function (frequencyData) {
        const lowFrequencies = frequencyData.slice(0, Math.floor(frequencyData.length * 0.1));
        const average = lowFrequencies.reduce((sum, value) => sum + value, 0) / lowFrequencies.length;

        if (average > this.aaFeatures.beatDetection.threshold * 255) {
            this.aaFeatures.beatDetection.bpm = this.calculateBPM(frequencyData);
        }
    },

    /**
     * 计算BPM
     * @param {Uint8Array} frequencyData - 频率数据
     * @returns {number} BPM值
     */
    calculateBPM: function (frequencyData) {
        const energy = frequencyData.reduce((sum, value) => sum + value, 0);
        const average = energy / frequencyData.length;

        // 简化的BPM计算
        return Math.round(60 + average * 0.5);
    },

    /**
     * 检测音高
     * @param {Uint8Array} frequencyData - 频率数据
     */
    detectPitch: function (frequencyData) {
        let maxAmplitude = 0;
        let maxFrequency = 0;

        for (let i = 0; i < frequencyData.length; i++) {
            if (frequencyData[i] > maxAmplitude) {
                maxAmplitude = frequencyData[i];
                maxFrequency = i * this.audioContext.sampleRate / this.analyser.fftSize;
            }
        }

        this.aaFeatures.pitchDetection.frequency = maxFrequency;
        this.aaFeatures.pitchDetection.note = this.frequencyToNote(maxFrequency);
    },

    /**
     * 频率转音符
     * @param {number} frequency - 频率
     * @returns {string} 音符
     */
    frequencyToNote: function (frequency) {
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const noteNumber = 12 * (Math.log2(frequency / 440)) + 69;
        const noteIndex = Math.round(noteNumber) % 12;

        return notes[noteIndex];
    },

    /**
     * 分析能量
     * @param {Uint8Array} frequencyData - 频率数据
     */
    analyzeEnergy: function (frequencyData) {
        const lowEnd = Math.floor(frequencyData.length * 0.1);
        const midEnd = Math.floor(frequencyData.length * 0.5);

        const lowEnergy = frequencyData.slice(0, lowEnd).reduce((sum, value) => sum + value, 0) / lowEnd;
        const midEnergy = frequencyData.slice(lowEnd, midEnd).reduce((sum, value) => sum + value, 0) / (midEnd - lowEnd);
        const highEnergy = frequencyData.slice(midEnd).reduce((sum, value) => sum + value, 0) / (frequencyData.length - midEnd);

        this.aaFeatures.energyAnalysis.low = lowEnergy / 255;
        this.aaFeatures.energyAnalysis.mid = midEnergy / 255;
        this.aaFeatures.energyAnalysis.high = highEnergy / 255;
    },

    /**
     * 获取频谱数据
     * @returns {Array} 频谱数据
     */
    getSpectrumData: function () {
        if (!this.analyser) {
            return [];
        }

        const bufferLength = this.analyser.frequencyBinCount;
        const frequencyData = new Uint8Array(bufferLength);

        this.analyser.getByteFrequencyData(frequencyData);

        return Array.from(frequencyData);
    },

    /**
     * 获取时域数据
     * @returns {Array} 时域数据
     */
    getTimeDomainData: function () {
        if (!this.analyser) {
            return [];
        }

        const bufferLength = this.analyser.frequencyBinCount;
        const timeDomainData = new Uint8Array(bufferLength);

        this.analyser.getByteTimeDomainData(timeDomainData);

        return Array.from(timeDomainData);
    },

    /**
     * 获取音量
     * @returns {number} 音量值
     */
    getVolume: function () {
        const frequencyData = this.getSpectrumData();
        const energy = frequencyData.reduce((sum, value) => sum + value, 0);

        return energy / (frequencyData.length * 255);
    },

    /**
     * 启用节拍检测
     * @param {number} threshold - 阈值
     */
    enableBeatDetection: function (threshold) {
        this.aaFeatures.beatDetection.enabled = true;
        this.aaFeatures.beatDetection.threshold = threshold || 0.5;
        this.saveAAFeatures();
    },

    /**
     * 禁用节拍检测
     */
    disableBeatDetection: function () {
        this.aaFeatures.beatDetection.enabled = false;
        this.saveAAFeatures();
    },

    /**
     * 启用音高检测
     */
    enablePitchDetection: function () {
        this.aaFeatures.pitchDetection.enabled = true;
        this.saveAAFeatures();
    },

    /**
     * 禁用音高检测
     */
    disablePitchDetection: function () {
        this.aaFeatures.pitchDetection.enabled = false;
        this.saveAAFeatures();
    },

    /**
     * 启用能量分析
     */
    enableEnergyAnalysis: function () {
        this.aaFeatures.energyAnalysis.enabled = true;
        this.saveAAFeatures();
    },

    /**
     * 禁用能量分析
     */
    disableEnergyAnalysis: function () {
        this.aaFeatures.energyAnalysis.enabled = false;
        this.saveAAFeatures();
    },

    /**
     * 设置FFT大小
     * @param {number} fftSize - FFT大小
     */
    setFFTSize: function (fftSize) {
        this.aaConfig.fftSize = fftSize;

        if (this.analyser) {
            this.analyser.fftSize = fftSize;
        }

        this.saveAAConfig();
    },

    /**
     * 设置平滑时间常数
     * @param {number} smoothingTimeConstant - 平滑时间常数
     */
    setSmoothingTimeConstant: function (smoothingTimeConstant) {
        this.aaConfig.smoothingTimeConstant = smoothingTimeConstant;

        if (this.analyser) {
            this.analyser.smoothingTimeConstant = smoothingTimeConstant;
        }

        this.saveAAConfig();
    },

    /**
     * 获取音频分析特征
     * @param {string} featureName - 特征名称
     * @returns {Object} 特征对象
     */
    getAAFeature: function (featureName) {
        return this.aaFeatures[featureName] || null;
    },

    /**
     * 获取所有音频分析特征
     * @returns {Object} 所有特征
     */
    getAllAAFeatures: function () {
        return this.aaFeatures;
    },

    /**
     * 保存音频分析历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveAAHistory: function (action, data) {
        this.aaHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.aaHistory.length > this.maxHistorySize) {
            this.aaHistory.shift();
        }
    },

    /**
     * 获取音频分析历史
     * @param {Object} options - 查询选项
     * @returns {Array} 音频分析历史
     */
    getAAHistory: function (options) {
        let history = [...this.aaHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置音频分析配置
     * @param {Object} config - 配置对象
     */
    setAAConfig: function (config) {
        this.aaConfig = { ...this.aaConfig, ...config };
        this.saveAAConfig();
    },

    /**
     * 获取音频分析配置
     * @returns {Object} 配置对象
     */
    getAAConfig: function () {
        return this.aaConfig;
    },

    /**
     * 重置音频分析系统
     */
    reset: function () {
        this.aaHistory = [];
        this.loadAAConfig();
        this.loadAAFeatures();
        this.initAudioContext();
    },

    /**
     * 获取音频分析统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.aaConfig.enabled,
            fftSize: this.aaConfig.fftSize,
            smoothingTimeConstant: this.aaConfig.smoothingTimeConstant,
            minDecibels: this.aaConfig.minDecibels,
            maxDecibels: this.aaConfig.maxDecibels,
            analysisInterval: this.aaConfig.analysisInterval,
            beatDetectionEnabled: this.aaFeatures.beatDetection.enabled,
            pitchDetectionEnabled: this.aaFeatures.pitchDetection.enabled,
            energyAnalysisEnabled: this.aaFeatures.energyAnalysis.enabled,
            totalHistory: this.aaHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏传感器融合优化
const GameSensorFusionOptimizer = {
    sfConfig: {},
    sfSensors: {},
    sfHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏传感器融合
     */
    init: function () {
        this.loadSFConfig();
        this.loadSFSensors();
        this.initSensors();
    },

    /**
     * 初始化传感器
     */
    initSensors: function () {
        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', this.handleDeviceOrientation.bind(this));
        }

        if (window.DeviceMotionEvent) {
            window.addEventListener('devicemotion', this.handleDeviceMotion.bind(this));
        }

        if (window.DeviceOrientationEvent && 'requestPermission' in DeviceOrientationEvent) {
            DeviceOrientationEvent.requestPermission()
                .then(response => {
                    if (response === 'granted') {
                        console.log('设备方向权限已授予');
                    }
                })
                .catch(console.error);
        }
    },

    /**
     * 处理设备方向
     * @param {DeviceOrientationEvent} event - 设备方向事件
     */
    handleDeviceOrientation: function (event) {
        this.sfSensors.orientation = {
            alpha: event.alpha,
            beta: event.beta,
            gamma: event.gamma,
            absolute: event.absolute,
            timestamp: Date.now()
        };

        this.saveSFSensors();
        this.saveSFHistory('orientation_updated', this.sfSensors.orientation);
    },

    /**
     * 处理设备运动
     * @param {DeviceMotionEvent} event - 设备运动事件
     */
    handleDeviceMotion: function (event) {
        this.sfSensors.acceleration = {
            x: event.acceleration.x,
            y: event.acceleration.y,
            z: event.acceleration.z,
            timestamp: Date.now()
        };

        this.sfSensors.accelerationIncludingGravity = {
            x: event.accelerationIncludingGravity.x,
            y: event.accelerationIncludingGravity.y,
            z: event.accelerationIncludingGravity.z,
            timestamp: Date.now()
        };

        this.sfSensors.rotationRate = {
            alpha: event.rotationRate.alpha,
            beta: event.rotationRate.beta,
            gamma: event.rotationRate.gamma,
            timestamp: Date.now()
        };

        this.saveSFSensors();
        this.saveSFHistory('motion_updated', {
            acceleration: this.sfSensors.acceleration,
            accelerationIncludingGravity: this.sfSensors.accelerationIncludingGravity,
            rotationRate: this.sfSensors.rotationRate
        });
    },

    /**
     * 加载传感器融合配置
     */
    loadSFConfig: function () {
        this.sfConfig = {
            enabled: true,
            maxHistorySize: 1000,
            fusionAlgorithm: 'kalman',
            updateInterval: 16,
            smoothingFactor: 0.8
        };

        const customConfig = localStorage.getItem('sfConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.sfConfig = { ...this.sfConfig, ...config };
            } catch (error) {
                console.error('加载传感器融合配置失败:', error);
            }
        }
    },

    /**
     * 保存传感器融合配置
     */
    saveSFConfig: function () {
        localStorage.setItem('sfConfig', JSON.stringify(this.sfConfig));
    },

    /**
     * 加载传感器数据
     */
    loadSFSensors: function () {
        const savedSensors = localStorage.getItem('sfSensors');
        if (savedSensors) {
            try {
                this.sfSensors = JSON.parse(savedSensors);
            } catch (error) {
                console.error('加载传感器数据失败:', error);
            }
        }

        if (!this.sfSensors.orientation) {
            this.sfSensors = {
                orientation: null,
                acceleration: null,
                accelerationIncludingGravity: null,
                rotationRate: null,
                magnetometer: null,
                proximity: null,
                light: null,
                gyroscope: null,
                fusionData: {
                    position: { x: 0, y: 0, z: 0 },
                    velocity: { x: 0, y: 0, z: 0 },
                    rotation: { x: 0, y: 0, z: 0 }
                }
            };

            this.saveSFSensors();
        }
    },

    /**
     * 保存传感器数据
     */
    saveSFSensors: function () {
        localStorage.setItem('sfSensors', JSON.stringify(this.sfSensors));
    },

    /**
     * 融合传感器数据
     * @returns {Object} 融合后的数据
     */
    fuseSensorData: function () {
        if (!this.sfConfig.enabled) {
            return null;
        }

        const fusionData = this.sfSensors.fusionData;

        // 使用加速度计更新位置和速度
        if (this.sfSensors.acceleration) {
            const acc = this.sfSensors.acceleration;
            const dt = this.sfConfig.updateInterval / 1000;

            fusionData.velocity.x += acc.x * dt;
            fusionData.velocity.y += acc.y * dt;
            fusionData.velocity.z += acc.z * dt;

            fusionData.position.x += fusionData.velocity.x * dt;
            fusionData.position.y += fusionData.velocity.y * dt;
            fusionData.position.z += fusionData.velocity.z * dt;
        }

        // 使用陀螺仪更新旋转
        if (this.sfSensors.rotationRate) {
            const rot = this.sfSensors.rotationRate;
            const dt = this.sfConfig.updateInterval / 1000;

            fusionData.rotation.x += rot.alpha * dt;
            fusionData.rotation.y += rot.beta * dt;
            fusionData.rotation.z += rot.gamma * dt;
        }

        // 应用平滑因子
        const smoothingFactor = this.sfConfig.smoothingFactor;
        fusionData.position.x *= smoothingFactor;
        fusionData.position.y *= smoothingFactor;
        fusionData.position.z *= smoothingFactor;
        fusionData.velocity.x *= smoothingFactor;
        fusionData.velocity.y *= smoothingFactor;
        fusionData.velocity.z *= smoothingFactor;

        this.saveSFSensors();

        this.saveSFHistory('sensor_fused', fusionData);

        return fusionData;
    },

    /**
     * 卡尔曼滤波
     * @param {Array} measurements - 测量值
     * @param {number} processNoise - 过程噪声
     * @param {number} measurementNoise - 测量噪声
     * @returns {Array} 滤波后的值
     */
    kalmanFilter: function (measurements, processNoise, measurementNoise) {
        let x = measurements[0];
        let P = 1;

        const filtered = [];

        for (let i = 0; i < measurements.length; i++) {
            const z = measurements[i];

            const K = P / (P + measurementNoise);
            x = x + K * (z - x);
            P = (1 - K) * P + processNoise;

            filtered.push(x);
        }

        return filtered;
    },

    /**
     * 互补滤波
     * @param {number} accelerometerValue - 加速度计值
     * @param {number} gyroscopeValue - 陀螺仪值
     * @param {number} alpha - 滤波系数
     * @returns {number} 滤波后的值
     */
    complementaryFilter: function (accelerometerValue, gyroscopeValue, alpha) {
        return alpha * accelerometerValue + (1 - alpha) * gyroscopeValue;
    },

    /**
     * 获取设备方向
     * @returns {Object} 设备方向
     */
    getOrientation: function () {
        return this.sfSensors.orientation;
    },

    /**
     * 获取加速度
     * @returns {Object} 加速度
     */
    getAcceleration: function () {
        return this.sfSensors.acceleration;
    },

    /**
     * 获取包含重力的加速度
     * @returns {Object} 包含重力的加速度
     */
    getAccelerationIncludingGravity: function () {
        return this.sfSensors.accelerationIncludingGravity;
    },

    /**
     * 获取旋转速率
     * @returns {Object} 旋转速率
     */
    getRotationRate: function () {
        return this.sfSensors.rotationRate;
    },

    /**
     * 获取融合数据
     * @returns {Object} 融合数据
     */
    getFusionData: function () {
        return this.sfSensors.fusionData;
    },

    /**
     * 获取位置
     * @returns {Object} 位置
     */
    getPosition: function () {
        return this.sfSensors.fusionData.position;
    },

    /**
     * 获取速度
     * @returns {Object} 速度
     */
    getVelocity: function () {
        return this.sfSensors.fusionData.velocity;
    },

    /**
     * 获取旋转
     * @returns {Object} 旋转
     */
    getRotation: function () {
        return this.sfSensors.fusionData.rotation;
    },

    /**
     * 重置位置
     */
    resetPosition: function () {
        this.sfSensors.fusionData.position = { x: 0, y: 0, z: 0 };
        this.sfSensors.fusionData.velocity = { x: 0, y: 0, z: 0 };
        this.saveSFSensors();
    },

    /**
     * 重置旋转
     */
    resetRotation: function () {
        this.sfSensors.fusionData.rotation = { x: 0, y: 0, z: 0 };
        this.saveSFSensors();
    },

    /**
     * 设置融合算法
     * @param {string} algorithm - 算法名称
     */
    setFusionAlgorithm: function (algorithm) {
        this.sfConfig.fusionAlgorithm = algorithm;
        this.saveSFConfig();
    },

    /**
     * 设置更新间隔
     * @param {number} interval - 间隔（毫秒）
     */
    setUpdateInterval: function (interval) {
        this.sfConfig.updateInterval = interval;
        this.saveSFConfig();
    },

    /**
     * 设置平滑因子
     * @param {number} factor - 平滑因子
     */
    setSmoothingFactor: function (factor) {
        this.sfConfig.smoothingFactor = factor;
        this.saveSFConfig();
    },

    /**
     * 保存传感器融合历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveSFHistory: function (action, data) {
        this.sfHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.sfHistory.length > this.maxHistorySize) {
            this.sfHistory.shift();
        }
    },

    /**
     * 获取传感器融合历史
     * @param {Object} options - 查询选项
     * @returns {Array} 传感器融合历史
     */
    getSFHistory: function (options) {
        let history = [...this.sfHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置传感器融合配置
     * @param {Object} config - 配置对象
     */
    setSFConfig: function (config) {
        this.sfConfig = { ...this.sfConfig, ...config };
        this.saveSFConfig();
    },

    /**
     * 获取传感器融合配置
     * @returns {Object} 配置对象
     */
    getSFConfig: function () {
        return this.sfConfig;
    },

    /**
     * 重置传感器融合系统
     */
    reset: function () {
        this.sfHistory = [];
        this.loadSFConfig();
        this.loadSFSensors();
    },

    /**
     * 获取传感器融合统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.sfConfig.enabled,
            fusionAlgorithm: this.sfConfig.fusionAlgorithm,
            updateInterval: this.sfConfig.updateInterval,
            smoothingFactor: this.sfConfig.smoothingFactor,
            hasOrientation: !!this.sfSensors.orientation,
            hasAcceleration: !!this.sfSensors.acceleration,
            hasRotationRate: !!this.sfSensors.rotationRate,
            totalHistory: this.sfHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏物联网优化
const GameIoTOptimizer = {
    iotConfig: {},
    iotDevices: {},
    iotHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏物联网
     */
    init: function () {
        this.loadIoTConfig();
        this.loadIoTDevices();
        this.initBluetooth();
        this.initWebSocket();
    },

    /**
     * 加载物联网配置
     */
    loadIoTConfig: function () {
        this.iotConfig = {
            enabled: true,
            maxHistorySize: 1000,
            autoConnect: true,
            maxRetries: 3,
            retryInterval: 1000,
            dataCompression: true
        };

        const customConfig = localStorage.getItem('iotConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.iotConfig = { ...this.iotConfig, ...config };
            } catch (error) {
                console.error('加载物联网配置失败:', error);
            }
        }
    },

    /**
     * 保存物联网配置
     */
    saveIoTConfig: function () {
        localStorage.setItem('iotConfig', JSON.stringify(this.iotConfig));
    },

    /**
     * 加载物联网设备
     */
    loadIoTDevices: function () {
        const savedDevices = localStorage.getItem('iotDevices');
        if (savedDevices) {
            try {
                this.iotDevices = JSON.parse(savedDevices);
            } catch (error) {
                console.error('加载物联网设备失败:', error);
            }
        }

        if (!this.iotDevices.bluetooth) {
            this.iotDevices = {
                bluetooth: {
                    enabled: false,
                    connected: false,
                    device: null,
                    server: null,
                    characteristics: {}
                },
                websocket: {
                    enabled: false,
                    connected: false,
                    url: '',
                    socket: null
                },
                mqtt: {
                    enabled: false,
                    connected: false,
                    broker: '',
                    clientId: '',
                    topics: {}
                },
                http: {
                    enabled: false,
                    endpoints: []
                }
            };

            this.saveIoTDevices();
        }
    },

    /**
     * 保存物联网设备
     */
    saveIoTDevices: function () {
        localStorage.setItem('iotDevices', JSON.stringify(this.iotDevices));
    },

    /**
     * 初始化蓝牙
     */
    initBluetooth: function () {
        if (!('bluetooth' in navigator)) {
            console.log('浏览器不支持Web Bluetooth API');
            return;
        }

        if (this.iotConfig.autoConnect && this.iotDevices.bluetooth.enabled) {
            this.connectBluetooth();
        }
    },

    /**
     * 连接蓝牙设备
     * @param {Object} options - 选项对象
     * @returns {Promise<Object>} 连接结果
     */
    connectBluetooth: function (options) {
        return new Promise((resolve, reject) => {
            if (!this.iotConfig.enabled) {
                reject({
                    success: false,
                    error: '物联网已禁用'
                });
                return;
            }

            if (!('bluetooth' in navigator)) {
                reject({
                    success: false,
                    error: '浏览器不支持Web Bluetooth API'
                });
                return;
            }

            const serviceUUID = options.serviceUUID || '0000180d-0000-1000-8000-00805f9b34fb';
            const characteristicUUID = options.characteristicUUID || '00002a37-0000-1000-8000-00805f9b34fb';

            navigator.bluetooth.requestDevice({
                filters: [{ services: [serviceUUID] }],
                optionalServices: [serviceUUID]
            })
                .then(device => {
                    this.iotDevices.bluetooth.device = device;

                    return device.gatt.connect();
                })
                .then(server => {
                    this.iotDevices.bluetooth.server = server;
                    this.iotDevices.bluetooth.connected = true;

                    return server.getPrimaryService(serviceUUID);
                })
                .then(service => {
                    return service.getCharacteristic(characteristicUUID);
                })
                .then(characteristic => {
                    this.iotDevices.bluetooth.characteristics[characteristicUUID] = characteristic;

                    characteristic.startNotifications();
                    characteristic.addEventListener('characteristicvaluechanged', this.handleBluetoothData.bind(this));

                    this.saveIoTDevices();

                    this.saveIoTHistory('bluetooth_connected', {
                        deviceName: this.iotDevices.bluetooth.device.name
                    });

                    resolve({
                        success: true,
                        device: this.iotDevices.bluetooth.device
                    });
                })
                .catch(error => {
                    reject({
                        success: false,
                        error: error.message
                    });
                });
        });
    },

    /**
     * 处理蓝牙数据
     * @param {Event} event - 事件对象
     */
    handleBluetoothData: function (event) {
        const value = event.target.value;
        const data = new Uint8Array(value.buffer);

        this.saveIoTHistory('bluetooth_data_received', {
            data: Array.from(data)
        });

        // 发送消息到游戏
        if (window.GameMessageBus) {
            GameMessageBus.publish('iot.bluetooth.data', {
                data: data
            });
        }
    },

    /**
     * 发送蓝牙数据
     * @param {string} characteristicUUID - 特征UUID
     * @param {ArrayBuffer} data - 数据
     * @returns {Promise<Object>} 发送结果
     */
    sendBluetoothData: function (characteristicUUID, data) {
        return new Promise((resolve, reject) => {
            const characteristic = this.iotDevices.bluetooth.characteristics[characteristicUUID];

            if (!characteristic) {
                reject({
                    success: false,
                    error: '特征不存在'
                });
                return;
            }

            characteristic.writeValue(data)
                .then(() => {
                    this.saveIoTHistory('bluetooth_data_sent', {
                        characteristicUUID: characteristicUUID,
                        dataLength: data.byteLength
                    });

                    resolve({
                        success: true
                    });
                })
                .catch(error => {
                    reject({
                        success: false,
                        error: error.message
                    });
                });
        });
    },

    /**
     * 断开蓝牙连接
     */
    disconnectBluetooth: function () {
        if (this.iotDevices.bluetooth.device && this.iotDevices.bluetooth.device.gatt.connected) {
            this.iotDevices.bluetooth.device.gatt.disconnect();
            this.iotDevices.bluetooth.connected = false;
            this.saveIoTDevices();

            this.saveIoTHistory('bluetooth_disconnected', {});
        }
    },

    /**
     * 初始化WebSocket
     */
    initWebSocket: function () {
        if (this.iotConfig.autoConnect && this.iotDevices.websocket.enabled && this.iotDevices.websocket.url) {
            this.connectWebSocket();
        }
    },

    /**
     * 连接WebSocket
     * @param {string} url - WebSocket URL
     * @returns {Promise<Object>} 连接结果
     */
    connectWebSocket: function (url) {
        return new Promise((resolve, reject) => {
            if (!this.iotConfig.enabled) {
                reject({
                    success: false,
                    error: '物联网已禁用'
                });
                return;
            }

            const wsUrl = url || this.iotDevices.websocket.url;

            if (!wsUrl) {
                reject({
                    success: false,
                    error: 'WebSocket URL未设置'
                });
                return;
            }

            const socket = new WebSocket(wsUrl);

            socket.onopen = () => {
                this.iotDevices.websocket.socket = socket;
                this.iotDevices.websocket.connected = true;
                this.iotDevices.websocket.url = wsUrl;

                this.saveIoTDevices();

                this.saveIoTHistory('websocket_connected', {
                    url: wsUrl
                });

                resolve({
                    success: true
                });
            };

            socket.onmessage = (event) => {
                this.handleWebSocketData(event.data);
            };

            socket.onclose = () => {
                this.iotDevices.websocket.connected = false;
                this.saveIoTDevices();

                this.saveIoTHistory('websocket_disconnected', {});
            };

            socket.onerror = (error) => {
                reject({
                    success: false,
                    error: 'WebSocket连接错误'
                });
            };
        });
    },

    /**
     * 处理WebSocket数据
     * @param {string} data - 数据
     */
    handleWebSocketData: function (data) {
        try {
            const parsedData = JSON.parse(data);

            this.saveIoTHistory('websocket_data_received', {
                data: parsedData
            });

            // 发送消息到游戏
            if (window.GameMessageBus) {
                GameMessageBus.publish('iot.websocket.data', {
                    data: parsedData
                });
            }
        } catch (error) {
            console.error('解析WebSocket数据失败:', error);
        }
    },

    /**
     * 发送WebSocket数据
     * @param {Object} data - 数据
     * @returns {Promise<Object>} 发送结果
     */
    sendWebSocketData: function (data) {
        return new Promise((resolve, reject) => {
            const socket = this.iotDevices.websocket.socket;

            if (!socket || socket.readyState !== WebSocket.OPEN) {
                reject({
                    success: false,
                    error: 'WebSocket未连接'
                });
                return;
            }

            try {
                const jsonData = JSON.stringify(data);

                socket.send(jsonData);

                this.saveIoTHistory('websocket_data_sent', {
                    data: data
                });

                resolve({
                    success: true
                });
            } catch (error) {
                reject({
                    success: false,
                    error: error.message
                });
            }
        });
    },

    /**
     * 断开WebSocket连接
     */
    disconnectWebSocket: function () {
        if (this.iotDevices.websocket.socket) {
            this.iotDevices.websocket.socket.close();
            this.iotDevices.websocket.connected = false;
            this.saveIoTDevices();

            this.saveIoTHistory('websocket_disconnected', {});
        }
    },

    /**
     * 添加HTTP端点
     * @param {string} name - 端点名称
     * @param {Object} endpoint - 端点对象
     */
    addHTTPEndpoint: function (name, endpoint) {
        this.iotDevices.http.endpoints.push({
            name: name,
            url: endpoint.url,
            method: endpoint.method || 'GET',
            headers: endpoint.headers || {},
            body: endpoint.body || null
        });

        this.saveIoTDevices();
    },

    /**
     * 发送HTTP请求
     * @param {string} name - 端点名称
     * @param {Object} data - 数据
     * @returns {Promise<Object>} 响应结果
     */
    sendHTTPRequest: function (name, data) {
        return new Promise((resolve, reject) => {
            const endpoint = this.iotDevices.http.endpoints.find(e => e.name === name);

            if (!endpoint) {
                reject({
                    success: false,
                    error: '端点不存在'
                });
                return;
            }

            const options = {
                method: endpoint.method,
                headers: endpoint.headers
            };

            if (endpoint.method !== 'GET' && data) {
                options.body = JSON.stringify(data);
            }

            fetch(endpoint.url, options)
                .then(response => response.json())
                .then(result => {
                    this.saveIoTHistory('http_request_sent', {
                        endpointName: name,
                        result: result
                    });

                    resolve({
                        success: true,
                        data: result
                    });
                })
                .catch(error => {
                    reject({
                        success: false,
                        error: error.message
                    });
                });
        });
    },

    /**
     * 设置蓝牙启用状态
     * @param {boolean} enabled - 是否启用
     */
    setBluetoothEnabled: function (enabled) {
        this.iotDevices.bluetooth.enabled = enabled;
        this.saveIoTDevices();
    },

    /**
     * 设置WebSocket启用状态
     * @param {boolean} enabled - 是否启用
     */
    setWebSocketEnabled: function (enabled) {
        this.iotDevices.websocket.enabled = enabled;
        this.saveIoTDevices();
    },

    /**
     * 设置WebSocket URL
     * @param {string} url - WebSocket URL
     */
    setWebSocketURL: function (url) {
        this.iotDevices.websocket.url = url;
        this.saveIoTDevices();
    },

    /**
     * 获取物联网设备
     * @param {string} deviceType - 设备类型
     * @returns {Object} 设备对象
     */
    getIoTDevice: function (deviceType) {
        return this.iotDevices[deviceType] || null;
    },

    /**
     * 获取所有物联网设备
     * @returns {Object} 所有设备
     */
    getAllIoTDevices: function () {
        return this.iotDevices;
    },

    /**
     * 保存物联网历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveIoTHistory: function (action, data) {
        this.iotHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.iotHistory.length > this.maxHistorySize) {
            this.iotHistory.shift();
        }
    },

    /**
     * 获取物联网历史
     * @param {Object} options - 查询选项
     * @returns {Array} 物联网历史
     */
    getIoTHistory: function (options) {
        let history = [...this.iotHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置物联网配置
     * @param {Object} config - 配置对象
     */
    setIoTConfig: function (config) {
        this.iotConfig = { ...this.iotConfig, ...config };
        this.saveIoTConfig();
    },

    /**
     * 获取物联网配置
     * @returns {Object} 配置对象
     */
    getIoTConfig: function () {
        return this.iotConfig;
    },

    /**
     * 重置物联网系统
     */
    reset: function () {
        this.iotHistory = [];
        this.disconnectBluetooth();
        this.disconnectWebSocket();
        this.loadIoTConfig();
        this.loadIoTDevices();
    },

    /**
     * 获取物联网统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.iotConfig.enabled,
            autoConnect: this.iotConfig.autoConnect,
            bluetoothEnabled: this.iotDevices.bluetooth.enabled,
            bluetoothConnected: this.iotDevices.bluetooth.connected,
            websocketEnabled: this.iotDevices.websocket.enabled,
            websocketConnected: this.iotDevices.websocket.connected,
            totalHTTPEndpoints: this.iotDevices.http.endpoints.length,
            totalHistory: this.iotHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏边缘计算优化
const GameEdgeComputingOptimizer = {
    ecConfig: {},
    ecTasks: {},
    ecWorkers: {},
    ecHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏边缘计算
     */
    init: function () {
        this.loadECConfig();
        this.loadECTasks();
        this.initWorkers();
    },

    /**
     * 加载边缘计算配置
     */
    loadECConfig: function () {
        this.ecConfig = {
            enabled: true,
            maxHistorySize: 1000,
            maxWorkers: 4,
            taskTimeout: 30000,
            autoCleanup: true,
            cleanupInterval: 60000,
            cacheEnabled: true,
            maxCacheSize: 100
        };

        const customConfig = localStorage.getItem('ecConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.ecConfig = { ...this.ecConfig, ...config };
            } catch (error) {
                console.error('加载边缘计算配置失败:', error);
            }
        }
    },

    /**
     * 保存边缘计算配置
     */
    saveECConfig: function () {
        localStorage.setItem('ecConfig', JSON.stringify(this.ecConfig));
    },

    /**
     * 加载边缘计算任务
     */
    loadECTasks: function () {
        const savedTasks = localStorage.getItem('ecTasks');
        if (savedTasks) {
            try {
                this.ecTasks = JSON.parse(savedTasks);
            } catch (error) {
                console.error('加载边缘计算任务失败:', error);
            }
        }

        if (!this.ecTasks.pending) {
            this.ecTasks = {
                pending: {},
                running: {},
                completed: {},
                failed: {},
                cache: {}
            };

            this.saveECTasks();
        }
    },

    /**
     * 保存边缘计算任务
     */
    saveECTasks: function () {
        localStorage.setItem('ecTasks', JSON.stringify(this.ecTasks));
    },

    /**
     * 初始化Worker
     */
    initWorkers: function () {
        for (let i = 0; i < this.ecConfig.maxWorkers; i++) {
            this.createWorker(i);
        }
    },

    /**
     * 创建Worker
     * @param {number} id - Worker ID
     */
    createWorker: function (id) {
        if (!('Worker' in window)) {
            console.log('浏览器不支持Web Worker API');
            return;
        }

        const workerCode = `
            self.onmessage = function(e) {
                const { taskId, taskType, data } = e.data;
                
                try {
                    let result;
                    
                    switch (taskType) {
                        case 'calculate':
                            result = calculate(data);
                            break;
                        case 'process':
                            result = process(data);
                            break;
                        case 'analyze':
                            result = analyze(data);
                            break;
                        case 'transform':
                            result = transform(data);
                            break;
                        default:
                            throw new Error('未知任务类型: ' + taskType);
                    }
                    
                    self.postMessage({
                        taskId: taskId,
                        success: true,
                        result: result
                    });
                } catch (error) {
                    self.postMessage({
                        taskId: taskId,
                        success: false,
                        error: error.message
                    });
                }
            };
            
            function calculate(data) {
                const { expression } = data;
                return eval(expression);
            }
            
            function process(data) {
                const { items, processor } = data;
                return items.map(item => {
                    return processor(item);
                });
            }
            
            function analyze(data) {
                const { values } = data;
                
                const sum = values.reduce((a, b) => a + b, 0);
                const avg = sum / values.length;
                const min = Math.min(...values);
                const max = Math.max(...values);
                
                return {
                    sum: sum,
                    avg: avg,
                    min: min,
                    max: max,
                    count: values.length
                };
            }
            
            function transform(data) {
                const { input, transformer } = data;
                return transformer(input);
            }
        `;

        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(blob);

        const worker = new Worker(workerUrl);

        worker.onmessage = this.handleWorkerMessage.bind(this);
        worker.onerror = this.handleWorkerError.bind(this);

        this.ecWorkers[id] = {
            worker: worker,
            busy: false,
            currentTask: null
        };
    },

    /**
     * 处理Worker消息
     * @param {MessageEvent} event - 消息事件
     */
    handleWorkerMessage: function (event) {
        const { taskId, success, result, error } = event.data;

        if (success) {
            this.completeTask(taskId, result);
        } else {
            this.failTask(taskId, error);
        }

        // 释放Worker
        const workerId = this.findWorkerByTask(taskId);
        if (workerId !== -1) {
            this.ecWorkers[workerId].busy = false;
            this.ecWorkers[workerId].currentTask = null;
        }
    },

    /**
     * 处理Worker错误
     * @param {ErrorEvent} event - 错误事件
     */
    handleWorkerError: function (event) {
        console.error('Worker错误:', event.error);
    },

    /**
     * 查找执行任务的Worker
     * @param {string} taskId - 任务ID
     * @returns {number} Worker ID
     */
    findWorkerByTask: function (taskId) {
        for (const id in this.ecWorkers) {
            if (this.ecWorkers[id].currentTask === taskId) {
                return parseInt(id);
            }
        }

        return -1;
    },

    /**
     * 提交任务
     * @param {string} taskType - 任务类型
     * @param {Object} data - 任务数据
     * @returns {Promise<Object>} 任务结果
     */
    submitTask: function (taskType, data) {
        return new Promise((resolve, reject) => {
            if (!this.ecConfig.enabled) {
                reject({
                    success: false,
                    error: '边缘计算已禁用'
                });
                return;
            }

            const taskId = this.generateTaskId();

            // 检查缓存
            if (this.ecConfig.cacheEnabled) {
                const cacheKey = this.generateCacheKey(taskType, data);
                const cachedResult = this.ecTasks.cache[cacheKey];

                if (cachedResult) {
                    this.saveECHistory('task_cache_hit', {
                        taskId: taskId,
                        taskType: taskType
                    });

                    resolve({
                        success: true,
                        result: cachedResult,
                        cached: true
                    });

                    return;
                }
            }

            // 查找空闲Worker
            const workerId = this.findIdleWorker();

            if (workerId === -1) {
                reject({
                    success: false,
                    error: '没有可用的Worker'
                });
                return;
            }

            // 创建任务
            const task = {
                id: taskId,
                type: taskType,
                data: data,
                status: 'pending',
                createdAt: Date.now(),
                resolve: resolve,
                reject: reject
            };

            this.ecTasks.pending[taskId] = task;
            this.saveECTasks();

            // 分配任务给Worker
            this.ecWorkers[workerId].busy = true;
            this.ecWorkers[workerId].currentTask = taskId;

            this.ecTasks.running[taskId] = task;
            delete this.ecTasks.pending[taskId];
            task.status = 'running';
            this.saveECTasks();

            // 发送任务到Worker
            this.ecWorkers[workerId].worker.postMessage({
                taskId: taskId,
                taskType: taskType,
                data: data
            });

            // 设置超时
            setTimeout(() => {
                if (this.ecTasks.running[taskId]) {
                    this.failTask(taskId, '任务超时');
                }
            }, this.ecConfig.taskTimeout);
        });
    },

    /**
     * 完成任务
     * @param {string} taskId - 任务ID
     * @param {Object} result - 任务结果
     */
    completeTask: function (taskId, result) {
        const task = this.ecTasks.running[taskId];

        if (!task) {
            return;
        }

        task.status = 'completed';
        task.completedAt = Date.now();
        task.result = result;

        this.ecTasks.completed[taskId] = task;
        delete this.ecTasks.running[taskId];
        this.saveECTasks();

        // 缓存结果
        if (this.ecConfig.cacheEnabled) {
            const cacheKey = this.generateCacheKey(task.type, task.data);

            if (Object.keys(this.ecTasks.cache).length >= this.ecConfig.maxCacheSize) {
                this.clearOldestCache();
            }

            this.ecTasks.cache[cacheKey] = result;
            this.saveECTasks();
        }

        this.saveECHistory('task_completed', {
            taskId: taskId,
            taskType: task.type
        });

        // 解析Promise
        task.resolve({
            success: true,
            result: result,
            cached: false
        });
    },

    /**
     * 失败任务
     * @param {string} taskId - 任务ID
     * @param {string} error - 错误信息
     */
    failTask: function (taskId, error) {
        const task = this.ecTasks.running[taskId] || this.ecTasks.pending[taskId];

        if (!task) {
            return;
        }

        task.status = 'failed';
        task.failedAt = Date.now();
        task.error = error;

        this.ecTasks.failed[taskId] = task;
        delete this.ecTasks.running[taskId];
        delete this.ecTasks.pending[taskId];
        this.saveECTasks();

        this.saveECHistory('task_failed', {
            taskId: taskId,
            taskType: task.type,
            error: error
        });

        // 拒绝Promise
        task.reject({
            success: false,
            error: error
        });
    },

    /**
     * 查找空闲Worker
     * @returns {number} Worker ID
     */
    findIdleWorker: function () {
        for (const id in this.ecWorkers) {
            if (!this.ecWorkers[id].busy) {
                return parseInt(id);
            }
        }

        return -1;
    },

    /**
     * 生成任务ID
     * @returns {string} 任务ID
     */
    generateTaskId: function () {
        return 'task_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    },

    /**
     * 生成缓存键
     * @param {string} taskType - 任务类型
     * @param {Object} data - 任务数据
     * @returns {string} 缓存键
     */
    generateCacheKey: function (taskType, data) {
        return taskType + '_' + JSON.stringify(data);
    },

    /**
     * 清除最旧的缓存
     */
    clearOldestCache: function () {
        let oldestKey = null;
        let oldestTime = Infinity;

        for (const key in this.ecTasks.cache) {
            const task = this.ecTasks.completed[key];

            if (task && task.completedAt < oldestTime) {
                oldestTime = task.completedAt;
                oldestKey = key;
            }
        }

        if (oldestKey) {
            delete this.ecTasks.cache[oldestKey];
        }
    },

    /**
     * 清理缓存
     */
    clearCache: function () {
        this.ecTasks.cache = {};
        this.saveECTasks();
    },

    /**
     * 获取任务状态
     * @param {string} taskId - 任务ID
     * @returns {Object} 任务状态
     */
    getTaskStatus: function (taskId) {
        const task = this.ecTasks.pending[taskId] ||
            this.ecTasks.running[taskId] ||
            this.ecTasks.completed[taskId] ||
            this.ecTasks.failed[taskId];

        if (!task) {
            return null;
        }

        return {
            id: task.id,
            type: task.type,
            status: task.status,
            createdAt: task.createdAt,
            completedAt: task.completedAt,
            failedAt: task.failedAt,
            result: task.result,
            error: task.error
        };
    },

    /**
     * 获取所有任务
     * @param {string} status - 任务状态
     * @returns {Array} 任务列表
     */
    getAllTasks: function (status) {
        let tasks = [];

        if (status) {
            tasks = Object.values(this.ecTasks[status] || {});
        } else {
            tasks = [
                ...Object.values(this.ecTasks.pending),
                ...Object.values(this.ecTasks.running),
                ...Object.values(this.ecTasks.completed),
                ...Object.values(this.ecTasks.failed)
            ];
        }

        return tasks;
    },

    /**
     * 取消任务
     * @param {string} taskId - 任务ID
     * @returns {boolean} 是否成功
     */
    cancelTask: function (taskId) {
        const task = this.ecTasks.pending[taskId] || this.ecTasks.running[taskId];

        if (!task) {
            return false;
        }

        // 释放Worker
        const workerId = this.findWorkerByTask(taskId);
        if (workerId !== -1) {
            this.ecWorkers[workerId].busy = false;
            this.ecWorkers[workerId].currentTask = null;
        }

        this.failTask(taskId, '任务已取消');

        return true;
    },

    /**
     * 保存边缘计算历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveECHistory: function (action, data) {
        this.ecHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.ecHistory.length > this.maxHistorySize) {
            this.ecHistory.shift();
        }
    },

    /**
     * 获取边缘计算历史
     * @param {Object} options - 查询选项
     * @returns {Array} 边缘计算历史
     */
    getECHistory: function (options) {
        let history = [...this.ecHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置边缘计算配置
     * @param {Object} config - 配置对象
     */
    setECConfig: function (config) {
        this.ecConfig = { ...this.ecConfig, ...config };
        this.saveECConfig();
    },

    /**
     * 获取边缘计算配置
     * @returns {Object} 配置对象
     */
    getECConfig: function () {
        return this.ecConfig;
    },

    /**
     * 重置边缘计算系统
     */
    reset: function () {
        this.ecHistory = [];
        this.loadECConfig();
        this.loadECTasks();

        // 终止所有Worker
        for (const id in this.ecWorkers) {
            this.ecWorkers[id].worker.terminate();
        }

        this.ecWorkers = {};
        this.initWorkers();
    },

    /**
     * 获取边缘计算统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.ecConfig.enabled,
            maxWorkers: this.ecConfig.maxWorkers,
            activeWorkers: Object.values(this.ecWorkers).filter(w => w.busy).length,
            pendingTasks: Object.keys(this.ecTasks.pending).length,
            runningTasks: Object.keys(this.ecTasks.running).length,
            completedTasks: Object.keys(this.ecTasks.completed).length,
            failedTasks: Object.keys(this.ecTasks.failed).length,
            cacheSize: Object.keys(this.ecTasks.cache).length,
            totalHistory: this.ecHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏云计算优化
const GameCloudComputingOptimizer = {
    ccConfig: {},
    ccServices: {},
    ccHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏云计算
     */
    init: function () {
        this.loadCCConfig();
        this.loadCCServices();
    },

    /**
     * 加载云计算配置
     */
    loadCCConfig: function () {
        this.ccConfig = {
            enabled: true,
            maxHistorySize: 1000,
            autoSync: true,
            syncInterval: 60000,
            offlineMode: false,
            maxRetries: 3,
            retryInterval: 1000,
            dataCompression: true
        };

        const customConfig = localStorage.getItem('ccConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.ccConfig = { ...this.ccConfig, ...config };
            } catch (error) {
                console.error('加载云计算配置失败:', error);
            }
        }
    },

    /**
     * 保存云计算配置
     */
    saveCCConfig: function () {
        localStorage.setItem('ccConfig', JSON.stringify(this.ccConfig));
    },

    /**
     * 加载云服务
     */
    loadCCServices: function () {
        const savedServices = localStorage.getItem('ccServices');
        if (savedServices) {
            try {
                this.ccServices = JSON.parse(savedServices);
            } catch (error) {
                console.error('加载云服务失败:', error);
            }
        }

        if (!this.ccServices.storage) {
            this.ccServices = {
                storage: {
                    enabled: false,
                    provider: '',
                    endpoint: '',
                    apiKey: '',
                    bucket: '',
                    region: ''
                },
                database: {
                    enabled: false,
                    provider: '',
                    endpoint: '',
                    apiKey: '',
                    database: ''
                },
                compute: {
                    enabled: false,
                    provider: '',
                    endpoint: '',
                    apiKey: '',
                    functionName: ''
                },
                messaging: {
                    enabled: false,
                    provider: '',
                    endpoint: '',
                    apiKey: '',
                    topic: ''
                },
                analytics: {
                    enabled: false,
                    provider: '',
                    endpoint: '',
                    apiKey: '',
                    projectId: ''
                }
            };

            this.saveCCServices();
        }
    },

    /**
     * 保存云服务
     */
    saveCCServices: function () {
        localStorage.setItem('ccServices', JSON.stringify(this.ccServices));
    },

    /**
     * 上传数据到云存储
     * @param {string} key - 键
     * @param {Object} data - 数据
     * @returns {Promise<Object>} 上传结果
     */
    uploadToStorage: function (key, data) {
        return new Promise((resolve, reject) => {
            if (!this.ccConfig.enabled) {
                reject({
                    success: false,
                    error: '云计算已禁用'
                });
                return;
            }

            if (this.ccConfig.offlineMode) {
                reject({
                    success: false,
                    error: '离线模式'
                });
                return;
            }

            if (!this.ccServices.storage.enabled) {
                reject({
                    success: false,
                    error: '云存储未启用'
                });
                return;
            }

            const storage = this.ccServices.storage;

            // 模拟云存储上传
            setTimeout(() => {
                const result = {
                    success: true,
                    key: key,
                    url: `https://${storage.bucket}.${storage.region}.${storage.provider}/${key}`,
                    size: JSON.stringify(data).length
                };

                this.saveCCHistory('storage_upload', {
                    key: key,
                    size: result.size
                });

                resolve(result);
            }, 1000);
        });
    },

    /**
     * 从云存储下载数据
     * @param {string} key - 键
     * @returns {Promise<Object>} 下载结果
     */
    downloadFromStorage: function (key) {
        return new Promise((resolve, reject) => {
            if (!this.ccConfig.enabled) {
                reject({
                    success: false,
                    error: '云计算已禁用'
                });
                return;
            }

            if (this.ccConfig.offlineMode) {
                reject({
                    success: false,
                    error: '离线模式'
                });
                return;
            }

            if (!this.ccServices.storage.enabled) {
                reject({
                    success: false,
                    error: '云存储未启用'
                });
                return;
            }

            // 模拟云存储下载
            setTimeout(() => {
                const result = {
                    success: true,
                    key: key,
                    data: null
                };

                this.saveCCHistory('storage_download', {
                    key: key
                });

                resolve(result);
            }, 1000);
        });
    },

    /**
     * 删除云存储数据
     * @param {string} key - 键
     * @returns {Promise<Object>} 删除结果
     */
    deleteFromStorage: function (key) {
        return new Promise((resolve, reject) => {
            if (!this.ccConfig.enabled) {
                reject({
                    success: false,
                    error: '云计算已禁用'
                });
                return;
            }

            if (this.ccConfig.offlineMode) {
                reject({
                    success: false,
                    error: '离线模式'
                });
                return;
            }

            if (!this.ccServices.storage.enabled) {
                reject({
                    success: false,
                    error: '云存储未启用'
                });
                return;
            }

            // 模拟云存储删除
            setTimeout(() => {
                const result = {
                    success: true,
                    key: key
                };

                this.saveCCHistory('storage_delete', {
                    key: key
                });

                resolve(result);
            }, 500);
        });
    },

    /**
     * 查询云数据库
     * @param {string} table - 表名
     * @param {Object} query - 查询对象
     * @returns {Promise<Object>} 查询结果
     */
    queryDatabase: function (table, query) {
        return new Promise((resolve, reject) => {
            if (!this.ccConfig.enabled) {
                reject({
                    success: false,
                    error: '云计算已禁用'
                });
                return;
            }

            if (this.ccConfig.offlineMode) {
                reject({
                    success: false,
                    error: '离线模式'
                });
                return;
            }

            if (!this.ccServices.database.enabled) {
                reject({
                    success: false,
                    error: '云数据库未启用'
                });
                return;
            }

            // 模拟云数据库查询
            setTimeout(() => {
                const result = {
                    success: true,
                    table: table,
                    data: [],
                    count: 0
                };

                this.saveCCHistory('database_query', {
                    table: table,
                    query: query
                });

                resolve(result);
            }, 1000);
        });
    },

    /**
     * 插入数据到云数据库
     * @param {string} table - 表名
     * @param {Object} data - 数据
     * @returns {Promise<Object>} 插入结果
     */
    insertIntoDatabase: function (table, data) {
        return new Promise((resolve, reject) => {
            if (!this.ccConfig.enabled) {
                reject({
                    success: false,
                    error: '云计算已禁用'
                });
                return;
            }

            if (this.ccConfig.offlineMode) {
                reject({
                    success: false,
                    error: '离线模式'
                });
                return;
            }

            if (!this.ccServices.database.enabled) {
                reject({
                    success: false,
                    error: '云数据库未启用'
                });
                return;
            }

            // 模拟云数据库插入
            setTimeout(() => {
                const result = {
                    success: true,
                    table: table,
                    id: Date.now()
                };

                this.saveCCHistory('database_insert', {
                    table: table
                });

                resolve(result);
            }, 1000);
        });
    },

    /**
     * 更新云数据库数据
     * @param {string} table - 表名
     * @param {Object} query - 查询对象
     * @param {Object} data - 数据
     * @returns {Promise<Object>} 更新结果
     */
    updateDatabase: function (table, query, data) {
        return new Promise((resolve, reject) => {
            if (!this.ccConfig.enabled) {
                reject({
                    success: false,
                    error: '云计算已禁用'
                });
                return;
            }

            if (this.ccConfig.offlineMode) {
                reject({
                    success: false,
                    error: '离线模式'
                });
                return;
            }

            if (!this.ccServices.database.enabled) {
                reject({
                    success: false,
                    error: '云数据库未启用'
                });
                return;
            }

            // 模拟云数据库更新
            setTimeout(() => {
                const result = {
                    success: true,
                    table: table,
                    affectedRows: 0
                };

                this.saveCCHistory('database_update', {
                    table: table
                });

                resolve(result);
            }, 1000);
        });
    },

    /**
     * 删除云数据库数据
     * @param {string} table - 表名
     * @param {Object} query - 查询对象
     * @returns {Promise<Object>} 删除结果
     */
    deleteFromDatabase: function (table, query) {
        return new Promise((resolve, reject) => {
            if (!this.ccConfig.enabled) {
                reject({
                    success: false,
                    error: '云计算已禁用'
                });
                return;
            }

            if (this.ccConfig.offlineMode) {
                reject({
                    success: false,
                    error: '离线模式'
                });
                return;
            }

            if (!this.ccServices.database.enabled) {
                reject({
                    success: false,
                    error: '云数据库未启用'
                });
                return;
            }

            // 模拟云数据库删除
            setTimeout(() => {
                const result = {
                    success: true,
                    table: table,
                    affectedRows: 0
                };

                this.saveCCHistory('database_delete', {
                    table: table
                });

                resolve(result);
            }, 1000);
        });
    },

    /**
     * 调用云计算函数
     * @param {string} functionName - 函数名
     * @param {Object} data - 数据
     * @returns {Promise<Object>} 调用结果
     */
    invokeCloudFunction: function (functionName, data) {
        return new Promise((resolve, reject) => {
            if (!this.ccConfig.enabled) {
                reject({
                    success: false,
                    error: '云计算已禁用'
                });
                return;
            }

            if (this.ccConfig.offlineMode) {
                reject({
                    success: false,
                    error: '离线模式'
                });
                return;
            }

            if (!this.ccServices.compute.enabled) {
                reject({
                    success: false,
                    error: '云计算未启用'
                });
                return;
            }

            // 模拟云计算函数调用
            setTimeout(() => {
                const result = {
                    success: true,
                    functionName: functionName,
                    result: null
                };

                this.saveCCHistory('compute_invoke', {
                    functionName: functionName
                });

                resolve(result);
            }, 2000);
        });
    },

    /**
     * 发送云消息
     * @param {string} topic - 主题
     * @param {Object} message - 消息
     * @returns {Promise<Object>} 发送结果
     */
    sendCloudMessage: function (topic, message) {
        return new Promise((resolve, reject) => {
            if (!this.ccConfig.enabled) {
                reject({
                    success: false,
                    error: '云计算已禁用'
                });
                return;
            }

            if (this.ccConfig.offlineMode) {
                reject({
                    success: false,
                    error: '离线模式'
                });
                return;
            }

            if (!this.ccServices.messaging.enabled) {
                reject({
                    success: false,
                    error: '云消息未启用'
                });
                return;
            }

            // 模拟云消息发送
            setTimeout(() => {
                const result = {
                    success: true,
                    topic: topic,
                    messageId: Date.now()
                };

                this.saveCCHistory('messaging_send', {
                    topic: topic
                });

                resolve(result);
            }, 500);
        });
    },

    /**
     * 记录云分析事件
     * @param {string} eventName - 事件名
     * @param {Object} eventData - 事件数据
     * @returns {Promise<Object>} 记录结果
     */
    logAnalyticsEvent: function (eventName, eventData) {
        return new Promise((resolve, reject) => {
            if (!this.ccConfig.enabled) {
                reject({
                    success: false,
                    error: '云计算已禁用'
                });
                return;
            }

            if (this.ccConfig.offlineMode) {
                reject({
                    success: false,
                    error: '离线模式'
                });
                return;
            }

            if (!this.ccServices.analytics.enabled) {
                reject({
                    success: false,
                    error: '云分析未启用'
                });
                return;
            }

            // 模拟云分析事件记录
            setTimeout(() => {
                const result = {
                    success: true,
                    eventName: eventName
                };

                this.saveCCHistory('analytics_log', {
                    eventName: eventName
                });

                resolve(result);
            }, 500);
        });
    },

    /**
     * 同步数据到云
     * @returns {Promise<Object>} 同步结果
     */
    syncToCloud: function () {
        return new Promise((resolve, reject) => {
            if (!this.ccConfig.enabled) {
                reject({
                    success: false,
                    error: '云计算已禁用'
                });
                return;
            }

            if (this.ccConfig.offlineMode) {
                reject({
                    success: false,
                    error: '离线模式'
                });
                return;
            }

            // 模拟数据同步
            setTimeout(() => {
                const result = {
                    success: true,
                    syncedItems: 0
                };

                this.saveCCHistory('sync_to_cloud', {});

                resolve(result);
            }, 2000);
        });
    },

    /**
     * 从云同步数据
     * @returns {Promise<Object>} 同步结果
     */
    syncFromCloud: function () {
        return new Promise((resolve, reject) => {
            if (!this.ccConfig.enabled) {
                reject({
                    success: false,
                    error: '云计算已禁用'
                });
                return;
            }

            if (this.ccConfig.offlineMode) {
                reject({
                    success: false,
                    error: '离线模式'
                });
                return;
            }

            // 模拟数据同步
            setTimeout(() => {
                const result = {
                    success: true,
                    syncedItems: 0
                };

                this.saveCCHistory('sync_from_cloud', {});

                resolve(result);
            }, 2000);
        });
    },

    /**
     * 设置云服务配置
     * @param {string} serviceType - 服务类型
     * @param {Object} config - 配置对象
     */
    setCloudService: function (serviceType, config) {
        if (this.ccServices[serviceType]) {
            this.ccServices[serviceType] = { ...this.ccServices[serviceType], ...config };
            this.saveCCServices();
        }
    },

    /**
     * 获取云服务配置
     * @param {string} serviceType - 服务类型
     * @returns {Object} 配置对象
     */
    getCloudService: function (serviceType) {
        return this.ccServices[serviceType] || null;
    },

    /**
     * 获取所有云服务配置
     * @returns {Object} 所有配置
     */
    getAllCloudServices: function () {
        return this.ccServices;
    },

    /**
     * 设置离线模式
     * @param {boolean} offline - 是否离线
     */
    setOfflineMode: function (offline) {
        this.ccConfig.offlineMode = offline;
        this.saveCCConfig();
    },

    /**
     * 保存云计算历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveCCHistory: function (action, data) {
        this.ccHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.ccHistory.length > this.maxHistorySize) {
            this.ccHistory.shift();
        }
    },

    /**
     * 获取云计算历史
     * @param {Object} options - 查询选项
     * @returns {Array} 云计算历史
     */
    getCCHistory: function (options) {
        let history = [...this.ccHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置云计算配置
     * @param {Object} config - 配置对象
     */
    setCCConfig: function (config) {
        this.ccConfig = { ...this.ccConfig, ...config };
        this.saveCCConfig();
    },

    /**
     * 获取云计算配置
     * @returns {Object} 配置对象
     */
    getCCConfig: function () {
        return this.ccConfig;
    },

    /**
     * 重置云计算系统
     */
    reset: function () {
        this.ccHistory = [];
        this.loadCCConfig();
        this.loadCCServices();
    },

    /**
     * 获取云计算统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.ccConfig.enabled,
            autoSync: this.ccConfig.autoSync,
            offlineMode: this.ccConfig.offlineMode,
            storageEnabled: this.ccServices.storage.enabled,
            databaseEnabled: this.ccServices.database.enabled,
            computeEnabled: this.ccServices.compute.enabled,
            messagingEnabled: this.ccServices.messaging.enabled,
            analyticsEnabled: this.ccServices.analytics.enabled,
            totalHistory: this.ccHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏区块链优化
const GameBlockchainOptimizer = {
    bcConfig: {},
    bcChain: {},
    bcHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏区块链
     */
    init: function () {
        this.loadBCConfig();
        this.loadBCChain();
    },

    /**
     * 加载区块链配置
     */
    loadBCConfig: function () {
        this.bcConfig = {
            enabled: true,
            maxHistorySize: 1000,
            difficulty: 4,
            maxBlockSize: 10,
            miningReward: 100,
            validationEnabled: true
        };

        const customConfig = localStorage.getItem('bcConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.bcConfig = { ...this.bcConfig, ...config };
            } catch (error) {
                console.error('加载区块链配置失败:', error);
            }
        }
    },

    /**
     * 保存区块链配置
     */
    saveBCConfig: function () {
        localStorage.setItem('bcConfig', JSON.stringify(this.bcConfig));
    },

    /**
     * 加载区块链
     */
    loadBCChain: function () {
        const savedChain = localStorage.getItem('bcChain');
        if (savedChain) {
            try {
                this.bcChain = JSON.parse(savedChain);
            } catch (error) {
                console.error('加载区块链失败:', error);
            }
        }

        if (!this.bcChain.blocks) {
            this.bcChain = {
                blocks: [],
                pendingTransactions: [],
                balances: {},
                validators: []
            };

            // 创建创世区块
            this.createGenesisBlock();

            this.saveBCChain();
        }
    },

    /**
     * 保存区块链
     */
    saveBCChain: function () {
        localStorage.setItem('bcChain', JSON.stringify(this.bcChain));
    },

    /**
     * 创建创世区块
     */
    createGenesisBlock: function () {
        const genesisBlock = {
            index: 0,
            timestamp: Date.now(),
            transactions: [],
            previousHash: '0',
            hash: this.calculateHash(0, Date.now(), [], '0'),
            nonce: 0
        };

        this.bcChain.blocks.push(genesisBlock);
    },

    /**
     * 计算哈希
     * @param {number} index - 区块索引
     * @param {number} timestamp - 时间戳
     * @param {Array} transactions - 交易列表
     * @param {string} previousHash - 前一个哈希
     * @returns {string} 哈希值
     */
    calculateHash: function (index, timestamp, transactions, previousHash) {
        const data = index + timestamp + JSON.stringify(transactions) + previousHash;

        let hash = 0;

        for (let i = 0; i < data.length; i++) {
            const char = data.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }

        return Math.abs(hash).toString(16);
    },

    /**
     * 挖矿
     * @param {string} minerAddress - 矿工地址
     * @returns {Object} 挖矿结果
     */
    mineBlock: function (minerAddress) {
        if (!this.bcConfig.enabled) {
            return {
                success: false,
                error: '区块链已禁用'
            };
        }

        const previousBlock = this.bcChain.blocks[this.bcChain.blocks.length - 1];
        const transactions = [...this.bcChain.pendingTransactions];

        // 添加挖矿奖励交易
        transactions.push({
            from: 'system',
            to: minerAddress,
            amount: this.bcConfig.miningReward,
            timestamp: Date.now()
        });

        let nonce = 0;
        let hash = this.calculateHash(
            previousBlock.index + 1,
            Date.now(),
            transactions,
            previousBlock.hash
        );

        // 简化版挖矿（实际应该使用真实的哈希算法）
        while (!hash.startsWith('0'.repeat(this.bcConfig.difficulty))) {
            nonce++;
            hash = this.calculateHash(
                previousBlock.index + 1,
                Date.now(),
                transactions,
                previousBlock.hash
            ) + nonce;
        }

        const newBlock = {
            index: previousBlock.index + 1,
            timestamp: Date.now(),
            transactions: transactions,
            previousHash: previousBlock.hash,
            hash: hash,
            nonce: nonce
        };

        this.bcChain.blocks.push(newBlock);
        this.bcChain.pendingTransactions = [];

        // 更新余额
        this.updateBalances(transactions);

        this.saveBCChain();

        this.saveBCHistory('block_mined', {
            blockIndex: newBlock.index,
            miner: minerAddress
        });

        return {
            success: true,
            block: newBlock
        };
    },

    /**
     * 添加交易
     * @param {string} from - 发送方
     * @param {string} to - 接收方
     * @param {number} amount - 金额
     * @returns {Object} 添加结果
     */
    addTransaction: function (from, to, amount) {
        if (!this.bcConfig.enabled) {
            return {
                success: false,
                error: '区块链已禁用'
            };
        }

        // 检查余额
        if (from !== 'system' && this.getBalance(from) < amount) {
            return {
                success: false,
                error: '余额不足'
            };
        }

        const transaction = {
            from: from,
            to: to,
            amount: amount,
            timestamp: Date.now()
        };

        this.bcChain.pendingTransactions.push(transaction);
        this.saveBCChain();

        this.saveBCHistory('transaction_added', {
            from: from,
            to: to,
            amount: amount
        });

        return {
            success: true,
            transaction: transaction
        };
    },

    /**
     * 获取余额
     * @param {string} address - 地址
     * @returns {number} 余额
     */
    getBalance: function (address) {
        let balance = 0;

        // 遍历所有区块
        for (const block of this.bcChain.blocks) {
            for (const transaction of block.transactions) {
                if (transaction.to === address) {
                    balance += transaction.amount;
                }

                if (transaction.from === address) {
                    balance -= transaction.amount;
                }
            }
        }

        return balance;
    },

    /**
     * 更新余额
     * @param {Array} transactions - 交易列表
     */
    updateBalances: function (transactions) {
        for (const transaction of transactions) {
            if (!this.bcChain.balances[transaction.to]) {
                this.bcChain.balances[transaction.to] = 0;
            }

            this.bcChain.balances[transaction.to] += transaction.amount;

            if (transaction.from !== 'system') {
                if (!this.bcChain.balances[transaction.from]) {
                    this.bcChain.balances[transaction.from] = 0;
                }

                this.bcChain.balances[transaction.from] -= transaction.amount;
            }
        }
    },

    /**
     * 验证区块链
     * @returns {boolean} 是否有效
     */
    validateChain: function () {
        if (!this.bcConfig.validationEnabled) {
            return true;
        }

        for (let i = 1; i < this.bcChain.blocks.length; i++) {
            const currentBlock = this.bcChain.blocks[i];
            const previousBlock = this.bcChain.blocks[i - 1];

            // 验证哈希
            const hash = this.calculateHash(
                currentBlock.index,
                currentBlock.timestamp,
                currentBlock.transactions,
                currentBlock.previousHash
            ) + currentBlock.nonce;

            if (hash !== currentBlock.hash) {
                return false;
            }

            // 验证前一个哈希
            if (currentBlock.previousHash !== previousBlock.hash) {
                return false;
            }
        }

        return true;
    },

    /**
     * 获取区块链
     * @returns {Array} 区块列表
     */
    getChain: function () {
        return this.bcChain.blocks;
    },

    /**
     * 获取待处理交易
     * @returns {Array} 待处理交易列表
     */
    getPendingTransactions: function () {
        return this.bcChain.pendingTransactions;
    },

    /**
     * 获取所有余额
     * @returns {Object} 余额对象
     */
    getAllBalances: function () {
        return this.bcChain.balances;
    },

    /**
     * 添加验证者
     * @param {string} address - 验证者地址
     */
    addValidator: function (address) {
        if (!this.bcChain.validators.includes(address)) {
            this.bcChain.validators.push(address);
            this.saveBCChain();
        }
    },

    /**
     * 移除验证者
     * @param {string} address - 验证者地址
     */
    removeValidator: function (address) {
        const index = this.bcChain.validators.indexOf(address);

        if (index > -1) {
            this.bcChain.validators.splice(index, 1);
            this.saveBCChain();
        }
    },

    /**
     * 获取验证者列表
     * @returns {Array} 验证者列表
     */
    getValidators: function () {
        return this.bcChain.validators;
    },

    /**
     * 设置难度
     * @param {number} difficulty - 难度
     */
    setDifficulty: function (difficulty) {
        this.bcConfig.difficulty = difficulty;
        this.saveBCConfig();
    },

    /**
     * 设置挖矿奖励
     * @param {number} reward - 奖励
     */
    setMiningReward: function (reward) {
        this.bcConfig.miningReward = reward;
        this.saveBCConfig();
    },

    /**
     * 保存区块链历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveBCHistory: function (action, data) {
        this.bcHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.bcHistory.length > this.maxHistorySize) {
            this.bcHistory.shift();
        }
    },

    /**
     * 获取区块链历史
     * @param {Object} options - 查询选项
     * @returns {Array} 区块链历史
     */
    getBCHistory: function (options) {
        let history = [...this.bcHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置区块链配置
     * @param {Object} config - 配置对象
     */
    setBCConfig: function (config) {
        this.bcConfig = { ...this.bcConfig, ...config };
        this.saveBCConfig();
    },

    /**
     * 获取区块链配置
     * @returns {Object} 配置对象
     */
    getBCConfig: function () {
        return this.bcConfig;
    },

    /**
     * 重置区块链系统
     */
    reset: function () {
        this.bcHistory = [];
        this.loadBCConfig();
        this.loadBCChain();
    },

    /**
     * 获取区块链统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.bcConfig.enabled,
            difficulty: this.bcConfig.difficulty,
            maxBlockSize: this.bcConfig.maxBlockSize,
            miningReward: this.bcConfig.miningReward,
            validationEnabled: this.bcConfig.validationEnabled,
            totalBlocks: this.bcChain.blocks.length,
            pendingTransactions: this.bcChain.pendingTransactions.length,
            totalBalances: Object.keys(this.bcChain.balances).length,
            totalValidators: this.bcChain.validators.length,
            isValid: this.validateChain(),
            totalHistory: this.bcHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏加密优化
const GameEncryptionOptimizer = {
    encConfig: {},
    encKeys: {},
    encHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏加密
     */
    init: function () {
        this.loadEncConfig();
        this.loadEncKeys();
    },

    /**
     * 加载加密配置
     */
    loadEncConfig: function () {
        this.encConfig = {
            enabled: true,
            maxHistorySize: 1000,
            defaultAlgorithm: 'AES',
            defaultKeySize: 256,
            defaultIVSize: 16,
            autoRotateKeys: false,
            keyRotationInterval: 86400000
        };

        const customConfig = localStorage.getItem('encConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.encConfig = { ...this.encConfig, ...config };
            } catch (error) {
                console.error('加载加密配置失败:', error);
            }
        }
    },

    /**
     * 保存加密配置
     */
    saveEncConfig: function () {
        localStorage.setItem('encConfig', JSON.stringify(this.encConfig));
    },

    /**
     * 加载加密密钥
     */
    loadEncKeys: function () {
        const savedKeys = localStorage.getItem('encKeys');
        if (savedKeys) {
            try {
                this.encKeys = JSON.parse(savedKeys);
            } catch (error) {
                console.error('加载加密密钥失败:', error);
            }
        }

        if (!this.encKeys.master) {
            this.encKeys = {
                master: this.generateKey(),
                session: {},
                rotationHistory: []
            };

            this.saveEncKeys();
        }
    },

    /**
     * 保存加密密钥
     */
    saveEncKeys: function () {
        localStorage.setItem('encKeys', JSON.stringify(this.encKeys));
    },

    /**
     * 生成密钥
     * @param {number} length - 密钥长度
     * @returns {string} 密钥
     */
    generateKey: function (length) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let key = '';

        for (let i = 0; i < (length || 32); i++) {
            key += chars.charAt(Math.floor(Math.random() * chars.length));
        }

        return key;
    },

    /**
     * 生成IV
     * @param {number} length - IV长度
     * @returns {string} IV
     */
    generateIV: function (length) {
        return this.generateKey(length || 16);
    },

    /**
     * 简单加密（实际应用中应该使用Web Crypto API）
     * @param {string} plaintext - 明文
     * @param {string} key - 密钥
     * @param {string} iv - IV
     * @returns {Object} 加密结果
     */
    encrypt: function (plaintext, key, iv) {
        if (!this.encConfig.enabled) {
            return {
                success: false,
                error: '加密已禁用'
            };
        }

        const encryptionKey = key || this.encKeys.master;
        const encryptionIV = iv || this.generateIV();

        // 简化的加密（实际应用中应该使用AES等标准算法）
        let encrypted = '';

        for (let i = 0; i < plaintext.length; i++) {
            const charCode = plaintext.charCodeAt(i);
            const keyChar = encryptionKey.charCodeAt(i % encryptionKey.length);
            const ivChar = encryptionIV.charCodeAt(i % encryptionIV.length);

            encrypted += String.fromCharCode(charCode ^ keyChar ^ ivChar);
        }

        // Base64编码
        const base64Encrypted = btoa(encrypted);

        this.saveEncHistory('encryption', {
            length: plaintext.length
        });

        return {
            success: true,
            ciphertext: base64Encrypted,
            iv: encryptionIV,
            algorithm: this.encConfig.defaultAlgorithm
        };
    },

    /**
     * 简单解密（实际应用中应该使用Web Crypto API）
     * @param {string} ciphertext - 密文
     * @param {string} key - 密钥
     * @param {string} iv - IV
     * @returns {Object} 解密结果
     */
    decrypt: function (ciphertext, key, iv) {
        if (!this.encConfig.enabled) {
            return {
                success: false,
                error: '加密已禁用'
            };
        }

        const decryptionKey = key || this.encKeys.master;
        const decryptionIV = iv || '';

        try {
            // Base64解码
            const encrypted = atob(ciphertext);

            // 简化的解密
            let decrypted = '';

            for (let i = 0; i < encrypted.length; i++) {
                const charCode = encrypted.charCodeAt(i);
                const keyChar = decryptionKey.charCodeAt(i % decryptionKey.length);
                const ivChar = decryptionIV.charCodeAt(i % decryptionIV.length);

                decrypted += String.fromCharCode(charCode ^ keyChar ^ ivChar);
            }

            this.saveEncHistory('decryption', {
                length: decrypted.length
            });

            return {
                success: true,
                plaintext: decrypted
            };
        } catch (error) {
            return {
                success: false,
                error: '解密失败'
            };
        }
    },

    /**
     * 哈希
     * @param {string} data - 数据
     * @returns {string} 哈希值
     */
    hash: function (data) {
        let hash = 0;

        for (let i = 0; i < data.length; i++) {
            const char = data.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }

        return Math.abs(hash).toString(16);
    },

    /**
     * HMAC
     * @param {string} data - 数据
     * @param {string} key - 密钥
     * @returns {string} HMAC值
     */
    hmac: function (data, key) {
        const hmacKey = key || this.encKeys.master;

        return this.hash(hmacKey + data);
    },

    /**
     * 生成会话密钥
     * @param {string} sessionId - 会话ID
     * @returns {string} 会话密钥
     */
    generateSessionKey: function (sessionId) {
        const sessionKey = this.generateKey();

        this.encKeys.session[sessionId] = {
            key: sessionKey,
            createdAt: Date.now(),
            expiresAt: Date.now() + 3600000 // 1小时后过期
        };

        this.saveEncKeys();

        return sessionKey;
    },

    /**
     * 获取会话密钥
     * @param {string} sessionId - 会话ID
     * @returns {string|null} 会话密钥
     */
    getSessionKey: function (sessionId) {
        const session = this.encKeys.session[sessionId];

        if (!session) {
            return null;
        }

        // 检查是否过期
        if (Date.now() > session.expiresAt) {
            delete this.encKeys.session[sessionId];
            this.saveEncKeys();

            return null;
        }

        return session.key;
    },

    /**
     * 删除会话密钥
     * @param {string} sessionId - 会话ID
     */
    deleteSessionKey: function (sessionId) {
        if (this.encKeys.session[sessionId]) {
            delete this.encKeys.session[sessionId];
            this.saveEncKeys();
        }
    },

    /**
     * 清理过期会话密钥
     */
    cleanupExpiredSessions: function () {
        const now = Date.now();

        for (const sessionId in this.encKeys.session) {
            const session = this.encKeys.session[sessionId];

            if (now > session.expiresAt) {
                delete this.encKeys.session[sessionId];
            }
        }

        this.saveEncKeys();
    },

    /**
     * 旋转主密钥
     */
    rotateMasterKey: function () {
        const oldKey = this.encKeys.master;
        const newKey = this.generateKey();

        this.encKeys.rotationHistory.push({
            oldKey: oldKey,
            newKey: newKey,
            rotatedAt: Date.now()
        });

        this.encKeys.master = newKey;

        this.saveEncKeys();

        this.saveEncHistory('key_rotation', {});
    },

    /**
     * 获取主密钥
     * @returns {string} 主密钥
     */
    getMasterKey: function () {
        return this.encKeys.master;
    },

    /**
     * 设置主密钥
     * @param {string} key - 主密钥
     */
    setMasterKey: function (key) {
        this.encKeys.master = key;
        this.saveEncKeys();
    },

    /**
     * 获取密钥旋转历史
     * @returns {Array} 旋转历史
     */
    getKeyRotationHistory: function () {
        return this.encKeys.rotationHistory;
    },

    /**
     * 设置默认算法
     * @param {string} algorithm - 算法名称
     */
    setDefaultAlgorithm: function (algorithm) {
        this.encConfig.defaultAlgorithm = algorithm;
        this.saveEncConfig();
    },

    /**
     * 设置密钥大小
     * @param {number} size - 密钥大小
     */
    setKeySize: function (size) {
        this.encConfig.defaultKeySize = size;
        this.saveEncConfig();
    },

    /**
     * 保存加密历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveEncHistory: function (action, data) {
        this.encHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.encHistory.length > this.maxHistorySize) {
            this.encHistory.shift();
        }
    },

    /**
     * 获取加密历史
     * @param {Object} options - 查询选项
     * @returns {Array} 加密历史
     */
    getEncHistory: function (options) {
        let history = [...this.encHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置加密配置
     * @param {Object} config - 配置对象
     */
    setEncConfig: function (config) {
        this.encConfig = { ...this.encConfig, ...config };
        this.saveEncConfig();
    },

    /**
     * 获取加密配置
     * @returns {Object} 配置对象
     */
    getEncConfig: function () {
        return this.encConfig;
    },

    /**
     * 重置加密系统
     */
    reset: function () {
        this.encHistory = [];
        this.loadEncConfig();
        this.loadEncKeys();
    },

    /**
     * 获取加密统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.encConfig.enabled,
            defaultAlgorithm: this.encConfig.defaultAlgorithm,
            defaultKeySize: this.encConfig.defaultKeySize,
            defaultIVSize: this.encConfig.defaultIVSize,
            autoRotateKeys: this.encConfig.autoRotateKeys,
            keyRotationInterval: this.encConfig.keyRotationInterval,
            activeSessions: Object.keys(this.encKeys.session).length,
            totalRotations: this.encKeys.rotationHistory.length,
            totalHistory: this.encHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏安全认证优化
const GameSecurityAuthOptimizer = {
    authConfig: {},
    authUsers: {},
    authSessions: {},
    authHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏安全认证
     */
    init: function () {
        this.loadAuthConfig();
        this.loadAuthUsers();
        this.loadAuthSessions();
    },

    /**
     * 加载认证配置
     */
    loadAuthConfig: function () {
        this.authConfig = {
            enabled: true,
            maxHistorySize: 1000,
            sessionTimeout: 3600000,
            maxLoginAttempts: 5,
            lockoutDuration: 300000,
            passwordMinLength: 8,
            requireUppercase: true,
            requireLowercase: true,
            requireNumbers: true,
            requireSpecialChars: true,
            twoFactorEnabled: false
        };

        const customConfig = localStorage.getItem('authConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.authConfig = { ...this.authConfig, ...config };
            } catch (error) {
                console.error('加载认证配置失败:', error);
            }
        }
    },

    /**
     * 保存认证配置
     */
    saveAuthConfig: function () {
        localStorage.setItem('authConfig', JSON.stringify(this.authConfig));
    },

    /**
     * 加载用户
     */
    loadAuthUsers: function () {
        const savedUsers = localStorage.getItem('authUsers');
        if (savedUsers) {
            try {
                this.authUsers = JSON.parse(savedUsers);
            } catch (error) {
                console.error('加载用户失败:', error);
            }
        }

        if (!this.authUsers.users) {
            this.authUsers = {
                users: {},
                roles: {
                    admin: ['*'],
                    user: ['game.play', 'game.save'],
                    guest: ['game.play']
                }
            };

            this.saveAuthUsers();
        }
    },

    /**
     * 保存用户
     */
    saveAuthUsers: function () {
        localStorage.setItem('authUsers', JSON.stringify(this.authUsers));
    },

    /**
     * 加载会话
     */
    loadAuthSessions: function () {
        const savedSessions = localStorage.getItem('authSessions');
        if (savedSessions) {
            try {
                this.authSessions = JSON.parse(savedSessions);
            } catch (error) {
                console.error('加载会话失败:', error);
            }
        }

        if (!this.authSessions.sessions) {
            this.authSessions = {
                sessions: {}
            };

            this.saveAuthSessions();
        }
    },

    /**
     * 保存会话
     */
    saveAuthSessions: function () {
        localStorage.setItem('authSessions', JSON.stringify(this.authSessions));
    },

    /**
     * 注册用户
     * @param {string} username - 用户名
     * @param {string} password - 密码
     * @param {string} email - 邮箱
     * @returns {Object} 注册结果
     */
    registerUser: function (username, password, email) {
        if (!this.authConfig.enabled) {
            return {
                success: false,
                error: '认证已禁用'
            };
        }

        // 检查用户名是否已存在
        if (this.authUsers.users[username]) {
            return {
                success: false,
                error: '用户名已存在'
            };
        }

        // 验证密码强度
        const passwordValidation = this.validatePassword(password);

        if (!passwordValidation.valid) {
            return {
                success: false,
                error: passwordValidation.error
            };
        }

        // 创建用户
        const user = {
            username: username,
            password: this.hashPassword(password),
            email: email,
            role: 'user',
            createdAt: Date.now(),
            lastLogin: null,
            loginAttempts: 0,
            lockedUntil: null,
            twoFactorSecret: null,
            permissions: this.authUsers.roles.user
        };

        this.authUsers.users[username] = user;
        this.saveAuthUsers();

        this.saveAuthHistory('user_registered', {
            username: username
        });

        return {
            success: true,
            user: user
        };
    },

    /**
     * 登录用户
     * @param {string} username - 用户名
     * @param {string} password - 密码
     * @returns {Object} 登录结果
     */
    loginUser: function (username, password) {
        if (!this.authConfig.enabled) {
            return {
                success: false,
                error: '认证已禁用'
            };
        }

        const user = this.authUsers.users[username];

        if (!user) {
            return {
                success: false,
                error: '用户不存在'
            };
        }

        // 检查是否被锁定
        if (user.lockedUntil && Date.now() < user.lockedUntil) {
            return {
                success: false,
                error: '账户已被锁定'
            };
        }

        // 验证密码
        const hashedPassword = this.hashPassword(password);

        if (hashedPassword !== user.password) {
            user.loginAttempts++;

            // 检查是否达到最大尝试次数
            if (user.loginAttempts >= this.authConfig.maxLoginAttempts) {
                user.lockedUntil = Date.now() + this.authConfig.lockoutDuration;
            }

            this.saveAuthUsers();

            return {
                success: false,
                error: '密码错误',
                remainingAttempts: this.authConfig.maxLoginAttempts - user.loginAttempts
            };
        }

        // 重置登录尝试
        user.loginAttempts = 0;
        user.lockedUntil = null;
        user.lastLogin = Date.now();

        this.saveAuthUsers();

        // 创建会话
        const sessionToken = this.generateSessionToken();

        this.authSessions.sessions[sessionToken] = {
            username: username,
            createdAt: Date.now(),
            expiresAt: Date.now() + this.authConfig.sessionTimeout
        };

        this.saveAuthSessions();

        this.saveAuthHistory('user_logged_in', {
            username: username
        });

        return {
            success: true,
            sessionToken: sessionToken,
            user: user
        };
    },

    /**
     * 登出用户
     * @param {string} sessionToken - 会话令牌
     * @returns {Object} 登出结果
     */
    logoutUser: function (sessionToken) {
        if (!this.authConfig.enabled) {
            return {
                success: false,
                error: '认证已禁用'
            };
        }

        const session = this.authSessions.sessions[sessionToken];

        if (!session) {
            return {
                success: false,
                error: '会话不存在'
            };
        }

        delete this.authSessions.sessions[sessionToken];
        this.saveAuthSessions();

        this.saveAuthHistory('user_logged_out', {
            username: session.username
        });

        return {
            success: true
        };
    },

    /**
     * 验证会话
     * @param {string} sessionToken - 会话令牌
     * @returns {Object} 验证结果
     */
    validateSession: function (sessionToken) {
        if (!this.authConfig.enabled) {
            return {
                success: false,
                error: '认证已禁用'
            };
        }

        const session = this.authSessions.sessions[sessionToken];

        if (!session) {
            return {
                success: false,
                error: '会话不存在'
            };
        }

        // 检查是否过期
        if (Date.now() > session.expiresAt) {
            delete this.authSessions.sessions[sessionToken];
            this.saveAuthSessions();

            return {
                success: false,
                error: '会话已过期'
            };
        }

        // 更新会话过期时间
        session.expiresAt = Date.now() + this.authConfig.sessionTimeout;
        this.saveAuthSessions();

        const user = this.authUsers.users[session.username];

        return {
            success: true,
            user: user
        };
    },

    /**
     * 验证权限
     * @param {string} sessionToken - 会话令牌
     * @param {string} permission - 权限
     * @returns {boolean} 是否有权限
     */
    hasPermission: function (sessionToken, permission) {
        const validation = this.validateSession(sessionToken);

        if (!validation.success) {
            return false;
        }

        const user = validation.user;

        // 检查是否有该权限
        return user.permissions.includes(permission) || user.permissions.includes('*');
    },

    /**
     * 修改密码
     * @param {string} sessionToken - 会话令牌
     * @param {string} oldPassword - 旧密码
     * @param {string} newPassword - 新密码
     * @returns {Object} 修改结果
     */
    changePassword: function (sessionToken, oldPassword, newPassword) {
        if (!this.authConfig.enabled) {
            return {
                success: false,
                error: '认证已禁用'
            };
        }

        const validation = this.validateSession(sessionToken);

        if (!validation.success) {
            return {
                success: false,
                error: '会话无效'
            };
        }

        const user = validation.user;

        // 验证旧密码
        const hashedOldPassword = this.hashPassword(oldPassword);

        if (hashedOldPassword !== user.password) {
            return {
                success: false,
                error: '旧密码错误'
            };
        }

        // 验证新密码强度
        const passwordValidation = this.validatePassword(newPassword);

        if (!passwordValidation.valid) {
            return {
                success: false,
                error: passwordValidation.error
            };
        }

        // 更新密码
        user.password = this.hashPassword(newPassword);
        this.saveAuthUsers();

        this.saveAuthHistory('password_changed', {
            username: user.username
        });

        return {
            success: true
        };
    },

    /**
     * 哈希密码
     * @param {string} password - 密码
     * @returns {string} 哈希后的密码
     */
    hashPassword: function (password) {
        let hash = 0;

        for (let i = 0; i < password.length; i++) {
            const char = password.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }

        return Math.abs(hash).toString(16);
    },

    /**
     * 验证密码强度
     * @param {string} password - 密码
     * @returns {Object} 验证结果
     */
    validatePassword: function (password) {
        if (password.length < this.authConfig.passwordMinLength) {
            return {
                valid: false,
                error: '密码长度不足'
            };
        }

        if (this.authConfig.requireUppercase && !/[A-Z]/.test(password)) {
            return {
                valid: false,
                error: '密码必须包含大写字母'
            };
        }

        if (this.authConfig.requireLowercase && !/[a-z]/.test(password)) {
            return {
                valid: false,
                error: '密码必须包含小写字母'
            };
        }

        if (this.authConfig.requireNumbers && !/[0-9]/.test(password)) {
            return {
                valid: false,
                error: '密码必须包含数字'
            };
        }

        if (this.authConfig.requireSpecialChars && !/[^a-zA-Z0-9]/.test(password)) {
            return {
                valid: false,
                error: '密码必须包含特殊字符'
            };
        }

        return {
            valid: true
        };
    },

    /**
     * 生成会话令牌
     * @returns {string} 会话令牌
     */
    generateSessionToken: function () {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let token = '';

        for (let i = 0; i < 64; i++) {
            token += chars.charAt(Math.floor(Math.random() * chars.length));
        }

        return token;
    },

    /**
     * 添加角色
     * @param {string} roleName - 角色名称
     * @param {Array} permissions - 权限列表
     */
    addRole: function (roleName, permissions) {
        this.authUsers.roles[roleName] = permissions;
        this.saveAuthUsers();
    },

    /**
     * 删除角色
     * @param {string} roleName - 角色名称
     */
    removeRole: function (roleName) {
        if (this.authUsers.roles[roleName]) {
            delete this.authUsers.roles[roleName];
            this.saveAuthUsers();
        }
    },

    /**
     * 设置用户角色
     * @param {string} username - 用户名
     * @param {string} roleName - 角色名称
     */
    setUserRole: function (username, roleName) {
        const user = this.authUsers.users[username];

        if (user && this.authUsers.roles[roleName]) {
            user.role = roleName;
            user.permissions = this.authUsers.roles[roleName];
            this.saveAuthUsers();
        }
    },

    /**
     * 删除用户
     * @param {string} username - 用户名
     */
    deleteUser: function (username) {
        if (this.authUsers.users[username]) {
            delete this.authUsers.users[username];
            this.saveAuthUsers();
        }
    },

    /**
     * 清理过期会话
     */
    cleanupExpiredSessions: function () {
        const now = Date.now();

        for (const sessionToken in this.authSessions.sessions) {
            const session = this.authSessions.sessions[sessionToken];

            if (now > session.expiresAt) {
                delete this.authSessions.sessions[sessionToken];
            }
        }

        this.saveAuthSessions();
    },

    /**
     * 保存认证历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveAuthHistory: function (action, data) {
        this.authHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.authHistory.length > this.maxHistorySize) {
            this.authHistory.shift();
        }
    },

    /**
     * 获取认证历史
     * @param {Object} options - 查询选项
     * @returns {Array} 认证历史
     */
    getAuthHistory: function (options) {
        let history = [...this.authHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置认证配置
     * @param {Object} config - 配置对象
     */
    setAuthConfig: function (config) {
        this.authConfig = { ...this.authConfig, ...config };
        this.saveAuthConfig();
    },

    /**
     * 获取认证配置
     * @returns {Object} 配置对象
     */
    getAuthConfig: function () {
        return this.authConfig;
    },

    /**
     * 重置认证系统
     */
    reset: function () {
        this.authHistory = [];
        this.loadAuthConfig();
        this.loadAuthUsers();
        this.loadAuthSessions();
    },

    /**
     * 获取认证统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.authConfig.enabled,
            sessionTimeout: this.authConfig.sessionTimeout,
            maxLoginAttempts: this.authConfig.maxLoginAttempts,
            lockoutDuration: this.authConfig.lockoutDuration,
            totalUsers: Object.keys(this.authUsers.users).length,
            totalRoles: Object.keys(this.authUsers.roles).length,
            activeSessions: Object.keys(this.authSessions.sessions).length,
            totalHistory: this.authHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏防作弊优化
const GameAntiCheatOptimizer = {
    acConfig: {},
    acViolations: {},
    acHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏防作弊
     */
    init: function () {
        this.loadACConfig();
        this.loadACViolations();
        this.startMonitoring();
    },

    /**
     * 加载防作弊配置
     */
    loadACConfig: function () {
        this.acConfig = {
            enabled: true,
            maxHistorySize: 1000,
            strictMode: false,
            autoBan: false,
            banDuration: 86400000,
            maxViolations: 5,
            violationResetInterval: 3600000,
            monitoringInterval: 1000,
            checks: {
                speedHack: true,
                teleportHack: true,
                resourceHack: true,
                scoreHack: true,
                timeHack: true,
                modifiedClient: true
            }
        };

        const customConfig = localStorage.getItem('acConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.acConfig = { ...this.acConfig, ...config };
            } catch (error) {
                console.error('加载防作弊配置失败:', error);
            }
        }
    },

    /**
     * 保存防作弊配置
     */
    saveACConfig: function () {
        localStorage.setItem('acConfig', JSON.stringify(this.acConfig));
    },

    /**
     * 加载违规记录
     */
    loadACViolations: function () {
        const savedViolations = localStorage.getItem('acViolations');
        if (savedViolations) {
            try {
                this.acViolations = JSON.parse(savedViolations);
            } catch (error) {
                console.error('加载违规记录失败:', error);
            }
        }

        if (!this.acViolations.violations) {
            this.acViolations = {
                violations: {},
                bannedPlayers: {}
            };

            this.saveACViolations();
        }
    },

    /**
     * 保存违规记录
     */
    saveACViolations: function () {
        localStorage.setItem('acViolations', JSON.stringify(this.acViolations));
    },

    /**
     * 开始监控
     */
    startMonitoring: function () {
        setInterval(() => {
            if (this.acConfig.enabled) {
                this.performChecks();
            }
        }, this.acConfig.monitoringInterval);
    },

    /**
     * 执行检查
     */
    performChecks: function () {
        // 速度检查
        if (this.acConfig.checks.speedHack) {
            this.checkSpeedHack();
        }

        // 传送检查
        if (this.acConfig.checks.teleportHack) {
            this.checkTeleportHack();
        }

        // 资源检查
        if (this.acConfig.checks.resourceHack) {
            this.checkResourceHack();
        }

        // 分数检查
        if (this.acConfig.checks.scoreHack) {
            this.checkScoreHack();
        }

        // 时间检查
        if (this.acConfig.checks.timeHack) {
            this.checkTimeHack();
        }

        // 客户端修改检查
        if (this.acConfig.checks.modifiedClient) {
            this.checkModifiedClient();
        }
    },

    /**
     * 检查速度作弊
     */
    checkSpeedHack: function () {
        // 模拟速度检查
        const playerSpeed = this.getPlayerSpeed();
        const maxSpeed = 10;

        if (playerSpeed > maxSpeed) {
            this.recordViolation('speedHack', {
                detectedSpeed: playerSpeed,
                maxSpeed: maxSpeed
            });
        }
    },

    /**
     * 检查传送作弊
     */
    checkTeleportHack: function () {
        // 模拟传送检查
        const playerPosition = this.getPlayerPosition();
        const lastPosition = this.getLastPlayerPosition();

        if (lastPosition) {
            const distance = this.calculateDistance(playerPosition, lastPosition);
            const maxDistance = 20;

            if (distance > maxDistance) {
                this.recordViolation('teleportHack', {
                    distance: distance,
                    maxDistance: maxDistance
                });
            }
        }

        this.setLastPlayerPosition(playerPosition);
    },

    /**
     * 检查资源作弊
     */
    checkResourceHack: function () {
        // 模拟资源检查
        const playerResources = this.getPlayerResources();
        const maxResources = 1000;

        if (playerResources > maxResources) {
            this.recordViolation('resourceHack', {
                detectedResources: playerResources,
                maxResources: maxResources
            });
        }
    },

    /**
     * 检查分数作弊
     */
    checkScoreHack: function () {
        // 模拟分数检查
        const playerScore = this.getPlayerScore();
        const lastScore = this.getLastPlayerScore();

        if (lastScore !== null) {
            const scoreDiff = playerScore - lastScore;
            const maxScoreDiff = 100;

            if (scoreDiff > maxScoreDiff) {
                this.recordViolation('scoreHack', {
                    scoreDiff: scoreDiff,
                    maxScoreDiff: maxScoreDiff
                });
            }
        }

        this.setLastPlayerScore(playerScore);
    },

    /**
     * 检查时间作弊
     */
    checkTimeHack: function () {
        // 模拟时间检查
        const gameTime = this.getGameTime();
        const lastGameTime = this.getLastGameTime();

        if (lastGameTime !== null) {
            const timeDiff = gameTime - lastGameTime;
            const maxTimeDiff = 2;

            if (timeDiff > maxTimeDiff) {
                this.recordViolation('timeHack', {
                    timeDiff: timeDiff,
                    maxTimeDiff: maxTimeDiff
                });
            }
        }

        this.setLastGameTime(gameTime);
    },

    /**
     * 检查客户端修改
     */
    checkModifiedClient: function () {
        // 模拟客户端修改检查
        const clientHash = this.getClientHash();
        const expectedHash = 'abc123';

        if (clientHash !== expectedHash) {
            this.recordViolation('modifiedClient', {
                detectedHash: clientHash,
                expectedHash: expectedHash
            });
        }
    },

    /**
     * 记录违规
     * @param {string} violationType - 违规类型
     * @param {Object} details - 详细信息
     */
    recordViolation: function (violationType, details) {
        const playerId = this.getCurrentPlayerId();

        if (!this.acViolations.violations[playerId]) {
            this.acViolations.violations[playerId] = [];
        }

        const violation = {
            type: violationType,
            details: details,
            timestamp: Date.now()
        };

        this.acViolations.violations[playerId].push(violation);

        // 检查是否达到最大违规次数
        if (this.acViolations.violations[playerId].length >= this.acConfig.maxViolations) {
            this.banPlayer(playerId);
        }

        this.saveACViolations();

        this.saveACHistory('violation_recorded', {
            playerId: playerId,
            violationType: violationType
        });

        // 发送通知
        if (window.GameMessageBus) {
            GameMessageBus.publish('anticheat.violation', {
                playerId: playerId,
                violation: violation
            });
        }
    },

    /**
     * 封禁玩家
     * @param {string} playerId - 玩家ID
     */
    banPlayer: function (playerId) {
        this.acViolations.bannedPlayers[playerId] = {
            bannedAt: Date.now(),
            expiresAt: Date.now() + this.acConfig.banDuration,
            violations: this.acViolations.violations[playerId].length
        };

        this.saveACViolations();

        this.saveACHistory('player_banned', {
            playerId: playerId
        });

        // 发送通知
        if (window.GameMessageBus) {
            GameMessageBus.publish('anticheat.player_banned', {
                playerId: playerId
            });
        }
    },

    /**
     * 解封玩家
     * @param {string} playerId - 玩家ID
     */
    unbanPlayer: function (playerId) {
        if (this.acViolations.bannedPlayers[playerId]) {
            delete this.acViolations.bannedPlayers[playerId];
            this.saveACViolations();

            this.saveACHistory('player_unbanned', {
                playerId: playerId
            });
        }
    },

    /**
     * 检查玩家是否被封禁
     * @param {string} playerId - 玩家ID
     * @returns {boolean} 是否被封禁
     */
    isPlayerBanned: function (playerId) {
        const ban = this.acViolations.bannedPlayers[playerId];

        if (!ban) {
            return false;
        }

        // 检查是否过期
        if (Date.now() > ban.expiresAt) {
            this.unbanPlayer(playerId);
            return false;
        }

        return true;
    },

    /**
     * 获取玩家违规记录
     * @param {string} playerId - 玩家ID
     * @returns {Array} 违规记录
     */
    getPlayerViolations: function (playerId) {
        return this.acViolations.violations[playerId] || [];
    },

    /**
     * 重置玩家违规记录
     * @param {string} playerId - 玩家ID
     */
    resetPlayerViolations: function (playerId) {
        if (this.acViolations.violations[playerId]) {
            this.acViolations.violations[playerId] = [];
            this.saveACViolations();
        }
    },

    /**
     * 清理过期封禁
     */
    cleanupExpiredBans: function () {
        const now = Date.now();

        for (const playerId in this.acViolations.bannedPlayers) {
            const ban = this.acViolations.bannedPlayers[playerId];

            if (now > ban.expiresAt) {
                delete this.acViolations.bannedPlayers[playerId];
            }
        }

        this.saveACViolations();
    },

    /**
     * 获取玩家速度
     * @returns {number} 速度
     */
    getPlayerSpeed: function () {
        // 模拟获取玩家速度
        return 5;
    },

    /**
     * 获取玩家位置
     * @returns {Object} 位置
     */
    getPlayerPosition: function () {
        // 模拟获取玩家位置
        return { x: 100, y: 100 };
    },

    /**
     * 获取上次玩家位置
     * @returns {Object|null} 位置
     */
    getLastPlayerPosition: function () {
        // 模拟获取上次玩家位置
        return this.lastPlayerPosition || null;
    },

    /**
     * 设置上次玩家位置
     * @param {Object} position - 位置
     */
    setLastPlayerPosition: function (position) {
        this.lastPlayerPosition = position;
    },

    /**
     * 计算距离
     * @param {Object} pos1 - 位置1
     * @param {Object} pos2 - 位置2
     * @returns {number} 距离
     */
    calculateDistance: function (pos1, pos2) {
        const dx = pos1.x - pos2.x;
        const dy = pos1.y - pos2.y;

        return Math.sqrt(dx * dx + dy * dy);
    },

    /**
     * 获取玩家资源
     * @returns {number} 资源数量
     */
    getPlayerResources: function () {
        // 模拟获取玩家资源
        return 100;
    },

    /**
     * 获取玩家分数
     * @returns {number} 分数
     */
    getPlayerScore: function () {
        // 模拟获取玩家分数
        return 1000;
    },

    /**
     * 获取上次玩家分数
     * @returns {number|null} 分数
     */
    getLastPlayerScore: function () {
        // 模拟获取上次玩家分数
        return this.lastPlayerScore || null;
    },

    /**
     * 设置上次玩家分数
     * @param {number} score - 分数
     */
    setLastPlayerScore: function (score) {
        this.lastPlayerScore = score;
    },

    /**
     * 获取游戏时间
     * @returns {number} 游戏时间
     */
    getGameTime: function () {
        // 模拟获取游戏时间
        return Date.now() / 1000;
    },

    /**
     * 获取上次游戏时间
     * @returns {number|null} 游戏时间
     */
    getLastGameTime: function () {
        // 模拟获取上次游戏时间
        return this.lastGameTime || null;
    },

    /**
     * 设置上次游戏时间
     * @param {number} time - 游戏时间
     */
    setLastGameTime: function (time) {
        this.lastGameTime = time;
    },

    /**
     * 获取客户端哈希
     * @returns {string} 哈希值
     */
    getClientHash: function () {
        // 模拟获取客户端哈希
        return 'abc123';
    },

    /**
     * 获取当前玩家ID
     * @returns {string} 玩家ID
     */
    getCurrentPlayerId: function () {
        // 模拟获取当前玩家ID
        return 'player1';
    },

    /**
     * 保存防作弊历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    saveACHistory: function (action, data) {
        this.acHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.acHistory.length > this.maxHistorySize) {
            this.acHistory.shift();
        }
    },

    /**
     * 获取防作弊历史
     * @param {Object} options - 查询选项
     * @returns {Array} 防作弊历史
     */
    getACHistory: function (options) {
        let history = [...this.acHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 设置防作弊配置
     * @param {Object} config - 配置对象
     */
    setACConfig: function (config) {
        this.acConfig = { ...this.acConfig, ...config };
        this.saveACConfig();
    },

    /**
     * 获取防作弊配置
     * @returns {Object} 配置对象
     */
    getACConfig: function () {
        return this.acConfig;
    },

    /**
     * 重置防作弊系统
     */
    reset: function () {
        this.acHistory = [];
        this.loadACConfig();
        this.loadACViolations();
    },

    /**
     * 获取防作弊统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.acConfig.enabled,
            strictMode: this.acConfig.strictMode,
            autoBan: this.acConfig.autoBan,
            maxViolations: this.acConfig.maxViolations,
            totalViolations: Object.values(this.acViolations.violations).reduce((sum, v) => sum + v.length, 0),
            totalBannedPlayers: Object.keys(this.acViolations.bannedPlayers).length,
            totalHistory: this.acHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏隐私保护优化
const GamePrivacyOptimizer = {
    privacyConfig: {},
    privacyConsents: {},
    privacyHistory: [],
    maxHistorySize: 1000,

    /**
     * 初始化游戏隐私保护
     */
    init: function () {
        this.loadPrivacyConfig();
        this.loadPrivacyConsents();
    },

    /**
     * 加载隐私配置
     */
    loadPrivacyConfig: function () {
        this.privacyConfig = {
            enabled: true,
            maxHistorySize: 1000,
            requireConsent: true,
            consentVersion: '1.0',
            dataCollection: {
                enabled: true,
                types: ['gameplay', 'analytics', 'personalization']
            },
            dataSharing: {
                enabled: false,
                thirdParty: []
            },
            dataRetention: {
                enabled: true,
                duration: 2592000000 // 30天
            },
            dataDeletion: {
                enabled: true,
                autoDelete: false
            },
            anonymization: {
                enabled: true,
                methods: ['hashing', 'masking', 'generalization']
            }
        };

        const customConfig = localStorage.getItem('privacyConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.privacyConfig = { ...this.privacyConfig, ...config };
            } catch (error) {
                console.error('加载隐私配置失败:', error);
            }
        }
    },

    /**
     * 保存隐私配置
     */
    savePrivacyConfig: function () {
        localStorage.setItem('privacyConfig', JSON.stringify(this.privacyConfig));
    },

    /**
     * 加载隐私同意
     */
    loadPrivacyConsents: function () {
        const savedConsents = localStorage.getItem('privacyConsents');
        if (savedConsents) {
            try {
                this.privacyConsents = JSON.parse(savedConsents);
            } catch (error) {
                console.error('加载隐私同意失败:', error);
            }
        }

        if (!this.privacyConsents.consents) {
            this.privacyConsents = {
                consents: {},
                dataRequests: {},
                deletionRequests: {}
            };

            this.savePrivacyConsents();
        }
    },

    /**
     * 保存隐私同意
     */
    savePrivacyConsents: function () {
        localStorage.setItem('privacyConsents', JSON.stringify(this.privacyConsents));
    },

    /**
     * 请求隐私同意
     * @param {string} userId - 用户ID
     * @param {Array} consentTypes - 同意类型
     * @returns {Object} 同意结果
     */
    requestConsent: function (userId, consentTypes) {
        if (!this.privacyConfig.enabled) {
            return {
                success: false,
                error: '隐私保护已禁用'
            };
        }

        const consent = {
            userId: userId,
            consentTypes: consentTypes,
            version: this.privacyConfig.consentVersion,
            granted: false,
            timestamp: Date.now()
        };

        this.privacyConsents.consents[userId] = consent;
        this.savePrivacyConsents();

        this.savePrivacyHistory('consent_requested', {
            userId: userId,
            consentTypes: consentTypes
        });

        return {
            success: true,
            consent: consent
        };
    },

    /**
     * 授予隐私同意
     * @param {string} userId - 用户ID
     * @param {Array} consentTypes - 同意类型
     * @returns {Object} 同意结果
     */
    grantConsent: function (userId, consentTypes) {
        if (!this.privacyConfig.enabled) {
            return {
                success: false,
                error: '隐私保护已禁用'
            };
        }

        if (!this.privacyConsents.consents[userId]) {
            return {
                success: false,
                error: '未找到同意请求'
            };
        }

        this.privacyConsents.consents[userId].granted = true;
        this.privacyConsents.consents[userId].consentTypes = consentTypes;
        this.privacyConsents.consents[userId].grantedAt = Date.now();

        this.savePrivacyConsents();

        this.savePrivacyHistory('consent_granted', {
            userId: userId,
            consentTypes: consentTypes
        });

        return {
            success: true
        };
    },

    /**
     * 撤销隐私同意
     * @param {string} userId - 用户ID
     * @returns {Object} 撤销结果
     */
    revokeConsent: function (userId) {
        if (!this.privacyConfig.enabled) {
            return {
                success: false,
                error: '隐私保护已禁用'
            };
        }

        if (!this.privacyConsents.consents[userId]) {
            return {
                success: false,
                error: '未找到同意记录'
            };
        }

        this.privacyConsents.consents[userId].granted = false;
        this.privacyConsents.consents[userId].revokedAt = Date.now();

        this.savePrivacyConsents();

        this.savePrivacyHistory('consent_revoked', {
            userId: userId
        });

        return {
            success: true
        };
    },

    /**
     * 检查隐私同意
     * @param {string} userId - 用户ID
     * @param {string} consentType - 同意类型
     * @returns {boolean} 是否同意
     */
    hasConsent: function (userId, consentType) {
        const consent = this.privacyConsents.consents[userId];

        if (!consent || !consent.granted) {
            return false;
        }

        return consent.consentTypes.includes(consentType);
    },

    /**
     * 匿名化数据
     * @param {Object} data - 数据
     * @param {Array} fields - 要匿名的字段
     * @returns {Object} 匿名化后的数据
     */
    anonymizeData: function (data, fields) {
        if (!this.privacyConfig.anonymization.enabled) {
            return data;
        }

        const anonymizedData = { ...data };

        for (const field of fields) {
            if (anonymizedData[field]) {
                const method = this.privacyConfig.anonymization.methods[0];

                switch (method) {
                    case 'hashing':
                        anonymizedData[field] = this.hashValue(anonymizedData[field]);
                        break;
                    case 'masking':
                        anonymizedData[field] = this.maskValue(anonymizedData[field]);
                        break;
                    case 'generalization':
                        anonymizedData[field] = this.generalizeValue(anonymizedData[field]);
                        break;
                }
            }
        }

        return anonymizedData;
    },

    /**
     * 哈希值
     * @param {string} value - 值
     * @returns {string} 哈希值
     */
    hashValue: function (value) {
        let hash = 0;

        for (let i = 0; i < value.length; i++) {
            const char = value.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }

        return Math.abs(hash).toString(16);
    },

    /**
     * 掩码值
     * @param {string} value - 值
     * @returns {string} 掩码后的值
     */
    maskValue: function (value) {
        if (typeof value !== 'string') {
            return '***';
        }

        if (value.length <= 4) {
            return '***';
        }

        return value.substring(0, 2) + '***' + value.substring(value.length - 2);
    },

    /**
     * 泛化值
     * @param {string} value - 值
     * @returns {string} 泛化后的值
     */
    generalizeValue: function (value) {
        if (typeof value !== 'string') {
            return 'Unknown';
        }

        return 'Generalized';
    },

    /**
     * 请求数据访问
     * @param {string} userId - 用户ID
     * @param {string} requestType - 请求类型
     * @returns {Object} 请求结果
     */
    requestDataAccess: function (userId, requestType) {
        if (!this.privacyConfig.enabled) {
            return {
                success: false,
                error: '隐私保护已禁用'
            };
        }

        const requestId = 'request_' + Date.now();

        this.privacyConsents.dataRequests[requestId] = {
            userId: userId,
            requestType: requestType,
            status: 'pending',
            createdAt: Date.now()
        };

        this.savePrivacyConsents();

        this.savePrivacyHistory('data_access_requested', {
            userId: userId,
            requestType: requestType
        });

        return {
            success: true,
            requestId: requestId
        };
    },

    /**
     * 请求数据删除
     * @param {string} userId - 用户ID
     * @returns {Object} 请求结果
     */
    requestDataDeletion: function (userId) {
        if (!this.privacyConfig.enabled || !this.privacyConfig.dataDeletion.enabled) {
            return {
                success: false,
                error: '数据删除已禁用'
            };
        }

        const requestId = 'deletion_' + Date.now();

        this.privacyConsents.deletionRequests[requestId] = {
            userId: userId,
            status: 'pending',
            createdAt: Date.now()
        };

        this.savePrivacyConsents();

        this.savePrivacyHistory('data_deletion_requested', {
            userId: userId
        });

        return {
            success: true,
            requestId: requestId
        };
    },

    /**
     * 处理数据删除请求
     * @param {string} requestId - 请求ID
     * @returns {Object} 处理结果
     */
    processDeletionRequest: function (requestId) {
        const request = this.privacyConsents.deletionRequests[requestId];

        if (!request) {
            return {
                success: false,
                error: '请求不存在'
            };
        }

        // 模拟数据删除
        request.status = 'completed';
        request.completedAt = Date.now();

        this.savePrivacyConsents();

        this.savePrivacyHistory('data_deletion_completed', {
            userId: request.userId
        });

        return {
            success: true
        };
    },

    /**
     * 清理过期数据
     */
    cleanupExpiredData: function () {
        if (!this.privacyConfig.dataRetention.enabled) {
            return;
        }

        const now = Date.now();
        const retentionPeriod = this.privacyConfig.dataRetention.duration;

        // 清理过期的同意记录
        for (const userId in this.privacyConsents.consents) {
            const consent = this.privacyConsents.consents[userId];

            if (now - consent.timestamp > retentionPeriod) {
                delete this.privacyConsents.consents[userId];
            }
        }

        this.savePrivacyConsents();

        this.savePrivacyHistory('expired_data_cleaned', {});
    },

    /**
     * 获取隐私政策
     * @returns {Object} 隐私政策
     */
    getPrivacyPolicy: function () {
        return {
            version: this.privacyConfig.consentVersion,
            dataCollection: this.privacyConfig.dataCollection,
            dataSharing: this.privacyConfig.dataSharing,
            dataRetention: this.privacyConfig.dataRetention,
            dataDeletion: this.privacyConfig.dataDeletion,
            anonymization: this.privacyConfig.anonymization
        };
    },

    /**
     * 设置隐私配置
     * @param {Object} config - 配置对象
     */
    setPrivacyConfig: function (config) {
        this.privacyConfig = { ...this.privacyConfig, ...config };
        this.savePrivacyConfig();
    },

    /**
     * 获取隐私配置
     * @returns {Object} 配置对象
     */
    getPrivacyConfig: function () {
        return this.privacyConfig;
    },

    /**
     * 保存隐私历史
     * @param {string} action - 操作类型
     * @param {Object} data - 数据
     */
    savePrivacyHistory: function (action, data) {
        this.privacyHistory.push({
            timestamp: Date.now(),
            action: action,
            data: data
        });

        if (this.privacyHistory.length > this.maxHistorySize) {
            this.privacyHistory.shift();
        }
    },

    /**
     * 获取隐私历史
     * @param {Object} options - 查询选项
     * @returns {Array} 隐私历史
     */
    getPrivacyHistory: function (options) {
        let history = [...this.privacyHistory];

        if (options && options.action) {
            history = history.filter(h => h.action === options.action);
        }

        if (options && options.startTime) {
            history = history.filter(h => h.timestamp >= options.startTime);
        }

        if (options && options.endTime) {
            history = history.filter(h => h.timestamp <= options.endTime);
        }

        if (options && options.limit) {
            history = history.slice(-options.limit);
        }

        return history;
    },

    /**
     * 重置隐私保护系统
     */
    reset: function () {
        this.privacyHistory = [];
        this.loadPrivacyConfig();
        this.loadPrivacyConsents();
    },

    /**
     * 获取隐私保护统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.privacyConfig.enabled,
            requireConsent: this.privacyConfig.requireConsent,
            consentVersion: this.privacyConfig.consentVersion,
            dataCollectionEnabled: this.privacyConfig.dataCollection.enabled,
            dataSharingEnabled: this.privacyConfig.dataSharing.enabled,
            dataRetentionEnabled: this.privacyConfig.dataRetention.enabled,
            dataDeletionEnabled: this.privacyConfig.dataDeletion.enabled,
            anonymizationEnabled: this.privacyConfig.anonymization.enabled,
            totalConsents: Object.keys(this.privacyConsents.consents).length,
            totalDataRequests: Object.keys(this.privacyConsents.dataRequests).length,
            totalDeletionRequests: Object.keys(this.privacyConsents.deletionRequests).length,
            totalHistory: this.privacyHistory.length,
            maxHistorySize: this.maxHistorySize
        };
    }
};

// 优化：游戏数据备份优化
const GameDataBackupOptimizer = {
    backupConfig: {},
    backupHistory: {},
    backupSchedule: {},

    /**
     * 初始化游戏数据备份
     */
    init: function () {
        this.loadBackupConfig();
        this.loadBackupHistory();
        this.loadBackupSchedule();
        this.startScheduledBackups();
    },

    /**
     * 加载备份配置
     */
    loadBackupConfig: function () {
        this.backupConfig = {
            enabled: true,
            autoBackup: true,
            backupInterval: 3600000,
            maxBackups: 10,
            compressionEnabled: true,
            encryptionEnabled: false,
            backupLocation: 'local',
            cloudBackup: false,
            backupOnExit: true
        };

        const customConfig = localStorage.getItem('backupConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.backupConfig = { ...this.backupConfig, ...config };
            } catch (error) {
                console.error('加载备份配置失败:', error);
            }
        }
    },

    /**
     * 保存备份配置
     */
    saveBackupConfig: function () {
        localStorage.setItem('backupConfig', JSON.stringify(this.backupConfig));
    },

    /**
     * 加载备份历史
     */
    loadBackupHistory: function () {
        const savedHistory = localStorage.getItem('backupHistory');
        if (savedHistory) {
            try {
                this.backupHistory = JSON.parse(savedHistory);
            } catch (error) {
                console.error('加载备份历史失败:', error);
            }
        }

        if (!this.backupHistory.backups) {
            this.backupHistory = {
                backups: {}
            };

            this.saveBackupHistory();
        }
    },

    /**
     * 保存备份历史
     */
    saveBackupHistory: function () {
        localStorage.setItem('backupHistory', JSON.stringify(this.backupHistory));
    },

    /**
     * 加载备份计划
     */
    loadBackupSchedule: function () {
        const savedSchedule = localStorage.getItem('backupSchedule');
        if (savedSchedule) {
            try {
                this.backupSchedule = JSON.parse(savedSchedule);
            } catch (error) {
                console.error('加载备份计划失败:', error);
            }
        }

        if (!this.backupSchedule.schedules) {
            this.backupSchedule = {
                schedules: {}
            };

            this.saveBackupSchedule();
        }
    },

    /**
     * 保存备份计划
     */
    saveBackupSchedule: function () {
        localStorage.setItem('backupSchedule', JSON.stringify(this.backupSchedule));
    },

    /**
     * 创建备份
     * @param {string} backupName - 备份名称
     * @returns {Object} 备份结果
     */
    createBackup: function (backupName) {
        if (!this.backupConfig.enabled) {
            return {
                success: false,
                error: '备份已禁用'
            };
        }

        const backupId = 'backup_' + Date.now();
        const name = backupName || 'backup_' + new Date().toISOString();

        // 收集游戏数据
        const gameData = this.collectGameData();

        // 压缩数据
        let backupData = gameData;

        if (this.backupConfig.compressionEnabled) {
            backupData = this.compressData(backupData);
        }

        // 加密数据
        if (this.backupConfig.encryptionEnabled) {
            backupData = this.encryptData(backupData);
        }

        // 创建备份记录
        const backup = {
            id: backupId,
            name: name,
            data: backupData,
            compressed: this.backupConfig.compressionEnabled,
            encrypted: this.backupConfig.encryptionEnabled,
            createdAt: Date.now(),
            size: JSON.stringify(backupData).length
        };

        this.backupHistory.backups[backupId] = backup;

        // 清理旧备份
        this.cleanupOldBackups();

        this.saveBackupHistory();

        return {
            success: true,
            backup: backup
        };
    },

    /**
     * 收集游戏数据
     * @returns {Object} 游戏数据
     */
    collectGameData: function () {
        const gameData = {};

        // 收集localStorage数据
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            gameData[key] = localStorage.getItem(key);
        }

        // 收集游戏状态
        if (window.StickmanAdventure && StickmanAdventure.game) {
            gameData.gameState = StickmanAdventure.game;
        }

        return gameData;
    },

    /**
     * 压缩数据
     * @param {Object} data - 数据
     * @returns {Object} 压缩后的数据
     */
    compressData: function (data) {
        // 简化的压缩（实际应用中应该使用真实的压缩算法）
        const jsonString = JSON.stringify(data);

        return {
            compressed: true,
            data: jsonString,
            originalSize: jsonString.length
        };
    },

    /**
     * 加密数据
     * @param {Object} data - 数据
     * @returns {Object} 加密后的数据
     */
    encryptData: function (data) {
        // 简化的加密（实际应用中应该使用真实的加密算法）
        const jsonString = JSON.stringify(data);

        let encrypted = '';

        for (let i = 0; i < jsonString.length; i++) {
            const charCode = jsonString.charCodeAt(i);
            encrypted += String.fromCharCode(charCode ^ 42);
        }

        return {
            encrypted: true,
            data: encrypted
        };
    },

    /**
     * 解密数据
     * @param {Object} data - 数据
     * @returns {Object} 解密后的数据
     */
    decryptData: function (data) {
        if (!data.encrypted) {
            return data;
        }

        let decrypted = '';

        for (let i = 0; i < data.data.length; i++) {
            const charCode = data.data.charCodeAt(i);
            decrypted += String.fromCharCode(charCode ^ 42);
        }

        return JSON.parse(decrypted);
    },

    /**
     * 解压数据
     * @param {Object} data - 数据
     * @returns {Object} 解压后的数据
     */
    decompressData: function (data) {
        if (!data.compressed) {
            return data;
        }

        return JSON.parse(data.data);
    },

    /**
     * 恢复备份
     * @param {string} backupId - 备份ID
     * @returns {Object} 恢复结果
     */
    restoreBackup: function (backupId) {
        if (!this.backupConfig.enabled) {
            return {
                success: false,
                error: '备份已禁用'
            };
        }

        const backup = this.backupHistory.backups[backupId];

        if (!backup) {
            return {
                success: false,
                error: '备份不存在'
            };
        }

        // 解密数据
        let restoreData = backup.data;

        if (backup.encrypted) {
            restoreData = this.decryptData(restoreData);
        }

        // 解压数据
        if (backup.compressed) {
            restoreData = this.decompressData(restoreData);
        }

        // 恢复数据
        this.restoreGameData(restoreData);

        return {
            success: true,
            backup: backup
        };
    },

    /**
     * 恢复游戏数据
     * @param {Object} data - 数据
     */
    restoreGameData: function (data) {
        // 恢复localStorage数据
        for (const key in data) {
            if (key !== 'gameState') {
                localStorage.setItem(key, data[key]);
            }
        }

        // 恢复游戏状态
        if (data.gameState && window.StickmanAdventure) {
            StickmanAdventure.game = data.gameState;
        }
    },

    /**
     * 删除备份
     * @param {string} backupId - 备份ID
     * @returns {Object} 删除结果
     */
    deleteBackup: function (backupId) {
        if (!this.backupHistory.backups[backupId]) {
            return {
                success: false,
                error: '备份不存在'
            };
        }

        delete this.backupHistory.backups[backupId];
        this.saveBackupHistory();

        return {
            success: true
        };
    },

    /**
     * 获取备份
     * @param {string} backupId - 备份ID
     * @returns {Object|null} 备份对象
     */
    getBackup: function (backupId) {
        return this.backupHistory.backups[backupId] || null;
    },

    /**
     * 获取所有备份
     * @returns {Array} 备份列表
     */
    getAllBackups: function () {
        return Object.values(this.backupHistory.backups);
    },

    /**
     * 清理旧备份
     */
    cleanupOldBackups: function () {
        const backups = Object.values(this.backupHistory.backups);

        if (backups.length <= this.backupConfig.maxBackups) {
            return;
        }

        // 按创建时间排序
        backups.sort((a, b) => a.createdAt - b.createdAt);

        // 删除最旧的备份
        const backupsToDelete = backups.slice(0, backups.length - this.backupConfig.maxBackups);

        for (const backup of backupsToDelete) {
            delete this.backupHistory.backups[backup.id];
        }

        this.saveBackupHistory();
    },

    /**
     * 添加备份计划
     * @param {string} scheduleId - 计划ID
     * @param {Object} schedule - 计划对象
     */
    addBackupSchedule: function (scheduleId, schedule) {
        this.backupSchedule.schedules[scheduleId] = {
            id: scheduleId,
            name: schedule.name,
            interval: schedule.interval,
            lastBackup: null,
            nextBackup: Date.now() + schedule.interval,
            enabled: true
        };

        this.saveBackupSchedule();
    },

    /**
     * 移除备份计划
     * @param {string} scheduleId - 计划ID
     */
    removeBackupSchedule: function (scheduleId) {
        if (this.backupSchedule.schedules[scheduleId]) {
            delete this.backupSchedule.schedules[scheduleId];
            this.saveBackupSchedule();
        }
    },

    /**
     * 开始计划备份
     */
    startScheduledBackups: function () {
        setInterval(() => {
            if (!this.backupConfig.enabled || !this.backupConfig.autoBackup) {
                return;
            }

            const now = Date.now();

            for (const scheduleId in this.backupSchedule.schedules) {
                const schedule = this.backupSchedule.schedules[scheduleId];

                if (!schedule.enabled) {
                    continue;
                }

                if (now >= schedule.nextBackup) {
                    this.createBackup(schedule.name);

                    schedule.lastBackup = now;
                    schedule.nextBackup = now + schedule.interval;

                    this.saveBackupSchedule();
                }
            }
        }, 60000); // 每分钟检查一次
    },

    /**
     * 导出备份
     * @param {string} backupId - 备份ID
     * @returns {Object} 导出结果
     */
    exportBackup: function (backupId) {
        const backup = this.backupHistory.backups[backupId];

        if (!backup) {
            return {
                success: false,
                error: '备份不存在'
            };
        }

        const exportData = {
            backup: backup,
            exportedAt: Date.now()
        };

        const jsonString = JSON.stringify(exportData);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `${backup.name}.json`;
        a.click();

        URL.revokeObjectURL(url);

        return {
            success: true
        };
    },

    /**
     * 导入备份
     * @param {File} file - 文件
     * @returns {Promise<Object>} 导入结果
     */
    importBackup: function (file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();

            reader.onload = (event) => {
                try {
                    const importData = JSON.parse(event.target.result);
                    const backup = importData.backup;

                    const backupId = 'imported_' + Date.now();

                    this.backupHistory.backups[backupId] = backup;
                    this.saveBackupHistory();

                    resolve({
                        success: true,
                        backup: backup
                    });
                } catch (error) {
                    reject({
                        success: false,
                        error: '导入失败'
                    });
                }
            };

            reader.onerror = () => {
                reject({
                    success: false,
                    error: '读取文件失败'
                });
            };

            reader.readAsText(file);
        });
    },

    /**
     * 设置备份配置
     * @param {Object} config - 配置对象
     */
    setBackupConfig: function (config) {
        this.backupConfig = { ...this.backupConfig, ...config };
        this.saveBackupConfig();
    },

    /**
     * 获取备份配置
     * @returns {Object} 配置对象
     */
    getBackupConfig: function () {
        return this.backupConfig;
    },

    /**
     * 获取备份统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const backups = Object.values(this.backupHistory.backups);
        const totalSize = backups.reduce((sum, backup) => sum + backup.size, 0);

        return {
            enabled: this.backupConfig.enabled,
            autoBackup: this.backupConfig.autoBackup,
            backupInterval: this.backupConfig.backupInterval,
            maxBackups: this.backupConfig.maxBackups,
            compressionEnabled: this.backupConfig.compressionEnabled,
            encryptionEnabled: this.backupConfig.encryptionEnabled,
            totalBackups: backups.length,
            totalSize: totalSize,
            activeSchedules: Object.values(this.backupSchedule.schedules).filter(s => s.enabled).length
        };
    }
};

// 优化：游戏数据恢复优化
const GameDataRecoveryOptimizer = {
    recoveryConfig: {},
    recoveryHistory: {},
    recoveryPoints: {},

    /**
     * 初始化游戏数据恢复
     */
    init: function () {
        this.loadRecoveryConfig();
        this.loadRecoveryHistory();
        this.loadRecoveryPoints();
        this.startAutoRecovery();
    },

    /**
     * 加载恢复配置
     */
    loadRecoveryConfig: function () {
        this.recoveryConfig = {
            enabled: true,
            autoRecovery: true,
            autoSaveInterval: 60000,
            maxRecoveryPoints: 20,
            recoveryOnCrash: true,
            recoveryOnExit: false,
            quickSave: true,
            quickLoad: true
        };

        const customConfig = localStorage.getItem('recoveryConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.recoveryConfig = { ...this.recoveryConfig, ...config };
            } catch (error) {
                console.error('加载恢复配置失败:', error);
            }
        }
    },

    /**
     * 保存恢复配置
     */
    saveRecoveryConfig: function () {
        localStorage.setItem('recoveryConfig', JSON.stringify(this.recoveryConfig));
    },

    /**
     * 加载恢复历史
     */
    loadRecoveryHistory: function () {
        const savedHistory = localStorage.getItem('recoveryHistory');
        if (savedHistory) {
            try {
                this.recoveryHistory = JSON.parse(savedHistory);
            } catch (error) {
                console.error('加载恢复历史失败:', error);
            }
        }

        if (!this.recoveryHistory.recoveries) {
            this.recoveryHistory = {
                recoveries: {}
            };

            this.saveRecoveryHistory();
        }
    },

    /**
     * 保存恢复历史
     */
    saveRecoveryHistory: function () {
        localStorage.setItem('recoveryHistory', JSON.stringify(this.recoveryHistory));
    },

    /**
     * 加载恢复点
     */
    loadRecoveryPoints: function () {
        const savedPoints = localStorage.getItem('recoveryPoints');
        if (savedPoints) {
            try {
                this.recoveryPoints = JSON.parse(savedPoints);
            } catch (error) {
                console.error('加载恢复点失败:', error);
            }
        }

        if (!this.recoveryPoints.points) {
            this.recoveryPoints = {
                points: {},
                autoSavePoint: null,
                quickSavePoint: null
            };

            this.saveRecoveryPoints();
        }
    },

    /**
     * 保存恢复点
     */
    saveRecoveryPoints: function () {
        localStorage.setItem('recoveryPoints', JSON.stringify(this.recoveryPoints));
    },

    /**
     * 创建恢复点
     * @param {string} pointName - 恢复点名称
     * @returns {Object} 恢复点
     */
    createRecoveryPoint: function (pointName) {
        if (!this.recoveryConfig.enabled) {
            return null;
        }

        const pointId = 'point_' + Date.now();
        const name = pointName || 'recovery_' + new Date().toISOString();

        // 收集游戏状态
        const gameState = this.captureGameState();

        // 创建恢复点
        const point = {
            id: pointId,
            name: name,
            gameState: gameState,
            createdAt: Date.now(),
            screenshot: this.captureScreenshot()
        };

        this.recoveryPoints.points[pointId] = point;

        // 清理旧恢复点
        this.cleanupOldRecoveryPoints();

        this.saveRecoveryPoints();

        return point;
    },

    /**
     * 捕获游戏状态
     * @returns {Object} 游戏状态
     */
    captureGameState: function () {
        const gameState = {};

        // 捕获游戏对象状态
        if (window.StickmanAdventure && StickmanAdventure.game) {
            gameState.game = {
                score: StickmanAdventure.game.score,
                level: StickmanAdventure.game.level,
                lives: StickmanAdventure.game.lives,
                time: StickmanAdventure.game.time,
                player: {
                    x: StickmanAdventure.game.player.x,
                    y: StickmanAdventure.game.player.y,
                    health: StickmanAdventure.game.player.health
                },
                enemies: StickmanAdventure.game.enemies.map(enemy => ({
                    x: enemy.x,
                    y: enemy.y,
                    type: enemy.type,
                    health: enemy.health
                })),
                items: StickmanAdventure.game.items.map(item => ({
                    x: item.x,
                    y: item.y,
                    type: item.type,
                    collected: item.collected
                }))
            };
        }

        // 捕获localStorage状态
        gameState.localStorage = {};

        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            gameState.localStorage[key] = localStorage.getItem(key);
        }

        return gameState;
    },

    /**
     * 捕获截图
     * @returns {string|null} 截图数据
     */
    captureScreenshot: function () {
        try {
            const canvas = document.getElementById('gameCanvas');

            if (canvas) {
                return canvas.toDataURL('image/png');
            }
        } catch (error) {
            console.error('捕获截图失败:', error);
        }

        return null;
    },

    /**
     * 恢复到恢复点
     * @param {string} pointId - 恢复点ID
     * @returns {Object} 恢复结果
     */
    recoverToPoint: function (pointId) {
        if (!this.recoveryConfig.enabled) {
            return {
                success: false,
                error: '恢复已禁用'
            };
        }

        const point = this.recoveryPoints.points[pointId];

        if (!point) {
            return {
                success: false,
                error: '恢复点不存在'
            };
        }

        // 恢复游戏状态
        this.restoreGameState(point.gameState);

        // 记录恢复历史
        const recoveryId = 'recovery_' + Date.now();

        this.recoveryHistory.recoveries[recoveryId] = {
            id: recoveryId,
            pointId: pointId,
            pointName: point.name,
            recoveredAt: Date.now()
        };

        this.saveRecoveryHistory();

        return {
            success: true,
            point: point
        };
    },

    /**
     * 恢复游戏状态
     * @param {Object} gameState - 游戏状态
     */
    restoreGameState: function (gameState) {
        // 恢复游戏对象状态
        if (gameState.game && window.StickmanAdventure && StickmanAdventure.game) {
            StickmanAdventure.game.score = gameState.game.score;
            StickmanAdventure.game.level = gameState.game.level;
            StickmanAdventure.game.lives = gameState.game.lives;
            StickmanAdventure.game.time = gameState.game.time;

            if (gameState.game.player) {
                StickmanAdventure.game.player.x = gameState.game.player.x;
                StickmanAdventure.game.player.y = gameState.game.player.y;
                StickmanAdventure.game.player.health = gameState.game.player.health;
            }

            if (gameState.game.enemies) {
                StickmanAdventure.game.enemies = gameState.game.enemies.map(enemyData => ({
                    x: enemyData.x,
                    y: enemyData.y,
                    type: enemyData.type,
                    health: enemyData.health
                }));
            }

            if (gameState.game.items) {
                StickmanAdventure.game.items = gameState.game.items.map(itemData => ({
                    x: itemData.x,
                    y: itemData.y,
                    type: itemData.type,
                    collected: itemData.collected
                }));
            }
        }

        // 恢复localStorage状态
        if (gameState.localStorage) {
            for (const key in gameState.localStorage) {
                localStorage.setItem(key, gameState.localStorage[key]);
            }
        }
    },

    /**
     * 快速保存
     */
    quickSave: function () {
        if (!this.recoveryConfig.quickSave) {
            return null;
        }

        const point = this.createRecoveryPoint('quick_save');

        if (point) {
            this.recoveryPoints.quickSavePoint = point.id;
            this.saveRecoveryPoints();
        }

        return point;
    },

    /**
     * 快速加载
     * @returns {Object} 加载结果
     */
    quickLoad: function () {
        if (!this.recoveryConfig.quickLoad) {
            return {
                success: false,
                error: '快速加载已禁用'
            };
        }

        const pointId = this.recoveryPoints.quickSavePoint;

        if (!pointId) {
            return {
                success: false,
                error: '没有快速保存点'
            };
        }

        return this.recoverToPoint(pointId);
    },

    /**
     * 自动保存
     */
    autoSave: function () {
        if (!this.recoveryConfig.autoRecovery) {
            return;
        }

        const point = this.createRecoveryPoint('auto_save');

        if (point) {
            this.recoveryPoints.autoSavePoint = point.id;
            this.saveRecoveryPoints();
        }
    },

    /**
     * 开始自动恢复
     */
    startAutoRecovery: function () {
        setInterval(() => {
            if (this.recoveryConfig.enabled && this.recoveryConfig.autoRecovery) {
                this.autoSave();
            }
        }, this.recoveryConfig.autoSaveInterval);
    },

    /**
     * 删除恢复点
     * @param {string} pointId - 恢复点ID
     * @returns {boolean} 是否成功
     */
    deleteRecoveryPoint: function (pointId) {
        if (!this.recoveryPoints.points[pointId]) {
            return false;
        }

        delete this.recoveryPoints.points[pointId];
        this.saveRecoveryPoints();

        return true;
    },

    /**
     * 获取恢复点
     * @param {string} pointId - 恢复点ID
     * @returns {Object|null} 恢复点对象
     */
    getRecoveryPoint: function (pointId) {
        return this.recoveryPoints.points[pointId] || null;
    },

    /**
     * 获取所有恢复点
     * @returns {Array} 恢复点列表
     */
    getAllRecoveryPoints: function () {
        return Object.values(this.recoveryPoints.points);
    },

    /**
     * 清理旧恢复点
     */
    cleanupOldRecoveryPoints: function () {
        const points = Object.values(this.recoveryPoints.points);

        if (points.length <= this.recoveryConfig.maxRecoveryPoints) {
            return;
        }

        // 按创建时间排序
        points.sort((a, b) => a.createdAt - b.createdAt);

        // 删除最旧的恢复点
        const pointsToDelete = points.slice(0, points.length - this.recoveryConfig.maxRecoveryPoints);

        for (const point of pointsToDelete) {
            delete this.recoveryPoints.points[point.id];
        }

        this.saveRecoveryPoints();
    },

    /**
     * 检测崩溃
     */
    detectCrash: function () {
        if (!this.recoveryConfig.recoveryOnCrash) {
            return;
        }

        // 检测游戏是否崩溃
        if (window.StickmanAdventure && StickmanAdventure.game && !StickmanAdventure.game.running) {
            // 恢复到自动保存点
            if (this.recoveryPoints.autoSavePoint) {
                this.recoverToPoint(this.recoveryPoints.autoSavePoint);
            }
        }
    },

    /**
     * 设置恢复配置
     * @param {Object} config - 配置对象
     */
    setRecoveryConfig: function (config) {
        this.recoveryConfig = { ...this.recoveryConfig, ...config };
        this.saveRecoveryConfig();
    },

    /**
     * 获取恢复配置
     * @returns {Object} 配置对象
     */
    getRecoveryConfig: function () {
        return this.recoveryConfig;
    },

    /**
     * 获取恢复统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const points = Object.values(this.recoveryPoints.points);
        const recoveries = Object.values(this.recoveryHistory.recoveries);

        return {
            enabled: this.recoveryConfig.enabled,
            autoRecovery: this.recoveryConfig.autoRecovery,
            autoSaveInterval: this.recoveryConfig.autoSaveInterval,
            maxRecoveryPoints: this.recoveryConfig.maxRecoveryPoints,
            recoveryOnCrash: this.recoveryConfig.recoveryOnCrash,
            quickSaveEnabled: this.recoveryConfig.quickSave,
            quickLoadEnabled: this.recoveryConfig.quickLoad,
            totalRecoveryPoints: points.length,
            hasAutoSavePoint: !!this.recoveryPoints.autoSavePoint,
            hasQuickSavePoint: !!this.recoveryPoints.quickSavePoint,
            totalRecoveries: recoveries.length
        };
    }
};

// 优化：游戏数据迁移优化
const GameDataMigrationOptimizer = {
    migrationConfig: {},
    migrationHistory: {},
    migrationTasks: {},

    /**
     * 初始化游戏数据迁移
     */
    init: function () {
        this.loadMigrationConfig();
        this.loadMigrationHistory();
        this.loadMigrationTasks();
    },

    /**
     * 加载迁移配置
     */
    loadMigrationConfig: function () {
        this.migrationConfig = {
            enabled: true,
            autoMigrate: false,
            validateBeforeMigrate: true,
            backupBeforeMigrate: true,
            migrationTimeout: 300000,
            maxRetries: 3,
            retryInterval: 5000
        };

        const customConfig = localStorage.getItem('migrationConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.migrationConfig = { ...this.migrationConfig, ...config };
            } catch (error) {
                console.error('加载迁移配置失败:', error);
            }
        }
    },

    /**
     * 保存迁移配置
     */
    saveMigrationConfig: function () {
        localStorage.setItem('migrationConfig', JSON.stringify(this.migrationConfig));
    },

    /**
     * 加载迁移历史
     */
    loadMigrationHistory: function () {
        const savedHistory = localStorage.getItem('migrationHistory');
        if (savedHistory) {
            try {
                this.migrationHistory = JSON.parse(savedHistory);
            } catch (error) {
                console.error('加载迁移历史失败:', error);
            }
        }

        if (!this.migrationHistory.migrations) {
            this.migrationHistory = {
                migrations: {}
            };

            this.saveMigrationHistory();
        }
    },

    /**
     * 保存迁移历史
     */
    saveMigrationHistory: function () {
        localStorage.setItem('migrationHistory', JSON.stringify(this.migrationHistory));
    },

    /**
     * 加载迁移任务
     */
    loadMigrationTasks: function () {
        const savedTasks = localStorage.getItem('migrationTasks');
        if (savedTasks) {
            try {
                this.migrationTasks = JSON.parse(savedTasks);
            } catch (error) {
                console.error('加载迁移任务失败:', error);
            }
        }

        if (!this.migrationTasks.tasks) {
            this.migrationTasks = {
                tasks: {}
            };

            this.saveMigrationTasks();
        }
    },

    /**
     * 保存迁移任务
     */
    saveMigrationTasks: function () {
        localStorage.setItem('migrationTasks', JSON.stringify(this.migrationTasks));
    },

    /**
     * 创建迁移任务
     * @param {string} taskName - 任务名称
     * @param {Object} source - 源配置
     * @param {Object} target - 目标配置
     * @returns {Object} 迁移任务
     */
    createMigrationTask: function (taskName, source, target) {
        if (!this.migrationConfig.enabled) {
            return {
                success: false,
                error: '迁移已禁用'
            };
        }

        const taskId = 'migration_' + Date.now();

        const task = {
            id: taskId,
            name: taskName,
            source: source,
            target: target,
            status: 'pending',
            createdAt: Date.now(),
            startedAt: null,
            completedAt: null,
            progress: 0,
            errors: [],
            retries: 0
        };

        this.migrationTasks.tasks[taskId] = task;
        this.saveMigrationTasks();

        return {
            success: true,
            task: task
        };
    },

    /**
     * 执行迁移任务
     * @param {string} taskId - 任务ID
     * @returns {Promise<Object>} 迁移结果
     */
    executeMigrationTask: function (taskId) {
        return new Promise((resolve, reject) => {
            if (!this.migrationConfig.enabled) {
                reject({
                    success: false,
                    error: '迁移已禁用'
                });
                return;
            }

            const task = this.migrationTasks.tasks[taskId];

            if (!task) {
                reject({
                    success: false,
                    error: '任务不存在'
                });
                return;
            }

            // 开始迁移
            task.status = 'running';
            task.startedAt = Date.now();
            this.saveMigrationTasks();

            // 验证源数据
            if (this.migrationConfig.validateBeforeMigrate) {
                const validation = this.validateSource(task.source);

                if (!validation.valid) {
                    task.status = 'failed';
                    task.completedAt = Date.now();
                    task.errors.push(validation.error);
                    this.saveMigrationTasks();

                    reject({
                        success: false,
                        error: '源数据验证失败: ' + validation.error
                    });
                    return;
                }
            }

            // 备份数据
            if (this.migrationConfig.backupBeforeMigrate) {
                const backup = this.createBackup(task.source);

                if (!backup.success) {
                    task.status = 'failed';
                    task.completedAt = Date.now();
                    task.errors.push('备份失败');
                    this.saveMigrationTasks();

                    reject({
                        success: false,
                        error: '备份失败'
                    });
                    return;
                }
            }

            // 提取数据
            const data = this.extractData(task.source);

            // 转换数据
            const transformedData = this.transformData(data, task.source, task.target);

            // 加载数据
            const loadResult = this.loadData(transformedData, task.target);

            if (!loadResult.success) {
                task.status = 'failed';
                task.completedAt = Date.now();
                task.errors.push(loadResult.error);
                this.saveMigrationTasks();

                reject({
                    success: false,
                    error: '加载数据失败: ' + loadResult.error
                });
                return;
            }

            // 完成迁移
            task.status = 'completed';
            task.completedAt = Date.now();
            task.progress = 100;
            this.saveMigrationTasks();

            // 记录迁移历史
            this.recordMigration(task);

            resolve({
                success: true,
                task: task
            });
        });
    },

    /**
     * 验证源数据
     * @param {Object} source - 源配置
     * @returns {Object} 验证结果
     */
    validateSource: function (source) {
        // 模拟验证
        return {
            valid: true
        };
    },

    /**
     * 创建备份
     * @param {Object} source - 源配置
     * @returns {Object} 备份结果
     */
    createBackup: function (source) {
        // 模拟备份
        return {
            success: true
        };
    },

    /**
     * 提取数据
     * @param {Object} source - 源配置
     * @returns {Object} 数据
     */
    extractData: function (source) {
        const data = {};

        // 从localStorage提取数据
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            data[key] = localStorage.getItem(key);
        }

        // 提取游戏状态
        if (window.StickmanAdventure && StickmanAdventure.game) {
            data.gameState = JSON.parse(JSON.stringify(StickmanAdventure.game));
        }

        return data;
    },

    /**
     * 转换数据
     * @param {Object} data - 数据
     * @param {Object} source - 源配置
     * @param {Object} target - 目标配置
     * @returns {Object} 转换后的数据
     */
    transformData: function (data, source, target) {
        // 模拟数据转换
        const transformedData = { ...data };

        // 根据源和目标类型进行转换
        if (source.type === 'localStorage' && target.type === 'json') {
            // 转换为JSON格式
            transformedData.format = 'json';
        }

        return transformedData;
    },

    /**
     * 加载数据
     * @param {Object} data - 数据
     * @param {Object} target - 目标配置
     * @returns {Object} 加载结果
     */
    loadData: function (data, target) {
        // 模拟加载数据
        return {
            success: true
        };
    },

    /**
     * 记录迁移
     * @param {Object} task - 任务对象
     */
    recordMigration: function (task) {
        const migrationId = 'migration_' + Date.now();

        this.migrationHistory.migrations[migrationId] = {
            id: migrationId,
            taskId: task.id,
            taskName: task.name,
            source: task.source,
            target: task.target,
            status: task.status,
            startedAt: task.startedAt,
            completedAt: task.completedAt,
            errors: task.errors
        };

        this.saveMigrationHistory();
    },

    /**
     * 取消迁移任务
     * @param {string} taskId - 任务ID
     * @returns {Object} 取消结果
     */
    cancelMigrationTask: function (taskId) {
        const task = this.migrationTasks.tasks[taskId];

        if (!task) {
            return {
                success: false,
                error: '任务不存在'
            };
        }

        if (task.status !== 'pending') {
            return {
                success: false,
                error: '任务已开始，无法取消'
            };
        }

        task.status = 'cancelled';
        task.completedAt = Date.now();
        this.saveMigrationTasks();

        return {
            success: true
        };
    },

    /**
     * 重试迁移任务
     * @param {string} taskId - 任务ID
     * @returns {Promise<Object>} 重试结果
     */
    retryMigrationTask: function (taskId) {
        return new Promise((resolve, reject) => {
            const task = this.migrationTasks.tasks[taskId];

            if (!task) {
                reject({
                    success: false,
                    error: '任务不存在'
                });
                return;
            }

            if (task.retries >= this.migrationConfig.maxRetries) {
                reject({
                    success: false,
                    error: '已达到最大重试次数'
                });
                return;
            }

            // 重置任务状态
            task.status = 'pending';
            task.errors = [];
            task.retries++;
            this.saveMigrationTasks();

            // 延迟后重试
            setTimeout(() => {
                this.executeMigrationTask(taskId)
                    .then(resolve)
                    .catch(reject);
            }, this.migrationConfig.retryInterval);
        });
    },

    /**
     * 获取迁移任务
     * @param {string} taskId - 任务ID
     * @returns {Object|null} 任务对象
     */
    getMigrationTask: function (taskId) {
        return this.migrationTasks.tasks[taskId] || null;
    },

    /**
     * 获取所有迁移任务
     * @returns {Array} 任务列表
     */
    getAllMigrationTasks: function () {
        return Object.values(this.migrationTasks.tasks);
    },

    /**
     * 获取迁移历史
     * @returns {Array} 迁移历史
     */
    getMigrationHistory: function () {
        return Object.values(this.migrationHistory.migrations);
    },

    /**
     * 清理完成的任务
     */
    cleanupCompletedTasks: function () {
        for (const taskId in this.migrationTasks.tasks) {
            const task = this.migrationTasks.tasks[taskId];

            if (task.status === 'completed' || task.status === 'failed' || task.status === 'cancelled') {
                delete this.migrationTasks.tasks[taskId];
            }
        }

        this.saveMigrationTasks();
    },

    /**
     * 设置迁移配置
     * @param {Object} config - 配置对象
     */
    setMigrationConfig: function (config) {
        this.migrationConfig = { ...this.migrationConfig, ...config };
        this.saveMigrationConfig();
    },

    /**
     * 获取迁移配置
     * @returns {Object} 配置对象
     */
    getMigrationConfig: function () {
        return this.migrationConfig;
    },

    /**
     * 获取迁移统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const tasks = Object.values(this.migrationTasks.tasks);
        const migrations = Object.values(this.migrationHistory.migrations);

        return {
            enabled: this.migrationConfig.enabled,
            autoMigrate: this.migrationConfig.autoMigrate,
            validateBeforeMigrate: this.migrationConfig.validateBeforeMigrate,
            backupBeforeMigrate: this.migrationConfig.backupBeforeMigrate,
            totalTasks: tasks.length,
            pendingTasks: tasks.filter(t => t.status === 'pending').length,
            runningTasks: tasks.filter(t => t.status === 'running').length,
            completedTasks: tasks.filter(t => t.status === 'completed').length,
            failedTasks: tasks.filter(t => t.status === 'failed').length,
            totalMigrations: migrations.length,
            successfulMigrations: migrations.filter(m => m.status === 'completed').length,
            failedMigrations: migrations.filter(m => m.status === 'failed').length
        };
    }
};

// 优化：游戏数据同步优化
const GameDataSyncOptimizer = {
    syncConfig: {},
    syncHistory: {},
    syncQueues: {},

    /**
     * 初始化游戏数据同步
     */
    init: function () {
        this.loadSyncConfig();
        this.loadSyncHistory();
        this.loadSyncQueues();
        this.startAutoSync();
    },

    /**
     * 加载同步配置
     */
    loadSyncConfig: function () {
        this.syncConfig = {
            enabled: true,
            autoSync: true,
            syncInterval: 60000,
            syncOnStart: false,
            syncOnExit: true,
            syncOnDataChange: true,
            conflictResolution: 'timestamp',
            maxRetries: 3,
            retryInterval: 5000,
            syncEndpoints: []
        };

        const customConfig = localStorage.getItem('syncConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.syncConfig = { ...this.syncConfig, ...config };
            } catch (error) {
                console.error('加载同步配置失败:', error);
            }
        }
    },

    /**
     * 保存同步配置
     */
    saveSyncConfig: function () {
        localStorage.setItem('syncConfig', JSON.stringify(this.syncConfig));
    },

    /**
     * 加载同步历史
     */
    loadSyncHistory: function () {
        const savedHistory = localStorage.getItem('syncHistory');
        if (savedHistory) {
            try {
                this.syncHistory = JSON.parse(savedHistory);
            } catch (error) {
                console.error('加载同步历史失败:', error);
            }
        }

        if (!this.syncHistory.syncs) {
            this.syncHistory = {
                syncs: {}
            };

            this.saveSyncHistory();
        }
    },

    /**
     * 保存同步历史
     */
    saveSyncHistory: function () {
        localStorage.setItem('syncHistory', JSON.stringify(this.syncHistory));
    },

    /**
     * 加载同步队列
     */
    loadSyncQueues: function () {
        const savedQueues = localStorage.getItem('syncQueues');
        if (savedQueues) {
            try {
                this.syncQueues = JSON.parse(savedQueues);
            } catch (error) {
                console.error('加载同步队列失败:', error);
            }
        }

        if (!this.syncQueues.queues) {
            this.syncQueues = {
                queues: {},
                pending: [],
                processing: [],
                completed: [],
                failed: []
            };

            this.saveSyncQueues();
        }
    },

    /**
     * 保存同步队列
     */
    saveSyncQueues: function () {
        localStorage.setItem('syncQueues', JSON.stringify(this.syncQueues));
    },

    /**
     * 添加同步端点
     * @param {string} endpointId - 端点ID
     * @param {Object} endpoint - 端点配置
     */
    addSyncEndpoint: function (endpointId, endpoint) {
        this.syncConfig.syncEndpoints.push({
            id: endpointId,
            url: endpoint.url,
            method: endpoint.method || 'POST',
            headers: endpoint.headers || {},
            authentication: endpoint.authentication || null
        });

        this.saveSyncConfig();
    },

    /**
     * 移除同步端点
     * @param {string} endpointId - 端点ID
     */
    removeSyncEndpoint: function (endpointId) {
        const index = this.syncConfig.syncEndpoints.findIndex(e => e.id === endpointId);

        if (index > -1) {
            this.syncConfig.syncEndpoints.splice(index, 1);
            this.saveSyncConfig();
        }
    },

    /**
     * 创建同步任务
     * @param {string} taskType - 任务类型
     * @param {Object} data - 数据
     * @returns {Object} 同步任务
     */
    createSyncTask: function (taskType, data) {
        if (!this.syncConfig.enabled) {
            return {
                success: false,
                error: '同步已禁用'
            };
        }

        const taskId = 'sync_' + Date.now();

        const task = {
            id: taskId,
            type: taskType,
            data: data,
            status: 'pending',
            createdAt: Date.now(),
            startedAt: null,
            completedAt: null,
            retries: 0,
            endpointId: null
        };

        this.syncQueues.pending.push(task);
        this.saveSyncQueues();

        return {
            success: true,
            task: task
        };
    },

    /**
     * 执行同步任务
     * @param {string} taskId - 任务ID
     * @returns {Promise<Object>} 同步结果
     */
    executeSyncTask: function (taskId) {
        return new Promise((resolve, reject) => {
            if (!this.syncConfig.enabled) {
                reject({
                    success: false,
                    error: '同步已禁用'
                });
                return;
            }

            // 查找任务
            let task = this.syncQueues.pending.find(t => t.id === taskId);

            if (!task) {
                reject({
                    success: false,
                    error: '任务不存在'
                });
                return;
            }

            // 移动到处理中
            this.syncQueues.pending = this.syncQueues.pending.filter(t => t.id !== taskId);
            this.syncQueues.processing.push(task);
            this.saveSyncQueues();

            // 开始处理
            task.status = 'running';
            task.startedAt = Date.now();
            this.saveSyncQueues();

            // 选择端点
            const endpoint = this.selectEndpoint();

            if (!endpoint) {
                task.status = 'failed';
                task.completedAt = Date.now();
                this.syncQueues.processing = this.syncQueues.processing.filter(t => t.id !== taskId);
                this.syncQueues.failed.push(task);
                this.saveSyncQueues();

                reject({
                    success: false,
                    error: '没有可用的同步端点'
                });
                return;
            }

            task.endpointId = endpoint.id;

            // 发送数据
            this.sendData(endpoint, task.data)
                .then(response => {
                    // 完成任务
                    task.status = 'completed';
                    task.completedAt = Date.now();
                    task.response = response;

                    this.syncQueues.processing = this.syncQueues.processing.filter(t => t.id !== taskId);
                    this.syncQueues.completed.push(task);
                    this.saveSyncQueues();

                    // 记录同步历史
                    this.recordSync(task);

                    resolve({
                        success: true,
                        task: task
                    });
                })
                .catch(error => {
                    // 处理失败
                    task.retries++;

                    if (task.retries >= this.syncConfig.maxRetries) {
                        task.status = 'failed';
                        task.completedAt = Date.now();
                        task.error = error.message;

                        this.syncQueues.processing = this.syncQueues.processing.filter(t => t.id !== taskId);
                        this.syncQueues.failed.push(task);
                        this.saveSyncQueues();

                        reject({
                            success: false,
                            error: error.message
                        });
                    } else {
                        // 重新放入队列
                        task.status = 'pending';
                        this.syncQueues.processing = this.syncQueues.processing.filter(t => t.id !== taskId);
                        this.syncQueues.pending.push(task);
                        this.saveSyncQueues();

                        // 延迟后重试
                        setTimeout(() => {
                            this.executeSyncTask(taskId)
                                .then(resolve)
                                .catch(reject);
                        }, this.syncConfig.retryInterval);
                    }
                });
        });
    },

    /**
     * 选择端点
     * @returns {Object|null} 端点对象
     */
    selectEndpoint: function () {
        if (this.syncConfig.syncEndpoints.length === 0) {
            return null;
        }

        // 简单的轮询选择
        const index = Math.floor(Math.random() * this.syncConfig.syncEndpoints.length);
        return this.syncConfig.syncEndpoints[index];
    },

    /**
     * 发送数据
     * @param {Object} endpoint - 端点配置
     * @param {Object} data - 数据
     * @returns {Promise<Object>} 响应结果
     */
    sendData: function (endpoint, data) {
        return new Promise((resolve, reject) => {
            const options = {
                method: endpoint.method,
                headers: endpoint.headers
            };

            if (endpoint.method !== 'GET') {
                options.body = JSON.stringify(data);
            }

            fetch(endpoint.url, options)
                .then(response => response.json())
                .then(result => {
                    resolve(result);
                })
                .catch(error => {
                    reject(error);
                });
        });
    },

    /**
     * 同步游戏数据
     * @returns {Promise<Object>} 同步结果
     */
    syncGameData: function () {
        return new Promise((resolve, reject) => {
            if (!this.syncConfig.enabled) {
                reject({
                    success: false,
                    error: '同步已禁用'
                });
                return;
            }

            // 收集游戏数据
            const gameData = this.collectGameData();

            // 创建同步任务
            const taskResult = this.createSyncTask('game_data', gameData);

            if (!taskResult.success) {
                reject(taskResult);
                return;
            }

            // 执行同步任务
            this.executeSyncTask(taskResult.task.id)
                .then(resolve)
                .catch(reject);
        });
    },

    /**
     * 收集游戏数据
     * @returns {Object} 游戏数据
     */
    collectGameData: function () {
        const gameData = {};

        // 收集localStorage数据
        gameData.localStorage = {};

        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            gameData.localStorage[key] = localStorage.getItem(key);
        }

        // 收集游戏状态
        if (window.StickmanAdventure && StickmanAdventure.game) {
            gameData.gameState = {
                score: StickmanAdventure.game.score,
                level: StickmanAdventure.game.level,
                lives: StickmanAdventure.game.lives,
                time: StickmanAdventure.game.time,
                player: {
                    x: StickmanAdventure.game.player.x,
                    y: StickmanAdventure.game.player.y,
                    health: StickmanAdventure.game.player.health
                }
            };
        }

        gameData.timestamp = Date.now();

        return gameData;
    },

    /**
     * 记录同步
     * @param {Object} task - 任务对象
     */
    recordSync: function (task) {
        const syncId = 'sync_' + Date.now();

        this.syncHistory.syncs[syncId] = {
            id: syncId,
            taskId: task.id,
            type: task.type,
            endpointId: task.endpointId,
            status: task.status,
            startedAt: task.startedAt,
            completedAt: task.completedAt,
            response: task.response
        };

        this.saveSyncHistory();
    },

    /**
     * 开始自动同步
     */
    startAutoSync: function () {
        setInterval(() => {
            if (this.syncConfig.enabled && this.syncConfig.autoSync) {
                this.syncGameData();
            }
        }, this.syncConfig.syncInterval);
    },

    /**
     * 处理数据变化
     */
    onDataChange: function () {
        if (this.syncConfig.enabled && this.syncConfig.syncOnDataChange) {
            this.syncGameData();
        }
    },

    /**
     * 获取同步任务
     * @param {string} taskId - 任务ID
     * @returns {Object|null} 任务对象
     */
    getSyncTask: function (taskId) {
        const task = this.syncQueues.pending.find(t => t.id === taskId) ||
            this.syncQueues.processing.find(t => t.id === taskId) ||
            this.syncQueues.completed.find(t => t.id === taskId) ||
            this.syncQueues.failed.find(t => t.id === taskId);

        return task || null;
    },

    /**
     * 获取所有同步任务
     * @param {string} status - 状态
     * @returns {Array} 任务列表
     */
    getAllSyncTasks: function (status) {
        if (status) {
            return this.syncQueues[status] || [];
        }

        return [
            ...this.syncQueues.pending,
            ...this.syncQueues.processing,
            ...this.syncQueues.completed,
            ...this.syncQueues.failed
        ];
    },

    /**
     * 获取同步历史
     * @returns {Array} 同步历史
     */
    getSyncHistory: function () {
        return Object.values(this.syncHistory.syncs);
    },

    /**
     * 清理完成的任务
     */
    cleanupCompletedTasks: function () {
        this.syncQueues.completed = [];
        this.syncQueues.failed = [];
        this.saveSyncQueues();
    },

    /**
     * 设置同步配置
     * @param {Object} config - 配置对象
     */
    setSyncConfig: function (config) {
        this.syncConfig = { ...this.syncConfig, ...config };
        this.saveSyncConfig();
    },

    /**
     * 获取同步配置
     * @returns {Object} 配置对象
     */
    getSyncConfig: function () {
        return this.syncConfig;
    },

    /**
     * 获取同步统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.syncConfig.enabled,
            autoSync: this.syncConfig.autoSync,
            syncInterval: this.syncConfig.syncInterval,
            syncOnStart: this.syncConfig.syncOnStart,
            syncOnExit: this.syncConfig.syncOnExit,
            syncOnDataChange: this.syncConfig.syncOnDataChange,
            totalEndpoints: this.syncConfig.syncEndpoints.length,
            pendingTasks: this.syncQueues.pending.length,
            processingTasks: this.syncQueues.processing.length,
            completedTasks: this.syncQueues.completed.length,
            failedTasks: this.syncQueues.failed.length,
            totalSyncs: Object.keys(this.syncHistory.syncs).length,
            successfulSyncs: Object.values(this.syncHistory.syncs).filter(s => s.status === 'completed').length,
            failedSyncs: Object.values(this.syncHistory.syncs).filter(s => s.status === 'failed').length
        };
    }
};

// 优化：游戏数据归档优化
const GameDataArchiveOptimizer = {
    archiveConfig: {},
    archiveHistory: {},
    archiveIndex: {},

    /**
     * 初始化游戏数据归档
     */
    init: function () {
        this.loadArchiveConfig();
        this.loadArchiveHistory();
        this.loadArchiveIndex();
        this.startAutoArchive();
    },

    /**
     * 加载归档配置
     */
    loadArchiveConfig: function () {
        this.archiveConfig = {
            enabled: true,
            autoArchive: true,
            archiveInterval: 86400000,
            maxArchives: 100,
            compressionEnabled: true,
            encryptionEnabled: false,
            archiveOnExit: false,
            archiveOnLevelComplete: true,
            archiveOnGameOver: true
        };

        const customConfig = localStorage.getItem('archiveConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.archiveConfig = { ...this.archiveConfig, ...config };
            } catch (error) {
                console.error('加载归档配置失败:', error);
            }
        }
    },

    /**
     * 保存归档配置
     */
    saveArchiveConfig: function () {
        localStorage.setItem('archiveConfig', JSON.stringify(this.archiveConfig));
    },

    /**
     * 加载归档历史
     */
    loadArchiveHistory: function () {
        const savedHistory = localStorage.getItem('archiveHistory');
        if (savedHistory) {
            try {
                this.archiveHistory = JSON.parse(savedHistory);
            } catch (error) {
                console.error('加载归档历史失败:', error);
            }
        }

        if (!this.archiveHistory.archives) {
            this.archiveHistory = {
                archives: {}
            };

            this.saveArchiveHistory();
        }
    },

    /**
     * 保存归档历史
     */
    saveArchiveHistory: function () {
        localStorage.setItem('archiveHistory', JSON.stringify(this.archiveHistory));
    },

    /**
     * 加载归档索引
     */
    loadArchiveIndex: function () {
        const savedIndex = localStorage.getItem('archiveIndex');
        if (savedIndex) {
            try {
                this.archiveIndex = JSON.parse(savedIndex);
            } catch (error) {
                console.error('加载归档索引失败:', error);
            }
        }

        if (!this.archiveIndex.index) {
            this.archiveIndex = {
                index: {}
            };

            this.saveArchiveIndex();
        }
    },

    /**
     * 保存归档索引
     */
    saveArchiveIndex: function () {
        localStorage.setItem('archiveIndex', JSON.stringify(this.archiveIndex));
    },

    /**
     * 创建归档
     * @param {string} archiveName - 归档名称
     * @param {string} archiveType - 归档类型
     * @returns {Object} 归档结果
     */
    createArchive: function (archiveName, archiveType) {
        if (!this.archiveConfig.enabled) {
            return {
                success: false,
                error: '归档已禁用'
            };
        }

        const archiveId = 'archive_' + Date.now();
        const name = archiveName || 'archive_' + new Date().toISOString();
        const type = archiveType || 'manual';

        // 收集游戏数据
        const gameData = this.collectGameData();

        // 压缩数据
        let archiveData = gameData;

        if (this.archiveConfig.compressionEnabled) {
            archiveData = this.compressData(archiveData);
        }

        // 加密数据
        if (this.archiveConfig.encryptionEnabled) {
            archiveData = this.encryptData(archiveData);
        }

        // 创建归档记录
        const archive = {
            id: archiveId,
            name: name,
            type: type,
            data: archiveData,
            compressed: this.archiveConfig.compressionEnabled,
            encrypted: this.archiveConfig.encryptionEnabled,
            createdAt: Date.now(),
            size: JSON.stringify(archiveData).length,
            metadata: this.generateMetadata(gameData)
        };

        this.archiveHistory.archives[archiveId] = archive;

        // 添加到索引
        this.addToIndex(archive);

        // 清理旧归档
        this.cleanupOldArchives();

        this.saveArchiveHistory();
        this.saveArchiveIndex();

        return {
            success: true,
            archive: archive
        };
    },

    /**
     * 收集游戏数据
     * @returns {Object} 游戏数据
     */
    collectGameData: function () {
        const gameData = {};

        // 收集localStorage数据
        gameData.localStorage = {};

        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            gameData.localStorage[key] = localStorage.getItem(key);
        }

        // 收集游戏状态
        if (window.StickmanAdventure && StickmanAdventure.game) {
            gameData.gameState = {
                score: StickmanAdventure.game.score,
                level: StickmanAdventure.game.level,
                lives: StickmanAdventure.game.lives,
                time: StickmanAdventure.game.time,
                player: {
                    x: StickmanAdventure.game.player.x,
                    y: StickmanAdventure.game.player.y,
                    health: StickmanAdventure.game.player.health
                },
                enemies: StickmanAdventure.game.enemies.map(enemy => ({
                    x: enemy.x,
                    y: enemy.y,
                    type: enemy.type,
                    health: enemy.health
                })),
                items: StickmanAdventure.game.items.map(item => ({
                    x: item.x,
                    y: item.y,
                    type: item.type,
                    collected: item.collected
                }))
            };
        }

        gameData.timestamp = Date.now();

        return gameData;
    },

    /**
     * 生成元数据
     * @param {Object} gameData - 游戏数据
     * @returns {Object} 元数据
     */
    generateMetadata: function (gameData) {
        const metadata = {
            timestamp: gameData.timestamp,
            score: gameData.gameState ? gameData.gameState.score : 0,
            level: gameData.gameState ? gameData.gameState.level : 1,
            lives: gameData.gameState ? gameData.gameState.lives : 3,
            time: gameData.gameState ? gameData.gameState.time : 0,
            version: '1.0'
        };

        return metadata;
    },

    /**
     * 压缩数据
     * @param {Object} data - 数据
     * @returns {Object} 压缩后的数据
     */
    compressData: function (data) {
        // 简化的压缩（实际应用中应该使用真实的压缩算法）
        const jsonString = JSON.stringify(data);

        return {
            compressed: true,
            data: jsonString,
            originalSize: jsonString.length
        };
    },

    /**
     * 加密数据
     * @param {Object} data - 数据
     * @returns {Object} 加密后的数据
     */
    encryptData: function (data) {
        // 简化的加密（实际应用中应该使用真实的加密算法）
        const jsonString = JSON.stringify(data);

        let encrypted = '';

        for (let i = 0; i < jsonString.length; i++) {
            const charCode = jsonString.charCodeAt(i);
            encrypted += String.fromCharCode(charCode ^ 42);
        }

        return {
            encrypted: true,
            data: encrypted
        };
    },

    /**
     * 解密数据
     * @param {Object} data - 数据
     * @returns {Object} 解密后的数据
     */
    decryptData: function (data) {
        if (!data.encrypted) {
            return data;
        }

        let decrypted = '';

        for (let i = 0; i < data.data.length; i++) {
            const charCode = data.data.charCodeAt(i);
            decrypted += String.fromCharCode(charCode ^ 42);
        }

        return JSON.parse(decrypted);
    },

    /**
     * 解压数据
     * @param {Object} data - 数据
     * @returns {Object} 解压后的数据
     */
    decompressData: function (data) {
        if (!data.compressed) {
            return data;
        }

        return JSON.parse(data.data);
    },

    /**
     * 添加到索引
     * @param {Object} archive - 归档对象
     */
    addToIndex: function (archive) {
        const index = {
            id: archive.id,
            name: archive.name,
            type: archive.type,
            createdAt: archive.createdAt,
            size: archive.size,
            metadata: archive.metadata
        };

        this.archiveIndex.index[archive.id] = index;
    },

    /**
     * 搜索归档
     * @param {Object} criteria - 搜索条件
     * @returns {Array} 归档列表
     */
    searchArchives: function (criteria) {
        const results = [];

        for (const archiveId in this.archiveIndex.index) {
            const index = this.archiveIndex.index[archiveId];
            let match = true;

            if (criteria.type && index.type !== criteria.type) {
                match = false;
            }

            if (criteria.minScore && index.metadata.score < criteria.minScore) {
                match = false;
            }

            if (criteria.maxScore && index.metadata.score > criteria.maxScore) {
                match = false;
            }

            if (criteria.minLevel && index.metadata.level < criteria.minLevel) {
                match = false;
            }

            if (criteria.maxLevel && index.metadata.level > criteria.maxLevel) {
                match = false;
            }

            if (criteria.startTime && index.createdAt < criteria.startTime) {
                match = false;
            }

            if (criteria.endTime && index.createdAt > criteria.endTime) {
                match = false;
            }

            if (match) {
                results.push(index);
            }
        }

        return results;
    },

    /**
     * 获取归档
     * @param {string} archiveId - 归档ID
     * @returns {Object|null} 归档对象
     */
    getArchive: function (archiveId) {
        return this.archiveHistory.archives[archiveId] || null;
    },

    /**
     * 恢复归档
     * @param {string} archiveId - 归档ID
     * @returns {Object} 恢复结果
     */
    restoreArchive: function (archiveId) {
        if (!this.archiveConfig.enabled) {
            return {
                success: false,
                error: '归档已禁用'
            };
        }

        const archive = this.archiveHistory.archives[archiveId];

        if (!archive) {
            return {
                success: false,
                error: '归档不存在'
            };
        }

        // 解密数据
        let restoreData = archive.data;

        if (archive.encrypted) {
            restoreData = this.decryptData(restoreData);
        }

        // 解压数据
        if (archive.compressed) {
            restoreData = this.decompressData(restoreData);
        }

        // 恢复数据
        this.restoreGameData(restoreData);

        return {
            success: true,
            archive: archive
        };
    },

    /**
     * 恢复游戏数据
     * @param {Object} data - 数据
     */
    restoreGameData: function (data) {
        // 恢复localStorage数据
        if (data.localStorage) {
            for (const key in data.localStorage) {
                localStorage.setItem(key, data.localStorage[key]);
            }
        }

        // 恢复游戏状态
        if (data.gameState && window.StickmanAdventure && StickmanAdventure.game) {
            StickmanAdventure.game.score = data.gameState.score;
            StickmanAdventure.game.level = data.gameState.level;
            StickmanAdventure.game.lives = data.gameState.lives;
            StickmanAdventure.game.time = data.gameState.time;

            if (data.gameState.player) {
                StickmanAdventure.game.player.x = data.gameState.player.x;
                StickmanAdventure.game.player.y = data.gameState.player.y;
                StickmanAdventure.game.player.health = data.gameState.player.health;
            }

            if (data.gameState.enemies) {
                StickmanAdventure.game.enemies = data.gameState.enemies.map(enemyData => ({
                    x: enemyData.x,
                    y: enemyData.y,
                    type: enemyData.type,
                    health: enemyData.health
                }));
            }

            if (data.gameState.items) {
                StickmanAdventure.game.items = data.gameState.items.map(itemData => ({
                    x: itemData.x,
                    y: itemData.y,
                    type: itemData.type,
                    collected: itemData.collected
                }));
            }
        }
    },

    /**
     * 删除归档
     * @param {string} archiveId - 归档ID
     * @returns {boolean} 是否成功
     */
    deleteArchive: function (archiveId) {
        if (!this.archiveHistory.archives[archiveId]) {
            return false;
        }

        delete this.archiveHistory.archives[archiveId];
        delete this.archiveIndex.index[archiveId];

        this.saveArchiveHistory();
        this.saveArchiveIndex();

        return true;
    },

    /**
     * 获取所有归档
     * @returns {Array} 归档列表
     */
    getAllArchives: function () {
        return Object.values(this.archiveHistory.archives);
    },

    /**
     * 获取归档索引
     * @returns {Array} 索引列表
     */
    getArchiveIndex: function () {
        return Object.values(this.archiveIndex.index);
    },

    /**
     * 清理旧归档
     */
    cleanupOldArchives: function () {
        const archives = Object.values(this.archiveHistory.archives);

        if (archives.length <= this.archiveConfig.maxArchives) {
            return;
        }

        // 按创建时间排序
        archives.sort((a, b) => a.createdAt - b.createdAt);

        // 删除最旧的归档
        const archivesToDelete = archives.slice(0, archives.length - this.archiveConfig.maxArchives);

        for (const archive of archivesToDelete) {
            delete this.archiveHistory.archives[archive.id];
            delete this.archiveIndex.index[archive.id];
        }

        this.saveArchiveHistory();
        this.saveArchiveIndex();
    },

    /**
     * 开始自动归档
     */
    startAutoArchive: function () {
        setInterval(() => {
            if (this.archiveConfig.enabled && this.archiveConfig.autoArchive) {
                this.createArchive('auto_archive', 'auto');
            }
        }, this.archiveConfig.archiveInterval);
    },

    /**
     * 关卡完成时归档
     */
    onLevelComplete: function () {
        if (this.archiveConfig.enabled && this.archiveConfig.archiveOnLevelComplete) {
            this.createArchive('level_complete', 'level_complete');
        }
    },

    /**
     * 游戏结束时归档
     */
    onGameOver: function () {
        if (this.archiveConfig.enabled && this.archiveConfig.archiveOnGameOver) {
            this.createArchive('game_over', 'game_over');
        }
    },

    /**
     * 导出归档
     * @param {string} archiveId - 归档ID
     * @returns {Object} 导出结果
     */
    exportArchive: function (archiveId) {
        const archive = this.archiveHistory.archives[archiveId];

        if (!archive) {
            return {
                success: false,
                error: '归档不存在'
            };
        }

        const exportData = {
            archive: archive,
            index: this.archiveIndex.index[archiveId],
            exportedAt: Date.now()
        };

        const jsonString = JSON.stringify(exportData);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = `${archive.name}.json`;
        a.click();

        URL.revokeObjectURL(url);

        return {
            success: true
        };
    },

    /**
     * 导入归档
     * @param {File} file - 文件
     * @returns {Promise<Object>} 导入结果
     */
    importArchive: function (file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();

            reader.onload = (event) => {
                try {
                    const importData = JSON.parse(event.target.result);
                    const archive = importData.archive;

                    const archiveId = 'imported_' + Date.now();

                    this.archiveHistory.archives[archiveId] = archive;
                    this.addToIndex(archive);

                    this.saveArchiveHistory();
                    this.saveArchiveIndex();

                    resolve({
                        success: true,
                        archive: archive
                    });
                } catch (error) {
                    reject({
                        success: false,
                        error: '导入失败'
                    });
                }
            };

            reader.onerror = () => {
                reject({
                    success: false,
                    error: '读取文件失败'
                });
            };

            reader.readAsText(file);
        });
    },

    /**
     * 设置归档配置
     * @param {Object} config - 配置对象
     */
    setArchiveConfig: function (config) {
        this.archiveConfig = { ...this.archiveConfig, ...config };
        this.saveArchiveConfig();
    },

    /**
     * 获取归档配置
     * @returns {Object} 配置对象
     */
    getArchiveConfig: function () {
        return this.archiveConfig;
    },

    /**
     * 获取归档统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        const archives = Object.values(this.archiveHistory.archives);
        const totalSize = archives.reduce((sum, archive) => sum + archive.size, 0);

        return {
            enabled: this.archiveConfig.enabled,
            autoArchive: this.archiveConfig.autoArchive,
            archiveInterval: this.archiveConfig.archiveInterval,
            maxArchives: this.archiveConfig.maxArchives,
            compressionEnabled: this.archiveConfig.compressionEnabled,
            encryptionEnabled: this.archiveConfig.encryptionEnabled,
            archiveOnExit: this.archiveConfig.archiveOnExit,
            archiveOnLevelComplete: this.archiveConfig.archiveOnLevelComplete,
            archiveOnGameOver: this.archiveConfig.archiveOnGameOver,
            totalArchives: archives.length,
            totalSize: totalSize,
            averageSize: archives.length > 0 ? totalSize / archives.length : 0
        };
    }
};

// 优化：游戏日志分析优化
const GameLogAnalysisOptimizer = {
    laConfig: {},
    laLogs: {},
    laAnalysis: {},

    /**
     * 初始化游戏日志分析
     */
    init: function () {
        this.loadLAConfig();
        this.loadLALogs();
        this.loadLAAnalysis();
    },

    /**
     * 加载日志分析配置
     */
    loadLAConfig: function () {
        this.laConfig = {
            enabled: true,
            maxLogs: 10000,
            maxAnalysisResults: 100,
            analysisInterval: 60000,
            autoAnalyze: true,
            logLevels: ['debug', 'info', 'warn', 'error'],
            patterns: [
                {
                    name: 'error_pattern',
                    regex: /error|exception|fail/i,
                    level: 'error'
                },
                {
                    name: 'warning_pattern',
                    regex: /warn|warning/i,
                    level: 'warn'
                },
                {
                    name: 'performance_pattern',
                    regex: /slow|timeout|latency/i,
                    level: 'warn'
                }
            ]
        };

        const customConfig = localStorage.getItem('laConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.laConfig = { ...this.laConfig, ...config };
            } catch (error) {
                console.error('加载日志分析配置失败:', error);
            }
        }
    },

    /**
     * 保存日志分析配置
     */
    saveLAConfig: function () {
        localStorage.setItem('laConfig', JSON.stringify(this.laConfig));
    },

    /**
     * 加载日志
     */
    loadLALogs: function () {
        const savedLogs = localStorage.getItem('laLogs');
        if (savedLogs) {
            try {
                this.laLogs = JSON.parse(savedLogs);
            } catch (error) {
                console.error('加载日志失败:', error);
            }
        }

        if (!this.laLogs.logs) {
            this.laLogs = {
                logs: [],
                stats: {
                    total: 0,
                    debug: 0,
                    info: 0,
                    warn: 0,
                    error: 0
                }
            };

            this.saveLALogs();
        }
    },

    /**
     * 保存日志
     */
    saveLALogs: function () {
        localStorage.setItem('laLogs', JSON.stringify(this.laLogs));
    },

    /**
     * 加载分析结果
     */
    loadLAAnalysis: function () {
        const savedAnalysis = localStorage.getItem('laAnalysis');
        if (savedAnalysis) {
            try {
                this.laAnalysis = JSON.parse(savedAnalysis);
            } catch (error) {
                console.error('加载分析结果失败:', error);
            }
        }

        if (!this.laAnalysis.results) {
            this.laAnalysis = {
                results: {},
                insights: [],
                alerts: []
            };

            this.saveLAAnalysis();
        }
    },

    /**
     * 保存分析结果
     */
    saveLAAnalysis: function () {
        localStorage.setItem('laAnalysis', JSON.stringify(this.laAnalysis));
    },

    /**
     * 记录日志
     * @param {string} level - 日志级别
     * @param {string} message - 消息
     * @param {Object} data - 数据
     */
    log: function (level, message, data) {
        if (!this.laConfig.enabled) {
            return;
        }

        if (!this.laConfig.logLevels.includes(level)) {
            return;
        }

        const log = {
            id: 'log_' + Date.now(),
            level: level,
            message: message,
            data: data || {},
            timestamp: Date.now()
        };

        this.laLogs.logs.push(log);

        // 更新统计
        this.laLogs.stats.total++;
        this.laLogs.stats[level]++;

        // 清理旧日志
        this.cleanupOldLogs();

        this.saveLALogs();

        // 触发分析
        if (this.laConfig.autoAnalyze) {
            this.analyzeLogs();
        }
    },

    /**
     * 清理旧日志
     */
    cleanupOldLogs: function () {
        if (this.laLogs.logs.length > this.laConfig.maxLogs) {
            const logsToDelete = this.laLogs.logs.length - this.laConfig.maxLogs;

            for (let i = 0; i < logsToDelete; i++) {
                const deletedLog = this.laLogs.logs.shift();

                // 更新统计
                this.laLogs.stats.total--;
                this.laLogs.stats[deletedLog.level]--;
            }

            this.saveLALogs();
        }
    },

    /**
     * 分析日志
     * @returns {Object} 分析结果
     */
    analyzeLogs: function () {
        if (!this.laConfig.enabled) {
            return {
                success: false,
                error: '日志分析已禁用'
            };
        }

        const analysisId = 'analysis_' + Date.now();

        // 统计分析
        const statsAnalysis = this.performStatsAnalysis();

        // 模式匹配
        const patternAnalysis = this.performPatternAnalysis();

        // 趋势分析
        const trendAnalysis = this.performTrendAnalysis();

        // 异常检测
        const anomalyAnalysis = this.performAnomalyDetection();

        // 生成洞察
        const insights = this.generateInsights(statsAnalysis, patternAnalysis, trendAnalysis, anomalyAnalysis);

        // 生成警告
        const alerts = this.generateAlerts(statsAnalysis, patternAnalysis, anomalyAnalysis);

        // 保存分析结果
        this.laAnalysis.results[analysisId] = {
            id: analysisId,
            stats: statsAnalysis,
            patterns: patternAnalysis,
            trends: trendAnalysis,
            anomalies: anomalyAnalysis,
            createdAt: Date.now()
        };

        this.laAnalysis.insights = insights;
        this.laAnalysis.alerts = alerts;

        this.saveLAAnalysis();

        return {
            success: true,
            analysis: this.laAnalysis.results[analysisId]
        };
    },

    /**
     * 执行统计分析
     * @returns {Object} 统计结果
     */
    performStatsAnalysis: function () {
        const stats = {
            total: this.laLogs.logs.length,
            byLevel: {},
            byHour: {},
            byDay: {}
        };

        // 按级别统计
        for (const level of this.laConfig.logLevels) {
            stats.byLevel[level] = this.laLogs.logs.filter(log => log.level === level).length;
        }

        // 按小时统计
        for (const log of this.laLogs.logs) {
            const hour = new Date(log.timestamp).getHours();

            if (!stats.byHour[hour]) {
                stats.byHour[hour] = 0;
            }

            stats.byHour[hour]++;
        }

        // 按天统计
        for (const log of this.laLogs.logs) {
            const day = new Date(log.timestamp).toDateString();

            if (!stats.byDay[day]) {
                stats.byDay[day] = 0;
            }

            stats.byDay[day]++;
        }

        return stats;
    },

    /**
     * 执行模式匹配
     * @returns {Object} 模式结果
     */
    performPatternAnalysis: function () {
        const patterns = {};

        for (const pattern of this.laConfig.patterns) {
            patterns[pattern.name] = {
                matches: [],
                count: 0,
                level: pattern.level
            };

            for (const log of this.laLogs.logs) {
                if (pattern.regex.test(log.message)) {
                    patterns[pattern.name].matches.push(log);
                    patterns[pattern.name].count++;
                }
            }
        }

        return patterns;
    },

    /**
     * 执行趋势分析
     * @returns {Object} 趋势结果
     */
    performTrendAnalysis: function () {
        const trends = {
            errorRate: [],
            warningRate: [],
            logVolume: []
        };

        // 按时间分组
        const timeGroups = {};

        for (const log of this.laLogs.logs) {
            const time = Math.floor(log.timestamp / 3600000); // 按小时分组

            if (!timeGroups[time]) {
                timeGroups[time] = {
                    total: 0,
                    error: 0,
                    warning: 0
                };
            }

            timeGroups[time].total++;

            if (log.level === 'error') {
                timeGroups[time].error++;
            } else if (log.level === 'warn') {
                timeGroups[time].warning++;
            }
        }

        // 计算趋势
        for (const time in timeGroups) {
            const group = timeGroups[time];

            trends.logVolume.push({
                time: parseInt(time) * 3600000,
                value: group.total
            });

            trends.errorRate.push({
                time: parseInt(time) * 3600000,
                value: group.total > 0 ? group.error / group.total : 0
            });

            trends.warningRate.push({
                time: parseInt(time) * 3600000,
                value: group.total > 0 ? group.warning / group.total : 0
            });
        }

        return trends;
    },

    /**
     * 执行异常检测
     * @returns {Object} 异常结果
     */
    performAnomalyDetection: function () {
        const anomalies = [];

        // 检测错误率异常
        const errorLogs = this.laLogs.logs.filter(log => log.level === 'error');
        const errorRate = errorLogs.length / this.laLogs.logs.length;

        if (errorRate > 0.1) {
            anomalies.push({
                type: 'high_error_rate',
                severity: 'high',
                value: errorRate,
                threshold: 0.1
            });
        }

        // 检测日志量异常
        const recentLogs = this.laLogs.logs.filter(log => Date.now() - log.timestamp < 3600000);

        if (recentLogs.length > 1000) {
            anomalies.push({
                type: 'high_log_volume',
                severity: 'medium',
                value: recentLogs.length,
                threshold: 1000
            });
        }

        // 检测重复错误
        const errorMessages = errorLogs.map(log => log.message);
        const messageCounts = {};

        for (const message of errorMessages) {
            if (!messageCounts[message]) {
                messageCounts[message] = 0;
            }

            messageCounts[message]++;
        }

        for (const message in messageCounts) {
            if (messageCounts[message] > 10) {
                anomalies.push({
                    type: 'repeated_error',
                    severity: 'medium',
                    message: message,
                    count: messageCounts[message],
                    threshold: 10
                });
            }
        }

        return anomalies;
    },

    /**
     * 生成洞察
     * @param {Object} stats - 统计结果
     * @param {Object} patterns - 模式结果
     * @param {Object} trends - 趋势结果
     * @param {Object} anomalies - 异常结果
     * @returns {Array} 洞察列表
     */
    generateInsights: function (stats, patterns, trends, anomalies) {
        const insights = [];

        // 错误率洞察
        if (stats.byLevel.error > 0) {
            insights.push({
                type: 'error_rate',
                message: `检测到 ${stats.byLevel.error} 个错误日志`,
                severity: 'high'
            });
        }

        // 模式洞察
        for (const patternName in patterns) {
            const pattern = patterns[patternName];

            if (pattern.count > 0) {
                insights.push({
                    type: 'pattern',
                    message: `检测到 ${pattern.count} 个 ${patternName} 匹配`,
                    severity: pattern.level
                });
            }
        }

        // 趋势洞察
        if (trends.errorRate.length > 1) {
            const lastErrorRate = trends.errorRate[trends.errorRate.length - 1].value;
            const prevErrorRate = trends.errorRate[trends.errorRate.length - 2].value;

            if (lastErrorRate > prevErrorRate * 1.5) {
                insights.push({
                    type: 'trend',
                    message: '错误率正在上升',
                    severity: 'high'
                });
            } else if (lastErrorRate < prevErrorRate * 0.5) {
                insights.push({
                    type: 'trend',
                    message: '错误率正在下降',
                    severity: 'low'
                });
            }
        }

        return insights;
    },

    /**
     * 生成警告
     * @param {Object} stats - 统计结果
     * @param {Object} patterns - 模式结果
     * @param {Object} anomalies - 异常结果
     * @returns {Array} 警告列表
     */
    generateAlerts: function (stats, patterns, anomalies) {
        const alerts = [];

        // 基于异常生成警告
        for (const anomaly of anomalies) {
            alerts.push({
                type: anomaly.type,
                severity: anomaly.severity,
                message: `检测到异常: ${anomaly.type}`,
                value: anomaly.value,
                threshold: anomaly.threshold
            });
        }

        return alerts;
    },

    /**
     * 搜索日志
     * @param {Object} criteria - 搜索条件
     * @returns {Array} 日志列表
     */
    searchLogs: function (criteria) {
        let results = [...this.laLogs.logs];

        if (criteria.level) {
            results = results.filter(log => log.level === criteria.level);
        }

        if (criteria.message) {
            results = results.filter(log => log.message.includes(criteria.message));
        }

        if (criteria.startTime) {
            results = results.filter(log => log.timestamp >= criteria.startTime);
        }

        if (criteria.endTime) {
            results = results.filter(log => log.timestamp <= criteria.endTime);
        }

        if (criteria.limit) {
            results = results.slice(-criteria.limit);
        }

        return results;
    },

    /**
     * 获取日志统计
     * @returns {Object} 统计信息
     */
    getLogStats: function () {
        return this.laLogs.stats;
    },

    /**
     * 获取分析结果
     * @param {string} analysisId - 分析ID
     * @returns {Object|null} 分析结果
     */
    getAnalysisResult: function (analysisId) {
        return this.laAnalysis.results[analysisId] || null;
    },

    /**
     * 获取所有分析结果
     * @returns {Array} 分析结果列表
     */
    getAllAnalysisResults: function () {
        return Object.values(this.laAnalysis.results);
    },

    /**
     * 获取洞察
     * @returns {Array} 洞察列表
     */
    getInsights: function () {
        return this.laAnalysis.insights;
    },

    /**
     * 获取警告
     * @returns {Array} 警告列表
     */
    getAlerts: function () {
        return this.laAnalysis.alerts;
    },

    /**
     * 清除所有日志
     */
    clearLogs: function () {
        this.laLogs.logs = [];
        this.laLogs.stats = {
            total: 0,
            debug: 0,
            info: 0,
            warn: 0,
            error: 0
        };

        this.saveLALogs();
    },

    /**
     * 清除所有分析结果
     */
    clearAnalysis: function () {
        this.laAnalysis = {
            results: {},
            insights: [],
            alerts: []
        };

        this.saveLAAnalysis();
    },

    /**
     * 设置日志分析配置
     * @param {Object} config - 配置对象
     */
    setLAConfig: function (config) {
        this.laConfig = { ...this.laConfig, ...config };
        this.saveLAConfig();
    },

    /**
     * 获取日志分析配置
     * @returns {Object} 配置对象
     */
    getLAConfig: function () {
        return this.laConfig;
    },

    /**
     * 获取日志分析统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.laConfig.enabled,
            maxLogs: this.laConfig.maxLogs,
            maxAnalysisResults: this.laConfig.maxAnalysisResults,
            analysisInterval: this.laConfig.analysisInterval,
            autoAnalyze: this.laConfig.autoAnalyze,
            totalLogs: this.laLogs.logs.length,
            totalAnalysisResults: Object.keys(this.laAnalysis.results).length,
            totalInsights: this.laAnalysis.insights.length,
            totalAlerts: this.laAnalysis.alerts.length
        };
    }
};

// 优化：游戏性能分析优化
const GamePerformanceAnalysisOptimizer = {
    paConfig: {},
    paMetrics: {},
    paHistory: {},

    /**
     * 初始化游戏性能分析
     */
    init: function () {
        this.loadPAConfig();
        this.loadPAMetrics();
        this.loadPAHistory();
        this.startMonitoring();
    },

    /**
     * 加载性能分析配置
     */
    loadPAConfig: function () {
        this.paConfig = {
            enabled: true,
            monitoringInterval: 1000,
            maxMetrics: 1000,
            maxHistory: 100,
            autoAnalyze: true,
            analysisInterval: 10000,
            thresholds: {
                fps: { min: 30, ideal: 60 },
                memory: { max: 100, warning: 80 },
                cpu: { max: 80, warning: 60 },
                latency: { max: 100, warning: 50 }
            }
        };

        const customConfig = localStorage.getItem('paConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.paConfig = { ...this.paConfig, ...config };
            } catch (error) {
                console.error('加载性能分析配置失败:', error);
            }
        }
    },

    /**
     * 保存性能分析配置
     */
    savePAConfig: function () {
        localStorage.setItem('paConfig', JSON.stringify(this.paConfig));
    },

    /**
     * 加载性能指标
     */
    loadPAMetrics: function () {
        const savedMetrics = localStorage.getItem('paMetrics');
        if (savedMetrics) {
            try {
                this.paMetrics = JSON.parse(savedMetrics);
            } catch (error) {
                console.error('加载性能指标失败:', error);
            }
        }

        if (!this.paMetrics.current) {
            this.paMetrics = {
                current: {},
                history: [],
                averages: {}
            };

            this.savePAMetrics();
        }
    },

    /**
     * 保存性能指标
     */
    savePAMetrics: function () {
        localStorage.setItem('paMetrics', JSON.stringify(this.paMetrics));
    },

    /**
     * 加载性能历史
     */
    loadPAHistory: function () {
        const savedHistory = localStorage.getItem('paHistory');
        if (savedHistory) {
            try {
                this.paHistory = JSON.parse(savedHistory);
            } catch (error) {
                console.error('加载性能历史失败:', error);
            }
        }

        if (!this.paHistory.analyses) {
            this.paHistory = {
                analyses: {},
                insights: [],
                warnings: []
            };

            this.savePAHistory();
        }
    },

    /**
     * 保存性能历史
     */
    savePAHistory: function () {
        localStorage.setItem('paHistory', JSON.stringify(this.paHistory));
    },

    /**
     * 开始监控
     */
    startMonitoring: function () {
        setInterval(() => {
            if (this.paConfig.enabled) {
                this.collectMetrics();
            }
        }, this.paConfig.monitoringInterval);

        // 自动分析
        setInterval(() => {
            if (this.paConfig.enabled && this.paConfig.autoAnalyze) {
                this.analyzePerformance();
            }
        }, this.paConfig.analysisInterval);
    },

    /**
     * 收集性能指标
     */
    collectMetrics: function () {
        const metrics = {
            timestamp: Date.now(),
            fps: this.measureFPS(),
            memory: this.measureMemory(),
            latency: this.measureLatency(),
            renderTime: this.measureRenderTime(),
            updateTime: this.measureUpdateTime()
        };

        this.paMetrics.current = metrics;

        // 添加到历史
        this.paMetrics.history.push(metrics);

        // 清理旧指标
        this.cleanupOldMetrics();

        // 计算平均值
        this.calculateAverages();

        this.savePAMetrics();
    },

    /**
     * 测量FPS
     * @returns {number} FPS值
     */
    measureFPS: function () {
        // 模拟FPS测量
        return 60;
    },

    /**
     * 测量内存
     * @returns {number} 内存使用量（MB）
     */
    measureMemory: function () {
        if (window.performance && window.performance.memory) {
            return window.performance.memory.usedJSHeapSize / 1048576;
        }

        return 0;
    },

    /**
     * 测量延迟
     * @returns {number} 延迟（ms）
     */
    measureLatency: function () {
        // 模拟延迟测量
        return 16;
    },

    /**
     * 测量渲染时间
     * @returns {number} 渲染时间（ms）
     */
    measureRenderTime: function () {
        // 模拟渲染时间测量
        return 10;
    },

    /**
     * 测量更新时间
     * @returns {number} 更新时间（ms）
     */
    measureUpdateTime: function () {
        // 模拟更新时间测量
        return 5;
    },

    /**
     * 清理旧指标
     */
    cleanupOldMetrics: function () {
        if (this.paMetrics.history.length > this.paConfig.maxMetrics) {
            const metricsToDelete = this.paMetrics.history.length - this.paConfig.maxMetrics;

            for (let i = 0; i < metricsToDelete; i++) {
                this.paMetrics.history.shift();
            }

            this.savePAMetrics();
        }
    },

    /**
     * 计算平均值
     */
    calculateAverages: function () {
        const history = this.paMetrics.history;

        if (history.length === 0) {
            return;
        }

        this.paMetrics.averages = {
            fps: history.reduce((sum, m) => sum + m.fps, 0) / history.length,
            memory: history.reduce((sum, m) => sum + m.memory, 0) / history.length,
            latency: history.reduce((sum, m) => sum + m.latency, 0) / history.length,
            renderTime: history.reduce((sum, m) => sum + m.renderTime, 0) / history.length,
            updateTime: history.reduce((sum, m) => sum + m.updateTime, 0) / history.length
        };
    },

    /**
     * 分析性能
     * @returns {Object} 分析结果
     */
    analyzePerformance: function () {
        if (!this.paConfig.enabled) {
            return {
                success: false,
                error: '性能分析已禁用'
            };
        }

        const analysisId = 'analysis_' + Date.now();

        // FPS分析
        const fpsAnalysis = this.analyzeFPS();

        // 内存分析
        const memoryAnalysis = this.analyzeMemory();

        // 延迟分析
        const latencyAnalysis = this.analyzeLatency();

        // 趋势分析
        const trendAnalysis = this.analyzeTrends();

        // 生成洞察
        const insights = this.generateInsights(fpsAnalysis, memoryAnalysis, latencyAnalysis, trendAnalysis);

        // 生成警告
        const warnings = this.generateWarnings(fpsAnalysis, memoryAnalysis, latencyAnalysis);

        // 保存分析结果
        this.paHistory.analyses[analysisId] = {
            id: analysisId,
            fps: fpsAnalysis,
            memory: memoryAnalysis,
            latency: latencyAnalysis,
            trends: trendAnalysis,
            createdAt: Date.now()
        };

        this.paHistory.insights = insights;
        this.paHistory.warnings = warnings;

        this.savePAHistory();

        return {
            success: true,
            analysis: this.paHistory.analyses[analysisId]
        };
    },

    /**
     * 分析FPS
     * @returns {Object} FPS分析结果
     */
    analyzeFPS: function () {
        const current = this.paMetrics.current.fps || 0;
        const average = this.paMetrics.averages.fps || 0;
        const min = this.paConfig.thresholds.fps.min;
        const ideal = this.paConfig.thresholds.fps.ideal;

        return {
            current: current,
            average: average,
            min: min,
            ideal: ideal,
            status: current >= ideal ? 'excellent' : current >= min ? 'good' : 'poor',
            deviation: Math.abs(current - average) / average
        };
    },

    /**
     * 分析内存
     * @returns {Object} 内存分析结果
     */
    analyzeMemory: function () {
        const current = this.paMetrics.current.memory || 0;
        const average = this.paMetrics.averages.memory || 0;
        const max = this.paConfig.thresholds.memory.max;
        const warning = this.paConfig.thresholds.memory.warning;

        return {
            current: current,
            average: average,
            max: max,
            warning: warning,
            status: current >= max ? 'critical' : current >= warning ? 'warning' : 'normal',
            usage: current / max
        };
    },

    /**
     * 分析延迟
     * @returns {Object} 延迟分析结果
     */
    analyzeLatency: function () {
        const current = this.paMetrics.current.latency || 0;
        const average = this.paMetrics.averages.latency || 0;
        const max = this.paConfig.thresholds.latency.max;
        const warning = this.paConfig.thresholds.latency.warning;

        return {
            current: current,
            average: average,
            max: max,
            warning: warning,
            status: current >= max ? 'critical' : current >= warning ? 'warning' : 'normal',
            deviation: Math.abs(current - average) / average
        };
    },

    /**
     * 分析趋势
     * @returns {Object} 趋势分析结果
     */
    analyzeTrends: function () {
        const history = this.paMetrics.history;

        if (history.length < 2) {
            return {
                fps: 'stable',
                memory: 'stable',
                latency: 'stable'
            };
        }

        const recent = history.slice(-10);
        const older = history.slice(-20, -10);

        const fpsTrend = this.calculateTrend(recent.map(m => m.fps), older.map(m => m.fps));
        const memoryTrend = this.calculateTrend(recent.map(m => m.memory), older.map(m => m.memory));
        const latencyTrend = this.calculateTrend(recent.map(m => m.latency), older.map(m => m.latency));

        return {
            fps: fpsTrend,
            memory: memoryTrend,
            latency: latencyTrend
        };
    },

    /**
     * 计算趋势
     * @param {Array} recent - 最近的数据
     * @param {Array} older - 较早的数据
     * @returns {string} 趋势
     */
    calculateTrend: function (recent, older) {
        if (recent.length === 0 || older.length === 0) {
            return 'stable';
        }

        const recentAvg = recent.reduce((sum, val) => sum + val, 0) / recent.length;
        const olderAvg = older.reduce((sum, val) => sum + val, 0) / older.length;

        const change = (recentAvg - olderAvg) / olderAvg;

        if (change > 0.1) {
            return 'increasing';
        } else if (change < -0.1) {
            return 'decreasing';
        } else {
            return 'stable';
        }
    },

    /**
     * 生成洞察
     * @param {Object} fpsAnalysis - FPS分析
     * @param {Object} memoryAnalysis - 内存分析
     * @param {Object} latencyAnalysis - 延迟分析
     * @param {Object} trendAnalysis - 趋势分析
     * @returns {Array} 洞察列表
     */
    generateInsights: function (fpsAnalysis, memoryAnalysis, latencyAnalysis, trendAnalysis) {
        const insights = [];

        // FPS洞察
        if (fpsAnalysis.status === 'poor') {
            insights.push({
                type: 'fps',
                message: 'FPS低于最低要求，可能影响游戏体验',
                severity: 'high'
            });
        } else if (fpsAnalysis.status === 'good') {
            insights.push({
                type: 'fps',
                message: 'FPS表现良好',
                severity: 'low'
            });
        }

        // 内存洞察
        if (memoryAnalysis.status === 'critical') {
            insights.push({
                type: 'memory',
                message: '内存使用量接近上限，可能导致性能问题',
                severity: 'high'
            });
        } else if (memoryAnalysis.status === 'warning') {
            insights.push({
                type: 'memory',
                message: '内存使用量较高，建议优化',
                severity: 'medium'
            });
        }

        // 延迟洞察
        if (latencyAnalysis.status === 'critical') {
            insights.push({
                type: 'latency',
                message: '延迟过高，可能影响游戏响应速度',
                severity: 'high'
            });
        } else if (latencyAnalysis.status === 'warning') {
            insights.push({
                type: 'latency',
                message: '延迟较高，建议优化',
                severity: 'medium'
            });
        }

        // 趋势洞察
        if (trendAnalysis.fps === 'decreasing') {
            insights.push({
                type: 'trend',
                message: 'FPS呈下降趋势，需要关注',
                severity: 'medium'
            });
        }

        if (trendAnalysis.memory === 'increasing') {
            insights.push({
                type: 'trend',
                message: '内存使用量呈上升趋势，可能存在内存泄漏',
                severity: 'high'
            });
        }

        if (trendAnalysis.latency === 'increasing') {
            insights.push({
                type: 'trend',
                message: '延迟呈上升趋势，需要优化',
                severity: 'medium'
            });
        }

        return insights;
    },

    /**
     * 生成警告
     * @param {Object} fpsAnalysis - FPS分析
     * @param {Object} memoryAnalysis - 内存分析
     * @param {Object} latencyAnalysis - 延迟分析
     * @returns {Array} 警告列表
     */
    generateWarnings: function (fpsAnalysis, memoryAnalysis, latencyAnalysis) {
        const warnings = [];

        // FPS警告
        if (fpsAnalysis.status === 'poor') {
            warnings.push({
                type: 'fps',
                severity: 'high',
                message: 'FPS过低',
                value: fpsAnalysis.current,
                threshold: fpsAnalysis.min
            });
        }

        // 内存警告
        if (memoryAnalysis.status === 'critical') {
            warnings.push({
                type: 'memory',
                severity: 'high',
                message: '内存使用量过高',
                value: memoryAnalysis.current,
                threshold: memoryAnalysis.max
            });
        } else if (memoryAnalysis.status === 'warning') {
            warnings.push({
                type: 'memory',
                severity: 'medium',
                message: '内存使用量较高',
                value: memoryAnalysis.current,
                threshold: memoryAnalysis.warning
            });
        }

        // 延迟警告
        if (latencyAnalysis.status === 'critical') {
            warnings.push({
                type: 'latency',
                severity: 'high',
                message: '延迟过高',
                value: latencyAnalysis.current,
                threshold: latencyAnalysis.max
            });
        } else if (latencyAnalysis.status === 'warning') {
            warnings.push({
                type: 'latency',
                severity: 'medium',
                message: '延迟较高',
                value: latencyAnalysis.current,
                threshold: latencyAnalysis.warning
            });
        }

        return warnings;
    },

    /**
     * 获取当前性能指标
     * @returns {Object} 性能指标
     */
    getCurrentMetrics: function () {
        return this.paMetrics.current;
    },

    /**
     * 获取平均性能指标
     * @returns {Object} 平均指标
     */
    getAverageMetrics: function () {
        return this.paMetrics.averages;
    },

    /**
     * 获取性能历史
     * @param {number} limit - 限制数量
     * @returns {Array} 性能历史
     */
    getPerformanceHistory: function (limit) {
        let history = [...this.paMetrics.history];

        if (limit) {
            history = history.slice(-limit);
        }

        return history;
    },

    /**
     * 获取分析结果
     * @param {string} analysisId - 分析ID
     * @returns {Object|null} 分析结果
     */
    getAnalysisResult: function (analysisId) {
        return this.paHistory.analyses[analysisId] || null;
    },

    /**
     * 获取所有分析结果
     * @returns {Array} 分析结果列表
     */
    getAllAnalysisResults: function () {
        return Object.values(this.paHistory.analyses);
    },

    /**
     * 获取洞察
     * @returns {Array} 洞察列表
     */
    getInsights: function () {
        return this.paHistory.insights;
    },

    /**
     * 获取警告
     * @returns {Array} 警告列表
     */
    getWarnings: function () {
        return this.paHistory.warnings;
    },

    /**
     * 清除所有指标
     */
    clearMetrics: function () {
        this.paMetrics = {
            current: {},
            history: [],
            averages: {}
        };

        this.savePAMetrics();
    },

    /**
     * 清除所有分析结果
     */
    clearAnalysis: function () {
        this.paHistory = {
            analyses: {},
            insights: [],
            warnings: []
        };

        this.savePAHistory();
    },

    /**
     * 设置性能分析配置
     * @param {Object} config - 配置对象
     */
    setPAConfig: function (config) {
        this.paConfig = { ...this.paConfig, ...config };
        this.savePAConfig();
    },

    /**
     * 获取性能分析配置
     * @returns {Object} 配置对象
     */
    getPAConfig: function () {
        return this.paConfig;
    },

    /**
     * 获取性能分析统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.paConfig.enabled,
            monitoringInterval: this.paConfig.monitoringInterval,
            maxMetrics: this.paConfig.maxMetrics,
            maxHistory: this.paConfig.maxHistory,
            autoAnalyze: this.paConfig.autoAnalyze,
            analysisInterval: this.paConfig.analysisInterval,
            totalMetrics: this.paMetrics.history.length,
            totalAnalysisResults: Object.keys(this.paHistory.analyses).length,
            totalInsights: this.paHistory.insights.length,
            totalWarnings: this.paHistory.warnings.length
        };
    }
};

// 优化：游戏用户分析优化
const GameUserAnalysisOptimizer = {
    uaConfig: {},
    uaUsers: {},
    uaSessions: {},
    uaAnalysis: {},

    /**
     * 初始化游戏用户分析
     */
    init: function () {
        this.loadUAConfig();
        this.loadUAUsers();
        this.loadUASessions();
        this.loadUAAnalysis();
    },

    /**
     * 加载用户分析配置
     */
    loadUAConfig: function () {
        this.uaConfig = {
            enabled: true,
            maxUsers: 1000,
            maxSessions: 10000,
            autoAnalyze: true,
            analysisInterval: 300000,
            trackEvents: [
                'game_start',
                'game_end',
                'level_complete',
                'level_fail',
                'item_collect',
                'enemy_defeat',
                'player_death'
            ]
        };

        const customConfig = localStorage.getItem('uaConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.uaConfig = { ...this.uaConfig, ...config };
            } catch (error) {
                console.error('加载用户分析配置失败:', error);
            }
        }
    },

    /**
     * 保存用户分析配置
     */
    saveUAConfig: function () {
        localStorage.setItem('uaConfig', JSON.stringify(this.uaConfig));
    },

    /**
     * 加载用户数据
     */
    loadUAUsers: function () {
        const savedUsers = localStorage.getItem('uaUsers');
        if (savedUsers) {
            try {
                this.uaUsers = JSON.parse(savedUsers);
            } catch (error) {
                console.error('加载用户数据失败:', error);
            }
        }

        if (!this.uaUsers.users) {
            this.uaUsers = {
                users: {},
                stats: {
                    total: 0,
                    active: 0,
                    new: 0,
                    returning: 0
                }
            };

            this.saveUAUsers();
        }
    },

    /**
     * 保存用户数据
     */
    saveUAUsers: function () {
        localStorage.setItem('uaUsers', JSON.stringify(this.uaUsers));
    },

    /**
     * 加载会话数据
     */
    loadUASessions: function () {
        const savedSessions = localStorage.getItem('uaSessions');
        if (savedSessions) {
            try {
                this.uaSessions = JSON.parse(savedSessions);
            } catch (error) {
                console.error('加载会话数据失败:', error);
            }
        }

        if (!this.uaSessions.sessions) {
            this.uaSessions = {
                sessions: {},
                currentSession: null
            };

            this.saveUASessions();
        }
    },

    /**
     * 保存会话数据
     */
    saveUASessions: function () {
        localStorage.setItem('uaSessions', JSON.stringify(this.uaSessions));
    },

    /**
     * 加载分析结果
     */
    loadUAAnalysis: function () {
        const savedAnalysis = localStorage.getItem('uaAnalysis');
        if (savedAnalysis) {
            try {
                this.uaAnalysis = JSON.parse(savedAnalysis);
            } catch (error) {
                console.error('加载分析结果失败:', error);
            }
        }

        if (!this.uaAnalysis.results) {
            this.uaAnalysis = {
                results: {},
                insights: [],
                recommendations: []
            };

            this.saveUAAnalysis();
        }
    },

    /**
     * 保存分析结果
     */
    saveUAAnalysis: function () {
        localStorage.setItem('uaAnalysis', JSON.stringify(this.uaAnalysis));
    },

    /**
     * 创建用户
     * @param {string} userId - 用户ID
     * @returns {Object} 用户对象
     */
    createUser: function (userId) {
        if (!this.uaConfig.enabled) {
            return null;
        }

        if (this.uaUsers.users[userId]) {
            return this.uaUsers.users[userId];
        }

        const user = {
            id: userId,
            createdAt: Date.now(),
            lastSeen: Date.now(),
            sessions: 0,
            totalTime: 0,
            totalScore: 0,
            maxScore: 0,
            totalLevels: 0,
            maxLevel: 0,
            events: [],
            properties: {}
        };

        this.uaUsers.users[userId] = user;
        this.uaUsers.stats.total++;
        this.uaUsers.stats.new++;

        this.saveUAUsers();

        return user;
    },

    /**
     * 获取用户
     * @param {string} userId - 用户ID
     * @returns {Object|null} 用户对象
     */
    getUser: function (userId) {
        return this.uaUsers.users[userId] || null;
    },

    /**
     * 更新用户
     * @param {string} userId - 用户ID
     * @param {Object} updates - 更新数据
     */
    updateUser: function (userId, updates) {
        const user = this.uaUsers.users[userId];

        if (!user) {
            return;
        }

        Object.assign(user, updates);
        user.lastSeen = Date.now();

        this.saveUAUsers();
    },

    /**
     * 开始会话
     * @param {string} userId - 用户ID
     * @returns {Object} 会话对象
     */
    startSession: function (userId) {
        if (!this.uaConfig.enabled) {
            return null;
        }

        // 创建用户
        this.createUser(userId);

        const sessionId = 'session_' + Date.now();

        const session = {
            id: sessionId,
            userId: userId,
            startTime: Date.now(),
            endTime: null,
            duration: 0,
            events: [],
            score: 0,
            level: 1,
            deaths: 0,
            itemsCollected: 0,
            enemiesDefeated: 0
        };

        this.uaSessions.sessions[sessionId] = session;
        this.uaSessions.currentSession = sessionId;

        // 更新用户
        this.updateUser(userId, {
            sessions: this.uaUsers.users[userId].sessions + 1
        });

        // 记录事件
        this.trackEvent(userId, 'session_start', {
            sessionId: sessionId
        });

        this.saveUASessions();

        return session;
    },

    /**
     * 结束会话
     * @returns {Object} 会话对象
     */
    endSession: function () {
        const sessionId = this.uaSessions.currentSession;

        if (!sessionId) {
            return null;
        }

        const session = this.uaSessions.sessions[sessionId];

        if (!session) {
            return null;
        }

        session.endTime = Date.now();
        session.duration = session.endTime - session.startTime;

        // 更新用户
        this.updateUser(session.userId, {
            totalTime: this.uaUsers.users[session.userId].totalTime + session.duration,
            totalScore: this.uaUsers.users[session.userId].totalScore + session.score,
            maxScore: Math.max(this.uaUsers.users[session.userId].maxScore, session.score),
            maxLevel: Math.max(this.uaUsers.users[session.userId].maxLevel, session.level)
        });

        // 记录事件
        this.trackEvent(session.userId, 'session_end', {
            sessionId: sessionId,
            duration: session.duration,
            score: session.score
        });

        this.uaSessions.currentSession = null;
        this.saveUASessions();

        return session;
    },

    /**
     * 获取当前会话
     * @returns {Object|null} 会话对象
     */
    getCurrentSession: function () {
        const sessionId = this.uaSessions.currentSession;

        if (!sessionId) {
            return null;
        }

        return this.uaSessions.sessions[sessionId] || null;
    },

    /**
     * 记录事件
     * @param {string} userId - 用户ID
     * @param {string} eventName - 事件名称
     * @param {Object} eventData - 事件数据
     */
    trackEvent: function (userId, eventName, eventData) {
        if (!this.uaConfig.enabled) {
            return;
        }

        if (!this.uaConfig.trackEvents.includes(eventName)) {
            return;
        }

        const user = this.uaUsers.users[userId];

        if (!user) {
            return;
        }

        const event = {
            id: 'event_' + Date.now(),
            name: eventName,
            data: eventData || {},
            timestamp: Date.now()
        };

        user.events.push(event);

        // 更新当前会话
        const session = this.getCurrentSession();

        if (session) {
            session.events.push(event);

            // 更新会话统计
            if (eventName === 'item_collect') {
                session.itemsCollected++;
            } else if (eventName === 'enemy_defeat') {
                session.enemiesDefeated++;
            } else if (eventName === 'player_death') {
                session.deaths++;
            }
        }

        this.saveUAUsers();
        this.saveUASessions();
    },

    /**
     * 分析用户
     * @returns {Object} 分析结果
     */
    analyzeUsers: function () {
        if (!this.uaConfig.enabled) {
            return {
                success: false,
                error: '用户分析已禁用'
            };
        }

        const analysisId = 'analysis_' + Date.now();

        // 用户统计
        const userStats = this.calculateUserStats();

        // 会话统计
        const sessionStats = this.calculateSessionStats();

        // 事件统计
        const eventStats = this.calculateEventStats();

        // 用户分群
        const userSegments = this.segmentUsers();

        // 生成洞察
        const insights = this.generateInsights(userStats, sessionStats, eventStats, userSegments);

        // 生成建议
        const recommendations = this.generateRecommendations(userStats, sessionStats, eventStats, userSegments);

        // 保存分析结果
        this.uaAnalysis.results[analysisId] = {
            id: analysisId,
            userStats: userStats,
            sessionStats: sessionStats,
            eventStats: eventStats,
            userSegments: userSegments,
            createdAt: Date.now()
        };

        this.uaAnalysis.insights = insights;
        this.uaAnalysis.recommendations = recommendations;

        this.saveUAAnalysis();

        return {
            success: true,
            analysis: this.uaAnalysis.results[analysisId]
        };
    },

    /**
     * 计算用户统计
     * @returns {Object} 用户统计
     */
    calculateUserStats: function () {
        const users = Object.values(this.uaUsers.users);
        const now = Date.now();
        const dayAgo = now - 86400000;
        const weekAgo = now - 604800000;

        return {
            total: users.length,
            active: users.filter(u => u.lastSeen > dayAgo).length,
            new: users.filter(u => u.createdAt > weekAgo).length,
            returning: users.filter(u => u.createdAt < weekAgo && u.lastSeen > dayAgo).length,
            avgSessions: users.length > 0 ? users.reduce((sum, u) => sum + u.sessions, 0) / users.length : 0,
            avgTotalTime: users.length > 0 ? users.reduce((sum, u) => sum + u.totalTime, 0) / users.length : 0,
            avgTotalScore: users.length > 0 ? users.reduce((sum, u) => sum + u.totalScore, 0) / users.length : 0,
            avgMaxScore: users.length > 0 ? users.reduce((sum, u) => sum + u.maxScore, 0) / users.length : 0,
            avgMaxLevel: users.length > 0 ? users.reduce((sum, u) => sum + u.maxLevel, 0) / users.length : 0
        };
    },

    /**
     * 计算会话统计
     * @returns {Object} 会话统计
     */
    calculateSessionStats: function () {
        const sessions = Object.values(this.uaSessions.sessions);

        return {
            total: sessions.length,
            avgDuration: sessions.length > 0 ? sessions.reduce((sum, s) => sum + s.duration, 0) / sessions.length : 0,
            avgScore: sessions.length > 0 ? sessions.reduce((sum, s) => sum + s.score, 0) / sessions.length : 0,
            avgDeaths: sessions.length > 0 ? sessions.reduce((sum, s) => sum + s.deaths, 0) / sessions.length : 0,
            avgItemsCollected: sessions.length > 0 ? sessions.reduce((sum, s) => sum + s.itemsCollected, 0) / sessions.length : 0,
            avgEnemiesDefeated: sessions.length > 0 ? sessions.reduce((sum, s) => sum + s.enemiesDefeated, 0) / sessions.length : 0
        };
    },

    /**
     * 计算事件统计
     * @returns {Object} 事件统计
     */
    calculateEventStats: function () {
        const eventStats = {};

        for (const eventName of this.uaConfig.trackEvents) {
            eventStats[eventName] = 0;
        }

        const users = Object.values(this.uaUsers.users);

        for (const user of users) {
            for (const event of user.events) {
                if (eventStats[event.name] !== undefined) {
                    eventStats[event.name]++;
                }
            }
        }

        return eventStats;
    },

    /**
     * 用户分群
     * @returns {Object} 用户分群
     */
    segmentUsers: function () {
        const users = Object.values(this.uaUsers.users);

        return {
            newbies: users.filter(u => u.sessions <= 3),
            casual: users.filter(u => u.sessions > 3 && u.sessions <= 10),
            regular: users.filter(u => u.sessions > 10 && u.sessions <= 50),
            hardcore: users.filter(u => u.sessions > 50),
            highScorers: users.filter(u => u.maxScore > 1000),
            highLevelers: users.filter(u => u.maxLevel > 10)
        };
    },

    /**
     * 生成洞察
     * @param {Object} userStats - 用户统计
     * @param {Object} sessionStats - 会话统计
     * @param {Object} eventStats - 事件统计
     * @param {Object} userSegments - 用户分群
     * @returns {Array} 洞察列表
     */
    generateInsights: function (userStats, sessionStats, eventStats, userSegments) {
        const insights = [];

        // 用户活跃度洞察
        if (userStats.active / userStats.total < 0.5) {
            insights.push({
                type: 'engagement',
                message: '用户活跃度较低，需要提高用户留存',
                severity: 'medium'
            });
        }

        // 新用户洞察
        if (userStats.new / userStats.total > 0.3) {
            insights.push({
                type: 'growth',
                message: '新用户比例较高，增长良好',
                severity: 'low'
            });
        }

        // 会话时长洞察
        if (sessionStats.avgDuration < 300000) {
            insights.push({
                type: 'engagement',
                message: '平均会话时长较短，需要提高游戏吸引力',
                severity: 'medium'
            });
        }

        // 事件洞察
        if (eventStats.player_death / eventStats.game_start > 0.5) {
            insights.push({
                type: 'difficulty',
                message: '玩家死亡率较高，可能需要降低难度',
                severity: 'high'
            });
        }

        return insights;
    },

    /**
     * 生成建议
     * @param {Object} userStats - 用户统计
     * @param {Object} sessionStats - 会话统计
     * @param {Object} eventStats - 事件统计
     * @param {Object} userSegments - 用户分群
     * @returns {Array} 建议列表
     */
    generateRecommendations: function (userStats, sessionStats, eventStats, userSegments) {
        const recommendations = [];

        // 用户留存建议
        if (userStats.returning / userStats.total < 0.3) {
            recommendations.push({
                type: 'retention',
                message: '建议增加每日任务和奖励系统以提高用户留存',
                priority: 'high'
            });
        }

        // 游戏难度建议
        if (eventStats.player_death / eventStats.game_start > 0.5) {
            recommendations.push({
                type: 'difficulty',
                message: '建议调整游戏难度，降低玩家死亡率',
                priority: 'high'
            });
        }

        // 用户分群建议
        if (userSegments.hardcore.length / userStats.total > 0.1) {
            recommendations.push({
                type: 'content',
                message: '建议为硬核玩家提供更多挑战性内容',
                priority: 'medium'
            });
        }

        return recommendations;
    },

    /**
     * 获取所有用户
     * @returns {Array} 用户列表
     */
    getAllUsers: function () {
        return Object.values(this.uaUsers.users);
    },

    /**
     * 获取所有会话
     * @returns {Array} 会话列表
     */
    getAllSessions: function () {
        return Object.values(this.uaSessions.sessions);
    },

    /**
     * 获取用户统计
     * @returns {Object} 统计信息
     */
    getUserStats: function () {
        return this.uaUsers.stats;
    },

    /**
     * 获取分析结果
     * @param {string} analysisId - 分析ID
     * @returns {Object|null} 分析结果
     */
    getAnalysisResult: function (analysisId) {
        return this.uaAnalysis.results[analysisId] || null;
    },

    /**
     * 获取所有分析结果
     * @returns {Array} 分析结果列表
     */
    getAllAnalysisResults: function () {
        return Object.values(this.uaAnalysis.results);
    },

    /**
     * 获取洞察
     * @returns {Array} 洞察列表
     */
    getInsights: function () {
        return this.uaAnalysis.insights;
    },

    /**
     * 获取建议
     * @returns {Array} 建议列表
     */
    getRecommendations: function () {
        return this.uaAnalysis.recommendations;
    },

    /**
     * 清除所有用户数据
     */
    clearUsers: function () {
        this.uaUsers = {
            users: {},
            stats: {
                total: 0,
                active: 0,
                new: 0,
                returning: 0
            }
        };

        this.saveUAUsers();
    },

    /**
     * 清除所有会话数据
     */
    clearSessions: function () {
        this.uaSessions = {
            sessions: {},
            currentSession: null
        };

        this.saveUASessions();
    },

    /**
     * 清除所有分析结果
     */
    clearAnalysis: function () {
        this.uaAnalysis = {
            results: {},
            insights: [],
            recommendations: []
        };

        this.saveUAAnalysis();
    },

    /**
     * 设置用户分析配置
     * @param {Object} config - 配置对象
     */
    setUAConfig: function (config) {
        this.uaConfig = { ...this.uaConfig, ...config };
        this.saveUAConfig();
    },

    /**
     * 获取用户分析配置
     * @returns {Object} 配置对象
     */
    getUAConfig: function () {
        return this.uaConfig;
    },

    /**
     * 获取用户分析统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.uaConfig.enabled,
            maxUsers: this.uaConfig.maxUsers,
            maxSessions: this.uaConfig.maxSessions,
            autoAnalyze: this.uaConfig.autoAnalyze,
            analysisInterval: this.uaConfig.analysisInterval,
            totalUsers: Object.keys(this.uaUsers.users).length,
            totalSessions: Object.keys(this.uaSessions.sessions).length,
            totalAnalysisResults: Object.keys(this.uaAnalysis.results).length,
            totalInsights: this.uaAnalysis.insights.length,
            totalRecommendations: this.uaAnalysis.recommendations.length
        };
    }
};

// 优化：游戏行为分析优化
const GameBehaviorAnalysisOptimizer = {
    baConfig: {},
    baBehaviors: {},
    baPatterns: {},
    baAnalysis: {},

    /**
     * 初始化游戏行为分析
     */
    init: function () {
        this.loadBAConfig();
        this.loadBABehaviors();
        this.loadBAPatterns();
        this.loadBAAnalysis();
        this.startTracking();
    },

    /**
     * 加载行为分析配置
     */
    loadBAConfig: function () {
        this.baConfig = {
            enabled: true,
            trackingInterval: 100,
            maxBehaviors: 10000,
            maxPatterns: 100,
            autoDetect: true,
            detectionInterval: 10000,
            behaviorTypes: [
                'movement',
                'interaction',
                'combat',
                'exploration',
                'puzzle',
                'social'
            ]
        };

        const customConfig = localStorage.getItem('baConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.baConfig = { ...this.baConfig, ...config };
            } catch (error) {
                console.error('加载行为分析配置失败:', error);
            }
        }
    },

    /**
     * 保存行为分析配置
     */
    saveBAConfig: function () {
        localStorage.setItem('baConfig', JSON.stringify(this.baConfig));
    },

    /**
     * 加载行为数据
     */
    loadBABehaviors: function () {
        const savedBehaviors = localStorage.getItem('baBehaviors');
        if (savedBehaviors) {
            try {
                this.baBehaviors = JSON.parse(savedBehaviors);
            } catch (error) {
                console.error('加载行为数据失败:', error);
            }
        }

        if (!this.baBehaviors.behaviors) {
            this.baBehaviors = {
                behaviors: [],
                stats: {
                    total: 0,
                    byType: {}
                }
            };

            this.saveBABehaviors();
        }
    },

    /**
     * 保存行为数据
     */
    saveBABehaviors: function () {
        localStorage.setItem('baBehaviors', JSON.stringify(this.baBehaviors));
    },

    /**
     * 加载模式数据
     */
    loadBAPatterns: function () {
        const savedPatterns = localStorage.getItem('baPatterns');
        if (savedPatterns) {
            try {
                this.baPatterns = JSON.parse(savedPatterns);
            } catch (error) {
                console.error('加载模式数据失败:', error);
            }
        }

        if (!this.baPatterns.patterns) {
            this.baPatterns = {
                patterns: {},
                templates: {}
            };

            this.saveBAPatterns();
        }
    },

    /**
     * 保存模式数据
     */
    saveBAPatterns: function () {
        localStorage.setItem('baPatterns', JSON.stringify(this.baPatterns));
    },

    /**
     * 加载分析结果
     */
    loadBAAnalysis: function () {
        const savedAnalysis = localStorage.getItem('baAnalysis');
        if (savedAnalysis) {
            try {
                this.baAnalysis = JSON.parse(savedAnalysis);
            } catch (error) {
                console.error('加载分析结果失败:', error);
            }
        }

        if (!this.baAnalysis.results) {
            this.baAnalysis = {
                results: {},
                insights: [],
                predictions: []
            };

            this.saveBAAnalysis();
        }
    },

    /**
     * 保存分析结果
     */
    saveBAAnalysis: function () {
        localStorage.setItem('baAnalysis', JSON.stringify(this.baAnalysis));
    },

    /**
     * 开始跟踪
     */
    startTracking: function () {
        setInterval(() => {
            if (this.baConfig.enabled) {
                this.trackBehaviors();
            }
        }, this.baConfig.trackingInterval);

        // 自动检测模式
        setInterval(() => {
            if (this.baConfig.enabled && this.baConfig.autoDetect) {
                this.detectPatterns();
            }
        }, this.baConfig.detectionInterval);
    },

    /**
     * 跟踪行为
     */
    trackBehaviors: function () {
        // 模拟行为跟踪
        if (window.StickmanAdventure && StickmanAdventure.game) {
            const player = StickmanAdventure.game.player;

            // 跟踪移动行为
            if (player) {
                this.recordBehavior('movement', {
                    x: player.x,
                    y: player.y,
                    velocity: player.velocity || 0
                });
            }

            // 跟踪交互行为
            if (StickmanAdventure.game.items) {
                const collectedItems = StickmanAdventure.game.items.filter(item => item.collected);

                if (collectedItems.length > 0) {
                    this.recordBehavior('interaction', {
                        type: 'collect',
                        count: collectedItems.length
                    });
                }
            }

            // 跟踪战斗行为
            if (StickmanAdventure.game.enemies) {
                const defeatedEnemies = StickmanAdventure.game.enemies.filter(enemy => enemy.health <= 0);

                if (defeatedEnemies.length > 0) {
                    this.recordBehavior('combat', {
                        type: 'defeat',
                        count: defeatedEnemies.length
                    });
                }
            }
        }
    },

    /**
     * 记录行为
     * @param {string} type - 行为类型
     * @param {Object} data - 行为数据
     */
    recordBehavior: function (type, data) {
        if (!this.baConfig.enabled) {
            return;
        }

        if (!this.baConfig.behaviorTypes.includes(type)) {
            return;
        }

        const behavior = {
            id: 'behavior_' + Date.now(),
            type: type,
            data: data || {},
            timestamp: Date.now()
        };

        this.baBehaviors.behaviors.push(behavior);

        // 更新统计
        this.baBehaviors.stats.total++;

        if (!this.baBehaviors.stats.byType[type]) {
            this.baBehaviors.stats.byType[type] = 0;
        }

        this.baBehaviors.stats.byType[type]++;

        // 清理旧行为
        this.cleanupOldBehaviors();

        this.saveBABehaviors();
    },

    /**
     * 清理旧行为
     */
    cleanupOldBehaviors: function () {
        if (this.baBehaviors.behaviors.length > this.baConfig.maxBehaviors) {
            const behaviorsToDelete = this.baBehaviors.behaviors.length - this.baConfig.maxBehaviors;

            for (let i = 0; i < behaviorsToDelete; i++) {
                const deletedBehavior = this.baBehaviors.behaviors.shift();

                // 更新统计
                this.baBehaviors.stats.total--;
                this.baBehaviors.stats.byType[deletedBehavior.type]--;
            }

            this.saveBABehaviors();
        }
    },

    /**
     * 检测模式
     * @returns {Object} 检测结果
     */
    detectPatterns: function () {
        if (!this.baConfig.enabled) {
            return {
                success: false,
                error: '行为分析已禁用'
            };
        }

        const analysisId = 'analysis_' + Date.now();

        // 移动模式
        const movementPatterns = this.detectMovementPatterns();

        // 交互模式
        const interactionPatterns = this.detectInteractionPatterns();

        // 战斗模式
        const combatPatterns = this.detectCombatPatterns();

        // 探索模式
        const explorationPatterns = this.detectExplorationPatterns();

        // 生成洞察
        const insights = this.generateInsights(movementPatterns, interactionPatterns, combatPatterns, explorationPatterns);

        // 生成预测
        const predictions = this.generatePredictions(movementPatterns, interactionPatterns, combatPatterns, explorationPatterns);

        // 保存分析结果
        this.baAnalysis.results[analysisId] = {
            id: analysisId,
            movement: movementPatterns,
            interaction: interactionPatterns,
            combat: combatPatterns,
            exploration: explorationPatterns,
            createdAt: Date.now()
        };

        this.baAnalysis.insights = insights;
        this.baAnalysis.predictions = predictions;

        this.saveBAAnalysis();

        return {
            success: true,
            analysis: this.baAnalysis.results[analysisId]
        };
    },

    /**
     * 检测移动模式
     * @returns {Object} 移动模式
     */
    detectMovementPatterns: function () {
        const movements = this.baBehaviors.behaviors.filter(b => b.type === 'movement');

        if (movements.length === 0) {
            return {
                total: 0,
                averageVelocity: 0,
                directionPreference: null,
                movementStyle: 'unknown'
            };
        }

        const velocities = movements.map(m => m.data.velocity || 0);
        const averageVelocity = velocities.reduce((sum, v) => sum + v, 0) / velocities.length;

        // 检测方向偏好
        const directions = movements.map(m => {
            if (m.data.x > 500) return 'right';
            if (m.data.x < 200) return 'left';
            if (m.data.y > 300) return 'down';
            return 'up';
        });

        const directionCounts = {};

        for (const direction of directions) {
            if (!directionCounts[direction]) {
                directionCounts[direction] = 0;
            }

            directionCounts[direction]++;
        }

        const directionPreference = Object.keys(directionCounts).reduce((a, b) => directionCounts[a] > directionCounts[b] ? a : b);

        // 检测移动风格
        let movementStyle = 'unknown';

        if (averageVelocity > 10) {
            movementStyle = 'aggressive';
        } else if (averageVelocity > 5) {
            movementStyle = 'normal';
        } else {
            movementStyle = 'cautious';
        }

        return {
            total: movements.length,
            averageVelocity: averageVelocity,
            directionPreference: directionPreference,
            movementStyle: movementStyle
        };
    },

    /**
     * 检测交互模式
     * @returns {Object} 交互模式
     */
    detectInteractionPatterns: function () {
        const interactions = this.baBehaviors.behaviors.filter(b => b.type === 'interaction');

        if (interactions.length === 0) {
            return {
                total: 0,
                averageFrequency: 0,
                preferredType: null
            };
        }

        const types = interactions.map(i => i.data.type);
        const typeCounts = {};

        for (const type of types) {
            if (!typeCounts[type]) {
                typeCounts[type] = 0;
            }

            typeCounts[type]++;
        }

        const preferredType = Object.keys(typeCounts).reduce((a, b) => typeCounts[a] > typeCounts[b] ? a : b);

        // 计算平均频率
        const timeSpan = interactions[interactions.length - 1].timestamp - interactions[0].timestamp;
        const averageFrequency = interactions.length / (timeSpan / 1000);

        return {
            total: interactions.length,
            averageFrequency: averageFrequency,
            preferredType: preferredType,
            typeDistribution: typeCounts
        };
    },

    /**
     * 检测战斗模式
     * @returns {Object} 战斗模式
     */
    detectCombatPatterns: function () {
        const combats = this.baBehaviors.behaviors.filter(b => b.type === 'combat');

        if (combats.length === 0) {
            return {
                total: 0,
                averageEnemiesPerEncounter: 0,
                preferredTactic: null,
                successRate: 0
            };
        }

        const enemies = combats.map(c => c.data.count || 0);
        const averageEnemiesPerEncounter = enemies.reduce((sum, e) => sum + e, 0) / enemies.length;

        const tactics = combats.map(c => c.data.tactic || 'unknown');
        const tacticCounts = {};

        for (const tactic of tactics) {
            if (!tacticCounts[tactic]) {
                tacticCounts[tactic] = 0;
            }

            tacticCounts[tactic]++;
        }

        const preferredTactic = Object.keys(tacticCounts).reduce((a, b) => tacticCounts[a] > tacticCounts[b] ? a : b);

        // 计算成功率
        const successfulCombats = combats.filter(c => c.data.success);
        const successRate = combats.length > 0 ? successfulCombats.length / combats.length : 0;

        return {
            total: combats.length,
            averageEnemiesPerEncounter: averageEnemiesPerEncounter,
            preferredTactic: preferredTactic,
            successRate: successRate
        };
    },

    /**
     * 检测探索模式
     * @returns {Object} 探索模式
     */
    detectExplorationPatterns: function () {
        const movements = this.baBehaviors.behaviors.filter(b => b.type === 'movement');

        if (movements.length === 0) {
            return {
                total: 0,
                coverage: 0,
                explorationStyle: 'unknown',
                revisitRate: 0
            };
        }

        // 计算覆盖范围
        const positions = movements.map(m => ({ x: m.data.x, y: m.data.y }));
        const uniquePositions = new Set(positions.map(p => `${p.x},${p.y}`));
        const coverage = uniquePositions.size / positions.length;

        // 检测探索风格
        let explorationStyle = 'unknown';

        if (coverage > 0.8) {
            explorationStyle = 'thorough';
        } else if (coverage > 0.5) {
            explorationStyle = 'balanced';
        } else {
            explorationStyle = 'focused';
        }

        // 计算重访率
        const revisitCount = positions.length - uniquePositions.size;
        const revisitRate = revisitCount / positions.length;

        return {
            total: movements.length,
            coverage: coverage,
            explorationStyle: explorationStyle,
            revisitRate: revisitRate
        };
    },

    /**
     * 生成洞察
     * @param {Object} movementPatterns - 移动模式
     * @param {Object} interactionPatterns - 交互模式
     * @param {Object} combatPatterns - 战斗模式
     * @param {Object} explorationPatterns - 探索模式
     * @returns {Array} 洞察列表
     */
    generateInsights: function (movementPatterns, interactionPatterns, combatPatterns, explorationPatterns) {
        const insights = [];

        // 移动洞察
        if (movementPatterns.movementStyle === 'aggressive') {
            insights.push({
                type: 'movement',
                message: '玩家移动风格激进，可能偏好快速游戏体验',
                severity: 'low'
            });
        }

        // 交互洞察
        if (interactionPatterns.averageFrequency > 1) {
            insights.push({
                type: 'interaction',
                message: '玩家交互频率较高，积极参与游戏',
                severity: 'low'
            });
        }

        // 战斗洞察
        if (combatPatterns.successRate < 0.5) {
            insights.push({
                type: 'combat',
                message: '战斗成功率较低，可能需要难度调整',
                severity: 'high'
            });
        }

        // 探索洞察
        if (explorationPatterns.coverage < 0.3) {
            insights.push({
                type: 'exploration',
                message: '探索覆盖率较低，玩家可能错过内容',
                severity: 'medium'
            });
        }

        return insights;
    },

    /**
     * 生成预测
     * @param {Object} movementPatterns - 移动模式
     * @param {Object} interactionPatterns - 交互模式
     * @param {Object} combatPatterns - 战斗模式
     * @param {Object} explorationPatterns - 探索模式
     * @returns {Array} 预测列表
     */
    generatePredictions: function (movementPatterns, interactionPatterns, combatPatterns, explorationPatterns) {
        const predictions = [];

        // 预测流失风险
        let churnRisk = 'low';

        if (combatPatterns.successRate < 0.3) {
            churnRisk = 'high';
        } else if (combatPatterns.successRate < 0.5) {
            churnRisk = 'medium';
        }

        predictions.push({
            type: 'churn',
            message: `流失风险: ${churnRisk}`,
            risk: churnRisk
        });

        // 预测游戏偏好
        let gamePreference = 'balanced';

        if (movementPatterns.movementStyle === 'aggressive' && combatPatterns.successRate > 0.7) {
            gamePreference = 'action';
        } else if (explorationPatterns.coverage > 0.7) {
            gamePreference = 'exploration';
        } else if (interactionPatterns.preferredType === 'collect') {
            gamePreference = 'collection';
        }

        predictions.push({
            type: 'preference',
            message: `游戏偏好: ${gamePreference}`,
            preference: gamePreference
        });

        return predictions;
    },

    /**
     * 获取行为数据
     * @param {string} type - 行为类型
     * @returns {Array} 行为列表
     */
    getBehaviors: function (type) {
        if (type) {
            return this.baBehaviors.behaviors.filter(b => b.type === type);
        }

        return this.baBehaviors.behaviors;
    },

    /**
     * 获取行为统计
     * @returns {Object} 统计信息
     */
    getBehaviorStats: function () {
        return this.baBehaviors.stats;
    },

    /**
     * 获取分析结果
     * @param {string} analysisId - 分析ID
     * @returns {Object|null} 分析结果
     */
    getAnalysisResult: function (analysisId) {
        return this.baAnalysis.results[analysisId] || null;
    },

    /**
     * 获取所有分析结果
     * @returns {Array} 分析结果列表
     */
    getAllAnalysisResults: function () {
        return Object.values(this.baAnalysis.results);
    },

    /**
     * 获取洞察
     * @returns {Array} 洞察列表
     */
    getInsights: function () {
        return this.baAnalysis.insights;
    },

    /**
     * 获取预测
     * @returns {Array} 预测列表
     */
    getPredictions: function () {
        return this.baAnalysis.predictions;
    },

    /**
     * 清除所有行为数据
     */
    clearBehaviors: function () {
        this.baBehaviors = {
            behaviors: [],
            stats: {
                total: 0,
                byType: {}
            }
        };

        this.saveBABehaviors();
    },

    /**
     * 清除所有模式数据
     */
    clearPatterns: function () {
        this.baPatterns = {
            patterns: {},
            templates: {}
        };

        this.saveBAPatterns();
    },

    /**
     * 清除所有分析结果
     */
    clearAnalysis: function () {
        this.baAnalysis = {
            results: {},
            insights: [],
            predictions: []
        };

        this.saveBAAnalysis();
    },

    /**
     * 设置行为分析配置
     * @param {Object} config - 配置对象
     */
    setBAConfig: function (config) {
        this.baConfig = { ...this.baConfig, ...config };
        this.saveBAConfig();
    },

    /**
     * 获取行为分析配置
     * @returns {Object} 配置对象
     */
    getBAConfig: function () {
        return this.baConfig;
    },

    /**
     * 获取行为分析统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.baConfig.enabled,
            trackingInterval: this.baConfig.trackingInterval,
            maxBehaviors: this.baConfig.maxBehaviors,
            maxPatterns: this.baConfig.maxPatterns,
            autoDetect: this.baConfig.autoDetect,
            detectionInterval: this.baConfig.detectionInterval,
            totalBehaviors: this.baBehaviors.behaviors.length,
            totalPatterns: Object.keys(this.baPatterns.patterns).length,
            totalAnalysisResults: Object.keys(this.baAnalysis.results).length,
            totalInsights: this.baAnalysis.insights.length,
            totalPredictions: this.baAnalysis.predictions.length
        };
    }
};

// 优化：游戏趋势分析优化
const GameTrendAnalysisOptimizer = {
    taConfig: {},
    taData: {},
    taAnalysis: {},

    /**
     * 初始化游戏趋势分析
     */
    init: function () {
        this.loadTAConfig();
        this.loadTAData();
        this.loadTAAnalysis();
        this.startCollection();
    },

    /**
     * 加载趋势分析配置
     */
    loadTAConfig: function () {
        this.taConfig = {
            enabled: true,
            collectionInterval: 60000,
            maxDataPoints: 1000,
            autoAnalyze: true,
            analysisInterval: 300000,
            trendTypes: [
                'user_growth',
                'engagement',
                'retention',
                'revenue',
                'performance'
            ]
        };

        const customConfig = localStorage.getItem('taConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.taConfig = { ...this.taConfig, ...config };
            } catch (error) {
                console.error('加载趋势分析配置失败:', error);
            }
        }
    },

    /**
     * 保存趋势分析配置
     */
    saveTAConfig: function () {
        localStorage.setItem('taConfig', JSON.stringify(this.taConfig));
    },

    /**
     * 加载趋势数据
     */
    loadTAData: function () {
        const savedData = localStorage.getItem('taData');
        if (savedData) {
            try {
                this.taData = JSON.parse(savedData);
            } catch (error) {
                console.error('加载趋势数据失败:', error);
            }
        }

        if (!this.taData.data) {
            this.taData = {
                data: {},
                stats: {
                    total: 0,
                    byType: {}
                }
            };

            this.saveTAData();
        }
    },

    /**
     * 保存趋势数据
     */
    saveTAData: function () {
        localStorage.setItem('taData', JSON.stringify(this.taData));
    },

    /**
     * 加载分析结果
     */
    loadTAAnalysis: function () {
        const savedAnalysis = localStorage.getItem('taAnalysis');
        if (savedAnalysis) {
            try {
                this.taAnalysis = JSON.parse(savedAnalysis);
            } catch (error) {
                console.error('加载分析结果失败:', error);
            }
        }

        if (!this.taAnalysis.results) {
            this.taAnalysis = {
                results: {},
                insights: [],
                forecasts: []
            };

            this.saveTAAnalysis();
        }
    },

    /**
     * 保存分析结果
     */
    saveTAAnalysis: function () {
        localStorage.setItem('taAnalysis', JSON.stringify(this.taAnalysis));
    },

    /**
     * 开始收集
     */
    startCollection: function () {
        setInterval(() => {
            if (this.taConfig.enabled) {
                this.collectData();
            }
        }, this.taConfig.collectionInterval);

        // 自动分析
        setInterval(() => {
            if (this.taConfig.enabled && this.taConfig.autoAnalyze) {
                this.analyzeTrends();
            }
        }, this.taConfig.analysisInterval);
    },

    /**
     * 收集数据
     */
    collectData: function () {
        const timestamp = Date.now();

        // 收集用户增长数据
        if (this.taConfig.trendTypes.includes('user_growth')) {
            this.collectTrendData('user_growth', timestamp, this.collectUserGrowthData());
        }

        // 收集参与度数据
        if (this.taConfig.trendTypes.includes('engagement')) {
            this.collectTrendData('engagement', timestamp, this.collectEngagementData());
        }

        // 收集留存数据
        if (this.taConfig.trendTypes.includes('retention')) {
            this.collectTrendData('retention', timestamp, this.collectRetentionData());
        }

        // 收集性能数据
        if (this.taConfig.trendTypes.includes('performance')) {
            this.collectTrendData('performance', timestamp, this.collectPerformanceData());
        }
    },

    /**
     * 收集趋势数据
     * @param {string} trendType - 趋势类型
     * @param {number} timestamp - 时间戳
     * @param {Object} data - 数据
     */
    collectTrendData: function (trendType, timestamp, data) {
        if (!this.taData.data[trendType]) {
            this.taData.data[trendType] = [];
        }

        const dataPoint = {
            timestamp: timestamp,
            data: data
        };

        this.taData.data[trendType].push(dataPoint);

        // 更新统计
        this.taData.stats.total++;

        if (!this.taData.stats.byType[trendType]) {
            this.taData.stats.byType[trendType] = 0;
        }

        this.taData.stats.byType[trendType]++;

        // 清理旧数据
        this.cleanupOldData();

        this.saveTAData();
    },

    /**
     * 收集用户增长数据
     * @returns {Object} 用户增长数据
     */
    collectUserGrowthData: function () {
        // 模拟用户增长数据
        return {
            totalUsers: Math.floor(Math.random() * 1000) + 100,
            newUsers: Math.floor(Math.random() * 10),
            returningUsers: Math.floor(Math.random() * 50),
            activeUsers: Math.floor(Math.random() * 30)
        };
    },

    /**
     * 收集参与度数据
     * @returns {Object} 参与度数据
     */
    collectEngagementData: function () {
        // 模拟参与度数据
        return {
            avgSessionDuration: Math.floor(Math.random() * 3600) + 600,
            avgActionsPerSession: Math.floor(Math.random() * 100) + 10,
            avgScore: Math.floor(Math.random() * 1000),
            completionRate: Math.random() * 0.5 + 0.3
        };
    },

    /**
     * 收集留存数据
     * @returns {Object} 留存数据
     */
    collectRetentionData: function () {
        // 模拟留存数据
        return {
            day1Retention: Math.random() * 0.5 + 0.3,
            day7Retention: Math.random() * 0.3 + 0.1,
            day30Retention: Math.random() * 0.2 + 0.05
        };
    },

    /**
     * 收集性能数据
     * @returns {Object} 性能数据
     */
    collectPerformanceData: function () {
        // 模拟性能数据
        return {
            avgFPS: Math.floor(Math.random() * 30) + 30,
            avgLatency: Math.floor(Math.random() * 50) + 10,
            avgMemory: Math.floor(Math.random() * 50) + 20,
            crashRate: Math.random() * 0.01
        };
    },

    /**
     * 清理旧数据
     */
    cleanupOldData: function () {
        for (const trendType in this.taData.data) {
            if (this.taData.data[trendType].length > this.taConfig.maxDataPoints) {
                const dataToDelete = this.taData.data[trendType].length - this.taConfig.maxDataPoints;

                for (let i = 0; i < dataToDelete; i++) {
                    this.taData.data[trendType].shift();
                }
            }
        }

        this.saveTAData();
    },

    /**
     * 分析趋势
     * @returns {Object} 分析结果
     */
    analyzeTrends: function () {
        if (!this.taConfig.enabled) {
            return {
                success: false,
                error: '趋势分析已禁用'
            };
        }

        const analysisId = 'analysis_' + Date.now();

        // 用户增长趋势
        const userGrowthTrend = this.analyzeUserGrowthTrend();

        // 参与度趋势
        const engagementTrend = this.analyzeEngagementTrend();

        // 留存趋势
        const retentionTrend = this.analyzeRetentionTrend();

        // 性能趋势
        const performanceTrend = this.analyzePerformanceTrend();

        // 生成洞察
        const insights = this.generateInsights(userGrowthTrend, engagementTrend, retentionTrend, performanceTrend);

        // 生成预测
        const forecasts = this.generateForecasts(userGrowthTrend, engagementTrend, retentionTrend, performanceTrend);

        // 保存分析结果
        this.taAnalysis.results[analysisId] = {
            id: analysisId,
            userGrowth: userGrowthTrend,
            engagement: engagementTrend,
            retention: retentionTrend,
            performance: performanceTrend,
            createdAt: Date.now()
        };

        this.taAnalysis.insights = insights;
        this.taAnalysis.forecasts = forecasts;

        this.saveTAAnalysis();

        return {
            success: true,
            analysis: this.taAnalysis.results[analysisId]
        };
    },

    /**
     * 分析用户增长趋势
     * @returns {Object} 用户增长趋势
     */
    analyzeUserGrowthTrend: function () {
        const data = this.taData.data['user_growth'] || [];

        if (data.length < 2) {
            return {
                trend: 'insufficient_data',
                growthRate: 0,
                projection: null
            };
        }

        const recent = data.slice(-10);
        const older = data.slice(-20, -10);

        const recentAvg = recent.reduce((sum, d) => sum + d.data.totalUsers, 0) / recent.length;
        const olderAvg = older.reduce((sum, d) => sum + d.data.totalUsers, 0) / older.length;

        const growthRate = (recentAvg - olderAvg) / olderAvg;

        // 预测未来30天
        const projection = this.projectTrend(data, 30);

        return {
            trend: growthRate > 0.1 ? 'growing' : growthRate < -0.1 ? 'declining' : 'stable',
            growthRate: growthRate,
            projection: projection
        };
    },

    /**
     * 分析参与度趋势
     * @returns {Object} 参与度趋势
     */
    analyzeEngagementTrend: function () {
        const data = this.taData.data['engagement'] || [];

        if (data.length < 2) {
            return {
                trend: 'insufficient_data',
                avgSessionDuration: 0,
                avgActionsPerSession: 0,
                avgScore: 0,
                completionRate: 0
            };
        }

        const recent = data.slice(-10);

        const avgSessionDuration = recent.reduce((sum, d) => sum + d.data.avgSessionDuration, 0) / recent.length;
        const avgActionsPerSession = recent.reduce((sum, d) => sum + d.data.avgActionsPerSession, 0) / recent.length;
        const avgScore = recent.reduce((sum, d) => sum + d.data.avgScore, 0) / recent.length;
        const completionRate = recent.reduce((sum, d) => sum + d.data.completionRate, 0) / recent.length;

        return {
            trend: 'stable',
            avgSessionDuration: avgSessionDuration,
            avgActionsPerSession: avgActionsPerSession,
            avgScore: avgScore,
            completionRate: completionRate
        };
    },

    /**
     * 分析留存趋势
     * @returns {Object} 留存趋势
     */
    analyzeRetentionTrend: function () {
        const data = this.taData.data['retention'] || [];

        if (data.length === 0) {
            return {
                trend: 'insufficient_data',
                day1Retention: 0,
                day7Retention: 0,
                day30Retention: 0
            };
        }

        const recent = data.slice(-10);

        const day1Retention = recent.reduce((sum, d) => sum + d.data.day1Retention, 0) / recent.length;
        const day7Retention = recent.reduce((sum, d) => sum + d.data.day7Retention, 0) / recent.length;
        const day30Retention = recent.reduce((sum, d) => sum + d.data.day30Retention, 0) / recent.length;

        return {
            trend: 'stable',
            day1Retention: day1Retention,
            day7Retention: day7Retention,
            day30Retention: day30Retention
        };
    },

    /**
     * 分析性能趋势
     * @returns {Object} 性能趋势
     */
    analyzePerformanceTrend: function () {
        const data = this.taData.data['performance'] || [];

        if (data.length < 2) {
            return {
                trend: 'insufficient_data',
                avgFPS: 0,
                avgLatency: 0,
                avgMemory: 0,
                crashRate: 0
            };
        }

        const recent = data.slice(-10);

        const avgFPS = recent.reduce((sum, d) => sum + d.data.avgFPS, 0) / recent.length;
        const avgLatency = recent.reduce((sum, d) => sum + d.data.avgLatency, 0) / recent.length;
        const avgMemory = recent.reduce((sum, d) => sum + d.data.avgMemory, 0) / recent.length;
        const crashRate = recent.reduce((sum, d) => sum + d.data.crashRate, 0) / recent.length;

        return {
            trend: 'stable',
            avgFPS: avgFPS,
            avgLatency: avgLatency,
            avgMemory: avgMemory,
            crashRate: crashRate
        };
    },

    /**
     * 预测趋势
     * @param {Array} data - 数据
     * @param {number} days - 天数
     * @returns {Array} 预测结果
     */
    projectTrend: function (data, days) {
        if (data.length < 2) {
            return [];
        }

        const projection = [];

        // 简单的线性回归预测
        const values = data.map(d => d.data.totalUsers);
        const timestamps = data.map(d => d.timestamp);

        const n = values.length;

        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;

        for (let i = 0; i < n; i++) {
            sumX += timestamps[i];
            sumY += values[i];
            sumXY += timestamps[i] * values[i];
            sumX2 += timestamps[i] * timestamps[i];
        }

        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;

        const interval = 86400000; // 一天
        const lastTimestamp = timestamps[timestamps.length - 1];

        for (let i = 1; i <= days; i++) {
            const futureTimestamp = lastTimestamp + i * interval;
            const projectedValue = slope * futureTimestamp + intercept;

            projection.push({
                timestamp: futureTimestamp,
                value: Math.max(0, projectedValue)
            });
        }

        return projection;
    },

    /**
     * 生成洞察
     * @param {Object} userGrowthTrend - 用户增长趋势
     * @param {Object} engagementTrend - 参与度趋势
     * @param {Object} retentionTrend - 留存趋势
     * @param {Object} performanceTrend - 性能趋势
     * @returns {Array} 洞察列表
     */
    generateInsights: function (userGrowthTrend, engagementTrend, retentionTrend, performanceTrend) {
        const insights = [];

        // 用户增长洞察
        if (userGrowthTrend.trend === 'declining') {
            insights.push({
                type: 'growth',
                message: '用户增长呈下降趋势，需要关注用户获取',
                severity: 'high'
            });
        } else if (userGrowthTrend.trend === 'growing') {
            insights.push({
                type: 'growth',
                message: '用户增长良好，继续保持',
                severity: 'low'
            });
        }

        // 参与度洞察
        if (engagementTrend.avgSessionDuration < 300) {
            insights.push({
                type: 'engagement',
                message: '平均会话时长较短，需要提高游戏吸引力',
                severity: 'medium'
            });
        }

        // 留存洞察
        if (retentionTrend.day1Retention < 0.3) {
            insights.push({
                type: 'retention',
                message: '首日留存率较低，需要优化新手体验',
                severity: 'high'
            });
        }

        // 性能洞察
        if (performanceTrend.avgFPS < 30) {
            insights.push({
                type: 'performance',
                message: '平均FPS较低，需要优化性能',
                severity: 'high'
            });
        }

        return insights;
    },

    /**
     * 生成预测
     * @param {Object} userGrowthTrend - 用户增长趋势
     * @param {Object} engagementTrend - 参与度趋势
     * @param {Object} retentionTrend - 留存趋势
     * @param {Object} performanceTrend - 性能趋势
     * @returns {Array} 预测列表
     */
    generateForecasts: function (userGrowthTrend, engagementTrend, retentionTrend, performanceTrend) {
        const forecasts = [];

        // 用户数量预测
        if (userGrowthTrend.projection && userGrowthTrend.projection.length > 0) {
            const futureUsers = userGrowthTrend.projection[userGrowthTrend.projection.length - 1].value;

            forecasts.push({
                type: 'users',
                message: `预计30天后用户数: ${Math.floor(futureUsers)}`,
                value: futureUsers
            });
        }

        // 收入预测
        if (userGrowthTrend.projection && userGrowthTrend.projection.length > 0) {
            const futureUsers = userGrowthTrend.projection[userGrowthTrend.projection.length - 1].value;
            const estimatedRevenue = futureUsers * 0.5; // 假设每用户平均收入0.5

            forecasts.push({
                type: 'revenue',
                message: `预计30天后收入: ${estimatedRevenue.toFixed(2)}`,
                value: estimatedRevenue
            });
        }

        return forecasts;
    },

    /**
     * 获取趋势数据
     * @param {string} trendType - 趋势类型
     * @returns {Array} 趋势数据
     */
    getTrendData: function (trendType) {
        return this.taData.data[trendType] || [];
    },

    /**
     * 获取分析结果
     * @param {string} analysisId - 分析ID
     * @returns {Object|null} 分析结果
     */
    getAnalysisResult: function (analysisId) {
        return this.taAnalysis.results[analysisId] || null;
    },

    /**
     * 获取所有分析结果
     * @returns {Array} 分析结果列表
     */
    getAllAnalysisResults: function () {
        return Object.values(this.taAnalysis.results);
    },

    /**
     * 获取洞察
     * @returns {Array} 洞察列表
     */
    getInsights: function () {
        return this.taAnalysis.insights;
    },

    /**
     * 获取预测
     * @returns {Array} 预测列表
     */
    getForecasts: function () {
        return this.taAnalysis.forecasts;
    },

    /**
     * 清除所有趋势数据
     */
    clearTrendData: function () {
        this.taData = {
            data: {},
            stats: {
                total: 0,
                byType: {}
            }
        };

        this.saveTAData();
    },

    /**
     * 清除所有分析结果
     */
    clearAnalysis: function () {
        this.taAnalysis = {
            results: {},
            insights: [],
            forecasts: []
        };

        this.saveTAAnalysis();
    },

    /**
     * 设置趋势分析配置
     * @param {Object} config - 配置对象
     */
    setTAConfig: function (config) {
        this.taConfig = { ...this.taConfig, ...config };
        this.saveTAConfig();
    },

    /**
     * 获取趋势分析配置
     * @returns {Object} 配置对象
     */
    getTAConfig: function () {
        return this.taConfig;
    },

    /**
     * 获取趋势分析统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.taConfig.enabled,
            collectionInterval: this.taConfig.collectionInterval,
            maxDataPoints: this.taConfig.maxDataPoints,
            autoAnalyze: this.taConfig.autoAnalyze,
            analysisInterval: this.taConfig.analysisInterval,
            totalDataPoints: this.taData.stats.total,
            totalAnalysisResults: Object.keys(this.taAnalysis.results).length,
            totalInsights: this.taAnalysis.insights.length,
            totalForecasts: this.taAnalysis.forecasts.length
        };
    }
};

// 优化：游戏预测分析优化
const GamePredictionAnalysisOptimizer = {
    paConfig: {},
    paModels: {},
    paPredictions: {},

    /**
     * 初始化游戏预测分析
     */
    init: function () {
        this.loadPAConfig();
        this.loadPAModels();
        this.loadPAPredictions();
    },

    /**
     * 加载预测分析配置
     */
    loadPAConfig: function () {
        this.paConfig = {
            enabled: true,
            maxModels: 10,
            maxPredictions: 100,
            autoPredict: true,
            predictionInterval: 300000,
            modelTypes: [
                'user_churn',
                'revenue',
                'engagement',
                'performance',
                'content_consumption'
            ]
        };

        const customConfig = localStorage.getItem('paConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.paConfig = { ...this.paConfig, ...config };
            } catch (error) {
                console.error('加载预测分析配置失败:', error);
            }
        }
    },

    /**
     * 保存预测分析配置
     */
    savePAConfig: function () {
        localStorage.setItem('paConfig', JSON.stringify(this.paConfig));
    },

    /**
     * 加载预测模型
     */
    loadPAModels: function () {
        const savedModels = localStorage.getItem('paModels');
        if (savedModels) {
            try {
                this.paModels = JSON.parse(savedModels);
            } catch (error) {
                console.error('加载预测模型失败:', error);
            }
        }

        if (!this.paModels.models) {
            this.paModels = {
                models: {},
                stats: {
                    total: 0,
                    byType: {},
                    accuracy: {}
                }
            };

            this.savePAModels();
        }
    },

    /**
     * 保存预测模型
     */
    savePAModels: function () {
        localStorage.setItem('paModels', JSON.stringify(this.paModels));
    },

    /**
     * 加载预测结果
     */
    loadPAPredictions: function () {
        const savedPredictions = localStorage.getItem('paPredictions');
        if (savedPredictions) {
            try {
                this.paPredictions = JSON.parse(savedPredictions);
            } catch (error) {
                console.error('加载预测结果失败:', error);
            }
        }

        if (!this.paPredictions.predictions) {
            this.paPredictions = {
                predictions: {},
                stats: {
                    total: 0,
                    byType: {},
                    accuracy: {}
                }
            };

            this.savePAPredictions();
        }
    },

    /**
     * 保存预测结果
     */
    savePAPredictions: function () {
        localStorage.setItem('paPredictions', JSON.stringify(this.paPredictions));
    },

    /**
     * 创建预测模型
     * @param {string} modelType - 模型类型
     * @param {Object} modelData - 模型数据
     * @returns {Object} 模型对象
     */
    createModel: function (modelType, modelData) {
        if (!this.paConfig.enabled) {
            return {
                success: false,
                error: '预测分析已禁用'
            };
        }

        if (!this.paConfig.modelTypes.includes(modelType)) {
            return {
                success: false,
                error: '不支持的模型类型'
            };
        }

        const modelId = 'model_' + Date.now();

        const model = {
            id: modelId,
            type: modelType,
            data: modelData,
            createdAt: Date.now(),
            accuracy: 0,
            predictions: 0,
            correctPredictions: 0
        };

        this.paModels.models[modelId] = model;

        // 更新统计
        this.paModels.stats.total++;

        if (!this.paModels.stats.byType[modelType]) {
            this.paModels.stats.byType[modelType] = 0;
        }

        this.paModels.stats.byType[modelType]++;

        this.savePAModels();

        return {
            success: true,
            model: model
        };
    },

    /**
     * 训练模型
     * @param {string} modelId - 模型ID
     * @param {Array} trainingData - 训练数据
     * @returns {Object} 训练结果
     */
    trainModel: function (modelId, trainingData) {
        if (!this.paConfig.enabled) {
            return {
                success: false,
                error: '预测分析已禁用'
            };
        }

        const model = this.paModels.models[modelId];

        if (!model) {
            return {
                success: false,
                error: '模型不存在'
            };
        }

        // 简化的训练过程
        model.trained = true;
        model.trainedAt = Date.now();
        model.trainingDataSize = trainingData.length;

        this.savePAModels();

        return {
            success: true,
            model: model
        };
    },

    /**
     * 预测
     * @param {string} modelId - 模型ID
     * @param {Object} inputData - 输入数据
     * @returns {Object} 预测结果
     */
    predict: function (modelId, inputData) {
        if (!this.paConfig.enabled) {
            return {
                success: false,
                error: '预测分析已禁用'
            };
        }

        const model = this.paModels.models[modelId];

        if (!model) {
            return {
                success: false,
                error: '模型不存在'
            };
        }

        if (!model.trained) {
            return {
                success: false,
                error: '模型未训练'
            };
        }

        // 根据模型类型进行预测
        let prediction = null;

        switch (model.type) {
            case 'user_churn':
                prediction = this.predictUserChurn(model, inputData);
                break;
            case 'revenue':
                prediction = this.predictRevenue(model, inputData);
                break;
            case 'engagement':
                prediction = this.predictEngagement(model, inputData);
                break;
            case 'performance':
                prediction = this.predictPerformance(model, inputData);
                break;
            case 'content_consumption':
                prediction = this.predictContentConsumption(model, inputData);
                break;
        }

        // 创建预测记录
        const predictionId = 'prediction_' + Date.now();

        const predictionRecord = {
            id: predictionId,
            modelId: modelId,
            modelType: model.type,
            inputData: inputData,
            prediction: prediction,
            confidence: prediction.confidence || 0.5,
            createdAt: Date.now()
        };

        this.paPredictions.predictions[predictionId] = predictionRecord;

        // 更新模型统计
        model.predictions++;
        this.paPredictions.stats.total++;

        if (!this.paPredictions.stats.byType[model.type]) {
            this.paPredictions.stats.byType[model.type] = 0;
        }

        this.paPredictions.stats.byType[model.type]++;

        this.savePAModels();
        this.savePAPredictions();

        return {
            success: true,
            prediction: predictionRecord
        };
    },

    /**
     * 预测用户流失
     * @param {Object} model - 模型对象
     * @param {Object} inputData - 输入数据
     * @returns {Object} 预测结果
     */
    predictUserChurn: function (model, inputData) {
        // 简化的流失预测
        const churnProbability = Math.random() * 0.3;

        return {
            type: 'user_churn',
            churnProbability: churnProbability,
            churnRisk: churnProbability > 0.2 ? 'high' : churnProbability > 0.1 ? 'medium' : 'low',
            confidence: 0.7
        };
    },

    /**
     * 预测收入
     * @param {Object} model - 模型对象
     * @param {Object} inputData - 输入数据
     * @returns {Object} 预测结果
     */
    predictRevenue: function (model, inputData) {
        // 简化的收入预测
        const estimatedRevenue = (inputData.userCount || 100) * 0.5 * (1 + Math.random() * 0.2);

        return {
            type: 'revenue',
            estimatedRevenue: estimatedRevenue,
            revenueRange: {
                low: estimatedRevenue * 0.8,
                high: estimatedRevenue * 1.2
            },
            confidence: 0.6
        };
    },

    /**
     * 预测参与度
     * @param {Object} model - 模型对象
     * @param {Object} inputData - 输入数据
     * @returns {Object} 预测结果
     */
    predictEngagement: function (model, inputData) {
        // 简化的参与度预测
        const engagementScore = Math.random() * 0.5 + 0.5;

        return {
            type: 'engagement',
            engagementScore: engagementScore,
            engagementLevel: engagementScore > 0.7 ? 'high' : engagementScore > 0.4 ? 'medium' : 'low',
            confidence: 0.65
        };
    },

    /**
     * 预测性能
     * @param {Object} model - 模型对象
     * @param {Object} inputData - 输入数据
     * @returns {Object} 预测结果
     */
    predictPerformance: function (model, inputData) {
        // 简化的性能预测
        const fps = Math.floor(Math.random() * 30) + 30;
        const latency = Math.floor(Math.random() * 50) + 10;

        return {
            type: 'performance',
            predictedFPS: fps,
            predictedLatency: latency,
            performanceLevel: fps >= 50 ? 'excellent' : fps >= 30 ? 'good' : 'poor',
            confidence: 0.6
        };
    },

    /**
     * 预测内容消费
     * @param {Object} model - 模型对象
     * @param {Object} inputData - 输入数据
     * @returns {Object} 预测结果
     */
    predictContentConsumption: function (model, inputData) {
        // 简化的内容消费预测
        const completionRate = Math.random() * 0.5 + 0.3;

        return {
            type: 'content_consumption',
            completionRate: completionRate,
            preferredContent: 'action',
            confidence: 0.55
        };
    },

    /**
     * 验证预测
     * @param {string} predictionId - 预测ID
     * @param {Object} actualData - 实际数据
     * @returns {Object} 验证结果
     */
    validatePrediction: function (predictionId, actualData) {
        const prediction = this.paPredictions.predictions[predictionId];

        if (!prediction) {
            return {
                success: false,
                error: '预测不存在'
            };
        }

        const model = this.paModels.models[prediction.modelId];

        if (!model) {
            return {
                success: false,
                error: '模型不存在'
            };
        }

        // 简化的验证
        let accuracy = 0.5;

        switch (prediction.modelType) {
            case 'user_churn':
                const actualChurn = actualData.churned ? 1 : 0;
                const predictedChurn = prediction.prediction.churnProbability > 0.2 ? 1 : 0;
                accuracy = actualChurn === predictedChurn ? 1 : 0;
                break;
            case 'revenue':
                const actualRevenue = actualData.revenue || 0;
                const predictedRevenue = prediction.prediction.estimatedRevenue;
                const error = Math.abs(actualRevenue - predictedRevenue) / predictedRevenue;
                accuracy = Math.max(0, 1 - error);
                break;
        }

        // 更新模型准确率
        model.accuracy = (model.accuracy * model.predictions + accuracy) / (model.predictions + 1);
        model.correctPredictions += accuracy;

        this.savePAModels();

        return {
            success: true,
            accuracy: accuracy
        };
    },

    /**
     * 获取模型
     * @param {string} modelId - 模型ID
     * @returns {Object|null} 模型对象
     */
    getModel: function (modelId) {
        return this.paModels.models[modelId] || null;
    },

    /**
     * 获取所有模型
     * @param {string} modelType - 模型类型
     * @returns {Array} 模型列表
     */
    getAllModels: function (modelType) {
        let models = Object.values(this.paModels.models);

        if (modelType) {
            models = models.filter(m => m.type === modelType);
        }

        return models;
    },

    /**
     * 获取预测
     * @param {string} predictionId - 预测ID
     * @returns {Object|null} 预测对象
     */
    getPrediction: function (predictionId) {
        return this.paPredictions.predictions[predictionId] || null;
    },

    /**
     * 获取所有预测
     * @param {string} modelType - 模型类型
     * @returns {Array} 预测列表
     */
    getAllPredictions: function (modelType) {
        let predictions = Object.values(this.paPredictions.predictions);

        if (modelType) {
            predictions = predictions.filter(p => p.modelType === modelType);
        }

        return predictions;
    },

    /**
     * 获取模型统计
     * @returns {Object} 统计信息
     */
    getModelStats: function () {
        return this.paModels.stats;
    },

    /**
     * 获取预测统计
     * @returns {Object} 统计信息
     */
    getPredictionStats: function () {
        return this.paPredictions.stats;
    },

    /**
     * 删除模型
     * @param {string} modelId - 模型ID
     * @returns {boolean} 是否成功
     */
    deleteModel: function (modelId) {
        if (!this.paModels.models[modelId]) {
            return false;
        }

        delete this.paModels.models[modelId];
        this.savePAModels();

        return true;
    },

    /**
     * 删除预测
     * @param {string} predictionId - 预测ID
     * @returns {boolean} 是否成功
     */
    deletePrediction: function (predictionId) {
        if (!this.paPredictions.predictions[predictionId]) {
            return false;
        }

        delete this.paPredictions.predictions[predictionId];
        this.savePAPredictions();

        return true;
    },

    /**
     * 设置预测分析配置
     * @param {Object} config - 配置对象
     */
    setPAConfig: function (config) {
        this.paConfig = { ...this.paConfig, ...config };
        this.savePAConfig();
    },

    /**
     * 获取预测分析配置
     * @returns {Object} 配置对象
     */
    getPAConfig: function () {
        return this.paConfig;
    },

    /**
     * 获取预测分析统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.paConfig.enabled,
            maxModels: this.paConfig.maxModels,
            maxPredictions: this.paConfig.maxPredictions,
            autoPredict: this.paConfig.autoPredict,
            predictionInterval: this.paConfig.predictionInterval,
            totalModels: Object.keys(this.paModels.models).length,
            totalPredictions: Object.keys(this.paPredictions.predictions).length,
            averageAccuracy: this.calculateAverageAccuracy()
        };
    },

    /**
     * 计算平均准确率
     * @returns {number} 平均准确率
     */
    calculateAverageAccuracy: function () {
        const models = Object.values(this.paModels.models);

        if (models.length === 0) {
            return 0;
        }

        return models.reduce((sum, model) => sum + model.accuracy, 0) / models.length;
    }
};

// 优化：游戏异常检测优化
const GameAnomalyDetectionOptimizer = {
    adConfig: {},
    adAnomalies: {},
    adRules: {},

    /**
     * 初始化游戏异常检测
     */
    init: function () {
        this.loadADConfig();
        this.loadADAnomalies();
        this.loadADRules();
        this.startDetection();
    },

    /**
     * 加载异常检测配置
     */
    loadADConfig: function () {
        this.adConfig = {
            enabled: true,
            detectionInterval: 1000,
            maxAnomalies: 1000,
            autoAlert: true,
            alertInterval: 60000,
            severityLevels: ['low', 'medium', 'high', 'critical'],
            detectionTypes: [
                'performance',
                'behavior',
                'data',
                'security',
                'system'
            ]
        };

        const customConfig = localStorage.getItem('adConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.adConfig = { ...this.adConfig, ...config };
            } catch (error) {
                console.error('加载异常检测配置失败:', error);
            }
        }
    },

    /**
     * 保存异常检测配置
     */
    saveADConfig: function () {
        localStorage.setItem('adConfig', JSON.stringify(this.adConfig));
    },

    /**
     * 加载异常数据
     */
    loadADAnomalies: function () {
        const savedAnomalies = localStorage.getItem('adAnomalies');
        if (savedAnomalies) {
            try {
                this.adAnomalies = JSON.parse(savedAnomalies);
            } catch (error) {
                console.error('加载异常数据失败:', error);
            }
        }

        if (!this.adAnomalies.anomalies) {
            this.adAnomalies = {
                anomalies: {},
                stats: {
                    total: 0,
                    byType: {},
                    bySeverity: {},
                    byStatus: {}
                }
            };

            this.saveADAnomalies();
        }
    },

    /**
     * 保存异常数据
     */
    saveADAnomalies: function () {
        localStorage.setItem('adAnomalies', JSON.stringify(this.adAnomalies));
    },

    /**
     * 加载检测规则
     */
    loadADRules: function () {
        const savedRules = localStorage.getItem('adRules');
        if (savedRules) {
            try {
                this.adRules = JSON.parse(savedRules);
            } catch (error) {
                console.error('加载检测规则失败:', error);
            }
        }

        if (!this.adRules.rules) {
            this.adRules = {
                rules: {},
                stats: {
                    total: 0,
                    byType: {},
                    active: 0
                }
            };

            // 创建默认规则
            this.createDefaultRules();

            this.saveADRules();
        }
    },

    /**
     * 保存检测规则
     */
    saveADRules: function () {
        localStorage.setItem('adRules', JSON.stringify(this.adRules));
    },

    /**
     * 创建默认规则
     */
    createDefaultRules: function () {
        // 性能异常规则
        this.addRule('performance', {
            name: 'low_fps',
            description: 'FPS过低',
            check: (data) => data.fps < 30,
            severity: 'high',
            enabled: true
        });

        this.addRule('performance', {
            name: 'high_latency',
            description: '延迟过高',
            check: (data) => data.latency > 100,
            severity: 'medium',
            enabled: true
        });

        this.addRule('performance', {
            name: 'high_memory',
            description: '内存使用过高',
            check: (data) => data.memory > 100,
            severity: 'critical',
            enabled: true
        });

        // 行为异常规则
        this.addRule('behavior', {
            name: 'abnormal_movement',
            description: '异常移动行为',
            check: (data) => data.velocity > 50,
            severity: 'medium',
            enabled: true
        });

        this.addRule('behavior', {
            name: 'rapid_clicking',
            description: '快速点击',
            check: (data) => data.clicksPerSecond > 10,
            severity: 'low',
            enabled: true
        });

        // 数据异常规则
        this.addRule('data', {
            name: 'score_spike',
            description: '分数异常增长',
            check: (data) => data.scoreIncrease > 1000,
            level: 'high',
            severity: 'high',
            enabled: true
        });

        this.addRule('data', {
            name: 'resource_anomaly',
            description: '资源异常',
            check: (data) => data.resourceCount > 10000,
            severity: 'critical',
            enabled: true
        });

        // 安全异常规则
        this.addRule('security', {
            name: 'modified_client',
            description: '客户端被修改',
            check: (data) => data.clientHash !== 'expected',
            severity: 'critical',
            enabled: true
        });

        // 系统异常规则
        this.addRule('system', {
            name: 'crash_detected',
            description: '检测到崩溃',
            check: (data) => data.crashed,
            severity: 'critical',
            enabled: true
        });
    },

    /**
     * 添加规则
     * @param {string} ruleType - 规则类型
     * @param {Object} rule - 规则对象
     */
    addRule: function (ruleType, rule) {
        if (!this.adConfig.enabled) {
            return;
        }

        if (!this.adConfig.detectionTypes.includes(ruleType)) {
            return;
        }

        const ruleId = 'rule_' + Date.now();

        this.adRules.rules[ruleId] = {
            id: ruleId,
            type: ruleType,
            name: rule.name,
            description: rule.description,
            check: rule.check,
            severity: rule.severity,
            enabled: rule.enabled,
            createdAt: Date.now(),
            triggered: 0,
            lastTriggered: null
        };

        // 更新统计
        this.adRules.stats.total++;

        if (!this.adRules.stats.byType[ruleType]) {
            this.adRules.stats.byType[ruleType] = 0;
        }

        this.adRules.stats.byType[ruleType]++;

        if (rule.enabled) {
            this.adRules.stats.active++;
        }

        this.saveADRules();
    },

    /**
     * 开始检测
     */
    startDetection: function () {
        setInterval(() => {
            if (this.adConfig.enabled) {
                this.detectAnomalies();
            }
        }, this.adConfig.detectionInterval);
    },

    /**
     * 检测异常
     */
    detectAnomalies: function () {
        // 收集检测数据
        const data = this.collectDetectionData();

        // 检查所有规则
        for (const ruleId in this.adRules.rules) {
            const rule = this.adRules.rules[ruleId];

            if (!rule.enabled) {
                continue;
            }

            if (rule.check(data)) {
                this.recordAnomaly(ruleId, data);
            }
        }
    },

    /**
     * 收集检测数据
     * @returns {Object} 检测数据
     */
    collectDetectionData: function () {
        const data = {};

        // 收集性能数据
        if (this.adConfig.detectionTypes.includes('performance')) {
            data.fps = this.measureFPS();
            data.latency = this.measureLatency();
            data.memory = this.measureMemory();
            data.crashed = this.checkCrashed();
        }

        // 收集行为数据
        if (this.adConfig.detectionTypes.includes('behavior')) {
            data.velocity = this.measureVelocity();
            data.clicksPerSecond = this.measureClicksPerSecond();
        }

        // 收集数据数据
        if (this.adConfig.detectionTypes.includes('data')) {
            data.scoreIncrease = this.measureScoreIncrease();
            data.resourceCount = this.measureResourceCount();
        }

        // 收集安全数据
        if (this.adConfig.detectionTypes.includes('security')) {
            data.clientHash = this.getClientHash();
        }

        return data;
    },

    /**
     * 测量FPS
     * @returns {number} FPS值
     */
    measureFPS: function () {
        // 模拟FPS测量
        return Math.floor(Math.random() * 40) + 20;
    },

    /**
     * 测量延迟
     * @returns {number} 延迟（ms）
     */
    measureLatency: function () {
        // 模拟延迟测量
        return Math.floor(Math.random() * 80) + 10;
    },

    /**
     * 测量内存
     * @returns {number} 内存使用量（MB）
     */
    measureMemory: function () {
        if (window.performance && window.performance.memory) {
            return window.performance.memory.usedJSHeapSize / 1048576;
        }

        return Math.floor(Math.random() * 80) + 20;
    },

    /**
     * 检查是否崩溃
     * @returns {boolean} 是否崩溃
     */
    checkCrashed: function () {
        // 模拟崩溃检测
        return false;
    },

    /**
     * 测量速度
     * @returns {number} 速度
     */
    measureVelocity: function () {
        // 模拟速度测量
        return Math.floor(Math.random() * 30) + 5;
    },

    /**
     * 测量点击频率
     * @returns {number} 每秒点击次数
     */
    measureClicksPerSecond: function () {
        // 模拟点击频率测量
        return Math.floor(Math.random() * 15);
    },

    /**
     * 测量分数增长
     * @returns {number} 分数增长
     */
    measureScoreIncrease: function () {
        // 模拟分数增长测量
        return Math.floor(Math.random() * 2000);
    },

    /**
     * 测量资源数量
     * @returns {number} 资源数量
     */
    measureResourceCount: function () {
        // 模拟资源数量测量
        return Math.floor(Math.random() * 15000);
    },

    /**
     * 获取客户端哈希
     * @returns {string} 哈希值
     */
    getClientHash: function () {
        // 模拟客户端哈希
        return 'expected';
    },

    /**
     * 记录异常
     * @param {string} ruleId - 规则ID
     * @param {Object} data - 检测数据
     */
    recordAnomaly: function (ruleId, data) {
        const rule = this.adRules.rules[ruleId];

        if (!rule) {
            return;
        }

        const anomalyId = 'anomaly_' + Date.now();

        const anomaly = {
            id: anomalyId,
            ruleId: ruleId,
            ruleType: rule.type,
            ruleName: rule.name,
            description: rule.description,
            severity: rule.severity,
            data: data,
            status: 'open',
            createdAt: Date.now(),
            resolvedAt: null
        };

        this.adAnomalies.anomalies[anomalyId] = anomaly;

        // 更新统计
        this.adAnomalies.stats.total++;

        if (!this.adAnomalies.stats.byType[rule.type]) {
            this.adAnomalies.stats.byType[rule.type] = 0;
        }

        this.adAnomalies.stats.byType[rule.type]++;

        if (!this.adAnomalies.stats.bySeverity[rule.severity]) {
            this.adAnomalies.stats.bySeverity[rule.severity] = 0;
        }

        this.adAnomalies.stats.bySeverity[rule.severity]++;

        if (!this.adAnomalies.stats.byStatus['open']) {
            this.adAnomalies.stats.byStatus['open'] = 0;
        }

        this.adAnomalies.stats.byStatus['open']++;

        // 更新规则触发次数
        rule.triggered++;
        rule.lastTriggered = Date.now();

        // 清理旧异常
        this.cleanupOldAnomalies();

        this.saveADAnomalies();
        this.saveADRules();

        // 发送警报
        if (this.adConfig.autoAlert) {
            this.sendAlert(anomaly);
        }
    },

    /**
     * 清理旧异常
     */
    cleanupOldAnomalies: function () {
        if (this.adAnomalies.anomalies.length > this.adConfig.maxAnomalies) {
            const anomaliesToDelete = this.adAnomalies.anomalies.length - this.adConfig.maxAnomalies;

            for (let i = 0; i < anomaliesToDelete; i++) {
                const deletedAnomaly = this.adAnomalies.anomalies.shift();

                // 更新统计
                this.adAnomalies.stats.total--;
                this.adAnomalies.stats.byType[deletedAnomaly.ruleType]--;
                this.adAnomalies.stats.bySeverity[deletedAnomaly.severity]--;
                this.adAnomalies.stats.byStatus[deletedAnomaly.status]--;
            }

            this.saveADAnomalies();
        }
    },

    /**
     * 发送警报
     * @param {Object} anomaly - 异常对象
     */
    sendAlert: function (anomaly) {
        // 模拟发送警报
        if (window.GameMessageBus) {
            GameMessageBus.publish('anomaly_detected', {
                anomaly: anomaly
            });
        }
    },

    /**
     * 解决异常
     * @param {string} anomalyId - 异常ID
     * @returns {Object} 解决结果
     */
    resolveAnomaly: function (anomalyId) {
        const anomaly = this.adAnomalies.anomalies[anomalyId];

        if (!anomaly) {
            return {
                success: false,
                error: '异常不存在'
            };
        }

        anomaly.status = 'resolved';
        anomaly.resolvedAt = Date.now();

        // 更新统计
        this.adAnomalies.stats.byStatus[anomaly.status]++;
        this.adAnomalies.stats.byStatus[anomaly.previousStatus]--;

        this.saveADAnomalies();

        return {
            success: true,
            anomaly: anomaly
        };
    },

    /**
     * 获取异常
     * @param {string} anomalyId - 异常ID
     * @returns {Object|null} 异常对象
     */
    getAnomaly: function (anomalyId) {
        return this.adAnomalies.anomalies[anomalyId] || null;
    },

    /**
     * 获取所有异常
     * @param {string} anomalyType - 异常类型
     * @param {string} severity - 严重程度
     * @param {string} status - 状态
     * @returns {Array} 异常列表
     */
    getAllAnomalies: function (anomalyType, severity, status) {
        let anomalies = Object.values(this.adAnomalies.anomalies);

        if (anomalyType) {
            anomalies = anomalies.filter(a => a.ruleType === anomalyType);
        }

        if (severity) {
            anomalies = anomalies.filter(a => a.severity === severity);
        }

        if (status) {
            anomalies = anomalies.filter(a => a.status === status);
        }

        return anomalies;
    },

    /**
     * 获取规则
     * @param {string} ruleId - 规则ID
     * @returns {Object|null} 规则对象
     */
    getRule: function (ruleId) {
        return this.adRules.rules[ruleId] || null;
    },

    /**
     * 获取所有规则
     * @param {string} ruleType - 规则类型
     * @returns {Array} 规则列表
     */
    getAllRules: function (ruleType) {
        let rules = Object.values(this.adRules.rules);

        if (ruleType) {
            rules = rules.filter(r => r.type === ruleType);
        }

        return rules;
    },

    /**
     * 获取异常统计
     * @returns {Object} 统计信息
     */
    getAnomalyStats: function () {
        return this.adAnomalies.stats;
    },

    /**
     * 获取规则统计
     * @returns {Object} 统计信息
     */
    getRuleStats: function () {
        return this.adRules.stats;
    },

    /**
     * 删除异常
     * @param {string} anomalyId - 异常ID
     * @returns {boolean} 是否成功
     */
    deleteAnomaly: function (anomalyId) {
        if (!this.adAnomalies.anomalies[anomalyId]) {
            return false;
        }

        delete this.adAnomalies.anomalies[anomalyId];
        this.saveADAnomalies();

        return true;
    },

    /**
     * 删除规则
     * @param {string} ruleId - 规则ID
     * @returns {boolean} 是否成功
     */
    deleteRule: function (ruleId) {
        if (!this.adRules.rules[ruleId]) {
            return false;
        }

        delete this.adRules.rules[ruleId];
        this.saveADRules();

        return true;
    },

    /**
     * 设置异常检测配置
     * @param {Object} config - 配置对象
     */
    setADConfig: function (config) {
        this.adConfig = { ...this.adConfig, ...config };
        this.saveADConfig();
    },

    /**
     * 获取异常检测配置
     * @returns {Object} 配置对象
     */
    getADConfig: function () {
        return this.adConfig;
    },

    /**
     * 获取异常检测统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.adConfig.enabled,
            detectionInterval: this.adConfig.detectionInterval,
            maxAnomalies: this.adConfig.maxAnomalies,
            autoAlert: this.adConfig.autoAlert,
            alertInterval: this.adConfig.alertInterval,
            totalAnomalies: Object.keys(this.adAnomalies.anomalies).length,
            totalRules: Object.keys(this.adRules.rules).length,
            activeRules: Object.values(this.adRules.rules).filter(r => r.enabled).length,
            openAnomalies: Object.values(this.adAnomalies.anomalies).filter(a => a.status === 'open').length,
            criticalAnomalies: Object.values(this.adAnomalies.anomalies).filter(a => a.severity === 'critical').length
        };
    }
};

// 优化：游戏故障诊断优化
const GameFaultDiagnosisOptimizer = {
    fdConfig: {},
    fdDiagnoses: {},
    fdSymptoms: {},

    /**
     * 初始化游戏故障诊断
     */
    init: function () {
        this.loadFDConfig();
        this.loadFDDiagnoses();
        this.loadFDSymptoms();
    },

    /**
     * 加载故障诊断配置
     */
    loadFDConfig: function () {
        this.fdConfig = {
            enabled: true,
            maxDiagnoses: 1000,
            maxSymptoms: 10000,
            autoDiagnose: true,
            diagnosisInterval: 5000,
            severityLevels: ['low', 'medium', 'high', 'critical'],
            faultTypes: [
                'performance',
                'network',
                'storage',
                'rendering',
                'input',
                'audio',
                'logic',
                'data'
            ]
        };

        const customConfig = localStorage.getItem('fdConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.fdConfig = { ...this.fdConfig, ...config };
            } catch (error) {
                console.error('加载故障诊断配置失败:', error);
            }
        }
    },

    /**
     * 保存故障诊断配置
     */
    saveFDConfig: function () {
        localStorage.setItem('fdConfig', JSON.stringify(this.fdConfig));
    },

    /**
     * 加载诊断数据
     */
    loadFDDiagnoses: function () {
        const savedDiagnoses = localStorage.getItem('fdDiagnoses');
        if (savedDiagnoses) {
            try {
                this.fdDiagnoses = JSON.parse(savedDiagnoses);
            } catch (error) {
                console.error('加载诊断数据失败:', error);
            }
        }

        if (!this.fdDiagnoses.diagnoses) {
            this.fdDiagnoses = {
                diagnoses: {},
                stats: {
                    total: 0,
                    byType: {},
                    bySeverity: {},
                    byStatus: {}
                }
            };

            this.saveFDDiagnoses();
        }
    },

    /**
     * 保存诊断数据
     */
    saveFDDiagnoses: function () {
        localStorage.setItem('fdDiagnoses', JSON.stringify(this.fdDiagnoses));
    },

    /**
     * 加载症状数据
     */
    loadFDSymptoms: function () {
        const savedSymptoms = localStorage.getItem('fdSymptoms');
        if (savedSymptoms) {
            try {
                this.fdSymptoms = JSON.parse(savedSymptoms);
            } catch (error) {
                console.error('加载症状数据失败:', error);
            }
        }

        if (!this.fdSymptoms.symptoms) {
            this.fdSymptoms = {
                symptoms: {},
                stats: {
                    total: 0,
                    byType: {},
                    byFrequency: {}
                }
            };

            this.saveFDSymptoms();
        }
    },

    /**
     * 保存症状数据
     */
    saveFDSymptoms: function () {
        localStorage.setItem('fdSymptoms', JSON.stringify(this.fdSymptoms));
    },

    /**
     * 记录症状
     * @param {string} symptomType - 症状类型
     * @param {Object} symptomData - 症状数据
     */
    recordSymptom: function (symptomType, symptomData) {
        if (!this.fdConfig.enabled) {
            return;
        }

        const symptomId = 'symptom_' + Date.now();

        const symptom = {
            id: symptomId,
            type: symptomType,
            data: symptomData,
            severity: symptomData.severity || 'medium',
            timestamp: Date.now(),
            frequency: 1
        };

        this.fdSymptoms.symptoms[symptomId] = symptom;

        // 更新统计
        this.fdSymptoms.stats.total++;

        if (!this.fdSymptoms.stats.byType[symptomType]) {
            this.fdSymptoms.stats.byType[symptomType] = 0;
        }

        this.fdSymptoms.stats.byType[symptomType]++;

        // 清理旧症状
        this.cleanupOldSymptoms();

        this.saveFDSymptoms();

        // 自动诊断
        if (this.fdConfig.autoDiagnose) {
            this.diagnose();
        }
    },

    /**
     * 清理旧症状
     */
    cleanupOldSymptoms: function () {
        if (Object.keys(this.fdSymptoms.symptoms).length > this.fdConfig.maxSymptoms) {
            const symptomsToDelete = Object.keys(this.fdSymptoms.symptoms).length - this.fdConfig.maxSymptoms;

            const sortedSymptoms = Object.values(this.fdSymptoms.symptoms)
                .sort((a, b) => a.timestamp - b.timestamp);

            for (let i = 0; i < symptomsToDelete; i++) {
                const deletedSymptom = sortedSymptoms[i];
                delete this.fdSymptoms.symptoms[deletedSymptom.id];

                // 更新统计
                this.fdSymptoms.stats.total--;
                this.fdSymptoms.stats.byType[deletedSymptom.type]--;
            }

            this.saveFDSymptoms();
        }
    },

    /**
     * 诊断
     * @returns {Object} 诊断结果
     */
    diagnose: function () {
        const symptoms = Object.values(this.fdSymptoms.symptoms);

        if (symptoms.length === 0) {
            return {
                success: false,
                error: '没有症状数据'
            };
        }

        // 分析症状
        const analysis = this.analyzeSymptoms(symptoms);

        // 生成诊断
        const diagnosis = this.generateDiagnosis(analysis);

        // 记录诊断
        this.recordDiagnosis(diagnosis);

        return {
            success: true,
            diagnosis: diagnosis
        };
    },

    /**
     * 分析症状
     * @param {Array} symptoms - 症状列表
     * @returns {Object} 分析结果
     */
    analyzeSymptoms: function (symptoms) {
        const analysis = {
            byType: {},
            bySeverity: {},
            frequency: {},
            patterns: []
        };

        symptoms.forEach(symptom => {
            // 按类型分析
            if (!analysis.byType[symptom.type]) {
                analysis.byType[symptom.type] = {
                    count: 0,
                    severity: []
                };
            }

            analysis.byType[symptom.type].count++;
            analysis.byType[symptom.type].severity.push(symptom.severity);

            // 按严重程度分析
            if (!analysis.bySeverity[symptom.severity]) {
                analysis.bySeverity[symptom.severity] = 0;
            }

            analysis.bySeverity[symptom.severity]++;

            // 频率分析
            if (!analysis.frequency[symptom.type]) {
                analysis.frequency[symptom.type] = [];
            }

            analysis.frequency[symptom.type].push(symptom.timestamp);
        });

        // 检测模式
        analysis.patterns = this.detectPatterns(symptoms);

        return analysis;
    },

    /**
     * 检测模式
     * @param {Array} symptoms - 症状列表
     * @returns {Array} 模式列表
     */
    detectPatterns: function (symptoms) {
        const patterns = [];

        // 检测频繁出现的症状
        const typeCounts = {};
        symptoms.forEach(symptom => {
            if (!typeCounts[symptom.type]) {
                typeCounts[symptom.type] = 0;
            }
            typeCounts[symptom.type]++;
        });

        Object.keys(typeCounts).forEach(type => {
            if (typeCounts[type] > 5) {
                patterns.push({
                    type: 'frequent',
                    symptomType: type,
                    count: typeCounts[type]
                });
            }
        });

        // 检测时间模式
        const timeGroups = {};
        const timeWindow = 60000; // 1分钟

        symptoms.forEach(symptom => {
            const timeKey = Math.floor(symptom.timestamp / timeWindow);

            if (!timeGroups[timeKey]) {
                timeGroups[timeKey] = [];
            }

            timeGroups[timeKey].push(symptom);
        });

        Object.keys(timeGroups).forEach(timeKey => {
            if (timeGroups[timeKey].length > 10) {
                patterns.push({
                    type: 'burst',
                    timestamp: timeKey * timeWindow,
                    count: timeGroups[timeKey].length
                });
            }
        });

        return patterns;
    },

    /**
     * 生成诊断
     * @param {Object} analysis - 分析结果
     * @returns {Object} 诊断对象
     */
    generateDiagnosis: function (analysis) {
        // 确定故障类型
        const faultType = this.determineFaultType(analysis);

        // 确定严重程度
        const severity = this.determineSeverity(analysis);

        // 生成建议
        const recommendations = this.generateRecommendations(analysis, faultType, severity);

        const diagnosis = {
            type: faultType,
            severity: severity,
            analysis: analysis,
            recommendations: recommendations,
            status: 'pending',
            createdAt: Date.now(),
            resolvedAt: null
        };

        return diagnosis;
    },

    /**
     * 确定故障类型
     * @param {Object} analysis - 分析结果
     * @returns {string} 故障类型
     */
    determineFaultType: function (analysis) {
        const types = Object.keys(analysis.byType);

        if (types.length === 0) {
            return 'unknown';
        }

        // 找出最常见的类型
        let maxCount = 0;
        let dominantType = 'unknown';

        types.forEach(type => {
            if (analysis.byType[type].count > maxCount) {
                maxCount = analysis.byType[type].count;
                dominantType = type;
            }
        });

        return dominantType;
    },

    /**
     * 确定严重程度
     * @param {Object} analysis - 分析结果
     * @returns {string} 严重程度
     */
    determineSeverity: function (analysis) {
        const severities = Object.keys(analysis.bySeverity);

        if (severities.includes('critical')) {
            return 'critical';
        }

        if (severities.includes('high')) {
            return 'high';
        }

        if (severities.includes('medium')) {
            return 'medium';
        }

        return 'low';
    },

    /**
     * 生成建议
     * @param {Object} analysis - 分析结果
     * @param {string} faultType - 故障类型
     * @param {string} severity - 严重程度
     * @returns {Array} 建议列表
     */
    generateRecommendations: function (analysis, faultType, severity) {
        const recommendations = [];

        switch (faultType) {
            case 'performance':
                recommendations.push('优化游戏性能');
                recommendations.push('减少不必要的计算');
                recommendations.push('优化渲染流程');
                break;
            case 'network':
                recommendations.push('检查网络连接');
                recommendations.push('优化网络请求');
                recommendations.push('实现离线模式');
                break;
            case 'storage':
                recommendations.push('清理缓存数据');
                recommendations.push('优化存储策略');
                recommendations.push('检查存储空间');
                break;
            case 'rendering':
                recommendations.push('优化渲染性能');
                recommendations.push('减少绘制调用');
                recommendations.push('使用硬件加速');
                break;
            case 'input':
                recommendations.push('检查输入设备');
                recommendations.push('优化输入处理');
                recommendations.push('添加输入验证');
                break;
            case 'audio':
                recommendations.push('检查音频设备');
                recommendations.push('优化音频加载');
                recommendations.push('减少音频延迟');
                break;
            case 'logic':
                recommendations.push('检查游戏逻辑');
                recommendations.push('修复逻辑错误');
                recommendations.push('添加错误处理');
                break;
            case 'data':
                recommendations.push('检查数据完整性');
                recommendations.push('修复数据损坏');
                recommendations.push('实施数据备份');
                break;
            default:
                recommendations.push('检查系统状态');
                recommendations.push('收集更多诊断信息');
                recommendations.push('联系技术支持');
        }

        return recommendations;
    },

    /**
     * 记录诊断
     * @param {Object} diagnosis - 诊断对象
     */
    recordDiagnosis: function (diagnosis) {
        const diagnosisId = 'diagnosis_' + Date.now();

        diagnosis.id = diagnosisId;

        this.fdDiagnoses.diagnoses[diagnosisId] = diagnosis;

        // 更新统计
        this.fdDiagnoses.stats.total++;

        if (!this.fdDiagnoses.stats.byType[diagnosis.type]) {
            this.fdDiagnoses.stats.byType[diagnosis.type] = 0;
        }

        this.fdDiagnoses.stats.byType[diagnosis.type]++;

        if (!this.fdDiagnoses.stats.bySeverity[diagnosis.severity]) {
            this.fdDiagnoses.stats.bySeverity[diagnosis.severity] = 0;
        }

        this.fdDiagnoses.stats.bySeverity[diagnosis.severity]++;

        if (!this.fdDiagnoses.stats.byStatus[diagnosis.status]) {
            this.fdDiagnoses.stats.byStatus[diagnosis.status] = 0;
        }

        this.fdDiagnoses.stats.byStatus[diagnosis.status]++;

        // 清理旧诊断
        this.cleanupOldDiagnoses();

        this.saveFDDiagnoses();
    },

    /**
     * 清理旧诊断
     */
    cleanupOldDiagnoses: function () {
        if (Object.keys(this.fdDiagnoses.diagnoses).length > this.fdConfig.maxDiagnoses) {
            const diagnosesToDelete = Object.keys(this.fdDiagnoses.diagnoses).length - this.fdConfig.maxDiagnoses;

            const sortedDiagnoses = Object.values(this.fdDiagnoses.diagnoses)
                .sort((a, b) => a.createdAt - b.createdAt);

            for (let i = 0; i < diagnosesToDelete; i++) {
                const deletedDiagnosis = sortedDiagnoses[i];
                delete this.fdDiagnoses.diagnoses[deletedDiagnosis.id];

                // 更新统计
                this.fdDiagnoses.stats.total--;
                this.fdDiagnoses.stats.byType[deletedDiagnosis.type]--;
                this.fdDiagnoses.stats.bySeverity[deletedDiagnosis.severity]--;
                this.fdDiagnoses.stats.byStatus[deletedDiagnosis.status]--;
            }

            this.saveFDDiagnoses();
        }
    },

    /**
     * 解决诊断
     * @param {string} diagnosisId - 诊断ID
     * @returns {Object} 解决结果
     */
    resolveDiagnosis: function (diagnosisId) {
        const diagnosis = this.fdDiagnoses.diagnoses[diagnosisId];

        if (!diagnosis) {
            return {
                success: false,
                error: '诊断不存在'
            };
        }

        diagnosis.status = 'resolved';
        diagnosis.resolvedAt = Date.now();

        // 更新统计
        this.fdDiagnoses.stats.byStatus[diagnosis.status]++;
        this.fdDiagnoses.stats.byStatus['pending']--;

        this.saveFDDiagnoses();

        return {
            success: true,
            diagnosis: diagnosis
        };
    },

    /**
     * 获取诊断
     * @param {string} diagnosisId - 诊断ID
     * @returns {Object|null} 诊断对象
     */
    getDiagnosis: function (diagnosisId) {
        return this.fdDiagnoses.diagnoses[diagnosisId] || null;
    },

    /**
     * 获取所有诊断
     * @param {string} diagnosisType - 诊断类型
     * @param {string} severity - 严重程度
     * @param {string} status - 状态
     * @returns {Array} 诊断列表
     */
    getAllDiagnoses: function (diagnosisType, severity, status) {
        let diagnoses = Object.values(this.fdDiagnoses.diagnoses);

        if (diagnosisType) {
            diagnoses = diagnoses.filter(d => d.type === diagnosisType);
        }

        if (severity) {
            diagnoses = diagnoses.filter(d => d.severity === severity);
        }

        if (status) {
            diagnoses = diagnoses.filter(d => d.status === status);
        }

        return diagnoses;
    },

    /**
     * 获取症状
     * @param {string} symptomId - 症状ID
     * @returns {Object|null} 症状对象
     */
    getSymptom: function (symptomId) {
        return this.fdSymptoms.symptoms[symptomId] || null;
    },

    /**
     * 获取所有症状
     * @param {string} symptomType - 症状类型
     * @returns {Array} 症状列表
     */
    getAllSymptoms: function (symptomType) {
        let symptoms = Object.values(this.fdSymptoms.symptoms);

        if (symptomType) {
            symptoms = symptoms.filter(s => s.type === symptomType);
        }

        return symptoms;
    },

    /**
     * 获取诊断统计
     * @returns {Object} 统计信息
     */
    getDiagnosisStats: function () {
        return this.fdDiagnoses.stats;
    },

    /**
     * 获取症状统计
     * @returns {Object} 统计信息
     */
    getSymptomStats: function () {
        return this.fdSymptoms.stats;
    },

    /**
     * 删除诊断
     * @param {string} diagnosisId - 诊断ID
     * @returns {boolean} 是否成功
     */
    deleteDiagnosis: function (diagnosisId) {
        if (!this.fdDiagnoses.diagnoses[diagnosisId]) {
            return false;
        }

        delete this.fdDiagnoses.diagnoses[diagnosisId];
        this.saveFDDiagnoses();

        return true;
    },

    /**
     * 删除症状
     * @param {string} symptomId - 症状ID
     * @returns {boolean} 是否成功
     */
    deleteSymptom: function (symptomId) {
        if (!this.fdSymptoms.symptoms[symptomId]) {
            return false;
        }

        delete this.fdSymptoms.symptoms[symptomId];
        this.saveFDSymptoms();

        return true;
    },

    /**
     * 设置故障诊断配置
     * @param {Object} config - 配置对象
     */
    setFDConfig: function (config) {
        this.fdConfig = { ...this.fdConfig, ...config };
        this.saveFDConfig();
    },

    /**
     * 获取故障诊断配置
     * @returns {Object} 配置对象
     */
    getFDConfig: function () {
        return this.fdConfig;
    },

    /**
     * 获取故障诊断统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.fdConfig.enabled,
            maxDiagnoses: this.fdConfig.maxDiagnoses,
            maxSymptoms: this.fdConfig.maxSymptoms,
            autoDiagnose: this.fdConfig.autoDiagnose,
            diagnosisInterval: this.fdConfig.diagnosisInterval,
            totalDiagnoses: Object.keys(this.fdDiagnoses.diagnoses).length,
            totalSymptoms: Object.keys(this.fdSymptoms.symptoms).length,
            pendingDiagnoses: Object.values(this.fdDiagnoses.diagnoses).filter(d => d.status === 'pending').length,
            criticalDiagnoses: Object.values(this.fdDiagnoses.diagnoses).filter(d => d.severity === 'critical').length
        };
    }
};

// 优化：游戏优化建议优化
const GameOptimizationSuggestionOptimizer = {
    osConfig: {},
    osSuggestions: {},
    osRules: {},

    /**
     * 初始化游戏优化建议
     */
    init: function () {
        this.loadOSConfig();
        this.loadOSSuggestions();
        this.loadOSRules();
        this.generateSuggestions();
    },

    /**
     * 加载优化建议配置
     */
    loadOSConfig: function () {
        this.osConfig = {
            enabled: true,
            maxSuggestions: 1000,
            autoGenerate: true,
            generationInterval: 60000,
            priorityLevels: ['low', 'medium', 'high', 'critical'],
            suggestionTypes: [
                'performance',
                'user_experience',
                'gameplay',
                'visual',
                'audio',
                'ui',
                'accessibility',
                'security',
                'compatibility',
                'maintenance'
            ]
        };

        const customConfig = localStorage.getItem('osConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.osConfig = { ...this.osConfig, ...config };
            } catch (error) {
                console.error('加载优化建议配置失败:', error);
            }
        }
    },

    /**
     * 保存优化建议配置
     */
    saveOSConfig: function () {
        localStorage.setItem('osConfig', JSON.stringify(this.osConfig));
    },

    /**
     * 加载建议数据
     */
    loadOSSuggestions: function () {
        const savedSuggestions = localStorage.getItem('osSuggestions');
        if (savedSuggestions) {
            try {
                this.osSuggestions = JSON.parse(savedSuggestions);
            } catch (error) {
                console.error('加载建议数据失败:', error);
            }
        }

        if (!this.osSuggestions.suggestions) {
            this.osSuggestions = {
                suggestions: {},
                stats: {
                    total: 0,
                    byType: {},
                    byPriority: {},
                    byStatus: {}
                }
            };

            this.saveOSSuggestions();
        }
    },

    /**
     * 保存建议数据
     */
    saveOSSuggestions: function () {
        localStorage.setItem('osSuggestions', JSON.stringify(this.osSuggestions));
    },

    /**
     * 加载规则数据
     */
    loadOSRules: function () {
        const savedRules = localStorage.getItem('osRules');
        if (savedRules) {
            try {
                this.osRules = JSON.parse(savedRules);
            } catch (error) {
                console.error('加载规则数据失败:', error);
            }
        }

        if (!this.osRules.rules) {
            this.osRules = {
                rules: {},
                stats: {
                    total: 0,
                    byType: {},
                    active: 0
                }
            };

            // 创建默认规则
            this.createDefaultRules();

            this.saveOSRules();
        }
    },

    /**
     * 保存规则数据
     */
    saveOSRules: function () {
        localStorage.setItem('osRules', JSON.stringify(this.osRules));
    },

    /**
     * 创建默认规则
     */
    createDefaultRules: function () {
        // 性能优化规则
        this.addRule('performance', {
            name: 'optimize_fps',
            description: '优化帧率',
            check: () => this.measureFPS() < 30,
            suggestion: '优化渲染逻辑，减少不必要的计算',
            priority: 'high',
            enabled: true
        });

        this.addRule('performance', {
            name: 'optimize_memory',
            description: '优化内存使用',
            check: () => this.measureMemory() > 100,
            suggestion: '清理未使用的资源，优化内存管理',
            priority: 'medium',
            enabled: true
        });

        this.addRule('performance', {
            name: 'optimize_loading',
            description: '优化加载时间',
            check: () => this.measureLoadingTime() > 5000,
            suggestion: '实现资源预加载，优化加载流程',
            priority: 'medium',
            enabled: true
        });

        // 用户体验优化规则
        this.addRule('user_experience', {
            name: 'improve_tutorial',
            description: '改进教程',
            check: () => this.measureTutorialCompletion() < 0.5,
            suggestion: '优化教程内容，提高用户理解度',
            priority: 'medium',
            enabled: true
        });

        this.addRule('user_experience', {
            name: 'improve_feedback',
            description: '改进反馈机制',
            check: () => this.measureFeedbackTimeliness() > 500,
            suggestion: '提供更及时的用户反馈',
            priority: 'low',
            enabled: true
        });

        // 游戏玩法优化规则
        this.addRule('gameplay', {
            name: 'balance_difficulty',
            description: '平衡难度',
            check: () => this.measureDifficultyBalance() < 0.3 || this.measureDifficultyBalance() > 0.7,
            suggestion: '调整游戏难度，提供更好的挑战性',
            priority: 'high',
            enabled: true
        });

        this.addRule('gameplay', {
            name: 'add_content',
            description: '添加内容',
            check: () => this.measureContentVariety() < 5,
            suggestion: '增加游戏内容，提高可玩性',
            priority: 'medium',
            enabled: true
        });

        // 视觉优化规则
        this.addRule('visual', {
            name: 'improve_graphics',
            description: '改进图形',
            check: () => this.measureGraphicsQuality() < 0.6,
            suggestion: '优化图形效果，提升视觉体验',
            priority: 'medium',
            enabled: true
        });

        this.addRule('visual', {
            name: 'optimize_animations',
            description: '优化动画',
            check: () => this.measureAnimationSmoothness() < 0.7,
            suggestion: '优化动画流畅度，提升视觉体验',
            priority: 'low',
            enabled: true
        });

        // 音频优化规则
        this.addRule('audio', {
            name: 'improve_sound',
            description: '改进音效',
            check: () => this.measureAudioQuality() < 0.6,
            suggestion: '优化音效质量，提升听觉体验',
            priority: 'low',
            enabled: true
        });

        this.addRule('audio', {
            name: 'add_music',
            description: '添加音乐',
            check: () => this.measureMusicVariety() < 3,
            suggestion: '增加背景音乐，提升氛围感',
            priority: 'low',
            enabled: true
        });

        // UI优化规则
        this.addRule('ui', {
            name: 'improve_layout',
            description: '改进布局',
            check: () => this.measureLayoutEfficiency() < 0.6,
            suggestion: '优化UI布局，提高可用性',
            priority: 'medium',
            enabled: true
        });

        this.addRule('ui', {
            name: 'improve_accessibility',
            description: '改进可访问性',
            check: () => this.measureAccessibility() < 0.5,
            suggestion: '提高UI可访问性，支持更多用户',
            priority: 'medium',
            enabled: true
        });

        // 可访问性优化规则
        this.addRule('accessibility', {
            name: 'add_keyboard_support',
            description: '添加键盘支持',
            check: () => this.measureKeyboardSupport() < 0.5,
            suggestion: '增加键盘操作支持',
            priority: 'high',
            enabled: true
        });

        this.addRule('accessibility', {
            name: 'add_screen_reader',
            description: '添加屏幕阅读器支持',
            check: () => this.measureScreenReaderSupport() < 0.5,
            suggestion: '优化屏幕阅读器兼容性',
            priority: 'high',
            enabled: true
        });

        // 安全优化规则
        this.addRule('security', {
            name: 'encrypt_data',
            description: '加密数据',
            check: () => !this.measureDataEncryption(),
            suggestion: '实施用户数据加密',
            priority: 'critical',
            enabled: true
        });

        this.addRule('security', {
            name: 'validate_input',
            description: '验证输入',
            check: () => !this.measureInputValidation(),
            suggestion: '添加输入验证，防止注入攻击',
            priority: 'critical',
            enabled: true
        });

        // 兼容性优化规则
        this.addRule('compatibility', {
            name: 'test_browsers',
            description: '测试浏览器兼容性',
            check: () => this.measureBrowserCompatibility() < 0.7,
            suggestion: '测试并优化多浏览器支持',
            priority: 'medium',
            enabled: true
        });

        this.addRule('compatibility', {
            name: 'optimize_mobile',
            description: '优化移动端',
            check: () => this.measureMobileOptimization() < 0.6,
            suggestion: '优化移动端性能和体验',
            priority: 'medium',
            enabled: true
        });

        // 维护优化规则
        this.addRule('maintenance', {
            name: 'add_logging',
            description: '添加日志',
            check: () => !this.measureLogging(),
            suggestion: '实现完整的日志系统',
            priority: 'medium',
            enabled: true
        });

        this.addRule('maintenance', {
            name: 'add_error_handling',
            description: '添加错误处理',
            check: () => this.measureErrorHandling() < 0.7,
            suggestion: '完善错误处理机制',
            priority: 'high',
            enabled: true
        });
    },

    /**
     * 添加规则
     * @param {string} ruleType - 规则类型
     * @param {Object} rule - 规则对象
     */
    addRule: function (ruleType, rule) {
        if (!this.osConfig.enabled) {
            return;
        }

        if (!this.osConfig.suggestionTypes.includes(ruleType)) {
            return;
        }

        const ruleId = 'rule_' + Date.now();

        this.osRules.rules[ruleId] = {
            id: ruleId,
            type: ruleType,
            name: rule.name,
            description: rule.description,
            check: rule.check,
            suggestion: rule.suggestion,
            priority: rule.priority,
            enabled: rule.enabled,
            createdAt: Date.now(),
            triggered: 0,
            lastTriggered: null
        };

        // 更新统计
        this.osRules.stats.total++;

        if (!this.osRules.stats.byType[ruleType]) {
            this.osRules.stats.byType[ruleType] = 0;
        }

        this.osRules.stats.byType[ruleType]++;

        if (rule.enabled) {
            this.osRules.stats.active++;
        }

        this.saveOSRules();
    },

    /**
     * 生成建议
     * @returns {Array} 建议列表
     */
    generateSuggestions: function () {
        if (!this.osConfig.enabled) {
            return [];
        }

        const suggestions = [];

        // 检查所有规则
        for (const ruleId in this.osRules.rules) {
            const rule = this.osRules.rules[ruleId];

            if (!rule.enabled) {
                continue;
            }

            if (rule.check()) {
                const suggestion = this.createSuggestion(rule);
                suggestions.push(suggestion);

                // 更新规则触发次数
                rule.triggered++;
                rule.lastTriggered = Date.now();
            }
        }

        // 保存建议
        suggestions.forEach(suggestion => {
            this.recordSuggestion(suggestion);
        });

        this.saveOSRules();

        return suggestions;
    },

    /**
     * 创建建议
     * @param {Object} rule - 规则对象
     * @returns {Object} 建议对象
     */
    createSuggestion: function (rule) {
        const suggestion = {
            type: rule.type,
            name: rule.name,
            description: rule.description,
            suggestion: rule.suggestion,
            priority: rule.priority,
            status: 'pending',
            createdAt: Date.now(),
            implementedAt: null
        };

        return suggestion;
    },

    /**
     * 记录建议
     * @param {Object} suggestion - 建议对象
     */
    recordSuggestion: function (suggestion) {
        const suggestionId = 'suggestion_' + Date.now();

        suggestion.id = suggestionId;

        this.osSuggestions.suggestions[suggestionId] = suggestion;

        // 更新统计
        this.osSuggestions.stats.total++;

        if (!this.osSuggestions.stats.byType[suggestion.type]) {
            this.osSuggestions.stats.byType[suggestion.type] = 0;
        }

        this.osSuggestions.stats.byType[suggestion.type]++;

        if (!this.osSuggestions.stats.byPriority[suggestion.priority]) {
            this.osSuggestions.stats.byPriority[suggestion.priority] = 0;
        }

        this.osSuggestions.stats.byPriority[suggestion.priority]++;

        if (!this.osSuggestions.stats.byStatus[suggestion.status]) {
            this.osSuggestions.stats.byStatus[suggestion.status] = 0;
        }

        this.osSuggestions.stats.byStatus[suggestion.status]++;

        // 清理旧建议
        this.cleanupOldSuggestions();

        this.saveOSSuggestions();
    },

    /**
     * 清理旧建议
     */
    cleanupOldSuggestions: function () {
        if (Object.keys(this.osSuggestions.suggestions).length > this.osConfig.maxSuggestions) {
            const suggestionsToDelete = Object.keys(this.osSuggestions.suggestions).length - this.osConfig.maxSuggestions;

            const sortedSuggestions = Object.values(this.osSuggestions.suggestions)
                .sort((a, b) => a.createdAt - b.createdAt);

            for (let i = 0; i < suggestionsToDelete; i++) {
                const deletedSuggestion = sortedSuggestions[i];
                delete this.osSuggestions.suggestions[deletedSuggestion.id];

                // 更新统计
                this.osSuggestions.stats.total--;
                this.osSuggestions.stats.byType[deletedSuggestion.type]--;
                this.osSuggestions.stats.byPriority[deletedSuggestion.priority]--;
                this.osSuggestions.stats.byStatus[deletedSuggestion.status]--;
            }

            this.saveOSSuggestions();
        }
    },

    /**
     * 实施建议
     * @param {string} suggestionId - 建议ID
     * @returns {Object} 实施结果
     */
    implementSuggestion: function (suggestionId) {
        const suggestion = this.osSuggestions.suggestions[suggestionId];

        if (!suggestion) {
            return {
                success: false,
                error: '建议不存在'
            };
        }

        suggestion.status = 'implemented';
        suggestion.implementedAt = Date.now();

        // 更新统计
        this.osSuggestions.stats.byStatus[suggestion.status]++;
        this.osSuggestions.stats.byStatus['pending']--;

        this.saveOSSuggestions();

        return {
            success: true,
            suggestion: suggestion
        };
    },

    /**
     * 忽略建议
     * @param {string} suggestionId - 建议ID
     * @returns {Object} 忽略结果
     */
    ignoreSuggestion: function (suggestionId) {
        const suggestion = this.osSuggestions.suggestions[suggestionId];

        if (!suggestion) {
            return {
                success: false,
                error: '建议不存在'
            };
        }

        suggestion.status = 'ignored';
        suggestion.ignoredAt = Date.now();

        // 更新统计
        this.osSuggestions.stats.byStatus[suggestion.status]++;
        this.osSuggestions.stats.byStatus['pending']--;

        this.saveOSSuggestions();

        return {
            success: true,
            suggestion: suggestion
        };
    },

    /**
     * 获取建议
     * @param {string} suggestionId - 建议ID
     * @returns {Object|null} 建议对象
     */
    getSuggestion: function (suggestionId) {
        return this.osSuggestions.suggestions[suggestionId] || null;
    },

    /**
     * 获取所有建议
     * @param {string} suggestionType - 建议类型
     * @param {string} priority - 优先级
     * @param {string} status - 状态
     * @returns {Array} 建议列表
     */
    getAllSuggestions: function (suggestionType, priority, status) {
        let suggestions = Object.values(this.osSuggestions.suggestions);

        if (suggestionType) {
            suggestions = suggestions.filter(s => s.type === suggestionType);
        }

        if (priority) {
            suggestions = suggestions.filter(s => s.priority === priority);
        }

        if (status) {
            suggestions = suggestions.filter(s => s.status === status);
        }

        return suggestions;
    },

    /**
     * 获取规则
     * @param {string} ruleId - 规则ID
     * @returns {Object|null} 规则对象
     */
    getRule: function (ruleId) {
        return this.osRules.rules[ruleId] || null;
    },

    /**
     * 获取所有规则
     * @param {string} ruleType - 规则类型
     * @returns {Array} 规则列表
     */
    getAllRules: function (ruleType) {
        let rules = Object.values(this.osRules.rules);

        if (ruleType) {
            rules = rules.filter(r => r.type === ruleType);
        }

        return rules;
    },

    /**
     * 获取建议统计
     * @returns {Object} 统计信息
     */
    getSuggestionStats: function () {
        return this.osSuggestions.stats;
    },

    /**
     * 获取规则统计
     * @returns {Object} 统计信息
     */
    getRuleStats: function () {
        return this.osRules.stats;
    },

    /**
     * 删除建议
     * @param {string} suggestionId - 建议ID
     * @returns {boolean} 是否成功
     */
    deleteSuggestion: function (suggestionId) {
        if (!this.osSuggestions.suggestions[suggestionId]) {
            return false;
        }

        delete this.osSuggestions.suggestions[suggestionId];
        this.saveOSSuggestions();

        return true;
    },

    /**
     * 删除规则
     * @param {string} ruleId - 规则ID
     * @returns {boolean} 是否成功
     */
    deleteRule: function (ruleId) {
        if (!this.osRules.rules[ruleId]) {
            return false;
        }

        delete this.osRules.rules[ruleId];
        this.saveOSRules();

        return true;
    },

    /**
     * 设置优化建议配置
     * @param {Object} config - 配置对象
     */
    setOSConfig: function (config) {
        this.osConfig = { ...this.osConfig, ...config };
        this.saveOSConfig();
    },

    /**
     * 获取优化建议配置
     * @returns {Object} 配置对象
     */
    getOSConfig: function () {
        return this.osConfig;
    },

    /**
     * 获取优化建议统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.osConfig.enabled,
            maxSuggestions: this.osConfig.maxSuggestions,
            autoGenerate: this.osConfig.autoGenerate,
            generationInterval: this.osConfig.generationInterval,
            totalSuggestions: Object.keys(this.osSuggestions.suggestions).length,
            totalRules: Object.keys(this.osRules.rules).length,
            activeRules: Object.values(this.osRules.rules).filter(r => r.enabled).length,
            pendingSuggestions: Object.values(this.osSuggestions.suggestions).filter(s => s.status === 'pending').length,
            criticalSuggestions: Object.values(this.osSuggestions.suggestions).filter(s => s.priority === 'critical').length
        };
    },

    /**
     * 测量FPS
     * @returns {number} FPS值
     */
    measureFPS: function () {
        // 模拟FPS测量
        return Math.floor(Math.random() * 40) + 20;
    },

    /**
     * 测量内存
     * @returns {number} 内存使用量（MB）
     */
    measureMemory: function () {
        if (window.performance && window.performance.memory) {
            return window.performance.memory.usedJSHeapSize / 1048576;
        }

        return Math.floor(Math.random() * 80) + 20;
    },

    /**
     * 测量加载时间
     * @returns {number} 加载时间（ms）
     */
    measureLoadingTime: function () {
        // 模拟加载时间测量
        return Math.floor(Math.random() * 8000) + 1000;
    },

    /**
     * 测量教程完成率
     * @returns {number} 完成率
     */
    measureTutorialCompletion: function () {
        // 模拟教程完成率测量
        return Math.random() * 0.8 + 0.2;
    },

    /**
     * 测量反馈及时性
     * @returns {number} 响应时间（ms）
     */
    measureFeedbackTimeliness: function () {
        // 模拟反馈及时性测量
        return Math.floor(Math.random() * 800) + 100;
    },

    /**
     * 测量难度平衡
     * @returns {number} 难度平衡度
     */
    measureDifficultyBalance: function () {
        // 模拟难度平衡测量
        return Math.random() * 0.8 + 0.1;
    },

    /**
     * 测量内容多样性
     * @returns {number} 内容数量
     */
    measureContentVariety: function () {
        // 模拟内容多样性测量
        return Math.floor(Math.random() * 10) + 3;
    },

    /**
     * 测量图形质量
     * @returns {number} 图形质量评分
     */
    measureGraphicsQuality: function () {
        // 模拟图形质量测量
        return Math.random() * 0.5 + 0.5;
    },

    /**
     * 测量动画流畅度
     * @returns {number} 动画流畅度评分
     */
    measureAnimationSmoothness: function () {
        // 模拟动画流畅度测量
        return Math.random() * 0.4 + 0.6;
    },

    /**
     * 测量音频质量
     * @returns {number} 音频质量评分
     */
    measureAudioQuality: function () {
        // 模拟音频质量测量
        return Math.random() * 0.5 + 0.5;
    },

    /**
     * 测量音乐多样性
     * @returns {number} 音乐数量
     */
    measureMusicVariety: function () {
        // 模拟音乐多样性测量
        return Math.floor(Math.random() * 8) + 2;
    },

    /**
     * 测量布局效率
     * @returns {number} 布局效率评分
     */
    measureLayoutEfficiency: function () {
        // 模拟布局效率测量
        return Math.random() * 0.5 + 0.5;
    },

    /**
     * 测量可访问性
     * @returns {number} 可访问性评分
     */
    measureAccessibility: function () {
        // 模拟可访问性测量
        return Math.random() * 0.6 + 0.4;
    },

    /**
     * 测量键盘支持
     * @returns {number} 键盘支持评分
     */
    measureKeyboardSupport: function () {
        // 模拟键盘支持测量
        return Math.random() * 0.6 + 0.4;
    },

    /**
     * 测量屏幕阅读器支持
     * @returns {number} 屏幕阅读器支持评分
     */
    measureScreenReaderSupport: function () {
        // 模拟屏幕阅读器支持测量
        return Math.random() * 0.6 + 0.4;
    },

    /**
     * 测量数据加密
     * @returns {boolean} 是否加密
     */
    measureDataEncryption: function () {
        // 模拟数据加密测量
        return Math.random() > 0.5;
    },

    /**
     * 测量输入验证
     * @returns {boolean} 是否验证
     */
    measureInputValidation: function () {
        // 模拟输入验证测量
        return Math.random() > 0.5;
    },

    /**
     * 测量浏览器兼容性
     * @returns {number} 兼容性评分
     */
    measureBrowserCompatibility: function () {
        // 模拟浏览器兼容性测量
        return Math.random() * 0.4 + 0.6;
    },

    /**
     * 测量移动端优化
     * @returns {number} 移动端优化评分
     */
    measureMobileOptimization: function () {
        // 模拟移动端优化测量
        return Math.random() * 0.5 + 0.5;
    },

    /**
     * 测量日志
     * @returns {boolean} 是否有日志
     */
    measureLogging: function () {
        // 模拟日志测量
        return Math.random() > 0.5;
    },

    /**
     * 测量错误处理
     * @returns {number} 错误处理评分
     */
    measureErrorHandling: function () {
        // 模拟错误处理测量
        return Math.random() * 0.4 + 0.6;
    }
};

// 优化：游戏自动化优化
const GameAutomationOptimizer = {
    autoConfig: {},
    autoTasks: {},
    autoWorkflows: {},

    /**
     * 初始化游戏自动化
     */
    init: function () {
        this.loadAutoConfig();
        this.loadAutoTasks();
        this.loadAutoWorkflows();
        this.startAutomation();
    },

    /**
     * 加载自动化配置
     */
    loadAutoConfig: function () {
        this.autoConfig = {
            enabled: true,
            maxTasks: 1000,
            maxWorkflows: 100,
            autoExecute: true,
            executionInterval: 1000,
            priorityLevels: ['low', 'medium', 'high', 'critical'],
            taskTypes: [
                'maintenance',
                'optimization',
                'monitoring',
                'backup',
                'cleanup',
                'update',
                'notification',
                'report',
                'analysis',
                'custom'
            ]
        };

        const customConfig = localStorage.getItem('autoConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.autoConfig = { ...this.autoConfig, ...config };
            } catch (error) {
                console.error('加载自动化配置失败:', error);
            }
        }
    },

    /**
     * 保存自动化配置
     */
    saveAutoConfig: function () {
        localStorage.setItem('autoConfig', JSON.stringify(this.autoConfig));
    },

    /**
     * 加载任务数据
     */
    loadAutoTasks: function () {
        const savedTasks = localStorage.getItem('autoTasks');
        if (savedTasks) {
            try {
                this.autoTasks = JSON.parse(savedTasks);
            } catch (error) {
                console.error('加载任务数据失败:', error);
            }
        }

        if (!this.autoTasks.tasks) {
            this.autoTasks = {
                tasks: {},
                stats: {
                    total: 0,
                    byType: {},
                    byPriority: {},
                    byStatus: {},
                    completed: 0,
                    failed: 0
                }
            };

            this.saveAutoTasks();
        }
    },

    /**
     * 保存任务数据
     */
    saveAutoTasks: function () {
        localStorage.setItem('autoTasks', JSON.stringify(this.autoTasks));
    },

    /**
     * 加载工作流数据
     */
    loadAutoWorkflows: function () {
        const savedWorkflows = localStorage.getItem('autoWorkflows');
        if (savedWorkflows) {
            try {
                this.autoWorkflows = JSON.parse(savedWorkflows);
            } catch (error) {
                console.error('加载工作流数据失败:', error);
            }
        }

        if (!this.autoWorkflows.workflows) {
            this.autoWorkflows = {
                workflows: {},
                stats: {
                    total: 0,
                    byType: {},
                    byStatus: {},
                    active: 0
                }
            };

            this.saveAutoWorkflows();
        }
    },

    /**
     * 保存工作流数据
     */
    saveAutoWorkflows: function () {
        localStorage.setItem('autoWorkflows', JSON.stringify(this.autoWorkflows));
    },

    /**
     * 开始自动化
     */
    startAutomation: function () {
        setInterval(() => {
            if (this.autoConfig.enabled && this.autoConfig.autoExecute) {
                this.executePendingTasks();
            }
        }, this.autoConfig.executionInterval);
    },

    /**
     * 创建任务
     * @param {string} taskType - 任务类型
     * @param {Object} taskData - 任务数据
     * @returns {Object} 任务对象
     */
    createTask: function (taskType, taskData) {
        if (!this.autoConfig.enabled) {
            return {
                success: false,
                error: '自动化已禁用'
            };
        }

        if (!this.autoConfig.taskTypes.includes(taskType)) {
            return {
                success: false,
                error: '不支持的任务类型'
            };
        }

        const taskId = 'task_' + Date.now();

        const task = {
            id: taskId,
            type: taskType,
            name: taskData.name || 'Unnamed Task',
            description: taskData.description || '',
            action: taskData.action,
            parameters: taskData.parameters || {},
            priority: taskData.priority || 'medium',
            status: 'pending',
            createdAt: Date.now(),
            scheduledAt: taskData.scheduledAt || Date.now(),
            startedAt: null,
            completedAt: null,
            result: null,
            error: null
        };

        this.autoTasks.tasks[taskId] = task;

        // 更新统计
        this.autoTasks.stats.total++;

        if (!this.autoTasks.stats.byType[taskType]) {
            this.autoTasks.stats.byType[taskType] = 0;
        }

        this.autoTasks.stats.byType[taskType]++;

        if (!this.autoTasks.stats.byPriority[task.priority]) {
            this.autoTasks.stats.byPriority[task.priority] = 0;
        }

        this.autoTasks.stats.byPriority[task.priority]++;

        if (!this.autoTasks.stats.byStatus[task.status]) {
            this.autoTasks.stats.byStatus[task.status] = 0;
        }

        this.autoTasks.stats.byStatus[task.status]++;

        // 清理旧任务
        this.cleanupOldTasks();

        this.saveAutoTasks();

        return {
            success: true,
            task: task
        };
    },

    /**
     * 执行待处理任务
     */
    executePendingTasks: function () {
        const tasks = Object.values(this.autoTasks.tasks)
            .filter(task => task.status === 'pending' && task.scheduledAt <= Date.now())
            .sort((a, b) => {
                // 按优先级排序
                const priorityOrder = {
                    'critical': 0,
                    'high': 1,
                    'medium': 2,
                    'low': 3
                };

                return priorityOrder[a.priority] - priorityOrder[b.priority];
            });

        tasks.forEach(task => {
            this.executeTask(task.id);
        });
    },

    /**
     * 执行任务
     * @param {string} taskId - 任务ID
     * @returns {Object} 执行结果
     */
    executeTask: function (taskId) {
        const task = this.autoTasks.tasks[taskId];

        if (!task) {
            return {
                success: false,
                error: '任务不存在'
            };
        }

        if (task.status !== 'pending') {
            return {
                success: false,
                error: '任务状态不正确'
            };
        }

        // 更新任务状态
        task.status = 'running';
        task.startedAt = Date.now();

        this.saveAutoTasks();

        // 执行任务
        try {
            const result = this.runTaskAction(task);

            task.status = 'completed';
            task.completedAt = Date.now();
            task.result = result;

            // 更新统计
            this.autoTasks.stats.completed++;
            this.autoTasks.stats.byStatus['completed']++;
            this.autoTasks.stats.byStatus['running']--;

            this.saveAutoTasks();

            return {
                success: true,
                task: task,
                result: result
            };
        } catch (error) {
            task.status = 'failed';
            task.completedAt = Date.now();
            task.error = error.message;

            // 更新统计
            this.autoTasks.stats.failed++;
            this.autoTasks.stats.byStatus['failed']++;
            this.autoTasks.stats.byStatus['running']--;

            this.saveAutoTasks();

            return {
                success: false,
                task: task,
                error: error.message
            };
        }
    },

    /**
     * 运行任务动作
     * @param {Object} task - 任务对象
     * @returns {Object} 执行结果
     */
    runTaskAction: function (task) {
        switch (task.type) {
            case 'maintenance':
                return this.runMaintenanceTask(task);
            case 'optimization':
                return this.runOptimizationTask(task);
            case 'monitoring':
                return this.runMonitoringTask(task);
            case 'backup':
                return this.runBackupTask(task);
            case 'cleanup':
                return this.runCleanupTask(task);
            case 'update':
                return this.runUpdateTask(task);
            case 'notification':
                return this.runNotificationTask(task);
            case 'report':
                return this.runReportTask(task);
            case 'analysis':
                return this.runAnalysisTask(task);
            case 'custom':
                return this.runCustomTask(task);
            default:
                throw new Error('不支持的任务类型');
        }
    },

    /**
     * 运行维护任务
     * @param {Object} task - 任务对象
     * @returns {Object} 执行结果
     */
    runMaintenanceTask: function (task) {
        // 模拟维护任务
        return {
            success: true,
            message: '维护任务完成',
            data: {
                itemsProcessed: Math.floor(Math.random() * 100) + 50
            }
        };
    },

    /**
     * 运行优化任务
     * @param {Object} task - 任务对象
     * @returns {Object} 执行结果
     */
    runOptimizationTask: function (task) {
        // 模拟优化任务
        return {
            success: true,
            message: '优化任务完成',
            data: {
                improvements: Math.floor(Math.random() * 20) + 5
            }
        };
    },

    /**
     * 运行监控任务
     * @param {Object} task - 任务对象
     * @returns {Object} 执行结果
     */
    runMonitoringTask: function (task) {
        // 模拟监控任务
        return {
            success: true,
            message: '监控任务完成',
            data: {
                metricsCollected: Math.floor(Math.random() * 50) + 20
            }
        };
    },

    /**
     * 运行备份任务
     * @param {Object} task - 任务对象
     * @returns {Object} 执行结果
     */
    runBackupTask: function (task) {
        // 模拟备份任务
        return {
            success: true,
            message: '备份任务完成',
            data: {
                itemsBackedUp: Math.floor(Math.random() * 30) + 10
            }
        };
    },

    /**
     * 运行清理任务
     * @param {Object} task - 任务对象
     * @returns {Object} 执行结果
     */
    runCleanupTask: function (task) {
        // 模拟清理任务
        return {
            success: true,
            message: '清理任务完成',
            data: {
                itemsCleaned: Math.floor(Math.random() * 40) + 15
            }
        };
    },

    /**
     * 运行更新任务
     * @param {Object} task - 任务对象
     * @returns {Object} 执行结果
     */
    runUpdateTask: function (task) {
        // 模拟更新任务
        return {
            success: true,
            message: '更新任务完成',
            data: {
                itemsUpdated: Math.floor(Math.random() * 25) + 5
            }
        };
    },

    /**
     * 运行通知任务
     * @param {Object} task - 任务对象
     * @returns {Object} 执行结果
     */
    runNotificationTask: function (task) {
        // 模拟通知任务
        return {
            success: true,
            message: '通知任务完成',
            data: {
                notificationsSent: Math.floor(Math.random() * 10) + 1
            }
        };
    },

    /**
     * 运行报告任务
     * @param {Object} task - 任务对象
     * @returns {Object} 执行结果
     */
    runReportTask: function (task) {
        // 模拟报告任务
        return {
            success: true,
            message: '报告任务完成',
            data: {
                reportsGenerated: Math.floor(Math.random() * 5) + 1
            }
        };
    },

    /**
     * 运行分析任务
     * @param {Object} task - 任务对象
     * @returns {Object} 执行结果
     */
    runAnalysisTask: function (task) {
        // 模拟分析任务
        return {
            success: true,
            message: '分析任务完成',
            data: {
                analysesCompleted: Math.floor(Math.random() * 8) + 2
            }
        };
    },

    /**
     * 运行自定义任务
     * @param {Object} task - 任务对象
     * @returns {Object} 执行结果
     */
    runCustomTask: function (task) {
        // 模拟自定义任务
        return {
            success: true,
            message: '自定义任务完成',
            data: {}
        };
    },

    /**
     * 取消任务
     * @param {string} taskId - 任务ID
     * @returns {Object} 取消结果
     */
    cancelTask: function (taskId) {
        const task = this.autoTasks.tasks[taskId];

        if (!task) {
            return {
                success: false,
                error: '任务不存在'
            };
        }

        if (task.status !== 'pending') {
            return {
                success: false,
                error: '任务状态不正确'
            };
        }

        task.status = 'cancelled';
        task.completedAt = Date.now();

        // 更新统计
        this.autoTasks.stats.byStatus['cancelled']++;
        this.autoTasks.stats.byStatus['pending']--;

        this.saveAutoTasks();

        return {
            success: true,
            task: task
        };
    },

    /**
     * 清理旧任务
     */
    cleanupOldTasks: function () {
        if (Object.keys(this.autoTasks.tasks).length > this.autoConfig.maxTasks) {
            const tasksToDelete = Object.keys(this.autoTasks.tasks).length - this.autoConfig.maxTasks;

            const sortedTasks = Object.values(this.autoTasks.tasks)
                .sort((a, b) => a.createdAt - b.createdAt);

            for (let i = 0; i < tasksToDelete; i++) {
                const deletedTask = sortedTasks[i];
                delete this.autoTasks.tasks[deletedTask.id];

                // 更新统计
                this.autoTasks.stats.total--;
                this.autoTasks.stats.byType[deletedTask.type]--;
                this.autoTasks.stats.byPriority[deletedTask.priority]--;
                this.autoTasks.stats.byStatus[deletedTask.status]--;
            }

            this.saveAutoTasks();
        }
    },

    /**
     * 创建工作流
     * @param {string} workflowType - 工作流类型
     * @param {Object} workflowData - 工作流数据
     * @returns {Object} 工作流对象
     */
    createWorkflow: function (workflowType, workflowData) {
        if (!this.autoConfig.enabled) {
            return {
                success: false,
                error: '自动化已禁用'
            };
        }

        const workflowId = 'workflow_' + Date.now();

        const workflow = {
            id: workflowId,
            type: workflowType,
            name: workflowData.name || 'Unnamed Workflow',
            description: workflowData.description || '',
            tasks: workflowData.tasks || [],
            status: 'active',
            createdAt: Date.now(),
            lastExecuted: null,
            executionCount: 0
        };

        this.autoWorkflows.workflows[workflowId] = workflow;

        // 更新统计
        this.autoWorkflows.stats.total++;

        if (!this.autoWorkflows.stats.byType[workflowType]) {
            this.autoWorkflows.stats.byType[workflowType] = 0;
        }

        this.autoWorkflows.stats.byType[workflowType]++;

        if (!this.autoWorkflows.stats.byStatus[workflow.status]) {
            this.autoWorkflows.stats.byStatus[workflow.status] = 0;
        }

        this.autoWorkflows.stats.byStatus[workflow.status]++;

        this.autoWorkflows.stats.active++;

        this.saveAutoWorkflows();

        return {
            success: true,
            workflow: workflow
        };
    },

    /**
     * 执行工作流
     * @param {string} workflowId - 工作流ID
     * @returns {Object} 执行结果
     */
    executeWorkflow: function (workflowId) {
        const workflow = this.autoWorkflows.workflows[workflowId];

        if (!workflow) {
            return {
                success: false,
                error: '工作流不存在'
            };
        }

        if (workflow.status !== 'active') {
            return {
                success: false,
                error: '工作流状态不正确'
            };
        }

        // 更新工作流
        workflow.lastExecuted = Date.now();
        workflow.executionCount++;

        this.saveAutoWorkflows();

        // 执行工作流中的任务
        const results = [];

        for (const taskData of workflow.tasks) {
            const taskResult = this.createTask(taskData.type, taskData);

            if (taskResult.success) {
                const executionResult = this.executeTask(taskResult.task.id);
                results.push(executionResult);
            } else {
                results.push(taskResult);
            }
        }

        return {
            success: true,
            workflow: workflow,
            results: results
        };
    },

    /**
     * 获取任务
     * @param {string} taskId - 任务ID
     * @returns {Object|null} 任务对象
     */
    getTask: function (taskId) {
        return this.autoTasks.tasks[taskId] || null;
    },

    /**
     * 获取所有任务
     * @param {string} taskType - 任务类型
     * @param {string} priority - 优先级
     * @param {string} status - 状态
     * @returns {Array} 任务列表
     */
    getAllTasks: function (taskType, priority, status) {
        let tasks = Object.values(this.autoTasks.tasks);

        if (taskType) {
            tasks = tasks.filter(t => t.type === taskType);
        }

        if (priority) {
            tasks = tasks.filter(t => t.priority === priority);
        }

        if (status) {
            tasks = tasks.filter(t => t.status === status);
        }

        return tasks;
    },

    /**
     * 获取工作流
     * @param {string} workflowId - 工作流ID
     * @returns {Object|null} 工作流对象
     */
    getWorkflow: function (workflowId) {
        return this.autoWorkflows.workflows[workflowId] || null;
    },

    /**
     * 获取所有工作流
     * @param {string} workflowType - 工作流类型
     * @param {string} status - 状态
     * @returns {Array} 工作流列表
     */
    getAllWorkflows: function (workflowType, status) {
        let workflows = Object.values(this.autoWorkflows.workflows);

        if (workflowType) {
            workflows = workflows.filter(w => w.type === workflowType);
        }

        if (status) {
            workflows = workflows.filter(w => w.status === status);
        }

        return workflows;
    },

    /**
     * 获取任务统计
     * @returns {Object} 统计信息
     */
    getTaskStats: function () {
        return this.autoTasks.stats;
    },

    /**
     * 获取工作流统计
     * @returns {Object} 统计信息
     */
    getWorkflowStats: function () {
        return this.autoWorkflows.stats;
    },

    /**
     * 删除任务
     * @param {string} taskId - 任务ID
     * @returns {boolean} 是否成功
     */
    deleteTask: function (taskId) {
        if (!this.autoTasks.tasks[taskId]) {
            return false;
        }

        delete this.autoTasks.tasks[taskId];
        this.saveAutoTasks();

        return true;
    },

    /**
     * 删除工作流
     * @param {string} workflowId - 工作流ID
     * @returns {boolean} 是否成功
     */
    deleteWorkflow: function (workflowId) {
        if (!this.autoWorkflows.workflows[workflowId]) {
            return false;
        }

        delete this.autoWorkflows.workflows[workflowId];
        this.saveAutoWorkflows();

        return true;
    },

    /**
     * 设置自动化配置
     * @param {Object} config - 配置对象
     */
    setAutoConfig: function (config) {
        this.autoConfig = { ...this.autoConfig, ...config };
        this.saveAutoConfig();
    },

    /**
     * 获取自动化配置
     * @returns {Object} 配置对象
     */
    getAutoConfig: function () {
        return this.autoConfig;
    },

    /**
     * 获取自动化统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.autoConfig.enabled,
            maxTasks: this.autoConfig.maxTasks,
            maxWorkflows: this.autoConfig.maxWorkflows,
            autoExecute: this.autoConfig.autoExecute,
            executionInterval: this.autoConfig.executionInterval,
            totalTasks: Object.keys(this.autoTasks.tasks).length,
            totalWorkflows: Object.keys(this.autoWorkflows.workflows).length,
            activeWorkflows: Object.values(this.autoWorkflows.workflows).filter(w => w.status === 'active').length,
            pendingTasks: Object.values(this.autoTasks.tasks).filter(t => t.status === 'pending').length,
            runningTasks: Object.values(this.autoTasks.tasks).filter(t => t.status === 'running').length,
            completedTasks: this.autoTasks.stats.completed,
            failedTasks: this.autoTasks.stats.failed
        };
    }
};

// 优化：游戏调度优化
const GameSchedulerOptimizer = {
    schedulerConfig: {},
    schedulerJobs: {},
    schedulerResources: {},

    /**
     * 初始化游戏调度
     */
    init: function () {
        this.loadSchedulerConfig();
        this.loadSchedulerJobs();
        this.loadSchedulerResources();
        this.startScheduler();
    },

    /**
     * 加载调度配置
     */
    loadSchedulerConfig: function () {
        this.schedulerConfig = {
            enabled: true,
            maxJobs: 1000,
            maxResources: 100,
            autoSchedule: true,
            schedulingInterval: 1000,
            priorityLevels: ['low', 'medium', 'high', 'critical'],
            jobTypes: [
                'periodic',
                'event',
                'conditional',
                'dependency',
                'batch',
                'realtime',
                'background',
                'custom'
            ]
        };

        const customConfig = localStorage.getItem('schedulerConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.schedulerConfig = { ...this.schedulerConfig, ...config };
            } catch (error) {
                console.error('加载调度配置失败:', error);
            }
        }
    },

    /**
     * 保存调度配置
     */
    saveSchedulerConfig: function () {
        localStorage.setItem('schedulerConfig', JSON.stringify(this.schedulerConfig));
    },

    /**
     * 加载作业数据
     */
    loadSchedulerJobs: function () {
        const savedJobs = localStorage.getItem('schedulerJobs');
        if (savedJobs) {
            try {
                this.schedulerJobs = JSON.parse(savedJobs);
            } catch (error) {
                console.error('加载作业数据失败:', error);
            }
        }

        if (!this.schedulerJobs.jobs) {
            this.schedulerJobs = {
                jobs: {},
                stats: {
                    total: 0,
                    byType: {},
                    byPriority: {},
                    byStatus: {},
                    executed: 0,
                    failed: 0,
                    skipped: 0
                }
            };

            this.saveSchedulerJobs();
        }
    },

    /**
     * 保存作业数据
     */
    saveSchedulerJobs: function () {
        localStorage.setItem('schedulerJobs', JSON.stringify(this.schedulerJobs));
    },

    /**
     * 加载资源数据
     */
    loadSchedulerResources: function () {
        const savedResources = localStorage.getItem('schedulerResources');
        if (savedResources) {
            try {
                this.schedulerResources = JSON.parse(savedResources);
            } catch (error) {
                console.error('加载资源数据失败:', error);
            }
        }

        if (!this.schedulerResources.resources) {
            this.schedulerResources = {
                resources: {},
                stats: {
                    total: 0,
                    allocated: 0,
                    available: 0,
                    byType: {}
                }
            };

            this.saveSchedulerResources();
        }
    },

    /**
     * 保存资源数据
     */
    saveSchedulerResources: function () {
        localStorage.setItem('schedulerResources', JSON.stringify(this.schedulerResources));
    },

    /**
     * 开始调度
     */
    startScheduler: function () {
        setInterval(() => {
            if (this.schedulerConfig.enabled && this.schedulerConfig.autoSchedule) {
                this.scheduleJobs();
            }
        }, this.schedulerConfig.schedulingInterval);
    },

    /**
     * 创建作业
     * @param {string} jobType - 作业类型
     * @param {Object} jobData - 作业数据
     * @returns {Object} 作业对象
     */
    createJob: function (jobType, jobData) {
        if (!this.schedulerConfig.enabled) {
            return {
                success: false,
                error: '调度已禁用'
            };
        }

        if (!this.schedulerConfig.jobTypes.includes(jobType)) {
            return {
                success: false,
                error: '不支持的作业类型'
            };
        }

        const jobId = 'job_' + Date.now();

        const job = {
            id: jobId,
            type: jobType,
            name: jobData.name || 'Unnamed Job',
            description: jobData.description || '',
            action: jobData.action,
            parameters: jobData.parameters || {},
            priority: jobData.priority || 'medium',
            status: 'pending',
            createdAt: Date.now(),
            scheduledTime: jobData.scheduledTime || Date.now(),
            executionTime: null,
            completionTime: null,
            result: null,
            error: null,
            dependencies: jobData.dependencies || [],
            resources: jobData.resources || [],
            retryCount: 0,
            maxRetries: jobData.maxRetries || 3
        };

        this.schedulerJobs.jobs[jobId] = job;

        // 更新统计
        this.schedulerJobs.stats.total++;

        if (!this.schedulerJobs.stats.byType[jobType]) {
            this.schedulerJobs.stats.byType[jobType] = 0;
        }

        this.schedulerJobs.stats.byType[jobType]++;

        if (!this.schedulerJobs.stats.byPriority[job.priority]) {
            this.schedulerJobs.stats.byPriority[job.priority] = 0;
        }

        this.schedulerJobs.stats.byPriority[job.priority]++;

        if (!this.schedulerJobs.stats.byStatus[job.status]) {
            this.schedulerJobs.stats.byStatus[job.status] = 0;
        }

        this.schedulerJobs.stats.byStatus[job.status]++;

        // 清理旧作业
        this.cleanupOldJobs();

        this.saveSchedulerJobs();

        return {
            success: true,
            job: job
        };
    },

    /**
     * 调度作业
     */
    scheduleJobs: function () {
        const jobs = Object.values(this.schedulerJobs.jobs)
            .filter(job => job.status === 'pending')
            .filter(job => job.scheduledTime <= Date.now())
            .sort((a, b) => {
                // 按优先级排序
                const priorityOrder = {
                    'critical': 0,
                    'high': 1,
                    'medium': 2,
                    'low': 3
                };

                return priorityOrder[a.priority] - priorityOrder[b.priority];
            });

        jobs.forEach(job => {
            if (this.checkDependencies(job)) {
                if (this.allocateResources(job)) {
                    this.executeJob(job.id);
                } else {
                    this.skipJob(job.id, '资源不足');
                }
            }
        });
    },

    /**
     * 检查依赖
     * @param {Object} job - 作业对象
     * @returns {boolean} 是否满足依赖
     */
    checkDependencies: function (job) {
        if (job.dependencies.length === 0) {
            return true;
        }

        for (const depId of job.dependencies) {
            const depJob = this.schedulerJobs.jobs[depId];

            if (!depJob) {
                return false;
            }

            if (depJob.status !== 'completed') {
                return false;
            }
        }

        return true;
    },

    /**
     * 分配资源
     * @param {Object} job - 作业对象
     * @returns {boolean} 是否成功分配
     */
    allocateResources: function (job) {
        if (job.resources.length === 0) {
            return true;
        }

        for (const resourceReq of job.resources) {
            const resource = this.schedulerResources.resources[resourceReq.type];

            if (!resource) {
                return false;
            }

            if (resource.available < resourceReq.amount) {
                return false;
            }
        }

        // 分配资源
        for (const resourceReq of job.resources) {
            const resource = this.schedulerResources.resources[resourceReq.type];
            resource.available -= resourceReq.amount;
            resource.allocated += resourceReq.amount;
        }

        this.saveSchedulerResources();

        return true;
    },

    /**
     * 释放资源
     * @param {Object} job - 作业对象
     */
    releaseResources: function (job) {
        if (job.resources.length === 0) {
            return;
        }

        for (const resourceReq of job.resources) {
            const resource = this.schedulerResources.resources[resourceReq.type];

            if (resource) {
                resource.available += resourceReq.amount;
                resource.allocated -= resourceReq.amount;
            }
        }

        this.saveSchedulerResources();
    },

    /**
     * 执行作业
     * @param {string} jobId - 作业ID
     * @returns {Object} 执行结果
     */
    executeJob: function (jobId) {
        const job = this.schedulerJobs.jobs[jobId];

        if (!job) {
            return {
                success: false,
                error: '作业不存在'
            };
        }

        if (job.status !== 'pending') {
            return {
                success: false,
                error: '作业状态不正确'
            };
        }

        // 更新作业状态
        job.status = 'running';
        job.executionTime = Date.now();

        this.saveSchedulerJobs();

        // 执行作业
        try {
            const result = this.runJobAction(job);

            job.status = 'completed';
            job.completionTime = Date.now();
            job.result = result;

            // 释放资源
            this.releaseResources(job);

            // 更新统计
            this.schedulerJobs.stats.executed++;
            this.schedulerJobs.stats.byStatus['completed']++;
            this.schedulerJobs.stats.byStatus['running']--;

            this.saveSchedulerJobs();

            return {
                success: true,
                job: job,
                result: result
            };
        } catch (error) {
            job.retryCount++;

            if (job.retryCount < job.maxRetries) {
                job.status = 'pending';
                job.scheduledTime = Date.now() + 5000; // 5秒后重试
            } else {
                job.status = 'failed';
                job.completionTime = Date.now();
                job.error = error.message;

                // 释放资源
                this.releaseResources(job);

                // 更新统计
                this.schedulerJobs.stats.failed++;
            }

            this.schedulerJobs.stats.byStatus['running']--;
            this.schedulerJobs.stats.byStatus[job.status]++;

            this.saveSchedulerJobs();

            return {
                success: false,
                job: job,
                error: error.message
            };
        }
    },

    /**
     * 运行作业动作
     * @param {Object} job - 作业对象
     * @returns {Object} 执行结果
     */
    runJobAction: function (job) {
        switch (job.type) {
            case 'periodic':
                return this.runPeriodicJob(job);
            case 'event':
                return this.runEventJob(job);
            case 'conditional':
                return this.runConditionalJob(job);
            case 'dependency':
                return this.runDependencyJob(job);
            case 'batch':
                return this.runBatchJob(job);
            case 'realtime':
                return this.runRealtimeJob(job);
            case 'background':
                return this.runBackgroundJob(job);
            case 'custom':
                return this.runCustomJob(job);
            default:
                throw new Error('不支持的作业类型');
        }
    },

    /**
     * 运行周期性作业
     * @param {Object} job - 作业对象
     * @returns {Object} 执行结果
     */
    runPeriodicJob: function (job) {
        // 模拟周期性作业
        return {
            success: true,
            message: '周期性作业完成',
            data: {
                iterations: Math.floor(Math.random() * 10) + 1
            }
        };
    },

    /**
     * 运行事件作业
     * @param {Object} job - 作业对象
     * @returns {Object} 执行结果
     */
    runEventJob: function (job) {
        // 模拟事件作业
        return {
            success: true,
            message: '事件作业完成',
            data: {
                eventsProcessed: Math.floor(Math.random() * 20) + 5
            }
        };
    },

    /**
     * 运行条件作业
     * @param {Object} job - 作业对象
     * @returns {Object} 执行结果
     */
    runConditionalJob: function (job) {
        // 模拟条件作业
        return {
            success: true,
            message: '条件作业完成',
            data: {
                conditionsMet: Math.random() > 0.3
            }
        };
    },

    /**
     * 运行依赖作业
     * @param {Object} job - 作业对象
     * @returns {Object} 执行结果
     */
    runDependencyJob: function (job) {
        // 模拟依赖作业
        return {
            success: true,
            message: '依赖作业完成',
            data: {
                dependenciesResolved: job.dependencies.length
            }
        };
    },

    /**
     * 运行批处理作业
     * @param {Object} job - 作业对象
     * @returns {Object} 执行结果
     */
    runBatchJob: function (job) {
        // 模拟批处理作业
        return {
            success: true,
            message: '批处理作业完成',
            data: {
                itemsProcessed: Math.floor(Math.random() * 100) + 50
            }
        };
    },

    /**
     * 运行实时作业
     * @param {Object} job - 作业对象
     * @returns {Object} 执行结果
     */
    runRealtimeJob: function (job) {
        // 模拟实时作业
        return {
            success: true,
            message: '实时作业完成',
            data: {
                responseTime: Math.floor(Math.random() * 100) + 10
            }
        };
    },

    /**
     * 运行后台作业
     * @param {Object} job - 作业对象
     * @returns {Object} 执行结果
     */
    runBackgroundJob: function (job) {
        // 模拟后台作业
        return {
            success: true,
            message: '后台作业完成',
            data: {
                backgroundTasks: Math.floor(Math.random() * 15) + 5
            }
        };
    },

    /**
     * 运行自定义作业
     * @param {Object} job - 作业对象
     * @returns {Object} 执行结果
     */
    runCustomJob: function (job) {
        // 模拟自定义作业
        return {
            success: true,
            message: '自定义作业完成',
            data: {}
        };
    },

    /**
     * 跳过作业
     * @param {string} jobId - 作业ID
     * @param {string} reason - 跳过原因
     * @returns {Object} 跳过结果
     */
    skipJob: function (jobId, reason) {
        const job = this.schedulerJobs.jobs[jobId];

        if (!job) {
            return {
                success: false,
                error: '作业不存在'
            };
        }

        if (job.status !== 'pending') {
            return {
                success: false,
                error: '作业状态不正确'
            };
        }

        job.status = 'skipped';
        job.completionTime = Date.now();
        job.error = reason;

        // 更新统计
        this.schedulerJobs.stats.skipped++;
        this.schedulerJobs.stats.byStatus['skipped']++;
        this.schedulerJobs.stats.byStatus['pending']--;

        this.saveSchedulerJobs();

        return {
            success: true,
            job: job
        };
    },

    /**
     * 清理旧作业
     */
    cleanupOldJobs: function () {
        if (Object.keys(this.schedulerJobs.jobs).length > this.schedulerConfig.maxJobs) {
            const jobsToDelete = Object.keys(this.schedulerJobs.jobs).length - this.schedulerConfig.maxJobs;

            const sortedJobs = Object.values(this.schedulerJobs.jobs)
                .sort((a, b) => a.createdAt - b.createdAt);

            for (let i = 0; i < jobsToDelete; i++) {
                const deletedJob = sortedJobs[i];
                delete this.schedulerJobs.jobs[deletedJob.id];

                // 更新统计
                this.schedulerJobs.stats.total--;
                this.schedulerJobs.stats.byType[deletedJob.type]--;
                this.schedulerJobs.stats.byPriority[deletedJob.priority]--;
                this.schedulerJobs.stats.byStatus[deletedJob.status]--;
            }

            this.saveSchedulerJobs();
        }
    },

    /**
     * 创建资源
     * @param {string} resourceType - 资源类型
     * @param {number} capacity - 容量
     * @returns {Object} 资源对象
     */
    createResource: function (resourceType, capacity) {
        if (!this.schedulerConfig.enabled) {
            return {
                success: false,
                error: '调度已禁用'
            };
        }

        const resourceId = 'resource_' + Date.now();

        const resource = {
            id: resourceId,
            type: resourceType,
            capacity: capacity,
            available: capacity,
            allocated: 0,
            createdAt: Date.now()
        };

        this.schedulerResources.resources[resourceId] = resource;

        // 更新统计
        this.schedulerResources.stats.total++;
        this.schedulerResources.stats.available += capacity;

        if (!this.schedulerResources.stats.byType[resourceType]) {
            this.schedulerResources.stats.byType[resourceType] = 0;
        }

        this.schedulerResources.stats.byType[resourceType]++;

        this.saveSchedulerResources();

        return {
            success: true,
            resource: resource
        };
    },

    /**
     * 获取作业
     * @param {string} jobId - 作业ID
     * @returns {Object|null} 作业对象
     */
    getJob: function (jobId) {
        return this.schedulerJobs.jobs[jobId] || null;
    },

    /**
     * 获取所有作业
     * @param {string} jobType - 作业类型
     * @param {string} priority - 优先级
     * @param {string} status - 状态
     * @returns {Array} 作业列表
     */
    getAllJobs: function (jobType, priority, status) {
        let jobs = Object.values(this.schedulerJobs.jobs);

        if (jobType) {
            jobs = jobs.filter(j => j.type === jobType);
        }

        if (priority) {
            jobs = jobs.filter(j => j.priority === priority);
        }

        if (status) {
            jobs = jobs.filter(j => j.status === status);
        }

        return jobs;
    },

    /**
     * 获取资源
     * @param {string} resourceId - 资源ID
     * @returns {Object|null} 资源对象
     */
    getResource: function (resourceId) {
        return this.schedulerResources.resources[resourceId] || null;
    },

    /**
     * 获取所有资源
     * @param {string} resourceType - 资源类型
     * @returns {Array} 资源列表
     */
    getAllResources: function (resourceType) {
        let resources = Object.values(this.schedulerResources.resources);

        if (resourceType) {
            resources = resources.filter(r => r.type === resourceType);
        }

        return resources;
    },

    /**
     * 获取作业统计
     * @returns {Object} 统计信息
     */
    getJobStats: function () {
        return this.schedulerJobs.stats;
    },

    /**
     * 获取资源统计
     * @returns {Object} 统计信息
     */
    getResourceStats: function () {
        return this.schedulerResources.stats;
    },

    /**
     * 删除作业
     * @param {string} jobId - 作业ID
     * @returns {boolean} 是否成功
     */
    deleteJob: function (jobId) {
        if (!this.schedulerJobs.jobs[jobId]) {
            return false;
        }

        delete this.schedulerJobs.jobs[jobId];
        this.saveSchedulerJobs();

        return true;
    },

    /**
     * 删除资源
     * @param {string} resourceId - 资源ID
     * @returns {boolean} 是否成功
     */
    deleteResource: function (resourceId) {
        if (!this.schedulerResources.resources[resourceId]) {
            return false;
        }

        delete this.schedulerResources.resources[resourceId];
        this.saveSchedulerResources();

        return true;
    },

    /**
     * 设置调度配置
     * @param {Object} config - 配置对象
     */
    setSchedulerConfig: function (config) {
        this.schedulerConfig = { ...this.schedulerConfig, ...config };
        this.saveSchedulerConfig();
    },

    /**
     * 获取调度配置
     * @returns {Object} 配置对象
     */
    getSchedulerConfig: function () {
        return this.schedulerConfig;
    },

    /**
     * 获取调度统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.schedulerConfig.enabled,
            maxJobs: this.schedulerConfig.maxJobs,
            maxResources: this.schedulerConfig.maxResources,
            autoSchedule: this.schedulerConfig.autoSchedule,
            schedulingInterval: this.schedulerConfig.schedulingInterval,
            totalJobs: Object.keys(this.schedulerJobs.jobs).length,
            totalResources: Object.keys(this.schedulerResources.resources).length,
            pendingJobs: Object.values(this.schedulerJobs.jobs).filter(j => j.status === 'pending').length,
            runningJobs: Object.values(this.schedulerJobs.jobs).filter(j => j.status === 'running').length,
            executedJobs: this.schedulerJobs.stats.executed,
            failedJobs: this.schedulerJobs.stats.failed,
            skippedJobs: this.schedulerJobs.stats.skipped,
            availableResources: this.schedulerResources.stats.available,
            allocatedResources: this.schedulerResources.stats.allocated
        };
    }
};

// 优化：游戏队列优化
const GameQueueOptimizer = {
    queueConfig: {},
    queueItems: {},
    queueWorkers: {},

    /**
     * 初始化游戏队列
     */
    init: function () {
        this.loadQueueConfig();
        this.loadQueueItems();
        this.loadQueueWorkers();
        this.startWorkers();
    },

    /**
     * 加载队列配置
     */
    loadQueueConfig: function () {
        this.queueConfig = {
            enabled: true,
            maxItems: 10000,
            maxWorkers: 10,
            autoProcess: true,
            processingInterval: 100,
            priorityLevels: ['low', 'medium', 'high', 'critical'],
            queueTypes: [
                'message',
                'event',
                'task',
                'command',
                'notification',
                'data',
                'file',
                'network',
                'render',
                'custom'
            ]
        };

        const customConfig = localStorage.getItem('queueConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.queueConfig = { ...this.queueConfig, ...config };
            } catch (error) {
                console.error('加载队列配置失败:', error);
            }
        }
    },

    /**
     * 保存队列配置
     */
    saveQueueConfig: function () {
        localStorage.setItem('queueConfig', JSON.stringify(this.queueConfig));
    },

    /**
     * 加载队列项数据
     */
    loadQueueItems: function () {
        const savedItems = localStorage.getItem('queueItems');
        if (savedItems) {
            try {
                this.queueItems = JSON.parse(savedItems);
            } catch (error) {
                console.error('加载队列项数据失败:', error);
            }
        }

        if (!this.queueItems.items) {
            this.queueItems = {
                items: {},
                stats: {
                    total: 0,
                    byType: {},
                    byPriority: {},
                    byStatus: {},
                    processed: 0,
                    failed: 0,
                    waiting: 0
                }
            };

            this.saveQueueItems();
        }
    },

    /**
     * 保存队列项数据
     */
    saveQueueItems: function () {
        localStorage.setItem('queueItems', JSON.stringify(this.queueItems));
    },

    /**
     * 加载工作器数据
     */
    loadQueueWorkers: function () {
        const savedWorkers = localStorage.getItem('queueWorkers');
        if (savedWorkers) {
            try {
                this.queueWorkers = JSON.parse(savedWorkers);
            } catch (error) {
                console.error('加载工作器数据失败:', error);
            }
        }

        if (!this.queueWorkers.workers) {
            this.queueWorkers = {
                workers: {},
                stats: {
                    total: 0,
                    active: 0,
                    idle: 0,
                    byType: {}
                }
            };

            this.saveQueueWorkers();
        }
    },

    /**
     * 保存工作器数据
     */
    saveQueueWorkers: function () {
        localStorage.setItem('queueWorkers', JSON.stringify(this.queueWorkers));
    },

    /**
     * 开始工作器
     */
    startWorkers: function () {
        setInterval(() => {
            if (this.queueConfig.enabled && this.queueConfig.autoProcess) {
                this.processQueue();
            }
        }, this.queueConfig.processingInterval);
    },

    /**
     * 入队
     * @param {string} queueType - 队列类型
     * @param {Object} itemData - 队列项数据
     * @returns {Object} 队列项对象
     */
    enqueue: function (queueType, itemData) {
        if (!this.queueConfig.enabled) {
            return {
                success: false,
                error: '队列已禁用'
            };
        }

        if (!this.queueConfig.queueTypes.includes(queueType)) {
            return {
                success: false,
                error: '不支持的队列类型'
            };
        }

        const itemId = 'item_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        const item = {
            id: itemId,
            type: queueType,
            data: itemData.data || {},
            priority: itemData.priority || 'medium',
            status: 'waiting',
            createdAt: Date.now(),
            enqueuedAt: Date.now(),
            processedAt: null,
            completedAt: null,
            result: null,
            error: null,
            retryCount: 0,
            maxRetries: itemData.maxRetries || 3,
            timeout: itemData.timeout || 30000
        };

        this.queueItems.items[itemId] = item;

        // 更新统计
        this.queueItems.stats.total++;

        if (!this.queueItems.stats.byType[queueType]) {
            this.queueItems.stats.byType[queueType] = 0;
        }

        this.queueItems.stats.byType[queueType]++;

        if (!this.queueItems.stats.byPriority[item.priority]) {
            this.queueItems.stats.byPriority[item.priority] = 0;
        }

        this.queueItems.stats.byPriority[item.priority]++;

        if (!this.queueItems.stats.byStatus[item.status]) {
            this.queueItems.stats.byStatus[item.status] = 0;
        }

        this.queueItems.stats.byStatus[item.status]++;
        this.queueItems.stats.waiting++;

        // 清理旧队列项
        this.cleanupOldItems();

        this.saveQueueItems();

        return {
            success: true,
            item: item
        };
    },

    /**
     * 出队
     * @param {string} itemId - 队列项ID
     * @returns {Object} 出队结果
     */
    dequeue: function (itemId) {
        const item = this.queueItems.items[itemId];

        if (!item) {
            return {
                success: false,
                error: '队列项不存在'
            };
        }

        if (item.status !== 'waiting') {
            return {
                success: false,
                error: '队列项状态不正确'
            };
        }

        return {
            success: true,
            item: item
        };
    },

    /**
     * 处理队列
     */
    processQueue: function () {
        const items = Object.values(this.queueItems.items)
            .filter(item => item.status === 'waiting')
            .sort((a, b) => {
                // 按优先级排序
                const priorityOrder = {
                    'critical': 0,
                    'high': 1,
                    'medium': 2,
                    'low': 3
                };

                return priorityOrder[a.priority] - priorityOrder[b.priority];
            });

        const availableWorkers = this.getAvailableWorkers();

        items.slice(0, availableWorkers.length).forEach(item => {
            this.processItem(item.id);
        });
    },

    /**
     * 处理队列项
     * @param {string} itemId - 队列项ID
     * @returns {Object} 处理结果
     */
    processItem: function (itemId) {
        const item = this.queueItems.items[itemId];

        if (!item) {
            return {
                success: false,
                error: '队列项不存在'
            };
        }

        if (item.status !== 'waiting') {
            return {
                success: false,
                error: '队列项状态不正确'
            };
        }

        // 更新队列项状态
        item.status = 'processing';
        item.processedAt = Date.now();

        this.saveQueueItems();

        // 处理队列项
        try {
            const result = this.processItemData(item);

            item.status = 'completed';
            item.completedAt = Date.now();
            item.result = result;

            // 更新统计
            this.queueItems.stats.processed++;
            this.queueItems.stats.waiting--;
            this.queueItems.stats.byStatus['completed']++;
            this.queueItems.stats.byStatus['processing']--;

            this.saveQueueItems();

            return {
                success: true,
                item: item,
                result: result
            };
        } catch (error) {
            item.retryCount++;

            if (item.retryCount < item.maxRetries) {
                item.status = 'waiting';
                item.enqueuedAt = Date.now();
            } else {
                item.status = 'failed';
                item.completedAt = Date.now();
                item.error = error.message;

                // 更新统计
                this.queueItems.stats.failed++;
            }

            this.queueItems.stats.waiting--;
            this.queueItems.stats.byStatus['processing']--;
            this.queueItems.stats.byStatus[item.status]++;

            this.saveQueueItems();

            return {
                success: false,
                item: item,
                error: error.message
            };
        }
    },

    /**
     * 处理队列项数据
     * @param {Object} item - 队列项对象
     * @returns {Object} 处理结果
     */
    processItemData: function (item) {
        switch (item.type) {
            case 'message':
                return this.processMessage(item);
            case 'event':
                return this.processEvent(item);
            case 'task':
                return this.processTask(item);
            case 'command':
                return this.processCommand(item);
            case 'notification':
                return this.processNotification(item);
            case 'data':
                return this.processData(item);
            case 'file':
                return this.processFile(item);
            case 'network':
                return this.processNetwork(item);
            case 'render':
                return this.processRender(item);
            case 'custom':
                return this.processCustom(item);
            default:
                throw new Error('不支持的队列项类型');
        }
    },

    /**
     * 处理消息
     * @param {Object} item - 队列项对象
     * @returns {Object} 处理结果
     */
    processMessage: function (item) {
        // 模拟处理消息
        return {
            success: true,
            message: '消息处理完成',
            data: {
                messageId: item.id,
                content: item.data.content
            }
        };
    },

    /**
     * 处理事件
     * @param {Object} item - 队列项对象
     * @returns {Object} 处理结果
     */
    processEvent: function (item) {
        // 模拟处理事件
        return {
            success: true,
            message: '事件处理完成',
            data: {
                eventId: item.id,
                eventType: item.data.eventType
            }
        };
    },

    /**
     * 处理任务
     * @param {Object} item - 队列项对象
     * @returns {Object} 处理结果
     */
    processTask: function (item) {
        // 模拟处理任务
        return {
            success: true,
            message: '任务处理完成',
            data: {
                taskId: item.id,
                taskName: item.data.taskName
            }
        };
    },

    /**
     * 处理命令
     * @param {Object} item - 队列项对象
     * @returns {Object} 处理结果
     */
    processCommand: function (item) {
        // 模拟处理命令
        return {
            success: true,
            message: '命令处理完成',
            data: {
                commandId: item.id,
                command: item.data.command
            }
        };
    },

    /**
     * 处理通知
     * @param {Object} item - 队列项对象
     * @returns {Object} 处理结果
     */
    processNotification: function (item) {
        // 模拟处理通知
        return {
            success: true,
            message: '通知处理完成',
            data: {
                notificationId: item.id,
                notificationType: item.data.notificationType
            }
        };
    },

    /**
     * 处理数据
     * @param {Object} item - 队列项对象
     * @returns {Object} 处理结果
     */
    processData: function (item) {
        // 模拟处理数据
        return {
            success: true,
            message: '数据处理完成',
            data: {
                dataId: item.id,
                dataType: item.data.dataType
            }
        };
    },

    /**
     * 处理文件
     * @param {Object} item - 队列项对象
     * @returns {Object} 处理结果
     */
    processFile: function (item) {
        // 模拟处理文件
        return {
            success: true,
            message: '文件处理完成',
            data: {
                fileId: item.id,
                fileName: item.data.fileName
            }
        };
    },

    /**
     * 处理网络请求
     * @param {Object} item - 队列项对象
     * @returns {Object} 处理结果
     */
    processNetwork: function (item) {
        // 模拟处理网络请求
        return {
            success: true,
            message: '网络请求处理完成',
            data: {
                requestId: item.id,
                url: item.data.url
            }
        };
    },

    /**
     * 处理渲染
     * @param {Object} item - 队列项对象
     * @returns {Object} 处理结果
     */
    processRender: function (item) {
        // 模拟处理渲染
        return {
            success: true,
            message: '渲染处理完成',
            data: {
                renderId: item.id,
                renderType: item.data.renderType
            }
        };
    },

    /**
     * 处理自定义项
     * @param {Object} item - 队列项对象
     * @returns {Object} 处理结果
     */
    processCustom: function (item) {
        // 模拟处理自定义项
        return {
            success: true,
            message: '自定义项处理完成',
            data: {}
        };
    },

    /**
     * 清理旧队列项
     */
    cleanupOldItems: function () {
        if (Object.keys(this.queueItems.items).length > this.queueConfig.maxItems) {
            const itemsToDelete = Object.keys(this.queueItems.items).length - this.queueConfig.maxItems;

            const sortedItems = Object.values(this.queueItems.items)
                .sort((a, b) => a.createdAt - b.createdAt);

            for (let i = 0; i < itemsToDelete; i++) {
                const deletedItem = sortedItems[i];
                delete this.queueItems.items[deletedItem.id];

                // 更新统计
                this.queueItems.stats.total--;
                this.queueItems.stats.byType[deletedItem.type]--;
                this.queueItems.stats.byPriority[deletedItem.priority]--;
                this.queueItems.stats.byStatus[deletedItem.status]--;
            }

            this.saveQueueItems();
        }
    },

    /**
     * 创建工作器
     * @param {string} workerType - 工作器类型
     * @param {Object} workerData - 工作器数据
     * @returns {Object} 工作器对象
     */
    createWorker: function (workerType, workerData) {
        if (!this.queueConfig.enabled) {
            return {
                success: false,
                error: '队列已禁用'
            };
        }

        if (Object.keys(this.queueWorkers.workers).length >= this.queueConfig.maxWorkers) {
            return {
                success: false,
                error: '工作器数量已达上限'
            };
        }

        const workerId = 'worker_' + Date.now();

        const worker = {
            id: workerId,
            type: workerType,
            name: workerData.name || 'Unnamed Worker',
            status: 'idle',
            createdAt: Date.now(),
            lastActive: Date.now(),
            processedCount: 0
        };

        this.queueWorkers.workers[workerId] = worker;

        // 更新统计
        this.queueWorkers.stats.total++;
        this.queueWorkers.stats.idle++;

        if (!this.queueWorkers.stats.byType[workerType]) {
            this.queueWorkers.stats.byType[workerType] = 0;
        }

        this.queueWorkers.stats.byType[workerType]++;

        this.saveQueueWorkers();

        return {
            success: true,
            worker: worker
        };
    },

    /**
     * 获取可用工作器
     * @returns {Array} 工作器列表
     */
    getAvailableWorkers: function () {
        return Object.values(this.queueWorkers.workers).filter(w => w.status === 'idle');
    },

    /**
     * 获取队列项
     * @param {string} itemId - 队列项ID
     * @returns {Object|null} 队列项对象
     */
    getItem: function (itemId) {
        return this.queueItems.items[itemId] || null;
    },

    /**
     * 获取所有队列项
     * @param {string} itemType - 队列项类型
     * @param {string} priority - 优先级
     * @param {string} status - 状态
     * @returns {Array} 队列项列表
     */
    getAllItems: function (itemType, priority, status) {
        let items = Object.values(this.queueItems.items);

        if (itemType) {
            items = items.filter(i => i.type === itemType);
        }

        if (priority) {
            items = items.filter(i => i.priority === priority);
        }

        if (status) {
            items = items.filter(i => i.status === status);
        }

        return items;
    },

    /**
     * 获取工作器
     * @param {string} workerId - 工作器ID
     * @returns {Object|null} 工作器对象
     */
    getWorker: function (workerId) {
        return this.queueWorkers.workers[workerId] || null;
    },

    /**
     * 获取所有工作器
     * @param {string} workerType - 工作器类型
     * @param {string} status - 状态
     * @returns {Array} 工作器列表
     */
    getAllWorkers: function (workerType, status) {
        let workers = Object.values(this.queueWorkers.workers);

        if (workerType) {
            workers = workers.filter(w => w.type === workerType);
        }

        if (status) {
            workers = workers.filter(w => w.status === status);
        }

        return workers;
    },

    /**
     * 获取队列项统计
     * @returns {Object} 统计信息
     */
    getItemStats: function () {
        return this.queueItems.stats;
    },

    /**
     * 获取工作器统计
     * @returns {Object} 统计信息
     */
    getWorkerStats: function () {
        return this.queueWorkers.stats;
    },

    /**
     * 删除队列项
     * @param {string} itemId - 队列项ID
     * @returns {boolean} 是否成功
     */
    deleteItem: function (itemId) {
        if (!this.queueItems.items[itemId]) {
            return false;
        }

        delete this.queueItems.items[itemId];
        this.saveQueueItems();

        return true;
    },

    /**
     * 删除工作器
     * @param {string} workerId - 工作器ID
     * @returns {boolean} 是否成功
     */
    deleteWorker: function (workerId) {
        if (!this.queueWorkers.workers[workerId]) {
            return false;
        }

        delete this.queueWorkers.workers[workerId];
        this.saveQueueWorkers();

        return true;
    },

    /**
     * 设置队列配置
     * @param {Object} config - 配置对象
     */
    setQueueConfig: function (config) {
        this.queueConfig = { ...this.queueConfig, ...config };
        this.saveQueueConfig();
    },

    /**
     * 获取队列配置
     * @returns {Object} 配置对象
     */
    getQueueConfig: function () {
        return this.queueConfig;
    },

    /**
     * 获取队列统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.queueConfig.enabled,
            maxItems: this.queueConfig.maxItems,
            maxWorkers: this.queueConfig.maxWorkers,
            autoProcess: this.queueConfig.autoProcess,
            processingInterval: this.queueConfig.processingInterval,
            totalItems: Object.keys(this.queueItems.items).length,
            totalWorkers: Object.keys(this.queueWorkers.workers).length,
            waitingItems: Object.values(this.queueItems.items).filter(i => i.status === 'waiting').length,
            processingItems: Object.values(this.queueItems.items).filter(i => i.status === 'processing').length,
            processedItems: this.queueItems.stats.processed,
            failedItems: this.queueItems.stats.failed,
            activeWorkers: this.queueWorkers.stats.active,
            idleWorkers: this.queueWorkers.stats.idle
        };
    }
};

// 优化：游戏任务优化
const GameTaskOptimizer = {
    taskConfig: {},
    taskDefinitions: {},
    taskInstances: {},

    /**
     * 初始化游戏任务
     */
    init: function () {
        this.loadTaskConfig();
        this.loadTaskDefinitions();
        this.loadTaskInstances();
        this.createDefaultTasks();
    },

    /**
     * 加载任务配置
     */
    loadTaskConfig: function () {
        this.taskConfig = {
            enabled: true,
            maxDefinitions: 100,
            maxInstances: 1000,
            autoTrack: true,
            trackingInterval: 1000,
            taskTypes: [
                'main',
                'side',
                'daily',
                'weekly',
                'monthly',
                'achievement',
                'challenge',
                'tutorial',
                'event',
                'custom'
            ],
            difficultyLevels: ['easy', 'medium', 'hard', 'expert', 'legendary']
        };

        const customConfig = localStorage.getItem('taskConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.taskConfig = { ...this.taskConfig, ...config };
            } catch (error) {
                console.error('加载任务配置失败:', error);
            }
        }
    },

    /**
     * 保存任务配置
     */
    saveTaskConfig: function () {
        localStorage.setItem('taskConfig', JSON.stringify(this.taskConfig));
    },

    /**
     * 加载任务定义
     */
    loadTaskDefinitions: function () {
        const savedDefinitions = localStorage.getItem('taskDefinitions');
        if (savedDefinitions) {
            try {
                this.taskDefinitions = JSON.parse(savedDefinitions);
            } catch (error) {
                console.error('加载任务定义失败:', error);
            }
        }

        if (!this.taskDefinitions.definitions) {
            this.taskDefinitions = {
                definitions: {},
                stats: {
                    total: 0,
                    byType: {},
                    byDifficulty: {},
                    active: 0
                }
            };

            this.saveTaskDefinitions();
        }
    },

    /**
     * 保存任务定义
     */
    saveTaskDefinitions: function () {
        localStorage.setItem('taskDefinitions', JSON.stringify(this.taskDefinitions));
    },

    /**
     * 加载任务实例
     */
    loadTaskInstances: function () {
        const savedInstances = localStorage.getItem('taskInstances');
        if (savedInstances) {
            try {
                this.taskInstances = JSON.parse(savedInstances);
            } catch (error) {
                console.error('加载任务实例失败:', error);
            }
        }

        if (!this.taskInstances.instances) {
            this.taskInstances = {
                instances: {},
                stats: {
                    total: 0,
                    byType: {},
                    byDifficulty: {},
                    byStatus: {},
                    completed: 0,
                    failed: 0,
                    inProgress: 0
                }
            };

            this.saveTaskInstances();
        }
    },

    /**
     * 保存任务实例
     */
    saveTaskInstances: function () {
        localStorage.setItem('taskInstances', JSON.stringify(this.taskInstances));
    },

    /**
     * 创建默认任务
     */
    createDefaultTasks: function () {
        // 主线任务
        this.createDefinition('main', {
            name: '初次冒险',
            description: '完成第一个关卡',
            difficulty: 'easy',
            objectives: [
                {
                    type: 'complete_level',
                    target: 1,
                    current: 0
                }
            ],
            rewards: {
                gold: 100,
                experience: 50
            },
            prerequisites: [],
            enabled: true
        });

        this.createDefinition('main', {
            name: '击败BOSS',
            description: '击败第一个BOSS',
            difficulty: 'medium',
            objectives: [
                {
                    type: 'defeat_boss',
                    target: 1,
                    current: 0
                }
            ],
            rewards: {
                gold: 500,
                experience: 200,
                items: ['sword']
            },
            prerequisites: ['初次冒险'],
            enabled: true
        });

        // 支线任务
        this.createDefinition('side', {
            name: '收集宝藏',
            description: '收集10个宝藏',
            difficulty: 'easy',
            objectives: [
                {
                    type: 'collect_item',
                    target: 10,
                    current: 0,
                    itemType: 'treasure'
                }
            ],
            rewards: {
                gold: 200,
                experience: 100
            },
            prerequisites: [],
            enabled: true
        });

        // 每日任务
        this.createDefinition('daily', {
            name: '每日登录',
            description: '每天登录游戏',
            difficulty: 'easy',
            objectives: [
                {
                    type: 'login',
                    target: 1,
                    current: 0
                }
            ],
            rewards: {
                gold: 50,
                experience: 20
            },
            prerequisites: [],
            enabled: true,
            repeatable: true,
            cooldown: 86400000 // 24小时
        });

        this.createDefinition('daily', {
            name: '每日战斗',
            description: '每天战斗10次',
            difficulty: 'medium',
            objectives: [
                {
                    type: 'battle',
                    target: 10,
                    current: 0
                }
            ],
            rewards: {
                gold: 150,
                experience: 80
            },
            prerequisites: [],
            enabled: true,
            repeatable: true,
            cooldown: 86400000
        });

        // 成就任务
        this.createDefinition('achievement', {
            name: '新手玩家',
            description: '累计游戏时间达到1小时',
            difficulty: 'easy',
            objectives: [
                {
                    type: 'play_time',
                    target: 3600,
                    current: 0,
                    unit: 'seconds'
                }
            ],
            rewards: {
                gold: 300,
                experience: 150,
                title: '新手'
            },
            prerequisites: [],
            enabled: true
        });

        this.createDefinition('achievement', {
            name: '战斗专家',
            description: '累计击败100个敌人',
            difficulty: 'medium',
            objectives: [
                {
                    type: 'defeat_enemy',
                    target: 100,
                    current: 0
                }
            ],
            rewards: {
                gold: 500,
                experience: 250,
                title: '战斗专家'
            },
            prerequisites: [],
            enabled: true
        });
    },

    /**
     * 创建任务定义
     * @param {string} taskType - 任务类型
     * @param {Object} taskData - 任务数据
     * @returns {Object} 任务定义对象
     */
    createDefinition: function (taskType, taskData) {
        if (!this.taskConfig.enabled) {
            return {
                success: false,
                error: '任务系统已禁用'
            };
        }

        if (!this.taskConfig.taskTypes.includes(taskType)) {
            return {
                success: false,
                error: '不支持的任务类型'
            };
        }

        const definitionId = 'def_' + Date.now();

        const definition = {
            id: definitionId,
            type: taskType,
            name: taskData.name,
            description: taskData.description,
            difficulty: taskData.difficulty || 'easy',
            objectives: taskData.objectives || [],
            rewards: taskData.rewards || {},
            prerequisites: taskData.prerequisites || [],
            enabled: taskData.enabled !== false,
            repeatable: taskData.repeatable || false,
            cooldown: taskData.cooldown || 0,
            createdAt: Date.now()
        };

        this.taskDefinitions.definitions[definitionId] = definition;

        // 更新统计
        this.taskDefinitions.stats.total++;

        if (!this.taskDefinitions.stats.byType[taskType]) {
            this.taskDefinitions.stats.byType[taskType] = 0;
        }

        this.taskDefinitions.stats.byType[taskType]++;

        if (!this.taskDefinitions.stats.byDifficulty[definition.difficulty]) {
            this.taskDefinitions.stats.byDifficulty[definition.difficulty] = 0;
        }

        this.taskDefinitions.stats.byDifficulty[definition.difficulty]++;

        if (definition.enabled) {
            this.taskDefinitions.stats.active++;
        }

        this.saveTaskDefinitions();

        return {
            success: true,
            definition: definition
        };
    },

    /**
     * 创建任务实例
     * @param {string} definitionId - 任务定义ID
     * @returns {Object} 任务实例对象
     */
    createInstance: function (definitionId) {
        if (!this.taskConfig.enabled) {
            return {
                success: false,
                error: '任务系统已禁用'
            };
        }

        const definition = this.taskDefinitions.definitions[definitionId];

        if (!definition) {
            return {
                success: false,
                error: '任务定义不存在'
            };
        }

        if (!definition.enabled) {
            return {
                success: false,
                error: '任务未启用'
            };
        }

        // 检查前置任务
        for (const prereqId of definition.prerequisites) {
            const prereqCompleted = this.isPrerequisiteCompleted(prereqId);

            if (!prereqCompleted) {
                return {
                    success: false,
                    error: '前置任务未完成'
                };
            }
        }

        const instanceId = 'ins_' + Date.now();

        const instance = {
            id: instanceId,
            definitionId: definitionId,
            type: definition.type,
            name: definition.name,
            description: definition.description,
            difficulty: definition.difficulty,
            objectives: JSON.parse(JSON.stringify(definition.objectives)),
            rewards: definition.rewards,
            status: 'in_progress',
            progress: 0,
            startedAt: Date.now(),
            completedAt: null,
            failedAt: null
        };

        this.taskInstances.instances[instanceId] = instance;

        // 更新统计
        this.taskInstances.stats.total++;

        if (!this.taskInstances.stats.byType[instance.type]) {
            this.taskInstances.stats.byType[instance.type] = 0;
        }

        this.taskInstances.stats.byType[instance.type]++;

        if (!this.taskInstances.stats.byDifficulty[instance.difficulty]) {
            this.taskInstances.stats.byDifficulty[instance.difficulty] = 0;
        }

        this.taskInstances.stats.byDifficulty[instance.difficulty]++;

        if (!this.taskInstances.stats.byStatus[instance.status]) {
            this.taskInstances.stats.byStatus[instance.status] = 0;
        }

        this.taskInstances.stats.byStatus[instance.status]++;
        this.taskInstances.stats.inProgress++;

        this.saveTaskInstances();

        return {
            success: true,
            instance: instance
        };
    },

    /**
     * 检查前置任务是否完成
     * @param {string} prereqName - 前置任务名称
     * @returns {boolean} 是否完成
     */
    isPrerequisiteCompleted: function (prereqName) {
        const instances = Object.values(this.taskInstances.instances);

        for (const instance of instances) {
            if (instance.name === prereqName && instance.status === 'completed') {
                return true;
            }
        }

        return false;
    },

    /**
     * 更新任务进度
     * @param {string} instanceId - 任务实例ID
     * @param {string} objectiveType - 目标类型
     * @param {number} progress - 进度
     * @returns {Object} 更新结果
     */
    updateProgress: function (instanceId, objectiveType, progress) {
        const instance = this.taskInstances.instances[instanceId];

        if (!instance) {
            return {
                success: false,
                error: '任务实例不存在'
            };
        }

        if (instance.status !== 'in_progress') {
            return {
                success: false,
                error: '任务状态不正确'
            };
        }

        // 更新目标进度
        for (const objective of instance.objectives) {
            if (objective.type === objectiveType) {
                objective.current = Math.min(objective.current + progress, objective.target);
            }
        }

        // 计算总进度
        let totalProgress = 0;
        let totalTarget = 0;

        for (const objective of instance.objectives) {
            totalProgress += objective.current;
            totalTarget += objective.target;
        }

        instance.progress = totalProgress / totalTarget;

        // 检查是否完成
        if (instance.progress >= 1) {
            instance.status = 'completed';
            instance.completedAt = Date.now();

            // 更新统计
            this.taskInstances.stats.completed++;
            this.taskInstances.stats.inProgress--;
            this.taskInstances.stats.byStatus['completed']++;
            this.taskInstances.stats.byStatus['in_progress']--;
        }

        this.saveTaskInstances();

        return {
            success: true,
            instance: instance
        };
    },

    /**
     * 完成任务
     * @param {string} instanceId - 任务实例ID
     * @returns {Object} 完成结果
     */
    completeTask: function (instanceId) {
        const instance = this.taskInstances.instances[instanceId];

        if (!instance) {
            return {
                success: false,
                error: '任务实例不存在'
            };
        }

        if (instance.status !== 'in_progress') {
            return {
                success: false,
                error: '任务状态不正确'
            };
        }

        // 强制完成所有目标
        for (const objective of instance.objectives) {
            objective.current = objective.target;
        }

        instance.progress = 1;
        instance.status = 'completed';
        instance.completedAt = Date.now();

        // 更新统计
        this.taskInstances.stats.completed++;
        this.taskInstances.stats.inProgress--;
        this.taskInstances.stats.byStatus['completed']++;
        this.taskInstances.stats.byStatus['in_progress']--;

        this.saveTaskInstances();

        return {
            success: true,
            instance: instance,
            rewards: instance.rewards
        };
    },

    /**
     * 放弃任务
     * @param {string} instanceId - 任务实例ID
     * @returns {Object} 放弃结果
     */
    abandonTask: function (instanceId) {
        const instance = this.taskInstances.instances[instanceId];

        if (!instance) {
            return {
                success: false,
                error: '任务实例不存在'
            };
        }

        if (instance.status !== 'in_progress') {
            return {
                success: false,
                error: '任务状态不正确'
            };
        }

        instance.status = 'failed';
        instance.failedAt = Date.now();

        // 更新统计
        this.taskInstances.stats.failed++;
        this.taskInstances.stats.inProgress--;
        this.taskInstances.stats.byStatus['failed']++;
        this.taskInstances.stats.byStatus['in_progress']--;

        this.saveTaskInstances();

        return {
            success: true,
            instance: instance
        };
    },

    /**
     * 获取任务定义
     * @param {string} definitionId - 任务定义ID
     * @returns {Object|null} 任务定义对象
     */
    getDefinition: function (definitionId) {
        return this.taskDefinitions.definitions[definitionId] || null;
    },

    /**
     * 获取所有任务定义
     * @param {string} taskType - 任务类型
     * @param {string} difficulty - 难度
     * @param {boolean} enabled - 是否启用
     * @returns {Array} 任务定义列表
     */
    getAllDefinitions: function (taskType, difficulty, enabled) {
        let definitions = Object.values(this.taskDefinitions.definitions);

        if (taskType) {
            definitions = definitions.filter(d => d.type === taskType);
        }

        if (difficulty) {
            definitions = definitions.filter(d => d.difficulty === difficulty);
        }

        if (enabled !== undefined) {
            definitions = definitions.filter(d => d.enabled === enabled);
        }

        return definitions;
    },

    /**
     * 获取任务实例
     * @param {string} instanceId - 任务实例ID
     * @returns {Object|null} 任务实例对象
     */
    getInstance: function (instanceId) {
        return this.taskInstances.instances[instanceId] || null;
    },

    /**
     * 获取所有任务实例
     * @param {string} taskType - 任务类型
     * @param {string} difficulty - 难度
     * @param {string} status - 状态
     * @returns {Array} 任务实例列表
     */
    getAllInstances: function (taskType, difficulty, status) {
        let instances = Object.values(this.taskInstances.instances);

        if (taskType) {
            instances = instances.filter(i => i.type === taskType);
        }

        if (difficulty) {
            instances = instances.filter(i => i.difficulty === difficulty);
        }

        if (status) {
            instances = instances.filter(i => i.status === status);
        }

        return instances;
    },

    /**
     * 获取任务定义统计
     * @returns {Object} 统计信息
     */
    getDefinitionStats: function () {
        return this.taskDefinitions.stats;
    },

    /**
     * 获取任务实例统计
     * @returns {Object} 统计信息
     */
    getInstanceStats: function () {
        return this.taskInstances.stats;
    },

    /**
     * 删除任务定义
     * @param {string} definitionId - 任务定义ID
     * @returns {boolean} 是否成功
     */
    deleteDefinition: function (definitionId) {
        if (!this.taskDefinitions.definitions[definitionId]) {
            return false;
        }

        delete this.taskDefinitions.definitions[definitionId];
        this.saveTaskDefinitions();

        return true;
    },

    /**
     * 删除任务实例
     * @param {string} instanceId - 任务实例ID
     * @returns {boolean} 是否成功
     */
    deleteInstance: function (instanceId) {
        if (!this.taskInstances.instances[instanceId]) {
            return false;
        }

        delete this.taskInstances.instances[instanceId];
        this.saveTaskInstances();

        return true;
    },

    /**
     * 设置任务配置
     * @param {Object} config - 配置对象
     */
    setTaskConfig: function (config) {
        this.taskConfig = { ...this.taskConfig, ...config };
        this.saveTaskConfig();
    },

    /**
     * 获取任务配置
     * @returns {Object} 配置对象
     */
    getTaskConfig: function () {
        return this.taskConfig;
    },

    /**
     * 获取任务统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.taskConfig.enabled,
            maxDefinitions: this.taskConfig.maxDefinitions,
            maxInstances: this.taskConfig.maxInstances,
            autoTrack: this.taskConfig.autoTrack,
            trackingInterval: this.taskConfig.trackingInterval,
            totalDefinitions: Object.keys(this.taskDefinitions.definitions).length,
            totalInstances: Object.keys(this.taskInstances.instances).length,
            activeDefinitions: this.taskDefinitions.stats.active,
            inProgressInstances: this.taskInstances.stats.inProgress,
            completedInstances: this.taskInstances.stats.completed,
            failedInstances: this.taskInstances.stats.failed
        };
    }
};

// 优化：游戏流程优化
const GameFlowOptimizer = {
    flowConfig: {},
    flowStates: {},
    flowTransitions: {},

    /**
     * 初始化游戏流程
     */
    init: function () {
        this.loadFlowConfig();
        this.loadFlowStates();
        this.loadFlowTransitions();
        this.createDefaultFlow();
    },

    /**
     * 加载流程配置
     */
    loadFlowConfig: function () {
        this.flowConfig = {
            enabled: true,
            maxStates: 100,
            maxTransitions: 1000,
            autoTrack: true,
            trackingInterval: 1000,
            stateTypes: [
                'menu',
                'loading',
                'gameplay',
                'pause',
                'settings',
                'inventory',
                'dialogue',
                'cutscene',
                'battle',
                'result',
                'custom'
            ]
        };

        const customConfig = localStorage.getItem('flowConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.flowConfig = { ...this.flowConfig, ...config };
            } catch (error) {
                console.error('加载流程配置失败:', error);
            }
        }
    },

    /**
     * 保存流程配置
     */
    saveFlowConfig: function () {
        localStorage.setItem('flowConfig', JSON.stringify(this.flowConfig));
    },

    /**
     * 加载流程状态
     */
    loadFlowStates: function () {
        const savedStates = localStorage.getItem('flowStates');
        if (savedStates) {
            try {
                this.flowStates = JSON.parse(savedStates);
            } catch (error) {
                console.error('加载流程状态失败:', error);
            }
        }

        if (!this.flowStates.states) {
            this.flowStates = {
                states: {},
                currentState: null,
                history: [],
                stats: {
                    total: 0,
                    byType: {},
                    transitions: 0,
                    stateChanges: 0
                }
            };

            this.saveFlowStates();
        }
    },

    /**
     * 保存流程状态
     */
    saveFlowStates: function () {
        localStorage.setItem('flowStates', JSON.stringify(this.flowStates));
    },

    /**
     * 加载流程转换
     */
    loadFlowTransitions: function () {
        const savedTransitions = localStorage.getItem('flowTransitions');
        if (savedTransitions) {
            try {
                this.flowTransitions = JSON.parse(savedTransitions);
            } catch (error) {
                console.error('加载流程转换失败:', error);
            }
        }

        if (!this.flowTransitions.transitions) {
            this.flowTransitions = {
                transitions: {},
                stats: {
                    total: 0,
                    byFromState: {},
                    byToState: {},
                    byTrigger: {}
                }
            };

            this.saveFlowTransitions();
        }
    },

    /**
     * 保存流程转换
     */
    saveFlowTransitions: function () {
        localStorage.setItem('flowTransitions', JSON.stringify(this.flowTransitions));
    },

    /**
     * 创建默认流程
     */
    createDefaultFlow: function () {
        // 创建状态
        this.createState('menu', {
            name: '主菜单',
            description: '游戏主菜单界面',
            canPause: false,
            canSave: true,
            canLoad: true
        });

        this.createState('loading', {
            name: '加载中',
            description: '游戏加载界面',
            canPause: false,
            canSave: false,
            canLoad: false
        });

        this.createState('gameplay', {
            name: '游戏进行中',
            description: '游戏主要玩法',
            canPause: true,
            canSave: true,
            canLoad: true
        });

        this.createState('pause', {
            name: '暂停',
            description: '游戏暂停界面',
            canPause: false,
            canSave: true,
            canLoad: true
        });

        this.createState('settings', {
            name: '设置',
            description: '游戏设置界面',
            canPause: false,
            canSave: true,
            canLoad: true
        });

        this.createState('inventory', {
            name: '背包',
            description: '背包界面',
            canPause: true,
            canSave: true,
            canLoad: true
        });

        this.createState('dialogue', {
            name: '对话',
            description: '对话界面',
            canPause: false,
            canSave: true,
            canLoad: true
        });

        this.createState('cutscene', {
            name: '过场动画',
            description: '过场动画',
            canPause: true,
            canSave: false,
            canLoad: false
        });

        this.createState('battle', {
            name: '战斗',
            description: '战斗界面',
            canPause: true,
            canSave: false,
            canLoad: false
        });

        this.createState('result', {
            name: '结果',
            description: '游戏结果界面',
            canPause: false,
            canSave: false,
            canLoad: true
        });

        // 创建转换
        this.createTransition('menu', 'loading', 'start_game');
        this.createTransition('loading', 'gameplay', 'load_complete');
        this.createTransition('gameplay', 'pause', 'pause_request');
        this.createTransition('pause', 'gameplay', 'resume_request');
        this.createTransition('gameplay', 'settings', 'open_settings');
        this.createTransition('settings', 'gameplay', 'close_settings');
        this.createTransition('gameplay', 'inventory', 'open_inventory');
        this.createTransition('inventory', 'gameplay', 'close_inventory');
        this.createTransition('gameplay', 'dialogue', 'start_dialogue');
        this.createTransition('dialogue', 'gameplay', 'end_dialogue');
        this.createTransition('gameplay', 'cutscene', 'start_cutscene');
        this.createTransition('cutscene', 'gameplay', 'end_cutscene');
        this.createTransition('gameplay', 'battle', 'start_battle');
        this.createTransition('battle', 'gameplay', 'end_battle');
        this.createTransition('gameplay', 'result', 'game_over');
        this.createTransition('result', 'menu', 'return_to_menu');

        // 设置初始状态
        this.transitionTo('menu');
    },

    /**
     * 创建状态
     * @param {string} stateType - 状态类型
     * @param {Object} stateData - 状态数据
     * @returns {Object} 状态对象
     */
    createState: function (stateType, stateData) {
        if (!this.flowConfig.enabled) {
            return {
                success: false,
                error: '流程管理已禁用'
            };
        }

        if (!this.flowConfig.stateTypes.includes(stateType)) {
            return {
                success: false,
                error: '不支持的状态类型'
            };
        }

        const stateId = 'state_' + stateType;

        const state = {
            id: stateId,
            type: stateType,
            name: stateData.name || 'Unnamed State',
            description: stateData.description || '',
            canPause: stateData.canPause !== false,
            canSave: stateData.canSave !== false,
            canLoad: stateData.canLoad !== false,
            createdAt: Date.now(),
            enteredAt: null,
            exitedAt: null,
            duration: 0
        };

        this.flowStates.states[stateId] = state;

        // 更新统计
        this.flowStates.stats.total++;

        if (!this.flowStates.stats.byType[stateType]) {
            this.flowStates.stats.byType[stateType] = 0;
        }

        this.flowStates.stats.byType[stateType]++;

        this.saveFlowStates();

        return {
            success: true,
            state: state
        };
    },

    /**
     * 创建转换
     * @param {string} fromStateId - 源状态ID
     * @param {string} toStateId - 目标状态ID
     * @param {string} trigger - 触发条件
     * @returns {Object} 转换对象
     */
    createTransition: function (fromStateId, toStateId, trigger) {
        if (!this.flowConfig.enabled) {
            return {
                success: false,
                error: '流程管理已禁用'
            };
        }

        const transitionId = 'trans_' + fromStateId + '_' + toStateId + '_' + trigger;

        const transition = {
            id: transitionId,
            fromState: fromStateId,
            toState: toStateId,
            trigger: trigger,
            createdAt: Date.now(),
            triggeredCount: 0
        };

        this.flowTransitions.transitions[transitionId] = transition;

        // 更新统计
        this.flowTransitions.stats.total++;

        if (!this.flowTransitions.stats.byFromState[fromStateId]) {
            this.flowTransitions.stats.byFromState[fromStateId] = 0;
        }

        this.flowTransitions.stats.byFromState[fromStateId]++;

        if (!this.flowTransitions.stats.byToState[toStateId]) {
            this.flowTransitions.stats.byToState[toStateId] = 0;
        }

        this.flowTransitions.stats.byToState[toStateId]++;

        if (!this.flowTransitions.stats.byTrigger[trigger]) {
            this.flowTransitions.stats.byTrigger[trigger] = 0;
        }

        this.flowTransitions.stats.byTrigger[trigger]++;

        this.saveFlowTransitions();

        return {
            success: true,
            transition: transition
        };
    },

    /**
     * 转换到状态
     * @param {string} stateId - 状态ID
     * @param {string} trigger - 触发条件
     * @returns {Object} 转换结果
     */
    transitionTo: function (stateId, trigger) {
        if (!this.flowConfig.enabled) {
            return {
                success: false,
                error: '流程管理已禁用'
            };
        }

        const state = this.flowStates.states[stateId];

        if (!state) {
            return {
                success: false,
                error: '状态不存在'
            };
        }

        const previousState = this.flowStates.currentState;

        // 检查转换是否有效
        if (previousState) {
            const transitionId = 'trans_' + previousState + '_' + stateId + '_' + trigger;
            const transition = this.flowTransitions.transitions[transitionId];

            if (!transition) {
                return {
                    success: false,
                    error: '无效的转换'
                };
            }

            // 更新转换统计
            transition.triggeredCount++;
            this.flowTransitions.stats.transitions++;
        }

        // 退出当前状态
        if (previousState) {
            const previousStateObj = this.flowStates.states[previousState];
            previousStateObj.exitedAt = Date.now();
            previousStateObj.duration = previousStateObj.exitedAt - previousStateObj.enteredAt;
        }

        // 进入新状态
        state.enteredAt = Date.now();
        state.exitedAt = null;
        state.duration = 0;

        this.flowStates.currentState = stateId;

        // 添加到历史
        this.flowStates.history.push({
            fromState: previousState,
            toState: stateId,
            trigger: trigger,
            timestamp: Date.now()
        });

        // 更新统计
        this.flowStates.stats.stateChanges++;

        this.saveFlowStates();
        this.saveFlowTransitions();

        return {
            success: true,
            state: state,
            previousState: previousState
        };
    },

    /**
     * 获取当前状态
     * @returns {Object|null} 当前状态对象
     */
    getCurrentState: function () {
        if (!this.flowStates.currentState) {
            return null;
        }

        return this.flowStates.states[this.flowStates.currentState] || null;
    },

    /**
     * 获取状态
     * @param {string} stateId - 状态ID
     * @returns {Object|null} 状态对象
     */
    getState: function (stateId) {
        return this.flowStates.states[stateId] || null;
    },

    /**
     * 获取所有状态
     * @param {string} stateType - 状态类型
     * @returns {Array} 状态列表
     */
    getAllStates: function (stateType) {
        let states = Object.values(this.flowStates.states);

        if (stateType) {
            states = states.filter(s => s.type === stateType);
        }

        return states;
    },

    /**
     * 获取转换
     * @param {string} transitionId - 转换ID
     * @returns {Object|null} 转换对象
     */
    getTransition: function (transitionId) {
        return this.flowTransitions.transitions[transitionId] || null;
    },

    /**
     * 获取所有转换
     * @param {string} fromState - 源状态
     * @param {string} toState - 目标状态
     * @returns {Array} 转换列表
     */
    getAllTransitions: function (fromState, toState) {
        let transitions = Object.values(this.flowTransitions.transitions);

        if (fromState) {
            transitions = transitions.filter(t => t.fromState === fromState);
        }

        if (toState) {
            transitions = transitions.filter(t => t.toState === toState);
        }

        return transitions;
    },

    /**
     * 获取状态历史
     * @param {number} limit - 限制数量
     * @returns {Array} 历史记录列表
     */
    getHistory: function (limit) {
        let history = this.flowStates.history;

        if (limit) {
            history = history.slice(-limit);
        }

        return history;
    },

    /**
     * 获取状态统计
     * @returns {Object} 统计信息
     */
    getStateStats: function () {
        return this.flowStates.stats;
    },

    /**
     * 获取转换统计
     * @returns {Object} 统计信息
     */
    getTransitionStats: function () {
        return this.flowTransitions.stats;
    },

    /**
     * 删除状态
     * @param {string} stateId - 状态ID
     * @returns {boolean} 是否成功
     */
    deleteState: function (stateId) {
        if (!this.flowStates.states[stateId]) {
            return false;
        }

        delete this.flowStates.states[stateId];
        this.saveFlowStates();

        return true;
    },

    /**
     * 删除转换
     * @param {string} transitionId - 转换ID
     * @returns {boolean} 是否成功
     */
    deleteTransition: function (transitionId) {
        if (!this.flowTransitions.transitions[transitionId]) {
            return false;
        }

        delete this.flowTransitions.transitions[transitionId];
        this.saveFlowTransitions();

        return true;
    },

    /**
     * 设置流程配置
     * @param {Object} config - 配置对象
     */
    setFlowConfig: function (config) {
        this.flowConfig = { ...this.flowConfig, ...config };
        this.saveFlowConfig();
    },

    /**
     * 获取流程配置
     * @returns {Object} 配置对象
     */
    getFlowConfig: function () {
        return this.flowConfig;
    },

    /**
     * 获取流程统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.flowConfig.enabled,
            maxStates: this.flowConfig.maxStates,
            maxTransitions: this.flowConfig.maxTransitions,
            autoTrack: this.flowConfig.autoTrack,
            trackingInterval: this.flowConfig.trackingInterval,
            totalStates: Object.keys(this.flowStates.states).length,
            totalTransitions: Object.keys(this.flowTransitions.transitions).length,
            currentState: this.flowStates.currentState,
            stateChanges: this.flowStates.stats.stateChanges,
            transitions: this.flowStates.stats.transitions,
            historySize: this.flowStates.history.length
        };
    }
};

// 优化：游戏工作流优化
const GameWorkflowOptimizer = {
    workflowConfig: {},
    workflowDefinitions: {},
    workflowInstances: {},

    /**
     * 初始化游戏工作流
     */
    init: function () {
        this.loadWorkflowConfig();
        this.loadWorkflowDefinitions();
        this.loadWorkflowInstances();
        this.createDefaultWorkflows();
    },

    /**
     * 加载工作流配置
     */
    loadWorkflowConfig: function () {
        this.workflowConfig = {
            enabled: true,
            maxDefinitions: 100,
            maxInstances: 1000,
            autoExecute: true,
            executionInterval: 1000,
            workflowTypes: [
                'sequential',
                'parallel',
                'conditional',
                'loop',
                'event_driven',
                'data_driven',
                'custom'
            ]
        };

        const customConfig = localStorage.getItem('workflowConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.workflowConfig = { ...this.workflowConfig, ...config };
            } catch (error) {
                console.error('加载工作流配置失败:', error);
            }
        }
    },

    /**
     * 保存工作流配置
     */
    saveWorkflowConfig: function () {
        localStorage.setItem('workflowConfig', JSON.stringify(this.workflowConfig));
    },

    /**
     * 加载工作流定义
     */
    loadWorkflowDefinitions: function () {
        const savedDefinitions = localStorage.getItem('workflowDefinitions');
        if (savedDefinitions) {
            try {
                this.workflowDefinitions = JSON.parse(savedDefinitions);
            } catch (error) {
                console.error('加载工作流定义失败:', error);
            }
        }

        if (!this.workflowDefinitions.definitions) {
            this.workflowDefinitions = {
                definitions: {},
                stats: {
                    total: 0,
                    byType: {},
                    active: 0
                }
            };

            this.saveWorkflowDefinitions();
        }
    },

    /**
     * 保存工作流定义
     */
    saveWorkflowDefinitions: function () {
        localStorage.setItem('workflowDefinitions', JSON.stringify(this.workflowDefinitions));
    },

    /**
     * 加载工作流实例
     */
    loadWorkflowInstances: function () {
        const savedInstances = localStorage.getItem('workflowInstances');
        if (savedInstances) {
            try {
                this.workflowInstances = JSON.parse(savedInstances);
            } catch (error) {
                console.error('加载工作流实例失败:', error);
            }
        }

        if (!this.workflowInstances.instances) {
            this.workflowInstances = {
                instances: {},
                stats: {
                    total: 0,
                    byType: {},
                    byStatus: {},
                    completed: 0,
                    failed: 0,
                    running: 0
                }
            };

            this.saveWorkflowInstances();
        }
    },

    /**
     * 保存工作流实例
     */
    saveWorkflowInstances: function () {
        localStorage.setItem('workflowInstances', JSON.stringify(this.workflowInstances));
    },

    /**
     * 创建默认工作流
     */
    createDefaultWorkflows: function () {
        // 创建顺序工作流
        this.createDefinition('sequential', {
            name: '游戏初始化流程',
            description: '游戏启动时的初始化流程',
            steps: [
                {
                    name: '加载配置',
                    action: 'load_config',
                    parameters: {}
                },
                {
                    name: '加载资源',
                    action: 'load_resources',
                    parameters: {}
                },
                {
                    name: '初始化系统',
                    action: 'initialize_systems',
                    parameters: {}
                },
                {
                    name: '显示主菜单',
                    action: 'show_menu',
                    parameters: {}
                }
            ],
            enabled: true
        });

        // 创建并行工作流
        this.createDefinition('parallel', {
            name: '资源预加载流程',
            description: '并行加载多种资源',
            steps: [
                {
                    name: '加载纹理',
                    action: 'load_textures',
                    parameters: {}
                },
                {
                    name: '加载音频',
                    action: 'load_audio',
                    parameters: {}
                },
                {
                    name: '加载模型',
                    action: 'load_models',
                    parameters: {}
                },
                {
                    name: '加载脚本',
                    action: 'load_scripts',
                    parameters: {}
                }
            ],
            enabled: true
        });

        // 创建条件工作流
        this.createDefinition('conditional', {
            name: '难度选择流程',
            description: '根据玩家选择调整游戏难度',
            steps: [
                {
                    name: '显示难度选择',
                    action: 'show_difficulty_selection',
                    parameters: {}
                },
                {
                    name: '设置难度',
                    action: 'set_difficulty',
                    parameters: {},
                    condition: 'difficulty_selected'
                },
                {
                    name: '开始游戏',
                    action: 'start_game',
                    parameters: {},
                    condition: 'difficulty_selected'
                }
            ],
            enabled: true
        });

        // 创建循环工作流
        this.createDefinition('loop', {
            name: '游戏循环',
            description: '游戏主循环',
            steps: [
                {
                    name: '处理输入',
                    action: 'process_input',
                    parameters: {}
                },
                {
                    name: '更新游戏状态',
                    action: 'update_game_state',
                    parameters: {}
                },
                {
                    name: '渲染游戏',
                    action: 'render_game',
                    parameters: {}
                },
                {
                    name: '检查游戏结束',
                    action: 'check_game_over',
                    parameters: {},
                    condition: 'game_not_over'
                }
            ],
            enabled: true,
            loopCondition: 'game_not_over'
        });

        // 创建事件驱动工作流
        this.createDefinition('event_driven', {
            name: '事件处理流程',
            description: '处理游戏事件',
            steps: [
                {
                    name: '监听事件',
                    action: 'listen_events',
                    parameters: {}
                },
                {
                    name: '处理事件',
                    action: 'process_event',
                    parameters: {},
                    trigger: 'event_received'
                },
                {
                    name: '更新状态',
                    action: 'update_state',
                    parameters: {},
                    trigger: 'event_processed'
                }
            ],
            enabled: true
        });
    },

    /**
     * 创建工作流定义
     * @param {string} workflowType - 工作流类型
     * @param {Object} workflowData - 工作流数据
     * @returns {Object} 工作流定义对象
     */
    createDefinition: function (workflowType, workflowData) {
        if (!this.workflowConfig.enabled) {
            return {
                success: false,
                error: '工作流系统已禁用'
            };
        }

        if (!this.workflowConfig.workflowTypes.includes(workflowType)) {
            return {
                success: false,
                error: '不支持的工作流类型'
            };
        }

        const definitionId = 'def_' + Date.now();

        const definition = {
            id: definitionId,
            type: workflowType,
            name: workflowData.name,
            description: workflowData.description,
            steps: workflowData.steps || [],
            enabled: workflowData.enabled !== false,
            loopCondition: workflowData.loopCondition || null,
            createdAt: Date.now()
        };

        this.workflowDefinitions.definitions[definitionId] = definition;

        // 更新统计
        this.workflowDefinitions.stats.total++;

        if (!this.workflowDefinitions.stats.byType[workflowType]) {
            this.workflowDefinitions.stats.byType[workflowType] = 0;
        }

        this.workflowDefinitions.stats.byType[workflowType]++;

        if (definition.enabled) {
            this.workflowDefinitions.stats.active++;
        }

        this.saveWorkflowDefinitions();

        return {
            success: true,
            definition: definition
        };
    },

    /**
     * 创建工作流实例
     * @param {string} definitionId - 工作流定义ID
     * @param {Object} instanceData - 实例数据
     * @returns {Object} 工作流实例对象
     */
    createInstance: function (definitionId, instanceData) {
        if (!this.workflowConfig.enabled) {
            return {
                success: false,
                error: '工作流系统已禁用'
            };
        }

        const definition = this.workflowDefinitions.definitions[definitionId];

        if (!definition) {
            return {
                success: false,
                error: '工作流定义不存在'
            };
        }

        if (!definition.enabled) {
            return {
                success: false,
                error: '工作流未启用'
            };
        }

        const instanceId = 'ins_' + Date.now();

        const instance = {
            id: instanceId,
            definitionId: definitionId,
            type: definition.type,
            name: definition.name,
            description: definition.description,
            steps: JSON.parse(JSON.stringify(definition.steps)),
            currentStep: 0,
            status: 'pending',
            startedAt: null,
            completedAt: null,
            failedAt: null,
            result: null,
            error: null,
            context: instanceData.context || {},
            loopCondition: definition.loopCondition
        };

        this.workflowInstances.instances[instanceId] = instance;

        // 更新统计
        this.workflowInstances.stats.total++;

        if (!this.workflowInstances.stats.byType[instance.type]) {
            this.workflowInstances.stats.byType[instance.type] = 0;
        }

        this.workflowInstances.stats.byType[instance.type]++;

        if (!this.workflowInstances.stats.byStatus[instance.status]) {
            this.workflowInstances.stats.byStatus[instance.status] = 0;
        }

        this.workflowInstances.stats.byStatus[instance.status]++;

        this.saveWorkflowInstances();

        return {
            success: true,
            instance: instance
        };
    },

    /**
     * 执行工作流实例
     * @param {string} instanceId - 工作流实例ID
     * @returns {Object} 执行结果
     */
    executeInstance: function (instanceId) {
        const instance = this.workflowInstances.instances[instanceId];

        if (!instance) {
            return {
                success: false,
                error: '工作流实例不存在'
            };
        }

        if (instance.status !== 'pending') {
            return {
                success: false,
                error: '工作流状态不正确'
            };
        }

        instance.status = 'running';
        instance.startedAt = Date.now();

        this.saveWorkflowInstances();

        // 执行工作流
        try {
            const result = this.executeWorkflow(instance);

            instance.status = 'completed';
            instance.completedAt = Date.now();
            instance.result = result;

            // 更新统计
            this.workflowInstances.stats.completed++;
            this.workflowInstances.stats.running--;
            this.workflowInstances.stats.byStatus['completed']++;
            this.workflowInstances.stats.byStatus['running']--;

            this.saveWorkflowInstances();

            return {
                success: true,
                instance: instance,
                result: result
            };
        } catch (error) {
            instance.status = 'failed';
            instance.failedAt = Date.now();
            instance.error = error.message;

            // 更新统计
            this.workflowInstances.stats.failed++;
            this.workflowInstances.stats.running--;
            this.workflowInstances.stats.byStatus['failed']++;
            this.workflowInstances.stats.byStatus['running']--;

            this.saveWorkflowInstances();

            return {
                success: false,
                instance: instance,
                error: error.message
            };
        }
    },

    /**
     * 执行工作流
     * @param {Object} instance - 工作流实例
     * @returns {Object} 执行结果
     */
    executeWorkflow: function (instance) {
        switch (instance.type) {
            case 'sequential':
                return this.executeSequentialWorkflow(instance);
            case 'parallel':
                return this.executeParallelWorkflow(instance);
            case 'conditional':
                return this.executeConditionalWorkflow(instance);
            case 'loop':
                return this.executeLoopWorkflow(instance);
            case 'event_driven':
                return this.executeEventDrivenWorkflow(instance);
            case 'data_driven':
                return this.executeDataDrivenWorkflow(instance);
            case 'custom':
                return this.executeCustomWorkflow(instance);
            default:
                throw new Error('不支持的工作流类型');
        }
    },

    /**
     * 执行顺序工作流
     * @param {Object} instance - 工作流实例
     * @returns {Object} 执行结果
     */
    executeSequentialWorkflow: function (instance) {
        const results = [];

        for (const step of instance.steps) {
            const stepResult = this.executeStep(instance, step);
            results.push(stepResult);
        }

        return {
            success: true,
            steps: results
        };
    },

    /**
     * 执行并行工作流
     * @param {Object} instance - 工作流实例
     * @returns {Object} 执行结果
     */
    executeParallelWorkflow: function (instance) {
        const promises = instance.steps.map(step => {
            return new Promise((resolve) => {
                const stepResult = this.executeStep(instance, step);
                resolve(stepResult);
            });
        });

        const results = Promise.all(promises);

        return {
            success: true,
            steps: results
        };
    },

    /**
     * 执行条件工作流
     * @param {Object} instance - 工作流实例
     * @returns {Object} 执行结果
     */
    executeConditionalWorkflow: function (instance) {
        const results = [];

        for (const step of instance.steps) {
            if (step.condition) {
                const conditionMet = this.evaluateCondition(instance, step.condition);

                if (!conditionMet) {
                    continue;
                }
            }

            const stepResult = this.executeStep(instance, step);
            results.push(stepResult);
        }

        return {
            success: true,
            steps: results
        };
    },

    /**
     * 执行循环工作流
     * @param {Object} instance - 工作流实例
     * @returns {Object} 执行结果
     */
    executeLoopWorkflow: function (instance) {
        const results = [];
        let loopCount = 0;
        const maxLoops = 1000;

        while (loopCount < maxLoops) {
            if (instance.loopCondition) {
                const conditionMet = this.evaluateCondition(instance, instance.loopCondition);

                if (!conditionMet) {
                    break;
                }
            }

            for (const step of instance.steps) {
                const stepResult = this.executeStep(instance, step);
                results.push(stepResult);
            }

            loopCount++;
        }

        return {
            success: true,
            steps: results,
            loopCount: loopCount
        };
    },

    /**
     * 执行事件驱动工作流
     * @param {Object} instance - 工作流实例
     * @returns {Object} 执行结果
     */
    executeEventDrivenWorkflow: function (instance) {
        const results = [];

        for (const step of instance.steps) {
            if (step.trigger) {
                // 模拟等待事件
                const eventReceived = Math.random() > 0.3;

                if (!eventReceived) {
                    continue;
                }
            }

            const stepResult = this.executeStep(instance, step);
            results.push(stepResult);
        }

        return {
            success: true,
            steps: results
        };
    },

    /**
     * 执行数据驱动工作流
     * @param {Object} instance - 工作流实例
     * @returns {Object} 执行结果
     */
    executeDataDrivenWorkflow: function (instance) {
        const results = [];

        for (const step of instance.steps) {
            // 根据数据执行步骤
            const data = instance.context[step.name] || {};

            if (Object.keys(data).length === 0) {
                continue;
            }

            const stepResult = this.executeStep(instance, step, data);
            results.push(stepResult);
        }

        return {
            success: true,
            steps: results
        };
    },

    /**
     * 执行自定义工作流
     * @param {Object} instance - 工作流实例
     * @returns {Object} 执行结果
     */
    executeCustomWorkflow: function (instance) {
        const results = [];

        for (const step of instance.steps) {
            const stepResult = this.executeStep(instance, step);
            results.push(stepResult);
        }

        return {
            success: true,
            steps: results
        };
    },

    /**
     * 执行步骤
     * @param {Object} instance - 工作流实例
     * @param {Object} step - 步骤对象
     * @param {Object} data - 数据
     * @returns {Object} 执行结果
     */
    executeStep: function (instance, step, data) {
        // 模拟执行步骤
        return {
            name: step.name,
            action: step.action,
            success: true,
            data: data || {}
        };
    },

    /**
     * 评估条件
     * @param {Object} instance - 工作流实例
     * @param {string} condition - 条件
     * @returns {boolean} 是否满足条件
     */
    evaluateCondition: function (instance, condition) {
        // 模拟条件评估
        return Math.random() > 0.3;
    },

    /**
     * 获取工作流定义
     * @param {string} definitionId - 工作流定义ID
     * @returns {Object|null} 工作流定义对象
     */
    getDefinition: function (definitionId) {
        return this.workflowDefinitions.definitions[definitionId] || null;
    },

    /**
     * 获取所有工作流定义
     * @param {string} workflowType - 工作流类型
     * @param {boolean} enabled - 是否启用
     * @returns {Array} 工作流定义列表
     */
    getAllDefinitions: function (workflowType, enabled) {
        let definitions = Object.values(this.workflowDefinitions.definitions);

        if (workflowType) {
            definitions = definitions.filter(d => d.type === workflowType);
        }

        if (enabled !== undefined) {
            definitions = definitions.filter(d => d.enabled === enabled);
        }

        return definitions;
    },

    /**
     * 获取工作流实例
     * @param {string} instanceId - 工作流实例ID
     * @returns {Object|null} 工作流实例对象
     */
    getInstance: function (instanceId) {
        return this.workflowInstances.instances[instanceId] || null;
    },

    /**
     * 获取所有工作流实例
     * @param {string} workflowType - 工作流类型
     * @param {string} status - 状态
     * @returns {Array} 工作流实例列表
     */
    getAllInstances: function (workflowType, status) {
        let instances = Object.values(this.workflowInstances.instances);

        if (workflowType) {
            instances = instances.filter(i => i.type === workflowType);
        }

        if (status) {
            instances = instances.filter(i => i.status === status);
        }

        return instances;
    },

    /**
     * 获取工作流定义统计
     * @returns {Object} 统计信息
     */
    getDefinitionStats: function () {
        return this.workflowDefinitions.stats;
    },

    /**
     * 获取工作流实例统计
     * @returns {Object} 统计信息
     */
    getInstanceStats: function () {
        return this.workflowInstances.stats;
    },

    /**
     * 删除工作流定义
     * @param {string} definitionId - 工作流定义ID
     * @returns {boolean} 是否成功
     */
    deleteDefinition: function (definitionId) {
        if (!this.workflowDefinitions.definitions[definitionId]) {
            return false;
        }

        delete this.workflowDefinitions.definitions[definitionId];
        this.saveWorkflowDefinitions();

        return true;
    },

    /**
     * 删除工作流实例
     * @param {string} instanceId - 工作流实例ID
     * @returns {boolean} 是否成功
     */
    deleteInstance: function (instanceId) {
        if (!this.workflowInstances.instances[instanceId]) {
            return false;
        }

        delete this.workflowInstances.instances[instanceId];
        this.saveWorkflowInstances();

        return true;
    },

    /**
     * 设置工作流配置
     * @param {Object} config - 配置对象
     */
    setWorkflowConfig: function (config) {
        this.workflowConfig = { ...this.workflowConfig, ...config };
        this.saveWorkflowConfig();
    },

    /**
     * 获取工作流配置
     * @returns {Object} 配置对象
     */
    getWorkflowConfig: function () {
        return this.workflowConfig;
    },

    /**
     * 获取工作流统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.workflowConfig.enabled,
            maxDefinitions: this.workflowConfig.maxDefinitions,
            maxInstances: this.workflowConfig.maxInstances,
            autoExecute: this.workflowConfig.autoExecute,
            executionInterval: this.workflowConfig.executionInterval,
            totalDefinitions: Object.keys(this.workflowDefinitions.definitions).length,
            totalInstances: Object.keys(this.workflowInstances.instances).length,
            activeDefinitions: this.workflowDefinitions.stats.active,
            runningInstances: this.workflowInstances.stats.running,
            completedInstances: this.workflowInstances.stats.completed,
            failedInstances: this.workflowInstances.stats.failed
        };
    }
};

// 优化：游戏管道优化
const GamePipelineOptimizer = {
    pipelineConfig: {},
    pipelineStages: {},
    pipelinePipelines: {},

    /**
     * 初始化游戏管道
     */
    init: function () {
        this.loadPipelineConfig();
        this.loadPipelineStages();
        this.loadPipelinePipelines();
        this.createDefaultPipelines();
    },

    /**
     * 加载管道配置
     */
    loadPipelineConfig: function () {
        this.pipelineConfig = {
            enabled: true,
            maxStages: 100,
            maxPipelines: 100,
            autoExecute: true,
            executionInterval: 1000,
            stageTypes: [
                'input',
                'processing',
                'transformation',
                'validation',
                'output',
                'storage',
                'custom'
            ]
        };

        const customConfig = localStorage.getItem('pipelineConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.pipelineConfig = { ...this.pipelineConfig, ...config };
            } catch (error) {
                console.error('加载管道配置失败:', error);
            }
        }
    },

    /**
     * 保存管道配置
     */
    savePipelineConfig: function () {
        localStorage.setItem('pipelineConfig', JSON.stringify(this.pipelineConfig));
    },

    /**
     * 加载管道阶段
     */
    loadPipelineStages: function () {
        const savedStages = localStorage.getItem('pipelineStages');
        if (savedStages) {
            try {
                this.pipelineStages = JSON.parse(savedStages);
            } catch (error) {
                console.error('加载管道阶段失败:', error);
            }
        }

        if (!this.pipelineStages.stages) {
            this.pipelineStages = {
                stages: {},
                stats: {
                    total: 0,
                    byType: {},
                    active: 0
                }
            };

            this.savePipelineStages();
        }
    },

    /**
     * 保存管道阶段
     */
    savePipelineStages: function () {
        localStorage.setItem('pipelineStages', JSON.stringify(this.pipelineStages));
    },

    /**
     * 加载管道
     */
    loadPipelinePipelines: function () {
        const savedPipelines = localStorage.getItem('pipelinePipelines');
        if (savedPipelines) {
            try {
                this.pipelinePipelines = JSON.parse(savedPipelines);
            } catch (error) {
                console.error('加载管道失败:', error);
            }
        }

        if (!this.pipelinePipelines.pipelines) {
            this.pipelinePipelines = {
                pipelines: {},
                stats: {
                    total: 0,
                    byStatus: {},
                    executed: 0,
                    failed: 0,
                    running: 0
                }
            };

            this.savePipelinePipelines();
        }
    },

    /**
     * 保存管道
     */
    savePipelinePipelines: function () {
        localStorage.setItem('pipelinePipelines', JSON.stringify(this.pipelinePipelines));
    },

    /**
     * 创建默认管道
     */
    createDefaultPipelines: function () {
        // 创建输入阶段
        this.createStage('input', {
            name: '输入处理',
            description: '处理用户输入',
            processor: function (data) {
                return {
                    success: true,
                    data: data
                };
            },
            enabled: true
        });

        // 创建处理阶段
        this.createStage('processing', {
            name: '数据处理',
            description: '处理游戏数据',
            processor: function (data) {
                return {
                    success: true,
                    data: data
                };
            },
            enabled: true
        });

        // 创建转换阶段
        this.createStage('transformation', {
            name: '数据转换',
            description: '转换数据格式',
            processor: function (data) {
                return {
                    success: true,
                    data: data
                };
            },
            enabled: true
        });

        // 创建验证阶段
        this.createStage('validation', {
            name: '数据验证',
            description: '验证数据完整性',
            processor: function (data) {
                return {
                    success: true,
                    data: data
                };
            },
            enabled: true
        });

        // 创建输出阶段
        this.createStage('output', {
            name: '输出处理',
            description: '处理输出数据',
            processor: function (data) {
                return {
                    success: true,
                    data: data
                };
            },
            enabled: true
        });

        // 创建存储阶段
        this.createStage('storage', {
            name: '数据存储',
            description: '存储数据',
            processor: function (data) {
                return {
                    success: true,
                    data: data
                };
            },
            enabled: true
        });

        // 创建渲染管道
        this.createPipeline('render_pipeline', {
            name: '渲染管道',
            description: '游戏渲染流程',
            stages: [
                'input',
                'processing',
                'transformation',
                'output'
            ],
            enabled: true
        });

        // 创建数据管道
        this.createPipeline('data_pipeline', {
            name: '数据管道',
            description: '数据处理流程',
            stages: [
                'input',
                'processing',
                'validation',
                'storage'
            ],
            enabled: true
        });
    },

    /**
     * 创建阶段
     * @param {string} stageType - 阶段类型
     * @param {Object} stageData - 阶段数据
     * @returns {Object} 阶段对象
     */
    createStage: function (stageType, stageData) {
        if (!this.pipelineConfig.enabled) {
            return {
                success: false,
                error: '管道系统已禁用'
            };
        }

        if (!this.pipelineConfig.stageTypes.includes(stageType)) {
            return {
                success: false,
                error: '不支持的阶段类型'
            };
        }

        const stageId = 'stage_' + Date.now();

        const stage = {
            id: stageId,
            type: stageType,
            name: stageData.name,
            description: stageData.description,
            processor: stageData.processor,
            enabled: stageData.enabled !== false,
            createdAt: Date.now()
        };

        this.pipelineStages.stages[stageId] = stage;

        // 更新统计
        this.pipelineStages.stats.total++;

        if (!this.pipelineStages.stats.byType[stageType]) {
            this.pipelineStages.stats.byType[stageType] = 0;
        }

        this.pipelineStages.stats.byType[stageType]++;

        if (stage.enabled) {
            this.pipelineStages.stats.active++;
        }

        this.savePipelineStages();

        return {
            success: true,
            stage: stage
        };
    },

    /**
     * 创建管道
     * @param {string} pipelineId - 管道ID
     * @param {Object} pipelineData - 管道数据
     * @returns {Object} 管道对象
     */
    createPipeline: function (pipelineId, pipelineData) {
        if (!this.pipelineConfig.enabled) {
            return {
                success: false,
                error: '管道系统已禁用'
            };
        }

        const pipeline = {
            id: pipelineId,
            name: pipelineData.name,
            description: pipelineData.description,
            stages: pipelineData.stages || [],
            enabled: pipelineData.enabled !== false,
            status: 'idle',
            createdAt: Date.now(),
            lastExecuted: null,
            executionCount: 0
        };

        this.pipelinePipelines.pipelines[pipelineId] = pipeline;

        // 更新统计
        this.pipelinePipelines.stats.total++;

        if (!this.pipelinePipelines.stats.byStatus[pipeline.status]) {
            this.pipelinePipelines.stats.byStatus[pipeline.status] = 0;
        }

        this.pipelinePipelines.stats.byStatus[pipeline.status]++;

        this.savePipelinePipelines();

        return {
            success: true,
            pipeline: pipeline
        };
    },

    /**
     * 执行管道
     * @param {string} pipelineId - 管道ID
     * @param {Object} inputData - 输入数据
     * @returns {Object} 执行结果
     */
    executePipeline: function (pipelineId, inputData) {
        const pipeline = this.pipelinePipelines.pipelines[pipelineId];

        if (!pipeline) {
            return {
                success: false,
                error: '管道不存在'
            };
        }

        if (!pipeline.enabled) {
            return {
                success: false,
                error: '管道未启用'
            };
        }

        pipeline.status = 'running';
        pipeline.lastExecuted = Date.now();

        this.savePipelinePipelines();

        // 执行管道
        try {
            const result = this.processPipeline(pipeline, inputData);

            pipeline.status = 'idle';
            pipeline.executionCount++;

            // 更新统计
            this.pipelinePipelines.stats.executed++;
            this.pipelinePipelines.stats.running--;
            this.pipelinePipelines.stats.byStatus['idle']++;
            this.pipelinePipelines.stats.byStatus['running']--;

            this.savePipelinePipelines();

            return {
                success: true,
                pipeline: pipeline,
                result: result
            };
        } catch (error) {
            pipeline.status = 'idle';

            // 更新统计
            this.pipelinePipelines.stats.failed++;
            this.pipelinePipelines.stats.running--;
            this.pipelinePipelines.stats.byStatus['idle']++;
            this.pipelinePipelines.stats.byStatus['running']--;

            this.savePipelinePipelines();

            return {
                success: false,
                pipeline: pipeline,
                error: error.message
            };
        }
    },

    /**
     * 处理管道
     * @param {Object} pipeline - 管道对象
     * @param {Object} inputData - 输入数据
     * @returns {Object} 处理结果
     */
    processPipeline: function (pipeline, inputData) {
        let currentData = inputData;
        const stageResults = [];

        for (const stageId of pipeline.stages) {
            const stage = this.pipelineStages.stages[stageId];

            if (!stage || !stage.enabled) {
                continue;
            }

            const stageResult = stage.processor(currentData);

            if (!stageResult.success) {
                throw new Error('阶段执行失败: ' + stage.name);
            }

            currentData = stageResult.data;
            stageResults.push({
                stage: stage.name,
                result: stageResult
            });
        }

        return {
            success: true,
            data: currentData,
            stages: stageResults
        };
    },

    /**
     * 获取阶段
     * @param {string} stageId - 阶段ID
     * @returns {Object|null} 阶段对象
     */
    getStage: function (stageId) {
        return this.pipelineStages.stages[stageId] || null;
    },

    /**
     * 获取所有阶段
     * @param {string} stageType - 阶段类型
     * @param {boolean} enabled - 是否启用
     * @returns {Array} 阶段列表
     */
    getAllStages: function (stageType, enabled) {
        let stages = Object.values(this.pipelineStages.stages);

        if (stageType) {
            stages = stages.filter(s => s.type === stageType);
        }

        if (enabled !== undefined) {
            stages = stages.filter(s => s.enabled === enabled);
        }

        return stages;
    },

    /**
     * 获取管道
     * @param {string} pipelineId - 管道ID
     * @returns {Object|null} 管道对象
     */
    getPipeline: function (pipelineId) {
        return this.pipelinePipelines.pipelines[pipelineId] || null;
    },

    /**
     * 获取所有管道
     * @param {string} status - 状态
     * @param {boolean} enabled - 是否启用
     * @returns {Array} 管道列表
     */
    getAllPipelines: function (status, enabled) {
        let pipelines = Object.values(this.pipelinePipelines.pipelines);

        if (status) {
            pipelines = pipelines.filter(p => p.status === status);
        }

        if (enabled !== undefined) {
            pipelines = pipelines.filter(p => p.enabled === enabled);
        }

        return pipelines;
    },

    /**
     * 获取阶段统计
     * @returns {Object} 统计信息
     */
    getStageStats: function () {
        return this.pipelineStages.stats;
    },

    /**
     * 获取管道统计
     * @returns {Object} 统计信息
     */
    getPipelineStats: function () {
        return this.pipelinePipelines.stats;
    },

    /**
     * 删除阶段
     * @param {string} stageId - 阶段ID
     * @returns {boolean} 是否成功
     */
    deleteStage: function (stageId) {
        if (!this.pipelineStages.stages[stageId]) {
            return false;
        }

        delete this.pipelineStages.stages[stageId];
        this.savePipelineStages();

        return true;
    },

    /**
     * 删除管道
     * @param {string} pipelineId - 管道ID
     * @returns {boolean} 是否成功
     */
    deletePipeline: function (pipelineId) {
        if (!this.pipelinePipelines.pipelines[pipelineId]) {
            return false;
        }

        delete this.pipelinePipelines.pipelines[pipelineId];
        this.savePipelinePipelines();

        return true;
    },

    /**
     * 设置管道配置
     * @param {Object} config - 配置对象
     */
    setPipelineConfig: function (config) {
        this.pipelineConfig = { ...this.pipelineConfig, ...config };
        this.savePipelineConfig();
    },

    /**
     * 获取管道配置
     * @returns {Object} 配置对象
     */
    getPipelineConfig: function () {
        return this.pipelineConfig;
    },

    /**
     * 获取管道统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.pipelineConfig.enabled,
            maxStages: this.pipelineConfig.maxStages,
            maxPipelines: this.pipelineConfig.maxPipelines,
            autoExecute: this.pipelineConfig.autoExecute,
            executionInterval: this.pipelineConfig.executionInterval,
            totalStages: Object.keys(this.pipelineStages.stages).length,
            totalPipelines: Object.keys(this.pipelinePipelines.pipelines).length,
            activeStages: this.pipelineStages.stats.active,
            runningPipelines: this.pipelinePipelines.stats.running,
            executedPipelines: this.pipelinePipelines.stats.executed,
            failedPipelines: this.pipelinePipelines.stats.failed
        };
    }
};

// 优化：游戏流优化
const GameStreamOptimizer = {
    streamConfig: {},
    streamSources: {},
    streamProcessors: {},

    /**
     * 初始化游戏流
     */
    init: function () {
        this.loadStreamConfig();
        this.loadStreamSources();
        this.loadStreamProcessors();
        this.createDefaultStreams();
    },

    /**
     * 加载流配置
     */
    loadStreamConfig: function () {
        this.streamConfig = {
            enabled: true,
            maxSources: 100,
            maxProcessors: 100,
            bufferSize: 1000,
            autoProcess: true,
            processingInterval: 100,
            sourceTypes: [
                'input',
                'event',
                'data',
                'network',
                'file',
                'sensor',
                'custom'
            ],
            processorTypes: [
                'filter',
                'transform',
                'aggregate',
                'split',
                'merge',
                'buffer',
                'throttle',
                'custom'
            ]
        };

        const customConfig = localStorage.getItem('streamConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.streamConfig = { ...this.streamConfig, ...config };
            } catch (error) {
                console.error('加载流配置失败:', error);
            }
        }
    },

    /**
     * 保存流配置
     */
    saveStreamConfig: function () {
        localStorage.setItem('streamConfig', JSON.stringify(this.streamConfig));
    },

    /**
     * 加载流源
     */
    loadStreamSources: function () {
        const savedSources = localStorage.getItem('streamSources');
        if (savedSources) {
            try {
                this.streamSources = JSON.parse(savedSources);
            } catch (error) {
                console.error('加载流源失败:', error);
            }
        }

        if (!this.streamSources.sources) {
            this.streamSources = {
                sources: {},
                stats: {
                    total: 0,
                    byType: {},
                    active: 0,
                    itemsProduced: 0
                }
            };

            this.saveStreamSources();
        }
    },

    /**
     * 保存流源
     */
    saveStreamSources: function () {
        localStorage.setItem('streamSources', JSON.stringify(this.streamSources));
    },

    /**
     * 加载流处理器
     */
    loadStreamProcessors: function () {
        const savedProcessors = localStorage.getItem('streamProcessors');
        if (savedProcessors) {
            try {
                this.streamProcessors = JSON.parse(savedProcessors);
            } catch (error) {
                console.error('加载流处理器失败:', error);
            }
        }

        if (!this.streamProcessors.processors) {
            this.streamProcessors = {
                processors: {},
                stats: {
                    total: 0,
                    byType: {},
                    active: 0,
                    itemsProcessed: 0
                }
            };

            this.saveStreamProcessors();
        }
    },

    /**
     * 保存流处理器
     */
    saveStreamProcessors: function () {
        localStorage.setItem('streamProcessors', JSON.stringify(this.streamProcessors));
    },

    /**
     * 创建默认流
     */
    createDefaultStreams: function () {
        // 创建输入流源
        this.createSource('input', {
            name: '输入流',
            description: '用户输入流',
            producer: function () {
                return {
                    type: 'input',
                    data: {},
                    timestamp: Date.now()
                };
            },
            interval: 100,
            enabled: true
        });

        // 创建事件流源
        this.createSource('event', {
            name: '事件流',
            description: '游戏事件流',
            producer: function () {
                return {
                    type: 'event',
                    data: {},
                    timestamp: Date.now()
                };
            },
            interval: 200,
            enabled: true
        });

        // 创建数据流源
        this.createSource('data', {
            name: '数据流',
            description: '游戏数据流',
            producer: function () {
                return {
                    type: 'data',
                    data: {},
                    timestamp: Date.now()
                };
            },
            interval: 150,
            enabled: true
        });

        // 创建过滤器处理器
        this.createProcessor('filter', {
            name: '输入过滤器',
            description: '过滤无效输入',
            processor: function (item) {
                if (!item.data || Object.keys(item.data).length === 0) {
                    return null;
                }
                return item;
            },
            enabled: true
        });

        // 创建转换器处理器
        this.createProcessor('transform', {
            name: '数据转换器',
            description: '转换数据格式',
            processor: function (item) {
                item.transformed = true;
                return item;
            },
            enabled: true
        });

        // 创建聚合器处理器
        this.createProcessor('aggregate', {
            name: '数据聚合器',
            description: '聚合数据',
            processor: function (item) {
                item.aggregated = true;
                return item;
            },
            enabled: true
        });
    },

    /**
     * 创建流源
     * @param {string} sourceType - 流源类型
     * @param {Object} sourceData - 流源数据
     * @returns {Object} 流源对象
     */
    createSource: function (sourceType, sourceData) {
        if (!this.streamConfig.enabled) {
            return {
                success: false,
                error: '流系统已禁用'
            };
        }

        if (!this.streamConfig.sourceTypes.includes(sourceType)) {
            return {
                success: false,
                error: '不支持的流源类型'
            };
        }

        const sourceId = 'source_' + Date.now();

        const source = {
            id: sourceId,
            type: sourceType,
            name: sourceData.name,
            description: sourceData.description,
            producer: sourceData.producer,
            interval: sourceData.interval || 1000,
            enabled: sourceData.enabled !== false,
            active: false,
            buffer: [],
            bufferSize: this.streamConfig.bufferSize,
            createdAt: Date.now(),
            itemsProduced: 0
        };

        this.streamSources.sources[sourceId] = source;

        // 更新统计
        this.streamSources.stats.total++;

        if (!this.streamSources.stats.byType[sourceType]) {
            this.streamSources.stats.byType[sourceType] = 0;
        }

        this.streamSources.stats.byType[sourceType]++;

        if (source.enabled) {
            this.streamSources.stats.active++;
        }

        this.saveStreamSources();

        return {
            success: true,
            source: source
        };
    },

    /**
     * 创建流处理器
     * @param {string} processorType - 流处理器类型
     * @param {Object} processorData - 流处理器数据
     * @returns {Object} 流处理器对象
     */
    createProcessor: function (processorType, processorData) {
        if (!this.streamConfig.enabled) {
            return {
                success: false,
                error: '流系统已禁用'
            };
        }

        if (!this.streamConfig.processorTypes.includes(processorType)) {
            return {
                success: false,
                error: '不支持的流处理器类型'
            };
        }

        const processorId = 'processor_' + Date.now();

        const processor = {
            id: processorId,
            type: processorType,
            name: processorData.name,
            description: processorData.description,
            processor: processorData.processor,
            enabled: processorData.enabled !== false,
            createdAt: Date.now(),
            itemsProcessed: 0
        };

        this.streamProcessors.processors[processorId] = processor;

        // 更新统计
        this.streamProcessors.stats.total++;

        if (!this.streamProcessors.stats.byType[processorType]) {
            this.streamProcessors.stats.byType[processorType] = 0;
        }

        this.streamProcessors.stats.byType[processorType]++;

        if (processor.enabled) {
            this.streamProcessors.stats.active++;
        }

        this.saveStreamProcessors();

        return {
            success: true,
            processor: processor
        };
    },

    /**
     * 启动流源
     * @param {string} sourceId - 流源ID
     * @returns {Object} 启动结果
     */
    startSource: function (sourceId) {
        const source = this.streamSources.sources[sourceId];

        if (!source) {
            return {
                success: false,
                error: '流源不存在'
            };
        }

        if (!source.enabled) {
            return {
                success: false,
                error: '流源未启用'
            };
        }

        if (source.active) {
            return {
                success: false,
                error: '流源已启动'
            };
        }

        source.active = true;

        // 启动生产
        source.intervalId = setInterval(() => {
            const item = source.producer();

            if (item) {
                source.buffer.push(item);

                // 限制缓冲区大小
                if (source.buffer.length > source.bufferSize) {
                    source.buffer.shift();
                }

                source.itemsProduced++;
                this.streamSources.stats.itemsProduced++;

                // 处理流
                this.processStream(sourceId);
            }
        }, source.interval);

        this.saveStreamSources();

        return {
            success: true,
            source: source
        };
    },

    /**
     * 停止流源
     * @param {string} sourceId - 流源ID
     * @returns {Object} 停止结果
     */
    stopSource: function (sourceId) {
        const source = this.streamSources.sources[sourceId];

        if (!source) {
            return {
                success: false,
                error: '流源不存在'
            };
        }

        if (!source.active) {
            return {
                success: false,
                error: '流源未启动'
            };
        }

        source.active = false;

        if (source.intervalId) {
            clearInterval(source.intervalId);
            source.intervalId = null;
        }

        this.saveStreamSources();

        return {
            success: true,
            source: source
        };
    },

    /**
     * 处理流
     * @param {string} sourceId - 流源ID
     */
    processStream: function (sourceId) {
        const source = this.streamSources.sources[sourceId];

        if (!source || source.buffer.length === 0) {
            return;
        }

        const item = source.buffer.shift();

        // 应用所有启用的处理器
        for (const processorId in this.streamProcessors.processors) {
            const processor = this.streamProcessors.processors[processorId];

            if (!processor.enabled) {
                continue;
            }

            try {
                const result = processor.processor(item);

                if (result === null) {
                    // 项目被过滤
                    return;
                }

                processor.itemsProcessed++;
                this.streamProcessors.stats.itemsProcessed++;
            } catch (error) {
                console.error('流处理器错误:', error);
            }
        }

        // 处理后的项目可以发送到目的地
        this.sendToDestination(item);
    },

    /**
     * 发送到目的地
     * @param {Object} item - 数据项
     */
    sendToDestination: function (item) {
        // 模拟发送到目的地
        if (window.GameMessageBus) {
            GameMessageBus.publish('stream_item', item);
        }
    },

    /**
     * 获取流源
     * @param {string} sourceId - 流源ID
     * @returns {Object|null} 流源对象
     */
    getSource: function (sourceId) {
        return this.streamSources.sources[sourceId] || null;
    },

    /**
     * 获取所有流源
     * @param {string} sourceType - 流源类型
     * @param {boolean} active - 是否活跃
     * @returns {Array} 流源列表
     */
    getAllSources: function (sourceType, active) {
        let sources = Object.values(this.streamSources.sources);

        if (sourceType) {
            sources = sources.filter(s => s.type === sourceType);
        }

        if (active !== undefined) {
            sources = sources.filter(s => s.active === active);
        }

        return sources;
    },

    /**
     * 获取流处理器
     * @param {string} processorId - 流处理器ID
     * @returns {Object|null} 流处理器对象
     */
    getProcessor: function (processorId) {
        return this.streamProcessors.processors[processorId] || null;
    },

    /**
     * 获取所有流处理器
     * @param {string} processorType - 流处理器类型
     * @param {boolean} enabled - 是否启用
     * @returns {Array} 流处理器列表
     */
    getAllProcessors: function (processorType, enabled) {
        let processors = Object.values(this.streamProcessors.processors);

        if (processorType) {
            processors = processors.filter(p => p.type === processorType);
        }

        if (enabled !== undefined) {
            processors = processors.filter(p => p.enabled === enabled);
        }

        return processors;
    },

    /**
     * 获取流源统计
     * @returns {Object} 统计信息
     */
    getSourceStats: function () {
        return this.streamSources.stats;
    },

    /**
     * 获取流处理器统计
     * @returns {Object} 统计信息
     */
    getProcessorStats: function () {
        return this.streamProcessors.stats;
    },

    /**
     * 删除流源
     * @param {string} sourceId - 流源ID
     * @returns {boolean} 是否成功
     */
    deleteSource: function (sourceId) {
        if (!this.streamSources.sources[sourceId]) {
            return false;
        }

        // 停止流源
        this.stopSource(sourceId);

        delete this.streamSources.sources[sourceId];
        this.saveStreamSources();

        return true;
    },

    /**
     * 删除流处理器
     * @param {string} processorId - 流处理器ID
     * @returns {boolean} 是否成功
     */
    deleteProcessor: function (processorId) {
        if (!this.streamProcessors.processors[processorId]) {
            return false;
        }

        delete this.streamProcessors.processors[processorId];
        this.saveStreamProcessors();

        return true;
    },

    /**
     * 设置流配置
     * @param {Object} config - 配置对象
     */
    setStreamConfig: function (config) {
        this.streamConfig = { ...this.streamConfig, ...config };
        this.saveStreamConfig();
    },

    /**
     * 获取流配置
     * @returns {Object} 配置对象
     */
    getStreamConfig: function () {
        return this.streamConfig;
    },

    /**
     * 获取流统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.streamConfig.enabled,
            maxSources: this.streamConfig.maxSources,
            maxProcessors: this.streamConfig.maxProcessors,
            bufferSize: this.streamConfig.bufferSize,
            autoProcess: this.streamConfig.autoProcess,
            processingInterval: this.streamConfig.processingInterval,
            totalSources: Object.keys(this.streamSources.sources).length,
            totalProcessors: Object.keys(this.streamProcessors.processors).length,
            activeSources: Object.values(this.streamSources.sources).filter(s => s.active).length,
            activeProcessors: this.streamProcessors.stats.active,
            itemsProduced: this.streamSources.stats.itemsProduced,
            itemsProcessed: this.streamProcessors.stats.itemsProcessed
        };
    }
};

// 优化：游戏流式处理优化
const GameStreamProcessingOptimizer = {
    spConfig: {},
    spStreams: {},
    spProcessors: {},

    /**
     * 初始化游戏流式处理
     */
    init: function () {
        this.loadSPConfig();
        this.loadSPStreams();
        this.loadSPProcessors();
        this.createDefaultStreamProcessing();
    },

    /**
     * 加载流式处理配置
     */
    loadSPConfig: function () {
        this.spConfig = {
            enabled: true,
            maxStreams: 100,
            maxProcessors: 100,
            chunkSize: 100,
            bufferSize: 1000,
            autoProcess: true,
            processingInterval: 100,
            streamTypes: [
                'data',
                'event',
                'message',
                'file',
                'network',
                'custom'
            ],
            processorTypes: [
                'transform',
                'filter',
                'map',
                'reduce',
                'aggregate',
                'sort',
                'group',
                'custom'
            ]
        };

        const customConfig = localStorage.getItem('spConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.spConfig = { ...this.spConfig, ...config };
            } catch (error) {
                console.error('加载流式处理配置失败:', error);
            }
        }
    },

    /**
     * 保存流式处理配置
     */
    saveSPConfig: function () {
        localStorage.setItem('spConfig', JSON.stringify(this.spConfig));
    },

    /**
     * 加载流
     */
    loadSPStreams: function () {
        const savedStreams = localStorage.getItem('spStreams');
        if (savedStreams) {
            try {
                this.spStreams = JSON.parse(savedStreams);
            } catch (error) {
                console.error('加载流失败:', error);
            }
        }

        if (!this.spStreams.streams) {
            this.spStreams = {
                streams: {},
                stats: {
                    total: 0,
                    byType: {},
                    active: 0,
                    chunksProcessed: 0,
                    bytesProcessed: 0
                }
            };

            this.saveSPStreams();
        }
    },

    /**
     * 保存流
     */
    saveSPStreams: function () {
        localStorage.setItem('spStreams', JSON.stringify(this.spStreams));
    },

    /**
     * 加载处理器
     */
    loadSPProcessors: function () {
        const savedProcessors = localStorage.getItem('spProcessors');
        if (savedProcessors) {
            try {
                this.spProcessors = JSON.parse(savedProcessors);
            } catch (error) {
                console.error('加载处理器失败:', error);
            }
        }

        if (!this.spProcessors.processors) {
            this.spProcessors = {
                processors: {},
                stats: {
                    total: 0,
                    byType: {},
                    active: 0,
                    itemsProcessed: 0
                }
            };

            this.saveSPProcessors();
        }
    },

    /**
     * 保存处理器
     */
    saveSPProcessors: function () {
        localStorage.setItem('spProcessors', JSON.stringify(this.spProcessors));
    },

    /**
     * 创建默认流式处理
     */
    createDefaultStreamProcessing: function () {
        // 创建数据流
        this.createStream('data', {
            name: '数据流',
            description: '处理游戏数据',
            chunkSize: 100,
            enabled: true
        });

        // 创建事件流
        this.createStream('event', {
            name: '事件流',
            description: '处理游戏事件',
            chunkSize: 50,
            enabled: true
        });

        // 创建消息流
        this.createStream('message', {
            name: '消息流',
            description: '处理游戏消息',
            chunkSize: 200,
            enabled: true
        });

        // 创建转换处理器
        this.createProcessor('transform', {
            name: '数据转换',
            description: '转换数据格式',
            processor: function (chunk) {
                return chunk.map(item => {
                    item.transformed = true;
                    return item;
                });
            },
            enabled: true
        });

        // 创建过滤器处理器
        this.createProcessor('filter', {
            name: '数据过滤',
            description: '过滤无效数据',
            processor: function (chunk) {
                return chunk.filter(item => {
                    return item.data && Object.keys(item.data).length > 0;
                });
            },
            enabled: true
        });

        // 创建映射处理器
        this.createProcessor('map', {
            name: '数据映射',
            description: '映射数据',
            processor: function (chunk) {
                return chunk.map(item => {
                    return {
                        id: item.id,
                        value: item.data.value || 0,
                        timestamp: item.timestamp
                    };
                });
            },
            enabled: true
        });

        // 创建聚合处理器
        this.createProcessor('aggregate', {
            name: '数据聚合',
            description: '聚合数据',
            processor: function (chunk) {
                const sum = chunk.reduce((acc, item) => acc + (item.value || 0), 0);
                const avg = sum / chunk.length;

                return [{
                    type: 'aggregate',
                    sum: sum,
                    avg: avg,
                    count: chunk.length
                }];
            },
            enabled: true
        });
    },

    /**
     * 创建流
     * @param {string} streamType - 流类型
     * @param {Object} streamData - 流数据
     * @returns {Object} 流对象
     */
    createStream: function (streamType, streamData) {
        if (!this.spConfig.enabled) {
            return {
                success: false,
                error: '流式处理已禁用'
            };
        }

        if (!this.spConfig.streamTypes.includes(streamType)) {
            return {
                success: false,
                error: '不支持的流类型'
            };
        }

        const streamId = 'stream_' + Date.now();

        const stream = {
            id: streamId,
            type: streamType,
            name: streamData.name,
            description: streamData.description,
            chunkSize: streamData.chunkSize || this.spConfig.chunkSize,
            bufferSize: streamData.bufferSize || this.spConfig.bufferSize,
            enabled: streamData.enabled !== false,
            active: false,
            buffer: [],
            processors: [],
            createdAt: Date.now(),
            chunksProcessed: 0,
            bytesProcessed: 0
        };

        this.spStreams.streams[streamId] = stream;

        // 更新统计
        this.spStreams.stats.total++;

        if (!this.spStreams.stats.byType[streamType]) {
            this.spStreams.stats.byType[streamType] = 0;
        }

        this.spStreams.stats.byType[streamType]++;

        if (stream.enabled) {
            this.spStreams.stats.active++;
        }

        this.saveSPStreams();

        return {
            success: true,
            stream: stream
        };
    },

    /**
     * 创建处理器
     * @param {string} processorType - 处理器类型
     * @param {Object} processorData - 处理器数据
     * @returns {Object} 处理器对象
     */
    createProcessor: function (processorType, processorData) {
        if (!this.spConfig.enabled) {
            return {
                success: false,
                error: '流式处理已禁用'
            };
        }

        if (!this.spConfig.processorTypes.includes(processorType)) {
            return {
                success: false,
                error: '不支持的处理器类型'
            };
        }

        const processorId = 'processor_' + Date.now();

        const processor = {
            id: processorId,
            type: processorType,
            name: processorData.name,
            description: processorData.description,
            processor: processorData.processor,
            enabled: processorData.enabled !== false,
            createdAt: Date.now(),
            itemsProcessed: 0
        };

        this.spProcessors.processors[processorId] = processor;

        // 更新统计
        this.spProcessors.stats.total++;

        if (!this.spProcessors.stats.byType[processorType]) {
            this.spProcessors.stats.byType[processorType] = 0;
        }

        this.spProcessors.stats.byType[processorType]++;

        if (processor.enabled) {
            this.spProcessors.stats.active++;
        }

        this.saveSPProcessors();

        return {
            success: true,
            processor: processor
        };
    },

    /**
     * 添加数据到流
     * @param {string} streamId - 流ID
     * @param {Object} item - 数据项
     * @returns {Object} 添加结果
     */
    addToStream: function (streamId, item) {
        const stream = this.spStreams.streams[streamId];

        if (!stream) {
            return {
                success: false,
                error: '流不存在'
            };
        }

        if (!stream.enabled) {
            return {
                success: false,
                error: '流未启用'
            };
        }

        stream.buffer.push(item);

        // 限制缓冲区大小
        if (stream.buffer.length > stream.bufferSize) {
            stream.buffer.shift();
        }

        // 检查是否达到块大小
        if (stream.buffer.length >= stream.chunkSize) {
            this.processChunk(streamId);
        }

        this.saveSPStreams();

        return {
            success: true,
            stream: stream
        };
    },

    /**
     * 处理块
     * @param {string} streamId - 流ID
     * @returns {Object} 处理结果
     */
    processChunk: function (streamId) {
        const stream = this.spStreams.streams[streamId];

        if (!stream || stream.buffer.length === 0) {
            return {
                success: false,
                error: '没有数据可处理'
            };
        }

        // 提取块
        const chunk = stream.buffer.splice(0, stream.chunkSize);

        // 应用处理器
        let processedChunk = chunk;

        for (const processorId of stream.processors) {
            const processor = this.spProcessors.processors[processorId];

            if (!processor || !processor.enabled) {
                continue;
            }

            try {
                processedChunk = processor.processor(processedChunk);

                processor.itemsProcessed += processedChunk.length;
                this.spProcessors.stats.itemsProcessed += processedChunk.length;
            } catch (error) {
                console.error('处理器错误:', error);
            }
        }

        // 更新统计
        stream.chunksProcessed++;
        stream.bytesProcessed += JSON.stringify(chunk).length;
        this.spStreams.stats.chunksProcessed++;
        this.spStreams.stats.bytesProcessed += JSON.stringify(chunk).length;

        this.saveSPStreams();

        return {
            success: true,
            chunk: processedChunk
        };
    },

    /**
     * 添加处理器到流
     * @param {string} streamId - 流ID
     * @param {string} processorId - 处理器ID
     * @returns {Object} 添加结果
     */
    addProcessorToStream: function (streamId, processorId) {
        const stream = this.spStreams.streams[streamId];

        if (!stream) {
            return {
                success: false,
                error: '流不存在'
            };
        }

        const processor = this.spProcessors.processors[processorId];

        if (!processor) {
            return {
                success: false,
                error: '处理器不存在'
            };
        }

        if (!processor.enabled) {
            return {
                success: false,
                error: '处理器未启用'
            };
        }

        if (stream.processors.includes(processorId)) {
            return {
                success: false,
                error: '处理器已添加'
            };
        }

        stream.processors.push(processorId);

        this.saveSPStreams();

        return {
            success: true,
            stream: stream
        };
    },

    /**
     * 从流中移除处理器
     * @param {string} streamId - 流ID
     * @param {string} processorId - 处理器ID
     * @returns {Object} 移除结果
     */
    removeProcessorFromStream: function (streamId, processorId) {
        const stream = this.spStreams.streams[streamId];

        if (!stream) {
            return {
                success: false,
                error: '流不存在'
            };
        }

        const index = stream.processors.indexOf(processorId);

        if (index === -1) {
            return {
                success: false,
                error: '处理器不存在于流中'
            };
        }

        stream.processors.splice(index, 1);

        this.saveSPStreams();

        return {
            success: true,
            stream: stream
        };
    },

    /**
     * 获取流
     * @param {string} streamId - 流ID
     * @returns {Object|null} 流对象
     */
    getStream: function (streamId) {
        return this.spStreams.streams[streamId] || null;
    },

    /**
     * 获取所有流
     * @param {string} streamType - 流类型
     * @param {boolean} active - 是否活跃
     * @returns {Array} 流列表
     */
    getAllStreams: function (streamType, active) {
        let streams = Object.values(this.spStreams.streams);

        if (streamType) {
            streams = streams.filter(s => s.type === streamType);
        }

        if (active !== undefined) {
            streams = streams.filter(s => s.active === active);
        }

        return streams;
    },

    /**
     * 获取处理器
     * @param {string} processorId - 处理器ID
     * @returns {Object|null} 处理器对象
     */
    getProcessor: function (processorId) {
        return this.spProcessors.processors[processorId] || null;
    },

    /**
     * 获取所有处理器
     * @param {string} processorType - 处理器类型
     * @param {boolean} enabled - 是否启用
     * @returns {Array} 处理器列表
     */
    getAllProcessors: function (processorType, enabled) {
        let processors = Object.values(this.spProcessors.processors);

        if (processorType) {
            processors = processors.filter(p => p.type === processorType);
        }

        if (enabled !== undefined) {
            processors = processors.filter(p => p.enabled === enabled);
        }

        return processors;
    },

    /**
     * 获取流统计
     * @returns {Object} 统计信息
     */
    getStreamStats: function () {
        return this.spStreams.stats;
    },

    /**
     * 获取处理器统计
     * @returns {Object} 统计信息
     */
    getProcessorStats: function () {
        return this.spProcessors.stats;
    },

    /**
     * 删除流
     * @param {string} streamId - 流ID
     * @returns {boolean} 是否成功
     */
    deleteStream: function (streamId) {
        if (!this.spStreams.streams[streamId]) {
            return false;
        }

        delete this.spStreams.streams[streamId];
        this.saveSPStreams();

        return true;
    },

    /**
     * 删除处理器
     * @param {string} processorId - 处理器ID
     * @returns {boolean} 是否成功
     */
    deleteProcessor: function (processorId) {
        if (!this.spProcessors.processors[processorId]) {
            return false;
        }

        delete this.spProcessors.processors[processorId];
        this.saveSPProcessors();

        return true;
    },

    /**
     * 设置流式处理配置
     * @param {Object} config - 配置对象
     */
    setSPConfig: function (config) {
        this.spConfig = { ...this.spConfig, ...config };
        this.saveSPConfig();
    },

    /**
     * 获取流式处理配置
     * @returns {Object} 配置对象
     */
    getSPConfig: function () {
        return this.spConfig;
    },

    /**
     * 获取流式处理统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.spConfig.enabled,
            maxStreams: this.spConfig.maxStreams,
            maxProcessors: this.spConfig.maxProcessors,
            chunkSize: this.spConfig.chunkSize,
            bufferSize: this.spConfig.bufferSize,
            autoProcess: this.spConfig.autoProcess,
            processingInterval: this.spConfig.processingInterval,
            totalStreams: Object.keys(this.spStreams.streams).length,
            totalProcessors: Object.keys(this.spProcessors.processors).length,
            activeStreams: this.spStreams.stats.active,
            activeProcessors: this.spProcessors.stats.active,
            chunksProcessed: this.spStreams.stats.chunksProcessed,
            bytesProcessed: this.spStreams.stats.bytesProcessed,
            itemsProcessed: this.spProcessors.stats.itemsProcessed
        };
    }
};

// 优化：游戏批处理优化
const GameBatchProcessingOptimizer = {
    batchConfig: {},
    batchJobs: {},
    batchTasks: {},

    /**
     * 初始化游戏批处理
     */
    init: function () {
        this.loadBatchConfig();
        this.loadBatchJobs();
        this.loadBatchTasks();
        this.createDefaultBatchProcessing();
    },

    /**
     * 加载批处理配置
     */
    loadBatchConfig: function () {
        this.batchConfig = {
            enabled: true,
            maxJobs: 100,
            maxTasks: 10000,
            batchSize: 100,
            autoProcess: true,
            processingInterval: 1000,
            jobTypes: [
                'data_import',
                'data_export',
                'data_sync',
                'data_backup',
                'data_cleanup',
                'report_generation',
                'analytics',
                'custom'
            ],
            taskStatuses: [
                'pending',
                'processing',
                'completed',
                'failed'
            ]
        };

        const customConfig = localStorage.getItem('batchConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.batchConfig = { ...this.batchConfig, ...config };
            } catch (error) {
                console.error('加载批处理配置失败:', error);
            }
        }
    },

    /**
     * 保存批处理配置
     */
    saveBatchConfig: function () {
        localStorage.setItem('batchConfig', JSON.stringify(this.batchConfig));
    },

    /**
     * 加载批处理作业
     */
    loadBatchJobs: function () {
        const savedJobs = localStorage.getItem('batchJobs');
        if (savedJobs) {
            try {
                this.batchJobs = JSON.parse(savedJobs);
            } catch (error) {
                console.error('加载批处理作业失败:', error);
            }
        }

        if (!this.batchJobs.jobs) {
            this.batchJobs = {
                jobs: {},
                stats: {
                    total: 0,
                    byType: {},
                    byStatus: {},
                    completed: 0,
                    failed: 0,
                    running: 0
                }
            };

            this.saveBatchJobs();
        }
    },

    /**
     * 保存批处理作业
     */
    saveBatchJobs: function () {
        localStorage.setItem('batchJobs', JSON.stringify(this.batchJobs));
    },

    /**
     * 加载批处理任务
     */
    loadBatchTasks: function () {
        const savedTasks = localStorage.getItem('batchTasks');
        if (savedTasks) {
            try {
                this.batchTasks = JSON.parse(savedTasks);
            } catch (error) {
                console.error('加载批处理任务失败:', error);
            }
        }

        if (!this.batchTasks.tasks) {
            this.batchTasks = {
                tasks: {},
                stats: {
                    total: 0,
                    byStatus: {},
                    completed: 0,
                    failed: 0,
                    processing: 0
                }
            };

            this.saveBatchTasks();
        }
    },

    /**
     * 保存批处理任务
     */
    saveBatchTasks: function () {
        localStorage.setItem('batchTasks', JSON.stringify(this.batchTasks));
    },

    /**
     * 创建默认批处理
     */
    createDefaultBatchProcessing: function () {
        // 创建数据导入作业
        this.createJob('data_import', {
            name: '数据导入',
            description: '批量导入游戏数据',
            batchSize: 100,
            enabled: true
        });

        // 创建数据导出作业
        this.createJob('data_export', {
            name: '数据导出',
            description: '批量导出游戏数据',
            batchSize: 50,
            enabled: true
        });

        // 创建数据同步作业
        this.createJob('data_sync', {
            name: '数据同步',
            description: '同步游戏数据',
            batchSize: 200,
            enabled: true
        });

        // 创建数据备份作业
        this.createJob('data_backup', {
            name: '数据备份',
            description: '备份游戏数据',
            batchSize: 1000,
            enabled: true
        });

        // 创建数据清理作业
        this.createJob('data_cleanup', {
            name: '数据清理',
            description: '清理游戏数据',
            batchSize: 500,
            enabled: true
        });
    },

    /**
     * 创建批处理作业
     * @param {string} jobType - 作业类型
     * @param {Object} jobData - 作业数据
     * @returns {Object} 作业对象
     */
    createJob: function (jobType, jobData) {
        if (!this.batchConfig.enabled) {
            return {
                success: false,
                error: '批处理已禁用'
            };
        }

        if (!this.batchConfig.jobTypes.includes(jobType)) {
            return {
                success: false,
                error: '不支持的作业类型'
            };
        }

        const jobId = 'job_' + Date.now();

        const job = {
            id: jobId,
            type: jobType,
            name: jobData.name,
            description: jobData.description,
            batchSize: jobData.batchSize || this.batchConfig.batchSize,
            enabled: jobData.enabled !== false,
            status: 'idle',
            createdAt: Date.now(),
            startedAt: null,
            completedAt: null,
            progress: 0,
            totalTasks: 0,
            completedTasks: 0,
            failedTasks: 0
        };

        this.batchJobs.jobs[jobId] = job;

        // 更新统计
        this.batchJobs.stats.total++;

        if (!this.batchJobs.stats.byType[jobType]) {
            this.batchJobs.stats.byType[jobType] = 0;
        }

        this.batchJobs.stats.byType[jobType]++;

        if (!this.batchJobs.stats.byStatus[job.status]) {
            this.batchJobs.stats.byStatus[job.status] = 0;
        }

        this.batchJobs.stats.byStatus[job.status]++;

        this.saveBatchJobs();

        return {
            success: true,
            job: job
        };
    },

    /**
     * 创建批处理任务
     * @param {string} jobId - 作业ID
     * @param {Object} taskData - 任务数据
     * @returns {Object} 任务对象
     */
    createTask: function (jobId, taskData) {
        const job = this.batchJobs.jobs[jobId];

        if (!job) {
            return {
                success: false,
                error: '作业不存在'
            };
        }

        const taskId = 'task_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        const task = {
            id: taskId,
            jobId: jobId,
            name: taskData.name || 'Unnamed Task',
            description: taskData.description || '',
            data: taskData.data || {},
            status: 'pending',
            createdAt: Date.now(),
            startedAt: null,
            completedAt: null,
            result: null,
            error: null
        };

        this.batchTasks.tasks[taskId] = task;

        // 更新统计
        this.batchTasks.stats.total++;

        if (!this.batchTasks.stats.byStatus[task.status]) {
            this.batchTasks.stats.byStatus[task.status] = 0;
        }

        this.batchTasks.stats.byStatus[task.status]++;

        // 更新作业统计
        job.totalTasks++;

        this.saveBatchTasks();
        this.saveBatchJobs();

        return {
            success: true,
            task: task
        };
    },

    /**
     * 执行批处理作业
     * @param {string} jobId - 作业ID
     * @returns {Object} 执行结果
     */
    executeJob: function (jobId) {
        const job = this.batchJobs.jobs[jobId];

        if (!job) {
            return {
                success: false,
                error: '作业不存在'
            };
        }

        if (!job.enabled) {
            return {
                success: false,
                error: '作业未启用'
            };
        }

        if (job.status === 'running') {
            return {
                success: false,
                error: '作业正在运行'
            };
        }

        job.status = 'running';
        job.startedAt = Date.now();

        this.saveBatchJobs();

        // 获取待处理任务
        const pendingTasks = Object.values(this.batchTasks.tasks)
            .filter(task => task.jobId === jobId && task.status === 'pending')
            .slice(0, job.batchSize);

        // 执行任务
        const results = [];

        for (const task of pendingTasks) {
            const result = this.executeTask(task.id);
            results.push(result);
        }

        // 更新作业进度
        job.completedTasks = Object.values(this.batchTasks.tasks)
            .filter(task => task.jobId === jobId && task.status === 'completed').length;

        job.failedTasks = Object.values(this.batchTasks.tasks)
            .filter(task => task.jobId === jobId && task.status === 'failed').length;

        job.progress = job.completedTasks / job.totalTasks;

        // 检查是否完成
        if (job.completedTasks + job.failedTasks >= job.totalTasks) {
            job.status = 'completed';
            job.completedAt = Date.now();

            // 更新统计
            this.batchJobs.stats.completed++;
            this.batchJobs.stats.running--;
            this.batchJobs.stats.byStatus['completed']++;
            this.batchJobs.stats.byStatus['running']--;
        }

        this.saveBatchJobs();

        return {
            success: true,
            job: job,
            results: results
        };
    },

    /**
     * 执行批处理任务
     * @param {string} taskId - 任务ID
     * @returns {Object} 执行结果
     */
    executeTask: function (taskId) {
        const task = this.batchTasks.tasks[taskId];

        if (!task) {
            return {
                success: false,
                error: '任务不存在'
            };
        }

        if (task.status !== 'pending') {
            return {
                success: false,
                error: '任务状态不正确'
            };
        }

        task.status = 'processing';
        task.startedAt = Date.now();

        this.saveBatchTasks();

        // 执行任务
        try {
            const result = this.processTask(task);

            task.status = 'completed';
            task.completedAt = Date.now();
            task.result = result;

            // 更新统计
            this.batchTasks.stats.completed++;
            this.batchTasks.stats.processing--;
            this.batchTasks.stats.byStatus['completed']++;
            this.batchTasks.stats.byStatus['processing']--;

            this.saveBatchTasks();

            return {
                success: true,
                task: task,
                result: result
            };
        } catch (error) {
            task.status = 'failed';
            task.completedAt = Date.now();
            task.error = error.message;

            // 更新统计
            this.batchTasks.stats.failed++;
            this.batchTasks.stats.processing--;
            this.batchTasks.stats.byStatus['failed']++;
            this.batchTasks.stats.byStatus['processing']--;

            this.saveBatchTasks();

            return {
                success: false,
                task: task,
                error: error.message
            };
        }
    },

    /**
     * 处理任务
     * @param {Object} task - 任务对象
     * @returns {Object} 处理结果
     */
    processTask: function (task) {
        const job = this.batchJobs.jobs[task.jobId];

        switch (job.type) {
            case 'data_import':
                return this.processImportTask(task);
            case 'data_export':
                return this.processExportTask(task);
            case 'data_sync':
                return this.processSyncTask(task);
            case 'data_backup':
                return this.processBackupTask(task);
            case 'data_cleanup':
                return this.processCleanupTask(task);
            default:
                return {
                    success: true,
                    data: task.data
                };
        }
    },

    /**
     * 处理导入任务
     * @param {Object} task - 任务对象
     * @returns {Object} 处理结果
     */
    processImportTask: function (task) {
        // 模拟导入处理
        return {
            success: true,
            message: '导入完成',
            itemsProcessed: Math.floor(Math.random() * 100) + 50
        };
    },

    /**
     * 处理导出任务
     * @param {Object} task - 任务对象
     * @returns {Object} 处理结果
     */
    processExportTask: function (task) {
        // 模拟导出处理
        return {
            success: true,
            message: '导出完成',
            itemsProcessed: Math.floor(Math.random() * 50) + 20
        };
    },

    /**
     * 处理同步任务
     * @param {Object} task - 任务对象
     * @returns {Object} 处理结果
     */
    processSyncTask: function (task) {
        // 模拟同步处理
        return {
            success: true,
            message: '同步完成',
            itemsProcessed: Math.floor(Math.random() * 200) + 100
        };
    },

    /**
     * 处理备份任务
     * @param {Object} task - 任务对象
     * @returns {Object} 处理结果
     */
    processBackupTask: function (task) {
        // 模拟备份处理
        return {
            success: true,
            message: '备份完成',
            itemsProcessed: Math.floor(Math.random() * 1000) + 500
        };
    },

    /**
     * 处理清理任务
     * @param {Object} task - 任务对象
     * @returns {Object} 处理结果
     */
    processCleanupTask: function (task) {
        // 模拟清理处理
        return {
            success: true,
            message: '清理完成',
            itemsProcessed: Math.floor(Math.random() * 500) + 200
        };
    },

    /**
     * 获取作业
     * @param {string} jobId - 作业ID
     * @returns {Object|null} 作业对象
     */
    getJob: function (jobId) {
        return this.batchJobs.jobs[jobId] || null;
    },

    /**
     * 获取所有作业
     * @param {string} jobType - 作业类型
     * @param {string} status - 状态
     * @returns {Array} 作业列表
     */
    getAllJobs: function (jobType, status) {
        let jobs = Object.values(this.batchJobs.jobs);

        if (jobType) {
            jobs = jobs.filter(j => j.type === jobType);
        }

        if (status) {
            jobs = jobs.filter(j => j.status === status);
        }

        return jobs;
    },

    /**
     * 获取任务
     * @param {string} taskId - 任务ID
     * @returns {Object|null} 任务对象
     */
    getTask: function (taskId) {
        return this.batchTasks.tasks[taskId] || null;
    },

    /**
     * 获取所有任务
     * @param {string} jobId - 作业ID
     * @param {string} status - 状态
     * @returns {Array} 任务列表
     */
    getAllTasks: function (jobId, status) {
        let tasks = Object.values(this.batchTasks.tasks);

        if (jobId) {
            tasks = tasks.filter(t => t.jobId === jobId);
        }

        if (status) {
            tasks = tasks.filter(t => t.status === status);
        }

        return tasks;
    },

    /**
     * 获取作业统计
     * @returns {Object} 统计信息
     */
    getJobStats: function () {
        return this.batchJobs.stats;
    },

    /**
     * 获取任务统计
     * @returns {Object} 统计信息
     */
    getTaskStats: function () {
        return this.batchTasks.stats;
    },

    /**
     * 删除作业
     * @param {string} jobId - 作业ID
     * @returns {boolean} 是否成功
     */
    deleteJob: function (jobId) {
        if (!this.batchJobs.jobs[jobId]) {
            return false;
        }

        delete this.batchJobs.jobs[jobId];
        this.saveBatchJobs();

        return true;
    },

    /**
     * 删除任务
     * @param {string} taskId - 任务ID
     * @returns {boolean} 是否成功
     */
    deleteTask: function (taskId) {
        if (!this.batchTasks.tasks[taskId]) {
            return false;
        }

        delete this.batchTasks.tasks[taskId];
        this.saveBatchTasks();

        return true;
    },

    /**
     * 设置批处理配置
     * @param {Object} config - 配置对象
     */
    setBatchConfig: function (config) {
        this.batchConfig = { ...this.batchConfig, ...config };
        this.saveBatchConfig();
    },

    /**
     * 获取批处理配置
     * @returns {Object} 配置对象
     */
    getBatchConfig: function () {
        return this.batchConfig;
    },

    /**
     * 获取批处理统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.batchConfig.enabled,
            maxJobs: this.batchConfig.maxJobs,
            maxTasks: this.batchConfig.maxTasks,
            batchSize: this.batchConfig.batchSize,
            autoProcess: this.batchConfig.autoProcess,
            processingInterval: this.batchConfig.processingInterval,
            totalJobs: Object.keys(this.batchJobs.jobs).length,
            totalTasks: Object.keys(this.batchTasks.tasks).length,
            runningJobs: this.batchJobs.stats.running,
            completedJobs: this.batchJobs.stats.completed,
            failedJobs: this.batchJobs.stats.failed,
            processingTasks: this.batchTasks.stats.processing,
            completedTasks: this.batchTasks.stats.completed,
            failedTasks: this.batchTasks.stats.failed
        };
    }
};

// 优化：游戏并发处理优化
const GameConcurrencyOptimizer = {
    concurrencyConfig: {},
    concurrencyTasks: {},
    concurrencyWorkers: {},

    /**
     * 初始化游戏并发处理
     */
    init: function () {
        this.loadConcurrencyConfig();
        this.loadConcurrencyTasks();
        this.loadConcurrencyWorkers();
        this.startWorkers();
    },

    /**
     * 加载并发配置
     */
    loadConcurrencyConfig: function () {
        this.concurrencyConfig = {
            enabled: true,
            maxWorkers: 10,
            maxTasks: 1000,
            taskTimeout: 30000,
            autoBalance: true,
            balanceInterval: 1000,
            workerTypes: [
                'rendering',
                'physics',
                'ai',
                'network',
                'io',
                'computation',
                'custom'
            ]
        };

        const customConfig = localStorage.getItem('concurrencyConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.concurrencyConfig = { ...this.concurrencyConfig, ...config };
            } catch (error) {
                console.error('加载并发配置失败:', error);
            }
        }
    },

    /**
     * 保存并发配置
     */
    saveConcurrencyConfig: function () {
        localStorage.setItem('concurrencyConfig', JSON.stringify(this.concurrencyConfig));
    },

    /**
     * 加载并发任务
     */
    loadConcurrencyTasks: function () {
        const savedTasks = localStorage.getItem('concurrencyTasks');
        if (savedTasks) {
            try {
                this.concurrencyTasks = JSON.parse(savedTasks);
            } catch (error) {
                console.error('加载并发任务失败:', error);
            }
        }

        if (!this.concurrencyTasks.tasks) {
            this.concurrencyTasks = {
                tasks: {},
                stats: {
                    total: 0,
                    byType: {},
                    byStatus: {},
                    completed: 0,
                    failed: 0,
                    running: 0
                }
            };

            this.saveConcurrencyTasks();
        }
    },

    /**
     * 保存并发任务
     */
    saveConcurrencyTasks: function () {
        localStorage.setItem('concurrencyTasks', JSON.stringify(this.concurrencyTasks));
    },

    /**
     * 加载并发工作器
     */
    loadConcurrencyWorkers: function () {
        const savedWorkers = localStorage.getItem('concurrencyWorkers');
        if (savedWorkers) {
            try {
                this.concurrencyWorkers = JSON.parse(savedWorkers);
            } catch (error) {
                console.error('加载并发工作器失败:', error);
            }
        }

        if (!this.concurrencyWorkers.workers) {
            this.concurrencyWorkers = {
                workers: {},
                stats: {
                    total: 0,
                    byType: {},
                    active: 0,
                    idle: 0
                }
            };

            this.saveConcurrencyWorkers();
        }
    },

    /**
     * 保存并发工作器
     */
    saveConcurrencyWorkers: function () {
        localStorage.setItem('concurrencyWorkers', JSON.stringify(this.concurrencyWorkers));
    },

    /**
     * 启动工作器
     */
    startWorkers: function () {
        setInterval(() => {
            if (this.concurrencyConfig.enabled && this.concurrencyConfig.autoBalance) {
                this.balanceTasks();
            }
        }, this.concurrencyConfig.balanceInterval);
    },

    /**
     * 创建并发任务
     * @param {string} taskType - 任务类型
     * @param {Object} taskData - 任务数据
     * @returns {Object} 任务对象
     */
    createTask: function (taskType, taskData) {
        if (!this.concurrencyConfig.enabled) {
            return {
                success: false,
                error: '并发处理已禁用'
            };
        }

        const taskId = 'task_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        const task = {
            id: taskId,
            type: taskType,
            name: taskData.name || 'Unnamed Task',
            description: taskData.description || '',
            action: taskData.action,
            parameters: taskData.parameters || {},
            priority: taskData.priority || 'medium',
            status: 'pending',
            createdAt: Date.now(),
            startedAt: null,
            completedAt: null,
            result: null,
            error: null,
            workerId: null
        };

        this.concurrencyTasks.tasks[taskId] = task;

        // 更新统计
        this.concurrencyTasks.stats.total++;

        if (!this.concurrencyTasks.stats.byType[taskType]) {
            this.concurrencyTasks.stats.byType[taskType] = 0;
        }

        this.concurrencyTasks.stats.byType[taskType]++;

        if (!this.concurrencyTasks.stats.byStatus[task.status]) {
            this.concurrencyTasks.stats.byStatus[task.status] = 0;
        }

        this.concurrencyTasks.stats.byStatus[task.status]++;

        this.saveConcurrencyTasks();

        return {
            success: true,
            task: task
        };
    },

    /**
     * 创建工作器
     * @param {string} workerType - 工作器类型
     * @param {Object} workerData - 工作器数据
     * @returns {Object} 工作器对象
     */
    createWorker: function (workerType, workerData) {
        if (!this.concurrencyConfig.enabled) {
            return {
                success: false,
                error: '并发处理已禁用'
            };
        }

        if (Object.keys(this.concurrencyWorkers.workers).length >= this.concurrencyConfig.maxWorkers) {
            return {
                success: false,
                error: '工作器数量已达上限'
            };
        }

        const workerId = 'worker_' + Date.now();

        const worker = {
            id: workerId,
            type: workerType,
            name: workerData.name || 'Unnamed Worker',
            status: 'idle',
            currentTask: null,
            tasksCompleted: 0,
            tasksFailed: 0,
            createdAt: Date.now()
        };

        this.concurrencyWorkers.workers[workerId] = worker;

        // 更新统计
        this.concurrencyWorkers.stats.total++;

        if (!this.concurrencyWorkers.stats.byType[workerType]) {
            this.concurrencyWorkers.stats.byType[workerType] = 0;
        }

        this.concurrencyWorkers.stats.byType[workerType]++;
        this.concurrencyWorkers.stats.idle++;

        this.saveConcurrencyWorkers();

        return {
            success: true,
            worker: worker
        };
    },

    /**
     * 平衡任务
     */
    balanceTasks: function () {
        const pendingTasks = Object.values(this.concurrencyTasks.tasks)
            .filter(task => task.status === 'pending')
            .sort((a, b) => {
                const priorityOrder = {
                    'high': 0,
                    'medium': 1,
                    'low': 2
                };
                return priorityOrder[a.priority] - priorityOrder[b.priority];
            });

        const idleWorkers = Object.values(this.concurrencyWorkers.workers)
            .filter(worker => worker.status === 'idle');

        const tasksToAssign = Math.min(pendingTasks.length, idleWorkers.length);

        for (let i = 0; i < tasksToAssign; i++) {
            this.assignTask(pendingTasks[i].id, idleWorkers[i].id);
        }
    },

    /**
     * 分配任务
     * @param {string} taskId - 任务ID
     * @param {string} workerId - 工作器ID
     * @returns {Object} 分配结果
     */
    assignTask: function (taskId, workerId) {
        const task = this.concurrencyTasks.tasks[taskId];
        const worker = this.concurrencyWorkers.workers[workerId];

        if (!task || !worker) {
            return {
                success: false,
                error: '任务或工作器不存在'
            };
        }

        if (task.status !== 'pending' || worker.status !== 'idle') {
            return {
                success: false,
                error: '状态不正确'
            };
        }

        // 分配任务
        task.status = 'running';
        task.startedAt = Date.now();
        task.workerId = workerId;

        worker.status = 'busy';
        worker.currentTask = taskId;

        // 更新统计
        this.concurrencyTasks.stats.running++;
        this.concurrencyTasks.stats.byStatus['running']++;
        this.concurrencyTasks.stats.byStatus['pending']--;

        this.concurrencyWorkers.stats.active++;
        this.concurrencyWorkers.stats.idle--;

        this.saveConcurrencyTasks();
        this.saveConcurrencyWorkers();

        // 执行任务
        this.executeTask(taskId);

        return {
            success: true,
            task: task,
            worker: worker
        };
    },

    /**
     * 执行任务
     * @param {string} taskId - 任务ID
     */
    executeTask: function (taskId) {
        const task = this.concurrencyTasks.tasks[taskId];
        const worker = this.concurrencyWorkers.workers[task.workerId];

        try {
            // 模拟任务执行
            setTimeout(() => {
                const result = {
                    success: true,
                    data: {},
                    message: '任务完成'
                };

                task.status = 'completed';
                task.completedAt = Date.now();
                task.result = result;
                task.workerId = null;

                worker.status = 'idle';
                worker.currentTask = null;
                worker.tasksCompleted++;

                // 更新统计
                this.concurrencyTasks.stats.completed++;
                this.concurrencyTasks.stats.running--;
                this.concurrencyTasks.stats.byStatus['completed']++;
                this.concurrencyTasks.stats.byStatus['running']--;

                this.concurrencyWorkers.stats.active--;
                this.concurrencyWorkers.stats.idle++;

                this.saveConcurrencyTasks();
                this.saveConcurrencyWorkers();
            }, Math.random() * 1000 + 500);
        } catch (error) {
            task.status = 'failed';
            task.completedAt = Date.now();
            task.error = error.message;
            task.workerId = null;

            worker.status = 'idle';
            worker.currentTask = null;
            worker.tasksFailed++;

            // 更新统计
            this.concurrencyTasks.stats.failed++;
            this.concurrencyTasks.stats.running--;
            this.concurrencyTasks.stats.byStatus['failed']++;
            this.concurrencyTasks.stats.byStatus['running']--;

            this.concurrencyWorkers.stats.active--;
            this.concurrencyWorkers.stats.idle++;

            this.saveConcurrencyTasks();
            this.saveConcurrencyWorkers();
        }
    },

    /**
     * 获取任务
     * @param {string} taskId - 任务ID
     * @returns {Object|null} 任务对象
     */
    getTask: function (taskId) {
        return this.concurrencyTasks.tasks[taskId] || null;
    },

    /**
     * 获取所有任务
     * @param {string} taskType - 任务类型
     * @param {string} status - 状态
     * @returns {Array} 任务列表
     */
    getAllTasks: function (taskType, status) {
        let tasks = Object.values(this.concurrencyTasks.tasks);

        if (taskType) {
            tasks = tasks.filter(t => t.type === taskType);
        }

        if (status) {
            tasks = tasks.filter(t => t.status === status);
        }

        return tasks;
    },

    /**
     * 获取工作器
     * @param {string} workerId - 工作器ID
     * @returns {Object|null} 工作器对象
     */
    getWorker: function (workerId) {
        return this.concurrencyWorkers.workers[workerId] || null;
    },

    /**
     * 获取所有工作器
     * @param {string} workerType - 工作器类型
     * @param {string} status - 状态
     * @returns {Array} 工作器列表
     */
    getAllWorkers: function (workerType, status) {
        let workers = Object.values(this.concurrencyWorkers.workers);

        if (workerType) {
            workers = workers.filter(w => w.type === workerType);
        }

        if (status) {
            workers = workers.filter(w => w.status === status);
        }

        return workers;
    },

    /**
     * 获取任务统计
     * @returns {Object} 统计信息
     */
    getTaskStats: function () {
        return this.concurrencyTasks.stats;
    },

    /**
     * 获取工作器统计
     * @returns {Object} 统计信息
     */
    getWorkerStats: function () {
        return this.concurrencyWorkers.stats;
    },

    /**
     * 删除任务
     * @param {string} taskId - 任务ID
     * @returns {boolean} 是否成功
     */
    deleteTask: function (taskId) {
        if (!this.concurrencyTasks.tasks[taskId]) {
            return false;
        }

        delete this.concurrencyTasks.tasks[taskId];
        this.saveConcurrencyTasks();

        return true;
    },

    /**
     * 删除工作器
     * @param {string} workerId - 工作器ID
     * @returns {boolean} 是否成功
     */
    deleteWorker: function (workerId) {
        if (!this.concurrencyWorkers.workers[workerId]) {
            return false;
        }

        delete this.concurrencyWorkers.workers[workerId];
        this.saveConcurrencyWorkers();

        return true;
    },

    /**
     * 设置并发配置
     * @param {Object} config - 配置对象
     */
    setConcurrencyConfig: function (config) {
        this.concurrencyConfig = { ...this.concurrencyConfig, ...config };
        this.saveConcurrencyConfig();
    },

    /**
     * 获取并发配置
     * @returns {Object} 配置对象
     */
    getConcurrencyConfig: function () {
        return this.concurrencyConfig;
    },

    /**
     * 获取并发统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.concurrencyConfig.enabled,
            maxWorkers: this.concurrencyConfig.maxWorkers,
            maxTasks: this.concurrencyConfig.maxTasks,
            taskTimeout: this.concurrencyConfig.taskTimeout,
            autoBalance: this.concurrencyConfig.autoBalance,
            balanceInterval: this.concurrencyConfig.balanceInterval,
            totalTasks: Object.keys(this.concurrencyTasks.tasks).length,
            totalWorkers: Object.keys(this.concurrencyWorkers.workers).length,
            pendingTasks: Object.values(this.concurrencyTasks.tasks).filter(t => t.status === 'pending').length,
            runningTasks: this.concurrencyTasks.stats.running,
            completedTasks: this.concurrencyTasks.stats.completed,
            failedTasks: this.concurrencyTasks.stats.failed,
            activeWorkers: this.concurrencyWorkers.stats.active,
            idleWorkers: this.concurrencyWorkers.stats.idle
        };
    }
};

// 优化：游戏异步处理优化
const GameAsyncOptimizer = {
    asyncConfig: {},
    asyncOperations: {},
    asyncPromises: {},

    /**
     * 初始化游戏异步处理
     */
    init: function () {
        this.loadAsyncConfig();
        this.loadAsyncOperations();
        this.loadAsyncPromises();
    },

    /**
     * 加载异步配置
     */
    loadAsyncConfig: function () {
        this.asyncConfig = {
            enabled: true,
            maxOperations: 1000,
            maxPromises: 10000,
            defaultTimeout: 30000,
            autoCleanup: true,
            cleanupInterval: 60000,
            operationTypes: [
                'fetch',
                'compute',
                'render',
                'io',
                'network',
                'animation',
                'custom'
            ]
        };

        const customConfig = localStorage.getItem('asyncConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.asyncConfig = { ...this.asyncConfig, ...config };
            } catch (error) {
                console.error('加载异步配置失败:', error);
            }
        }
    },

    /**
     * 保存异步配置
     */
    saveAsyncConfig: function () {
        localStorage.setItem('asyncConfig', JSON.stringify(this.asyncConfig));
    },

    /**
     * 加载异步操作
     */
    loadAsyncOperations: function () {
        const savedOperations = localStorage.getItem('asyncOperations');
        if (savedOperations) {
            try {
                this.asyncOperations = JSON.parse(savedOperations);
            } catch (error) {
                console.error('加载异步操作失败:', error);
            }
        }

        if (!this.asyncOperations.operations) {
            this.asyncOperations = {
                operations: {},
                stats: {
                    total: 0,
                    byType: {},
                    byStatus: {},
                    completed: 0,
                    failed: 0,
                    pending: 0
                }
            };

            this.saveAsyncOperations();
        }
    },

    /**
     * 保存异步操作
     */
    saveAsyncOperations: function () {
        localStorage.setItem('asyncOperations', JSON.stringify(this.asyncOperations));
    },

    /**
     * 加载异步Promise
     */
    loadAsyncPromises: function () {
        const savedPromises = localStorage.getItem('asyncPromises');
        if (savedPromises) {
            try {
                this.asyncPromises = JSON.parse(savedPromises);
            } catch (error) {
                console.error('加载异步Promise失败:', error);
            }
        }

        if (!this.asyncPromises.promises) {
            this.asyncPromises = {
                promises: {},
                stats: {
                    total: 0,
                    resolved: 0,
                    rejected: 0,
                    pending: 0
                }
            };

            this.saveAsyncPromises();
        }
    },

    /**
     * 保存异步Promise
     */
    saveAsyncPromises: function () {
        localStorage.setItem('asyncPromises', JSON.stringify(this.asyncPromises));
    },

    /**
     * 创建异步操作
     * @param {string} operationType - 操作类型
     * @param {Object} operationData - 操作数据
     * @returns {Object} 操作对象
     */
    createOperation: function (operationType, operationData) {
        if (!this.asyncConfig.enabled) {
            return {
                success: false,
                error: '异步处理已禁用'
            };
        }

        const operationId = 'op_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        const operation = {
            id: operationId,
            type: operationType,
            name: operationData.name || 'Unnamed Operation',
            description: operationData.description || '',
            action: operationData.action,
            parameters: operationData.parameters || {},
            status: 'pending',
            createdAt: Date.now(),
            startedAt: null,
            completedAt: null,
            result: null,
            error: null,
            timeout: operationData.timeout || this.asyncConfig.defaultTimeout
        };

        this.asyncOperations.operations[operationId] = operation;

        // 更新统计
        this.asyncOperations.stats.total++;

        if (!this.asyncOperations.stats.byType[operationType]) {
            this.asyncOperations.stats.byType[operationType] = 0;
        }

        this.asyncOperations.stats.byType[operationType]++;

        if (!this.asyncOperations.stats.byStatus[operation.status]) {
            this.asyncOperations.stats.byStatus[operation.status] = 0;
        }

        this.asyncOperations.stats.byStatus[operation.status]++;
        this.asyncOperations.stats.pending++;

        // 清理旧操作
        this.cleanupOldOperations();

        this.saveAsyncOperations();

        return {
            success: true,
            operation: operation
        };
    },

    /**
     * 执行异步操作
     * @param {string} operationId - 操作ID
     * @returns {Promise} Promise对象
     */
    executeOperation: function (operationId) {
        const operation = this.asyncOperations.operations[operationId];

        if (!operation) {
            return Promise.reject({
                success: false,
                error: '操作不存在'
            });
        }

        if (operation.status !== 'pending') {
            return Promise.reject({
                success: false,
                error: '操作状态不正确'
            });
        }

        operation.status = 'running';
        operation.startedAt = Date.now();

        this.saveAsyncOperations();

        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                operation.status = 'failed';
                operation.completedAt = Date.now();
                operation.error = '操作超时';

                this.asyncOperations.stats.failed++;
                this.asyncOperations.stats.pending--;
                this.asyncOperations.stats.byStatus['failed']++;
                this.asyncOperations.stats.byStatus['running']--;

                this.saveAsyncOperations();

                reject({
                    success: false,
                    operation: operation,
                    error: '操作超时'
                });
            }, operation.timeout);

            try {
                const result = operation.action(operation.parameters);

                if (result && typeof result.then === 'function') {
                    // 如果返回Promise
                    result.then(data => {
                        clearTimeout(timeoutId);

                        operation.status = 'completed';
                        operation.completedAt = Date.now();
                        operation.result = data;

                        this.asyncOperations.stats.completed++;
                        this.asyncOperations.stats.pending--;
                        this.asyncOperations.stats.byStatus['completed']++;
                        this.asyncOperations.stats.byStatus['running']--;

                        this.saveAsyncOperations();

                        resolve({
                            success: true,
                            operation: operation,
                            result: data
                        });
                    }).catch(error => {
                        clearTimeout(timeoutId);

                        operation.status = 'failed';
                        operation.completedAt = Date.now();
                        operation.error = error.message;

                        this.asyncOperations.stats.failed++;
                        this.asyncOperations.stats.pending--;
                        this.asyncOperations.stats.byStatus['failed']++;
                        this.asyncOperations.stats.byStatus['running']--;

                        this.saveAsyncOperations();

                        reject({
                            success: false,
                            operation: operation,
                            error: error.message
                        });
                    });
                } else {
                    // 如果返回普通值
                    clearTimeout(timeoutId);

                    operation.status = 'completed';
                    operation.completedAt = Date.now();
                    operation.result = result;

                    this.asyncOperations.stats.completed++;
                    this.asyncOperations.stats.pending--;
                    this.asyncOperations.stats.byStatus['completed']++;
                    this.asyncOperations.stats.byStatus['running']--;

                    this.saveAsyncOperations();

                    resolve({
                        success: true,
                        operation: operation,
                        result: result
                    });
                }
            } catch (error) {
                clearTimeout(timeoutId);

                operation.status = 'failed';
                operation.completedAt = Date.now();
                operation.error = error.message;

                this.asyncOperations.stats.failed++;
                this.asyncOperations.stats.pending--;
                this.asyncOperations.stats.byStatus['failed']++;
                this.asyncOperations.stats.byStatus['running']--;

                this.saveAsyncOperations();

                reject({
                    success: false,
                    operation: operation,
                    error: error.message
                });
            }
        });
    },

    /**
     * 创建Promise
     * @param {Function} executor - 执行器函数
     * @returns {Object} Promise对象
     */
    createPromise: function (executor) {
        if (!this.asyncConfig.enabled) {
            return {
                success: false,
                error: '异步处理已禁用'
            };
        }

        const promiseId = 'promise_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        const promise = {
            id: promiseId,
            status: 'pending',
            createdAt: Date.now(),
            resolvedAt: null,
            rejectedAt: null,
            result: null,
            error: null
        };

        this.asyncPromises.promises[promiseId] = promise;

        // 更新统计
        this.asyncPromises.stats.total++;
        this.asyncPromises.stats.pending++;

        // 清理旧Promise
        this.cleanupOldPromises();

        this.saveAsyncPromises();

        try {
            const nativePromise = new Promise((resolve, reject) => {
                executor(
                    (value) => {
                        promise.status = 'resolved';
                        promise.resolvedAt = Date.now();
                        promise.result = value;

                        this.asyncPromises.stats.resolved++;
                        this.asyncPromises.stats.pending--;

                        this.saveAsyncPromises();

                        resolve(value);
                    },
                    (error) => {
                        promise.status = 'rejected';
                        promise.rejectedAt = Date.now();
                        promise.error = error;

                        this.asyncPromises.stats.rejected++;
                        this.asyncPromises.stats.pending--;

                        this.saveAsyncPromises();

                        reject(error);
                    }
                );
            });

            return {
                success: true,
                promise: nativePromise,
                promiseId: promiseId
            };
        } catch (error) {
            promise.status = 'rejected';
            promise.rejectedAt = Date.now();
            promise.error = error.message;

            this.asyncPromises.stats.rejected++;
            this.asyncPromises.stats.pending--;

            this.saveAsyncPromises();

            return {
                success: false,
                error: error.message
            };
        }
    },

    /**
     * 清理旧操作
     */
    cleanupOldOperations: function () {
        if (!this.asyncConfig.autoCleanup) {
            return;
        }

        const now = Date.now();
        const operationsToDelete = [];

        for (const opId in this.asyncOperations.operations) {
            const operation = this.asyncOperations.operations[opId];

            if (operation.status === 'completed' || operation.status === 'failed') {
                const age = now - operation.completedAt;

                if (age > this.asyncConfig.cleanupInterval) {
                    operationsToDelete.push(opId);
                }
            }
        }

        for (const opId of operationsToDelete) {
            const deletedOperation = this.asyncOperations.operations[opId];
            delete this.asyncOperations.operations[opId];

            // 更新统计
            this.asyncOperations.stats.total--;
            this.asyncOperations.stats.byType[deletedOperation.type]--;
            this.asyncOperations.stats.byStatus[deletedOperation.status]--;
        }

        if (operationsToDelete.length > 0) {
            this.saveAsyncOperations();
        }
    },

    /**
     * 清理旧Promise
     */
    cleanupOldPromises: function () {
        if (!this.asyncConfig.autoCleanup) {
            return;
        }

        const now = Date.now();
        const promisesToDelete = [];

        for (const promiseId in this.asyncPromises.promises) {
            const promise = this.asyncPromises.promises[promiseId];

            if (promise.status === 'resolved' || promise.status === 'rejected') {
                const completedAt = promise.resolvedAt || promise.rejectedAt;
                const age = now - completedAt;

                if (age > this.asyncConfig.cleanupInterval) {
                    promisesToDelete.push(promiseId);
                }
            }
        }

        for (const promiseId of promisesToDelete) {
            delete this.asyncPromises.promises[promiseId];

            // 更新统计
            this.asyncPromises.stats.total--;
        }

        if (promisesToDelete.length > 0) {
            this.saveAsyncPromises();
        }
    },

    /**
     * 获取操作
     * @param {string} operationId - 操作ID
     * @returns {Object|null} 操作对象
     */
    getOperation: function (operationId) {
        return this.asyncOperations.operations[operationId] || null;
    },

    /**
     * 获取所有操作
     * @param {string} operationType - 操作类型
     * @param {string} status - 状态
     * @returns {Array} 操作列表
     */
    getAllOperations: function (operationType, status) {
        let operations = Object.values(this.asyncOperations.operations);

        if (operationType) {
            operations = operations.filter(o => o.type === operationType);
        }

        if (status) {
            operations = operations.filter(o => o.status === status);
        }

        return operations;
    },

    /**
     * 获取Promise
     * @param {string} promiseId - Promise ID
     * @returns {Object|null} Promise对象
     */
    getPromise: function (promiseId) {
        return this.asyncPromises.promises[promiseId] || null;
    },

    /**
     * 获取所有Promise
     * @param {string} status - 状态
     * @returns {Array} Promise列表
     */
    getAllPromises: function (status) {
        let promises = Object.values(this.asyncPromises.promises);

        if (status) {
            promises = promises.filter(p => p.status === status);
        }

        return promises;
    },

    /**
     * 获取操作统计
     * @returns {Object} 统计信息
     */
    getOperationStats: function () {
        return this.asyncOperations.stats;
    },

    /**
     * 获取Promise统计
     * @returns {Object} 统计信息
     */
    getPromiseStats: function () {
        return this.asyncPromises.stats;
    },

    /**
     * 删除操作
     * @param {string} operationId - 操作ID
     * @returns {boolean} 是否成功
     */
    deleteOperation: function (operationId) {
        if (!this.asyncOperations.operations[operationId]) {
            return false;
        }

        delete this.asyncOperations.operations[operationId];
        this.saveAsyncOperations();

        return true;
    },

    /**
     * 删除Promise
     * @param {string} promiseId - Promise ID
     * @returns {boolean} 是否成功
     */
    deletePromise: function (promiseId) {
        if (!this.asyncPromises.promises[promiseId]) {
            return false;
        }

        delete this.asyncPromises.promises[promiseId];
        this.saveAsyncPromises();

        return true;
    },

    /**
     * 设置异步配置
     * @param {Object} config - 配置对象
     */
    setAsyncConfig: function (config) {
        this.asyncConfig = { ...this.asyncConfig, ...config };
        this.saveAsyncConfig();
    },

    /**
     * 获取异步配置
     * @returns {Object} 配置对象
     */
    getAsyncConfig: function () {
        return this.asyncConfig;
    },

    /**
     * 获取异步统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.asyncConfig.enabled,
            maxOperations: this.asyncConfig.maxOperations,
            maxPromises: this.asyncConfig.maxPromises,
            defaultTimeout: this.asyncConfig.defaultTimeout,
            autoCleanup: this.asyncConfig.autoCleanup,
            cleanupInterval: this.asyncConfig.cleanupInterval,
            totalOperations: Object.keys(this.asyncOperations.operations).length,
            totalPromises: Object.keys(this.asyncPromises.promises).length,
            pendingOperations: this.asyncOperations.stats.pending,
            completedOperations: this.asyncOperations.stats.completed,
            failedOperations: this.asyncOperations.stats.failed,
            pendingPromises: this.asyncPromises.stats.pending,
            resolvedPromises: this.asyncPromises.stats.resolved,
            rejectedPromises: this.asyncPromises.stats.rejected
        };
    }
};

// 优化：游戏同步处理优化
const GameSyncOptimizer = {
    syncConfig: {},
    syncOperations: {},
    syncLocks: {},

    /**
     * 初始化游戏同步处理
     */
    init: function () {
        this.loadSyncConfig();
        this.loadSyncOperations();
        this.loadSyncLocks();
    },

    /**
     * 加载同步配置
     */
    loadSyncConfig: function () {
        this.syncConfig = {
            enabled: true,
            maxOperations: 1000,
            maxLocks: 100,
            defaultTimeout: 5000,
            autoUnlock: true,
            unlockInterval: 60000,
            operationTypes: [
                'read',
                'write',
                'update',
                'delete',
                'transaction',
                'custom'
            ]
        };

        const customConfig = localStorage.getItem('syncConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.syncConfig = { ...this.syncConfig, ...config };
            } catch (error) {
                console.error('加载同步配置失败:', error);
            }
        }
    },

    /**
     * 保存同步配置
     */
    saveSyncConfig: function () {
        localStorage.setItem('syncConfig', JSON.stringify(this.syncConfig));
    },

    /**
     * 加载同步操作
     */
    loadSyncOperations: function () {
        const savedOperations = localStorage.getItem('syncOperations');
        if (savedOperations) {
            try {
                this.syncOperations = JSON.parse(savedOperations);
            } catch (error) {
                console.error('加载同步操作失败:', error);
            }
        }

        if (!this.syncOperations.operations) {
            this.syncOperations = {
                operations: {},
                stats: {
                    total: 0,
                    byType: {},
                    byStatus: {},
                    completed: 0,
                    failed: 0
                }
            };

            this.saveSyncOperations();
        }
    },

    /**
     * 保存同步操作
     */
    saveSyncOperations: function () {
        localStorage.setItem('syncOperations', JSON.stringify(this.syncOperations));
    },

    /**
     * 加载同步锁
     */
    loadSyncLocks: function () {
        const savedLocks = localStorage.getItem('syncLocks');
        if (savedLocks) {
            try {
                this.syncLocks = JSON.parse(savedLocks);
            } catch (error) {
                console.error('加载同步锁失败:', error);
            }
        }

        if (!this.syncLocks.locks) {
            this.syncLocks = {
                locks: {},
                stats: {
                    total: 0,
                    active: 0,
                    byResource: {}
                }
            };

            this.saveSyncLocks();
        }
    },

    /**
     * 保存同步锁
     */
    saveSyncLocks: function () {
        localStorage.setItem('syncLocks', JSON.stringify(this.syncLocks));
    },

    /**
     * 创建同步操作
     * @param {string} operationType - 操作类型
     * @param {Object} operationData - 操作数据
     * @returns {Object} 操作对象
     */
    createOperation: function (operationType, operationData) {
        if (!this.syncConfig.enabled) {
            return {
                success: false,
                error: '同步处理已禁用'
            };
        }

        const operationId = 'sync_op_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        const operation = {
            id: operationId,
            type: operationType,
            name: operationData.name || 'Unnamed Operation',
            description: operationData.description || '',
            action: operationData.action,
            parameters: operationData.parameters || {},
            resource: operationData.resource || null,
            status: 'pending',
            createdAt: Date.now(),
            startedAt: null,
            completedAt: null,
            result: null,
            error: null
        };

        this.syncOperations.operations[operationId] = operation;

        // 更新统计
        this.syncOperations.stats.total++;

        if (!this.syncOperations.stats.byType[operationType]) {
            this.syncOperations.stats.byType[operationType] = 0;
        }

        this.syncOperations.stats.byType[operationType]++;

        if (!this.syncOperations.stats.byStatus[operation.status]) {
            this.syncOperations.stats.byStatus[operation.status] = 0;
        }

        this.syncOperations.stats.byStatus[operation.status]++;

        this.saveSyncOperations();

        return {
            success: true,
            operation: operation
        };
    },

    /**
     * 执行同步操作
     * @param {string} operationId - 操作ID
     * @returns {Object} 执行结果
     */
    executeOperation: function (operationId) {
        const operation = this.syncOperations.operations[operationId];

        if (!operation) {
            return {
                success: false,
                error: '操作不存在'
            };
        }

        if (operation.status !== 'pending') {
            return {
                success: false,
                error: '操作状态不正确'
            };
        }

        operation.status = 'running';
        operation.startedAt = Date.now();

        this.saveSyncOperations();

        try {
            // 如果需要锁资源
            if (operation.resource) {
                const lockResult = this.acquireLock(operation.resource, operationId);

                if (!lockResult.success) {
                    operation.status = 'failed';
                    operation.completedAt = Date.now();
                    operation.error = '无法获取资源锁';

                    this.syncOperations.stats.failed++;
                    this.syncOperations.stats.byStatus['failed']++;
                    this.syncOperations.stats.byStatus['running']--;

                    this.saveSyncOperations();

                    return {
                        success: false,
                        operation: operation,
                        error: '无法获取资源锁'
                    };
                }
            }

            // 执行操作
            const result = operation.action(operation.parameters);

            operation.status = 'completed';
            operation.completedAt = Date.now();
            operation.result = result;

            // 释放锁
            if (operation.resource) {
                this.releaseLock(operation.resource, operationId);
            }

            // 更新统计
            this.syncOperations.stats.completed++;
            this.syncOperations.stats.byStatus['completed']++;
            this.syncOperations.stats.byStatus['running']--;

            this.saveSyncOperations();

            return {
                success: true,
                operation: operation,
                result: result
            };
        } catch (error) {
            operation.status = 'failed';
            operation.completedAt = Date.now();
            operation.error = error.message;

            // 释放锁
            if (operation.resource) {
                this.releaseLock(operation.resource, operationId);
            }

            // 更新统计
            this.syncOperations.stats.failed++;
            this.syncOperations.stats.byStatus['failed']++;
            this.syncOperations.stats.byStatus['running']--;

            this.saveSyncOperations();

            return {
                success: false,
                operation: operation,
                error: error.message
            };
        }
    },

    /**
     * 获取锁
     * @param {string} resource - 资源
     * @param {string} operationId - 操作ID
     * @returns {Object} 锁对象
     */
    acquireLock: function (resource, operationId) {
        if (this.syncLocks.locks[resource]) {
            return {
                success: false,
                error: '资源已被锁定'
            };
        }

        const lock = {
            resource: resource,
            operationId: operationId,
            acquiredAt: Date.now(),
            timeout: this.syncConfig.defaultTimeout
        };

        this.syncLocks.locks[resource] = lock;

        // 更新统计
        this.syncLocks.stats.total++;
        this.syncLocks.stats.active++;

        if (!this.syncLocks.stats.byResource[resource]) {
            this.syncLocks.stats.byResource[resource] = 0;
        }

        this.syncLocks.stats.byResource[resource]++;

        this.saveSyncLocks();

        return {
            success: true,
            lock: lock
        };
    },

    /**
     * 释放锁
     * @param {string} resource - 资源
     * @param {string} operationId - 操作ID
     * @returns {boolean} 是否成功
     */
    releaseLock: function (resource, operationId) {
        const lock = this.syncLocks.locks[resource];

        if (!lock) {
            return false;
        }

        if (lock.operationId !== operationId) {
            return false;
        }

        delete this.syncLocks.locks[resource];

        // 更新统计
        this.syncLocks.stats.active--;
        this.syncLocks.stats.byResource[resource]--;

        this.saveSyncLocks();

        return true;
    },

    /**
     * 尝试获取锁
     * @param {string} resource - 资源
     * @param {string} operationId - 操作ID
     * @param {number} timeout - 超时时间(ms)
     * @returns {Object} 锁对象
     */
    tryAcquireLock: function (resource, operationId, timeout) {
        if (this.syncLocks.locks[resource]) {
            return {
                success: false,
                error: '资源已被锁定'
            };
        }

        return this.acquireLock(resource, operationId);
    },

    /**
     * 检查锁状态
     * @param {string} resource - 资源
     * @returns {boolean} 是否被锁定
     */
    isLocked: function (resource) {
        return !!this.syncLocks.locks[resource];
    },

    /**
     * 获取锁信息
     * @param {string} resource - 资源
     * @returns {Object|null} 锁对象
     */
    getLock: function (resource) {
        return this.syncLocks.locks[resource] || null;
    },

    /**
     * 获取所有锁
     * @returns {Array} 锁列表
     */
    getAllLocks: function () {
        return Object.values(this.syncLocks.locks);
    },

    /**
     * 清理过期锁
     */
    cleanupExpiredLocks: function () {
        if (!this.syncConfig.autoUnlock) {
            return;
        }

        const now = Date.now();
        const locksToRelease = [];

        for (const resource in this.syncLocks.locks) {
            const lock = this.syncLocks.locks[resource];
            const age = now - lock.acquiredAt;

            if (age > lock.timeout) {
                locksToRelease.push(resource);
            }
        }

        for (const resource of locksToRelease) {
            delete this.syncLocks.locks[resource];

            // 更新统计
            this.syncLocks.stats.active--;
            this.syncLocks.stats.byResource[resource]--;
        }

        if (locksToRelease.length > 0) {
            this.saveSyncLocks();
        }
    },

    /**
     * 获取操作
     * @param {string} operationId - 操作ID
     * @returns {Object|null} 操作对象
     */
    getOperation: function (operationId) {
        return this.syncOperations.operations[operationId] || null;
    },

    /**
     * 获取所有操作
     * @param {string} operationType - 操作类型
     * @param {string} status - 状态
     * @returns {Array} 操作列表
     */
    getAllOperations: function (operationType, status) {
        let operations = Object.values(this.syncOperations.operations);

        if (operationType) {
            operations = operations.filter(o => o.type === operationType);
        }

        if (status) {
            operations = operations.filter(o => o.status === status);
        }

        return operations;
    },

    /**
     * 获取操作统计
     * @returns {Object} 统计信息
     */
    getOperationStats: function () {
        return this.syncOperations.stats;
    },

    /**
     * 获取锁统计
     * @returns {Object} 统计信息
     */
    getLockStats: function () {
        return this.syncLocks.stats;
    },

    /**
     * 删除操作
     * @param {string} operationId - 操作ID
     * @returns {boolean} 是否成功
     */
    deleteOperation: function (operationId) {
        if (!this.syncOperations.operations[operationId]) {
            return false;
        }

        delete this.syncOperations.operations[operationId];
        this.saveSyncOperations();

        return true;
    },

    /**
     * 设置同步配置
     * @param {Object} config - 配置对象
     */
    setSyncConfig: function (config) {
        this.syncConfig = { ...this.syncConfig, ...config };
        this.saveSyncConfig();
    },

    /**
     * 获取同步配置
     * @returns {Object} 配置对象
     */
    getSyncConfig: function () {
        return this.syncConfig;
    },

    /**
     * 获取同步统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.syncConfig.enabled,
            maxOperations: this.syncConfig.maxOperations,
            maxLocks: this.syncConfig.maxLocks,
            defaultTimeout: this.syncConfig.defaultTimeout,
            autoUnlock: this.syncConfig.autoUnlock,
            unlockInterval: this.syncConfig.unlockInterval,
            totalOperations: Object.keys(this.syncOperations.operations).length,
            totalLocks: Object.keys(this.syncLocks.locks).length,
            completedOperations: this.syncOperations.stats.completed,
            failedOperations: this.syncOperations.stats.failed,
            activeLocks: this.syncLocks.stats.active
        };
    }
};

// 优化：游戏事件处理优化
const GameEventOptimizer = {
    eventConfig: {},
    eventListeners: {},
    eventQueue: {},
    eventHistory: {},

    /**
     * 初始化游戏事件处理
     */
    init: function () {
        this.loadEventConfig();
        this.loadEventListeners();
        this.loadEventQueue();
        this.loadEventHistory();
        this.startEventProcessing();
    },

    /**
     * 加载事件配置
     */
    loadEventConfig: function () {
        this.eventConfig = {
            enabled: true,
            maxListeners: 1000,
            maxQueueSize: 10000,
            maxHistorySize: 1000,
            autoProcess: true,
            processingInterval: 16,
            eventTypes: [
                'input',
                'collision',
                'state_change',
                'animation',
                'audio',
                'network',
                'ui',
                'game',
                'custom'
            ]
        };

        const customConfig = localStorage.getItem('eventConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.eventConfig = { ...this.eventConfig, ...config };
            } catch (error) {
                console.error('加载事件配置失败:', error);
            }
        }
    },

    /**
     * 保存事件配置
     */
    saveEventConfig: function () {
        localStorage.setItem('eventConfig', JSON.stringify(this.eventConfig));
    },

    /**
     * 加载事件监听器
     */
    loadEventListeners: function () {
        const savedListeners = localStorage.getItem('eventListeners');
        if (savedListeners) {
            try {
                this.eventListeners = JSON.parse(savedListeners);
            } catch (error) {
                console.error('加载事件监听器失败:', error);
            }
        }

        if (!this.eventListeners.listeners) {
            this.eventListeners = {
                listeners: {},
                stats: {
                    total: 0,
                    byType: {},
                    byPriority: {},
                    active: 0
                }
            };

            this.saveEventListeners();
        }
    },

    /**
     * 保存事件监听器
     */
    saveEventListeners: function () {
        localStorage.setItem('eventListeners', JSON.stringify(this.eventListeners));
    },

    /**
     * 加载事件队列
     */
    loadEventQueue: function () {
        const savedQueue = localStorage.getItem('eventQueue');
        if (savedQueue) {
            try {
                this.eventQueue = JSON.parse(savedQueue);
            } catch (error) {
                console.error('加载事件队列失败:', error);
            }
        }

        if (!this.eventQueue.queue) {
            this.eventQueue = {
                queue: [],
                stats: {
                    total: 0,
                    processed: 0,
                    failed: 0,
                    byType: {}
                }
            };

            this.saveEventQueue();
        }
    },

    /**
     * 保存事件队列
     */
    saveEventQueue: function () {
        localStorage.setItem('eventQueue', JSON.stringify(this.eventQueue));
    },

    /**
     * 加载事件历史
     */
    loadEventHistory: function () {
        const savedHistory = localStorage.getItem('eventHistory');
        if (savedHistory) {
            try {
                this.eventHistory = JSON.parse(savedHistory);
            } catch (error) {
                console.error('加载事件历史失败:', error);
            }
        }

        if (!this.eventHistory.history) {
            this.eventHistory = {
                history: [],
                stats: {
                    total: 0,
                    byType: {}
                }
            };

            this.saveEventHistory();
        }
    },

    /**
     * 保存事件历史
     */
    saveEventHistory: function () {
        localStorage.setItem('eventHistory', JSON.stringify(this.eventHistory));
    },

    /**
     * 启动事件处理
     */
    startEventProcessing: function () {
        setInterval(() => {
            if (this.eventConfig.enabled && this.eventConfig.autoProcess) {
                this.processEvents();
            }
        }, this.eventConfig.processingInterval);
    },

    /**
     * 添加事件监听器
     * @param {string} eventType - 事件类型
     * @param {Function} listener - 监听器函数
     * @param {Object} listenerData - 监听器数据
     * @returns {Object} 监听器对象
     */
    addListener: function (eventType, listener, listenerData) {
        if (!this.eventConfig.enabled) {
            return {
                success: false,
                error: '事件处理已禁用'
            };
        }

        if (Object.keys(this.eventListeners.listeners).length >= this.eventConfig.maxListeners) {
            return {
                success: false,
                error: '监听器数量已达上限'
            };
        }

        const listenerId = 'listener_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        const listenerObj = {
            id: listenerId,
            type: eventType,
            listener: listener,
            priority: listenerData.priority || 'medium',
            once: listenerData.once || false,
            enabled: listenerData.enabled !== false,
            createdAt: Date.now(),
            callCount: 0
        };

        this.eventListeners.listeners[listenerId] = listenerObj;

        // 更新统计
        this.eventListeners.stats.total++;

        if (!this.eventListeners.stats.byType[eventType]) {
            this.eventListeners.stats.byType[eventType] = 0;
        }

        this.eventListeners.stats.byType[eventType]++;

        if (!this.eventListeners.stats.byPriority[listenerObj.priority]) {
            this.eventListeners.stats.byPriority[listenerObj.priority] = 0;
        }

        this.eventListeners.stats.byPriority[listenerObj.priority]++;

        if (listenerObj.enabled) {
            this.eventListeners.stats.active++;
        }

        this.saveEventListeners();

        return {
            success: true,
            listener: listenerObj
        };
    },

    /**
     * 移除事件监听器
     * @param {string} listenerId - 监听器ID
     * @returns {boolean} 是否成功
     */
    removeListener: function (listenerId) {
        if (!this.eventListeners.listeners[listenerId]) {
            return false;
        }

        const deletedListener = this.eventListeners.listeners[listenerId];

        if (deletedListener.enabled) {
            this.eventListeners.stats.active--;
        }

        this.eventListeners.stats.total--;
        this.eventListeners.stats.byType[deletedListener.type]--;
        this.eventListeners.stats.byPriority[deletedListener.priority]--;

        delete this.eventListeners.listeners[listenerId];
        this.saveEventListeners();

        return true;
    },

    /**
     * 触发事件
     * @param {string} eventType - 事件类型
     * @param {Object} eventData - 事件数据
     * @returns {Object} 触发结果
     */
    triggerEvent: function (eventType, eventData) {
        if (!this.eventConfig.enabled) {
            return {
                success: false,
                error: '事件处理已禁用'
            };
        }

        const event = {
            id: 'event_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            type: eventType,
            data: eventData || {},
            timestamp: Date.now()
        };

        // 添加到队列
        this.eventQueue.queue.push(event);

        // 限制队列大小
        if (this.eventQueue.queue.length > this.eventConfig.maxQueueSize) {
            this.eventQueue.queue.shift();
        }

        // 更新统计
        this.eventQueue.stats.total++;

        if (!this.eventQueue.stats.byType[eventType]) {
            this.eventQueue.stats.byType[eventType] = 0;
        }

        this.eventQueue.stats.byType[eventType]++;

        this.saveEventQueue();

        return {
            success: true,
            event: event
        };
    },

    /**
     * 处理事件
     */
    processEvents: function () {
        if (this.eventQueue.queue.length === 0) {
            return;
        }

        const event = this.eventQueue.queue.shift();

        // 获取相关监听器
        const listeners = Object.values(this.eventListeners.listeners)
            .filter(l => l.type === event.type && l.enabled)
            .sort((a, b) => {
                const priorityOrder = {
                    'high': 0,
                    'medium': 1,
                    'low': 2
                };
                return priorityOrder[a.priority] - priorityOrder[b.priority];
            });

        // 触发监听器
        for (const listener of listeners) {
            try {
                listener.listener(event);
                listener.callCount++;

                // 如果是一次性监听器，移除它
                if (listener.once) {
                    this.removeListener(listener.id);
                }
            } catch (error) {
                console.error('事件监听器错误:', error);
                this.eventQueue.stats.failed++;
            }
        }

        // 更新统计
        this.eventQueue.stats.processed++;

        // 添加到历史
        this.addToHistory(event);

        this.saveEventQueue();
        this.saveEventListeners();
    },

    /**
     * 添加到历史
     * @param {Object} event - 事件对象
     */
    addToHistory: function (event) {
        this.eventHistory.history.push(event);

        // 限制历史大小
        if (this.eventHistory.history.length > this.eventConfig.maxHistorySize) {
            this.eventHistory.history.shift();
        }

        // 更新统计
        this.eventHistory.stats.total++;

        if (!this.eventHistory.stats.byType[event.type]) {
            this.eventHistory.stats.byType[event.type] = 0;
        }

        this.eventHistory.stats.byType[event.type]++;

        this.saveEventHistory();
    },

    /**
     * 获取监听器
     * @param {string} listenerId - 监听器ID
     * @returns {Object|null} 监听器对象
     */
    getListener: function (listenerId) {
        return this.eventListeners.listeners[listenerId] || null;
    },

    /**
     * 获取所有监听器
     * @param {string} eventType - 事件类型
     * @param {boolean} enabled - 是否启用
     * @returns {Array} 监听器列表
     */
    getAllListeners: function (eventType, enabled) {
        let listeners = Object.values(this.eventListeners.listeners);

        if (eventType) {
            listeners = listeners.filter(l => l.type === eventType);
        }

        if (enabled !== undefined) {
            listeners = listeners.filter(l => l.enabled === enabled);
        }

        return listeners;
    },

    /**
     * 获取事件历史
     * @param {number} limit - 限制数量
     * @returns {Array} 事件列表
     */
    getHistory: function (limit) {
        let history = this.eventHistory.history;

        if (limit) {
            history = history.slice(-limit);
        }

        return history;
    },

    /**
     * 获取监听器统计
     * @returns {Object} 统计信息
     */
    getListenerStats: function () {
        return this.eventListeners.stats;
    },

    /**
     * 获取队列统计
     * @returns {Object} 统计信息
     */
    getQueueStats: function () {
        return this.eventQueue.stats;
    },

    /**
     * 获取历史统计
     * @returns {Object} 统计信息
     */
    getHistoryStats: function () {
        return this.eventHistory.stats;
    },

    /**
     * 清空队列
     */
    clearQueue: function () {
        this.eventQueue.queue = [];
        this.saveEventQueue();
    },

    /**
     * 清空历史
     */
    clearHistory: function () {
        this.eventHistory.history = [];
        this.eventHistory.stats.total = 0;
        this.eventHistory.stats.byType = {};
        this.saveEventHistory();
    },

    /**
     * 设置事件配置
     * @param {Object} config - 配置对象
     */
    setEventConfig: function (config) {
        this.eventConfig = { ...this.eventConfig, ...config };
        this.saveEventConfig();
    },

    /**
     * 获取事件配置
     * @returns {Object} 配置对象
     */
    getEventConfig: function () {
        return this.eventConfig;
    },

    /**
     * 获取事件统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.eventConfig.enabled,
            maxListeners: this.eventConfig.maxListeners,
            maxQueueSize: this.eventConfig.maxQueueSize,
            maxHistorySize: this.eventConfig.maxHistorySize,
            autoProcess: this.eventConfig.autoProcess,
            processingInterval: this.eventConfig.processingInterval,
            totalListeners: Object.keys(this.eventListeners.listeners).length,
            queueSize: this.eventQueue.queue.length,
            historySize: this.eventHistory.history.length,
            activeListeners: this.eventListeners.stats.active,
            processedEvents: this.eventQueue.stats.processed,
            failedEvents: this.eventQueue.stats.failed
        };
    }
};

// 优化：游戏消息处理优化
const GameMessageOptimizer = {
    messageConfig: {},
    messageSubscribers: {},
    messageQueue: {},
    messageHistory: {},

    /**
     * 初始化游戏消息处理
     */
    init: function () {
        this.loadMessageConfig();
        this.loadMessageSubscribers();
        this.loadMessageQueue();
        this.loadMessageHistory();
        this.startMessageProcessing();
    },

    /**
     * 加载消息配置
     */
    loadMessageConfig: function () {
        this.messageConfig = {
            enabled: true,
            maxSubscribers: 1000,
            maxQueueSize: 10000,
            maxHistorySize: 1000,
            autoProcess: true,
            processingInterval: 16,
            messageTypes: [
                'system',
                'game',
                'player',
                'enemy',
                'ui',
                'network',
                'audio',
                'custom'
            ]
        };

        const customConfig = localStorage.getItem('messageConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.messageConfig = { ...this.messageConfig, ...config };
            } catch (error) {
                console.error('加载消息配置失败:', error);
            }
        }
    },

    /**
     * 保存消息配置
     */
    saveMessageConfig: function () {
        localStorage.setItem('messageConfig', JSON.stringify(this.messageConfig));
    },

    /**
     * 加载消息订阅者
     */
    loadMessageSubscribers: function () {
        const savedSubscribers = localStorage.getItem('messageSubscribers');
        if (savedSubscribers) {
            try {
                this.messageSubscribers = JSON.parse(savedSubscribers);
            } catch (error) {
                console.error('加载消息订阅者失败:', error);
            }
        }

        if (!this.messageSubscribers.subscribers) {
            this.messageSubscribers = {
                subscribers: {},
                stats: {
                    total: 0,
                    byType: {},
                    byPriority: {},
                    active: 0
                }
            };

            this.saveMessageSubscribers();
        }
    },

    /**
     * 保存消息订阅者
     */
    saveMessageSubscribers: function () {
        localStorage.setItem('messageSubscribers', JSON.stringify(this.messageSubscribers));
    },

    /**
     * 加载消息队列
     */
    loadMessageQueue: function () {
        const savedQueue = localStorage.getItem('messageQueue');
        if (savedQueue) {
            try {
                this.messageQueue = JSON.parse(savedQueue);
            } catch (error) {
                console.error('加载消息队列失败:', error);
            }
        }

        if (!this.messageQueue.queue) {
            this.messageQueue = {
                queue: [],
                stats: {
                    total: 0,
                    processed: 0,
                    failed: 0,
                    byType: {}
                }
            };

            this.saveMessageQueue();
        }
    },

    /**
     * 保存消息队列
     */
    saveMessageQueue: function () {
        localStorage.setItem('messageQueue', JSON.stringify(this.messageQueue));
    },

    /**
     * 加载消息历史
     */
    loadMessageHistory: function () {
        const savedHistory = localStorage.getItem('messageHistory');
        if (savedHistory) {
            try {
                this.messageHistory = JSON.parse(savedHistory);
            } catch (error) {
                console.error('加载消息历史失败:', error);
            }
        }

        if (!this.messageHistory.history) {
            this.messageHistory = {
                history: [],
                stats: {
                    total: 0,
                    byType: {}
                }
            };

            this.saveMessageHistory();
        }
    },

    /**
     * 保存消息历史
     */
    saveMessageHistory: function () {
        localStorage.setItem('messageHistory', JSON.stringify(this.messageHistory));
    },

    /**
     * 启动消息处理
     */
    startMessageProcessing: function () {
        setInterval(() => {
            if (this.messageConfig.enabled && this.messageConfig.autoProcess) {
                this.processMessages();
            }
        }, this.messageConfig.processingInterval);
    },

    /**
     * 订阅消息
     * @param {string} messageType - 消息类型
     * @param {Function} subscriber - 订阅者函数
     * @param {Object} subscriberData - 订阅者数据
     * @returns {Object} 订阅者对象
     */
    subscribe: function (messageType, subscriber, subscriberData) {
        if (!this.messageConfig.enabled) {
            return {
                success: false,
                error: '消息处理已禁用'
            };
        }

        if (Object.keys(this.messageSubscribers.subscribers).length >= this.messageConfig.maxSubscribers) {
            return {
                success: false,
                error: '订阅者数量已达上限'
            };
        }

        const subscriberId = 'subscriber_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        const subscriberObj = {
            id: subscriberId,
            type: messageType,
            subscriber: subscriber,
            priority: subscriberData.priority || 'medium',
            once: subscriberData.once || false,
            enabled: subscriberData.enabled !== false,
            createdAt: Date.now(),
            callCount: 0
        };

        this.messageSubscribers.subscribers[subscriberId] = subscriberObj;

        // 更新统计
        this.messageSubscribers.stats.total++;

        if (!this.messageSubscribers.stats.byType[messageType]) {
            this.messageSubscribers.stats.byType[messageType] = 0;
        }

        this.messageSubscribers.stats.byType[messageType]++;

        if (!this.messageSubscribers.stats.byPriority[subscriberObj.priority]) {
            this.messageSubscribers.stats.byPriority[subscriberObj.priority] = 0;
        }

        this.messageSubscribers.stats.byPriority[subscriberObj.priority]++;

        if (subscriberObj.enabled) {
            this.messageSubscribers.stats.active++;
        }

        this.saveMessageSubscribers();

        return {
            success: true,
            subscriber: subscriberObj
        };
    },

    /**
     * 取消订阅
     * @param {string} subscriberId - 订阅者ID
     * @returns {boolean} 是否成功
     */
    unsubscribe: function (subscriberId) {
        if (!this.messageSubscribers.subscribers[subscriberId]) {
            return false;
        }

        const deletedSubscriber = this.messageSubscribers.subscribers[subscriberId];

        if (deletedSubscriber.enabled) {
            this.messageSubscribers.stats.active--;
        }

        this.messageSubscribers.stats.total--;
        this.messageSubscribers.stats.byType[deletedSubscriber.type]--;
        this.messageSubscribers.stats.byPriority[deletedSubscriber.priority]--;

        delete this.messageSubscribers.subscribers[subscriberId];
        this.saveMessageSubscribers();

        return true;
    },

    /**
     * 发布消息
     * @param {string} messageType - 消息类型
     * @param {Object} messageData - 消息数据
     * @returns {Object} 发布结果
     */
    publish: function (messageType, messageData) {
        if (!this.messageConfig.enabled) {
            return {
                success: false,
                error: '消息处理已禁用'
            };
        }

        const message = {
            id: 'message_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            type: messageType,
            data: messageData || {},
            timestamp: Date.now()
        };

        // 添加到队列
        this.messageQueue.queue.push(message);

        // 限制队列大小
        if (this.messageQueue.queue.length > this.messageConfig.maxQueueSize) {
            this.messageQueue.queue.shift();
        }

        // 更新统计
        this.messageQueue.stats.total++;

        if (!this.messageQueue.stats.byType[messageType]) {
            this.messageQueue.stats.byType[messageType] = 0;
        }

        this.messageQueue.stats.byType[messageType]++;

        this.saveMessageQueue();

        return {
            success: true,
            message: message
        };
    },

    /**
     * 处理消息
     */
    processMessages: function () {
        if (this.messageQueue.queue.length === 0) {
            return;
        }

        const message = this.messageQueue.queue.shift();

        // 获取相关订阅者
        const subscribers = Object.values(this.messageSubscribers.subscribers)
            .filter(s => s.type === message.type && s.enabled)
            .sort((a, b) => {
                const priorityOrder = {
                    'high': 0,
                    'medium': 1,
                    'low': 2
                };
                return priorityOrder[a.priority] - priorityOrder[b.priority];
            });

        // 触发订阅者
        for (const subscriber of subscribers) {
            try {
                subscriber.subscriber(message);
                subscriber.callCount++;

                // 如果是一次性订阅者，移除它
                if (subscriber.once) {
                    this.unsubscribe(subscriber.id);
                }
            } catch (error) {
                console.error('消息订阅者错误:', error);
                this.messageQueue.stats.failed++;
            }
        }

        // 更新统计
        this.messageQueue.stats.processed++;

        // 添加到历史
        this.addToHistory(message);

        this.saveMessageQueue();
        this.saveMessageSubscribers();
    },

    /**
     * 添加到历史
     * @param {Object} message - 消息对象
     */
    addToHistory: function (message) {
        this.messageHistory.history.push(message);

        // 限制历史大小
        if (this.messageHistory.history.length > this.messageConfig.maxHistorySize) {
            this.messageHistory.history.shift();
        }

        // 更新统计
        this.messageHistory.stats.total++;

        if (!this.messageHistory.stats.byType[message.type]) {
            this.messageHistory.stats.byType[message.type] = 0;
        }

        this.messageHistory.stats.byType[message.type]++;

        this.saveMessageHistory();
    },

    /**
     * 获取订阅者
     * @param {string} subscriberId - 订阅者ID
     * @returns {Object|null} 订阅者对象
     */
    getSubscriber: function (subscriberId) {
        return this.messageSubscribers.subscribers[subscriberId] || null;
    },

    /**
     * 获取所有订阅者
     * @param {string} messageType - 消息类型
     * @param {boolean} enabled - 是否启用
     * @returns {Array} 订阅者列表
     */
    getAllSubscribers: function (messageType, enabled) {
        let subscribers = Object.values(this.messageSubscribers.subscribers);

        if (messageType) {
            subscribers = subscribers.filter(s => s.type === messageType);
        }

        if (enabled !== undefined) {
            subscribers = subscribers.filter(s => s.enabled === enabled);
        }

        return subscribers;
    },

    /**
     * 获取消息历史
     * @param {number} limit - 限制数量
     * @returns {Array} 消息列表
     */
    getHistory: function (limit) {
        let history = this.messageHistory.history;

        if (limit) {
            history = history.slice(-limit);
        }

        return history;
    },

    /**
     * 获取订阅者统计
     * @returns {Object} 统计信息
     */
    getSubscriberStats: function () {
        return this.messageSubscribers.stats;
    },

    /**
     * 获取队列统计
     * @returns {Object} 统计信息
     */
    getQueueStats: function () {
        return this.messageQueue.stats;
    },

    /**
     * 获取历史统计
     * @returns {Object} 统计信息
     */
    getHistoryStats: function () {
        return this.messageHistory.stats;
    },

    /**
     * 清空队列
     */
    clearQueue: function () {
        this.messageQueue.queue = [];
        this.saveMessageQueue();
    },

    /**
     * 清空历史
     */
    clearHistory: function () {
        this.messageHistory.history = [];
        this.messageHistory.stats.total = 0;
        this.messageHistory.stats.byType = {};
        this.saveMessageHistory();
    },

    /**
     * 设置消息配置
     * @param {Object} config - 配置对象
     */
    setMessageConfig: function (config) {
        this.messageConfig = { ...this.messageConfig, ...config };
        this.saveMessageConfig();
    },

    /**
     * 获取消息配置
     * @returns {Object} 配置对象
     */
    getMessageConfig: function () {
        return this.messageConfig;
    },

    /**
     * 获取消息统计信息
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return {
            enabled: this.messageConfig.enabled,
            maxSubscribers: this.messageConfig.maxSubscribers,
            maxQueueSize: this.messageConfig.maxQueueSize,
            maxHistorySize: this.messageConfig.maxHistorySize,
            autoProcess: this.messageConfig.autoProcess,
            processingInterval: this.messageConfig.processingInterval,
            totalSubscribers: Object.keys(this.messageSubscribers.subscribers).length,
            queueSize: this.messageQueue.queue.length,
            historySize: this.messageHistory.history.length,
            activeSubscribers: this.messageSubscribers.stats.active,
            processedMessages: this.messageQueue.stats.processed,
            failedMessages: this.messageQueue.stats.failed
        };
    }
};

// 优化：游戏渲染优化
const GameRenderOptimizer = {
    renderConfig: {},
    renderStats: {},
    renderCache: {},

    /**
     * 初始化游戏渲染优化
     */
    init: function () {
        this.loadRenderConfig();
        this.loadRenderStats();
        this.loadRenderCache();
        this.initCanvas();
        this.optimizeRendering();
    },

    /**
     * 加载渲染配置
     */
    loadRenderConfig: function () {
        this.renderConfig = {
            enabled: true,
            useCache: true,
            maxCacheSize: 1000,
            useDoubleBuffering: true,
            useRequestAnimationFrame: true,
            useOffscreenCanvas: false,
            optimizeImages: true,
            lazyLoadImages: true,
            reduceDrawCalls: true,
            batchDraw: true,
            cullingEnabled: true,
            frustumCulling: true,
            occlusionCulling: false,
            useWebGL: false,
            maxFPS: 60,
            minFPS: 30,
            adaptiveQuality: true,
            qualityLevels: ['low', 'medium', 'high', 'ultra'],
            currentQuality: 'medium'
        };

        const customConfig = localStorage.getItem('renderConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.renderConfig = { ...this.renderConfig, ...config };
            } catch (error) {
                console.error('加载渲染配置失败:', error);
            }
        }
    },

    /**
     * 保存渲染配置
     */
    saveRenderConfig: function () {
        localStorage.setItem('renderConfig', JSON.stringify(this.renderConfig));
    },

    /**
     * 加载渲染统计
     */
    loadRenderStats: function () {
        const savedStats = localStorage.getItem('renderStats');
        if (savedStats) {
            try {
                this.renderStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载渲染统计失败:', error);
            }
        }

        if (!this.renderStats.stats) {
            this.renderStats = {
                stats: {
                    frameCount: 0,
                    lastFrameTime: 0,
                    fps: 0,
                    avgFPS: 0,
                    minFPS: 60,
                    maxFPS: 0,
                    drawCalls: 0,
                    triangles: 0,
                    vertices: 0,
                    pixels: 0,
                    cacheHits: 0,
                    cacheMisses: 0,
                    cacheHitRate: 0
                }
            };

            this.saveRenderStats();
        }
    },

    /**
     * 保存渲染统计
     */
    saveRenderStats: function () {
        localStorage.setItem('renderStats', JSON.stringify(this.renderStats));
    },

    /**
     * 加载渲染缓存
     */
    loadRenderCache: function () {
        const savedCache = localStorage.getItem('renderCache');
        if (savedCache) {
            try {
                this.renderCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载渲染缓存失败:', error);
            }
        }

        if (!this.renderCache.cache) {
            this.renderCache = {
                cache: {},
                stats: {
                    size: 0,
                    maxSize: this.renderConfig.maxCacheSize,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveRenderCache();
        }
    },

    /**
     * 保存渲染缓存
     */
    saveRenderCache: function () {
        localStorage.setItem('renderCache', JSON.stringify(this.renderCache));
    },

    /**
     * 初始化Canvas
     */
    initCanvas: function () {
        const canvas = document.getElementById('gameCanvas');
        if (!canvas) {
            return;
        }

        // 启用双缓冲
        if (this.renderConfig.useDoubleBuffering) {
            this.backBuffer = document.createElement('canvas');
            this.backBuffer.width = canvas.width;
            this.backBuffer.height = canvas.height;
            this.backCtx = this.backBuffer.getContext('2d');
        }

        // 启用离屏Canvas
        if (this.renderConfig.useOffscreenCanvas && typeof OffscreenCanvas !== 'undefined') {
            this.offscreenCanvas = new OffscreenCanvas(canvas.width, canvas.height);
            this.offscreenCtx = this.offscreenCanvas.getContext('2d');
        }
    },

    /**
     * 优化渲染
     */
    optimizeRendering: function () {
        // 使用requestAnimationFrame
        if (this.renderConfig.useRequestAnimationFrame) {
            this.useRequestAnimationFrame();
        }

        // 启用自适应质量
        if (this.renderConfig.adaptiveQuality) {
            this.enableAdaptiveQuality();
        }

        // 启用剔除
        if (this.renderConfig.cullingEnabled) {
            this.enableCulling();
        }
    },

    /**
     * 使用requestAnimationFrame
     */
    useRequestAnimationFrame: function () {
        if (typeof window.requestAnimationFrame === 'function') {
            window.requestAnimationFrame = (function () {
                return window.requestAnimationFrame ||
                    window.webkitRequestAnimationFrame ||
                    window.mozRequestAnimationFrame ||
                    window.oRequestAnimationFrame ||
                    window.msRequestAnimationFrame ||
                    function (callback) {
                        window.setTimeout(callback, 1000 / 60);
                    };
            })();
        }
    },

    /**
     * 启用自适应质量
     */
    enableAdaptiveQuality: function () {
        setInterval(() => {
            if (!this.renderConfig.adaptiveQuality) {
                return;
            }

            const fps = this.renderStats.stats.fps;
            const currentQuality = this.renderConfig.currentQuality;
            const qualityLevels = this.renderConfig.qualityLevels;
            const currentIndex = qualityLevels.indexOf(currentQuality);

            // FPS太低，降低质量
            if (fps < this.renderConfig.minFPS && currentIndex > 0) {
                this.setQuality(qualityLevels[currentIndex - 1]);
            }
            // FPS足够高，提高质量
            else if (fps > this.renderConfig.maxFPS && currentIndex < qualityLevels.length - 1) {
                this.setQuality(qualityLevels[currentIndex + 1]);
            }
        }, 1000);
    },

    /**
     * 设置质量
     * @param {string} quality - 质量级别
     */
    setQuality: function (quality) {
        if (!this.renderConfig.qualityLevels.includes(quality)) {
            return;
        }

        this.renderConfig.currentQuality = quality;
        this.saveRenderConfig();

        // 根据质量级别调整渲染参数
        switch (quality) {
            case 'low':
                this.renderConfig.useCache = true;
                this.renderConfig.optimizeImages = true;
                this.renderConfig.reduceDrawCalls = true;
                this.renderConfig.batchDraw = true;
                this.renderConfig.cullingEnabled = true;
                this.renderConfig.maxFPS = 30;
                break;
            case 'medium':
                this.renderConfig.useCache = true;
                this.renderConfig.optimizeImages = true;
                this.renderConfig.reduceDrawCalls = true;
                this.renderConfig.batchDraw = true;
                this.renderConfig.cullingEnabled = true;
                this.renderConfig.maxFPS = 60;
                break;
            case 'high':
                this.renderConfig.useCache = true;
                this.renderConfig.optimizeImages = false;
                this.renderConfig.reduceDrawCalls = false;
                this.renderConfig.batchDraw = true;
                this.renderConfig.cullingEnabled = true;
                this.renderConfig.maxFPS = 60;
                break;
            case 'ultra':
                this.renderConfig.useCache = false;
                this.renderConfig.optimizeImages = false;
                this.renderConfig.reduceDrawCalls = false;
                this.renderConfig.batchDraw = false;
                this.renderConfig.cullingEnabled = false;
                this.renderConfig.maxFPS = 120;
                break;
        }
    },

    /**
     * 启用剔除
     */
    enableCulling: function () {
        // 视锥体剔除
        if (this.renderConfig.frustumCulling) {
            this.enableFrustumCulling();
        }

        // 遮挡剔除
        if (this.renderConfig.occlusionCulling) {
            this.enableOcclusionCulling();
        }
    },

    /**
     * 启用视锥体剔除
     */
    enableFrustumCulling: function () {
        // 实现视锥体剔除逻辑
    },

    /**
     * 启用遮挡剔除
     */
    enableOcclusionCulling: function () {
        // 实现遮挡剔除逻辑
    },

    /**
     * 缓存渲染结果
     * @param {string} key - 缓存键
     * @param {Object} value - 缓存值
     */
    cacheRender: function (key, value) {
        if (!this.renderConfig.useCache) {
            return;
        }

        // 检查缓存大小
        if (Object.keys(this.renderCache.cache).length >= this.renderConfig.maxCacheSize) {
            // 删除最旧的缓存项
            const oldestKey = Object.keys(this.renderCache.cache)[0];
            delete this.renderCache.cache[oldestKey];
        }

        this.renderCache.cache[key] = {
            value: value,
            timestamp: Date.now()
        };

        this.renderCache.stats.size = Object.keys(this.renderCache.cache).length;
        this.saveRenderCache();
    },

    /**
     * 获取缓存渲染结果
     * @param {string} key - 缓存键
     * @returns {Object|null} 缓存值
     */
    getCachedRender: function (key) {
        if (!this.renderConfig.useCache) {
            return null;
        }

        const cached = this.renderCache.cache[key];

        if (cached) {
            this.renderCache.stats.hits++;
            this.renderStats.stats.cacheHits++;
        } else {
            this.renderCache.stats.misses++;
            this.renderStats.stats.cacheMisses++;
        }

        // 更新缓存命中率
        const total = this.renderCache.stats.hits + this.renderCache.stats.misses;
        this.renderCache.stats.hitRate = total > 0 ? (this.renderCache.stats.hits / total) * 100 : 0;
        this.renderStats.stats.cacheHitRate = this.renderCache.stats.hitRate;

        this.saveRenderCache();
        this.saveRenderStats();

        return cached ? cached.value : null;
    },

    /**
     * 更新渲染统计
     */
    updateRenderStats: function () {
        const now = Date.now();
        const lastFrameTime = this.renderStats.stats.lastFrameTime;

        if (lastFrameTime > 0) {
            const delta = now - lastFrameTime;
            const fps = 1000 / delta;

            this.renderStats.stats.fps = fps;
            this.renderStats.stats.minFPS = Math.min(this.renderStats.stats.minFPS, fps);
            this.renderStats.stats.maxFPS = Math.max(this.renderStats.stats.maxFPS, fps);

            // 计算平均FPS
            this.renderStats.stats.frameCount++;
            const totalFPS = this.renderStats.stats.avgFPS * (this.renderStats.stats.frameCount - 1) + fps;
            this.renderStats.stats.avgFPS = totalFPS / this.renderStats.stats.frameCount;
        }

        this.renderStats.stats.lastFrameTime = now;
        this.saveRenderStats();
    },

    /**
     * 获取渲染统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.renderStats.stats;
    },

    /**
     * 清空缓存
     */
    clearCache: function () {
        this.renderCache.cache = {};
        this.renderCache.stats.size = 0;
        this.saveRenderCache();
    },

    /**
     * 设置渲染配置
     * @param {Object} config - 配置对象
     */
    setRenderConfig: function (config) {
        this.renderConfig = { ...this.renderConfig, ...config };
        this.saveRenderConfig();
    },

    /**
     * 获取渲染配置
     * @returns {Object} 配置对象
     */
    getRenderConfig: function () {
        return this.renderConfig;
    }
};

// 优化：游戏物理优化
const GamePhysicsOptimizer = {
    physicsConfig: {},
    physicsStats: {},
    physicsCache: {},

    /**
     * 初始化游戏物理优化
     */
    init: function () {
        this.loadPhysicsConfig();
        this.loadPhysicsStats();
        this.loadPhysicsCache();
        this.initPhysicsWorld();
        this.optimizePhysics();
    },

    /**
     * 加载物理配置
     */
    loadPhysicsConfig: function () {
        this.physicsConfig = {
            enabled: true,
            gravity: { x: 0, y: 0.5 },
            friction: 0.98,
            restitution: 0.7,
            maxVelocity: 20,
            minVelocity: -20,
            maxAngularVelocity: 10,
            collisionDetection: true,
            collisionResponse: true,
            continuousCollisionDetection: false,
            subSteps: 1,
            fixedTimeStep: 1 / 60,
            maxSubSteps: 3,
            sleep: true,
            sleepTimeLimit: 0.5,
            sleepLinearVelocity: 0.1,
            sleepAngularVelocity: 0.1,
            useSpatialHash: true,
            spatialHashCellSize: 100,
            useQuadTree: false,
            quadTreeMaxObjects: 10,
            quadTreeMaxLevels: 5,
            useBroadPhase: true,
            useNarrowPhase: true,
            optimizationLevel: 'medium'
        };

        const customConfig = localStorage.getItem('physicsConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.physicsConfig = { ...this.physicsConfig, ...config };
            } catch (error) {
                console.error('加载物理配置失败:', error);
            }
        }
    },

    /**
     * 保存物理配置
     */
    savePhysicsConfig: function () {
        localStorage.setItem('physicsConfig', JSON.stringify(this.physicsConfig));
    },

    /**
     * 加载物理统计
     */
    loadPhysicsStats: function () {
        const savedStats = localStorage.getItem('physicsStats');
        if (savedStats) {
            try {
                this.physicsStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载物理统计失败:', error);
            }
        }

        if (!this.physicsStats.stats) {
            this.physicsStats = {
                stats: {
                    totalBodies: 0,
                    activeBodies: 0,
                    sleepingBodies: 0,
                    totalCollisions: 0,
                    totalContacts: 0,
                    collisionChecks: 0,
                    broadPhaseChecks: 0,
                    narrowPhaseChecks: 0,
                    solveTime: 0,
                    updateTime: 0,
                    avgSolveTime: 0,
                    avgUpdateTime: 0
                }
            };

            this.savePhysicsStats();
        }
    },

    /**
     * 保存物理统计
     */
    savePhysicsStats: function () {
        localStorage.setItem('physicsStats', JSON.stringify(this.physicsStats));
    },

    /**
     * 加载物理缓存
     */
    loadPhysicsCache: function () {
        const savedCache = localStorage.getItem('physicsCache');
        if (savedCache) {
            try {
                this.physicsCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载物理缓存失败:', error);
            }
        }

        if (!this.physicsCache.cache) {
            this.physicsCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.savePhysicsCache();
        }
    },

    /**
     * 保存物理缓存
     */
    savePhysicsCache: function () {
        localStorage.setItem('physicsCache', JSON.stringify(this.physicsCache));
    },

    /**
     * 初始化物理世界
     */
    initPhysicsWorld: function () {
        // 初始化空间哈希
        if (this.physicsConfig.useSpatialHash) {
            this.spatialHash = {};
        }

        // 初始化四叉树
        if (this.physicsConfig.useQuadTree) {
            this.quadTree = this.createQuadTree();
        }
    },

    /**
     * 创建四叉树
     * @param {Object} bounds - 边界
     * @param {number} level - 层级
     * @returns {Object} 四叉树
     */
    createQuadTree: function (bounds, level) {
        return {
            bounds: bounds || { x: 0, y: 0, width: 2000, height: 2000 },
            level: level || 0,
            objects: [],
            nodes: [],
            maxObjects: this.physicsConfig.quadTreeMaxObjects,
            maxLevels: this.physicsConfig.quadTreeMaxLevels
        };
    },

    /**
     * 优化物理
     */
    optimizePhysics: function () {
        // 启用空间哈希
        if (this.physicsConfig.useSpatialHash) {
            this.enableSpatialHash();
        }

        // 启用四叉树
        if (this.physicsConfig.useQuadTree) {
            this.enableQuadTree();
        }

        // 启用睡眠
        if (this.physicsConfig.sleep) {
            this.enableSleep();
        }

        // 设置优化级别
        this.setOptimizationLevel(this.physicsConfig.optimizationLevel);
    },

    /**
     * 启用空间哈希
     */
    enableSpatialHash: function () {
        // 实现空间哈希逻辑
    },

    /**
     * 启用四叉树
     */
    enableQuadTree: function () {
        // 实现四叉树逻辑
    },

    /**
     * 启用睡眠
     */
    enableSleep: function () {
        // 实现睡眠逻辑
    },

    /**
     * 设置优化级别
     * @param {string} level - 优化级别
     */
    setOptimizationLevel: function (level) {
        this.physicsConfig.optimizationLevel = level;

        switch (level) {
            case 'low':
                this.physicsConfig.useSpatialHash = false;
                this.physicsConfig.useQuadTree = false;
                this.physicsConfig.useBroadPhase = false;
                this.physicsConfig.continuousCollisionDetection = false;
                this.physicsConfig.subSteps = 1;
                break;
            case 'medium':
                this.physicsConfig.useSpatialHash = true;
                this.physicsConfig.useQuadTree = false;
                this.physicsConfig.useBroadPhase = true;
                this.physicsConfig.continuousCollisionDetection = false;
                this.physicsConfig.subSteps = 2;
                break;
            case 'high':
                this.physicsConfig.useSpatialHash = true;
                this.physicsConfig.useQuadTree = true;
                this.physicsConfig.useBroadPhase = true;
                this.physicsConfig.continuousCollisionDetection = true;
                this.physicsConfig.subSteps = 3;
                break;
        }

        this.savePhysicsConfig();
    },

    /**
     * 更新物理
     * @param {number} deltaTime - 时间增量
     */
    updatePhysics: function (deltaTime) {
        if (!this.physicsConfig.enabled) {
            return;
        }

        const startTime = Date.now();

        // 固定时间步长
        const fixedTimeStep = this.physicsConfig.fixedTimeStep;
        const maxSubSteps = this.physicsConfig.maxSubSteps;

        let accumulatedTime = deltaTime;
        let steps = 0;

        while (accumulatedTime >= fixedTimeStep && steps < maxSubSteps) {
            this.stepPhysics(fixedTimeStep);
            accumulatedTime -= fixedTimeStep;
            steps++;
        }

        const endTime = Date.now();
        const updateTime = endTime - startTime;

        // 更新统计
        this.physicsStats.stats.updateTime = updateTime;
        this.physicsStats.stats.avgUpdateTime =
            (this.physicsStats.stats.avgUpdateTime + updateTime) / 2;

        this.savePhysicsStats();
    },

    /**
     * 物理步进
     * @param {number} deltaTime - 时间增量
     */
    stepPhysics: function (deltaTime) {
        const startTime = Date.now();

        // 应用重力
        this.applyGravity(deltaTime);

        // 应用摩擦力
        this.applyFriction(deltaTime);

        // 碰撞检测
        if (this.physicsConfig.collisionDetection) {
            this.detectCollisions(deltaTime);
        }

        // 碰撞响应
        if (this.physicsConfig.collisionResponse) {
            this.resolveCollisions(deltaTime);
        }

        // 更新位置
        this.updatePositions(deltaTime);

        // 检查睡眠
        if (this.physicsConfig.sleep) {
            this.checkSleep(deltaTime);
        }

        const endTime = Date.now();
        const solveTime = endTime - startTime;

        // 更新统计
        this.physicsStats.stats.solveTime = solveTime;
        this.physicsStats.stats.avgSolveTime =
            (this.physicsStats.stats.avgSolveTime + solveTime) / 2;

        this.savePhysicsStats();
    },

    /**
     * 应用重力
     * @param {number} deltaTime - 时间增量
     */
    applyGravity: function (deltaTime) {
        // 实现重力应用逻辑
    },

    /**
     * 应用摩擦力
     * @param {number} deltaTime - 时间增量
     */
    applyFriction: function (deltaTime) {
        // 实现摩擦力应用逻辑
    },

    /**
     * 碰撞检测
     * @param {number} deltaTime - 时间增量
     */
    detectCollisions: function (deltaTime) {
        // 实现碰撞检测逻辑
    },

    /**
     * 碰撞响应
     * @param {number} deltaTime - 时间增量
     */
    resolveCollisions: function (deltaTime) {
        // 实现碰撞响应逻辑
    },

    /**
     * 更新位置
     * @param {number} deltaTime - 时间增量
     */
    updatePositions: function (deltaTime) {
        // 实现位置更新逻辑
    },

    /**
     * 检查睡眠
     * @param {number} deltaTime - 时间增量
     */
    checkSleep: function (deltaTime) {
        // 实现睡眠检查逻辑
    },

    /**
     * 获取物理统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.physicsStats.stats;
    },

    /**
     * 设置物理配置
     * @param {Object} config - 配置对象
     */
    setPhysicsConfig: function (config) {
        this.physicsConfig = { ...this.physicsConfig, ...config };
        this.savePhysicsConfig();
    },

    /**
     * 获取物理配置
     * @returns {Object} 配置对象
     */
    getPhysicsConfig: function () {
        return this.physicsConfig;
    }
};

// 优化：游戏AI优化
const GameAIOptimizer = {
    aiConfig: {},
    aiStats: {},
    aiCache: {},

    /**
     * 初始化游戏AI优化
     */
    init: function () {
        this.loadAIConfig();
        this.loadAIStats();
        this.loadAICache();
        this.initAIWorld();
        this.optimizeAI();
    },

    /**
     * 加载AI配置
     */
    loadAIConfig: function () {
        this.aiConfig = {
            enabled: true,
            usePathfinding: true,
            pathfindingAlgorithm: 'A*',
            useBehaviorTree: true,
            useStateMachine: true,
            useUtilityAI: false,
            useNeuralNetwork: false,
            useGeneticAlgorithm: false,
            maxPathfindingNodes: 1000,
            maxPathfindingTime: 100,
            pathfindingHeuristic: 'manhattan',
            behaviorTreeUpdateInterval: 100,
            stateMachineUpdateInterval: 50,
            utilityAIUpdateInterval: 100,
            neuralNetworkUpdateInterval: 1000,
            geneticAlgorithmUpdateInterval: 5000,
            aiDifficulty: 'medium',
            difficultyLevels: ['easy', 'medium', 'hard', 'expert'],
            learningEnabled: false,
            learningRate: 0.1,
            explorationRate: 0.1,
            memorySize: 1000
        };

        const customConfig = localStorage.getItem('aiConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.aiConfig = { ...this.aiConfig, ...config };
            } catch (error) {
                console.error('加载AI配置失败:', error);
            }
        }
    },

    /**
     * 保存AI配置
     */
    saveAIConfig: function () {
        localStorage.setItem('aiConfig', JSON.stringify(this.aiConfig));
    },

    /**
     * 加载AI统计
     */
    loadAIStats: function () {
        const savedStats = localStorage.getItem('aiStats');
        if (savedStats) {
            try {
                this.aiStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载AI统计失败:', error);
            }
        }

        if (!this.aiStats.stats) {
            this.aiStats = {
                stats: {
                    totalAgents: 0,
                    activeAgents: 0,
                    totalDecisions: 0,
                    totalActions: 0,
                    totalPathfinding: 0,
                    totalPathfindingTime: 0,
                    avgPathfindingTime: 0,
                    totalBehaviorTreeUpdates: 0,
                    totalStateMachineUpdates: 0,
                    totalUtilityAIUpdates: 0,
                    totalNeuralNetworkUpdates: 0,
                    totalGeneticAlgorithmUpdates: 0,
                    learningEpisodes: 0,
                    learningRewards: 0,
                    avgLearningReward: 0
                }
            };

            this.saveAIStats();
        }
    },

    /**
     * 保存AI统计
     */
    saveAIStats: function () {
        localStorage.setItem('aiStats', JSON.stringify(this.aiStats));
    },

    /**
     * 加载AI缓存
     */
    loadAICache: function () {
        const savedCache = localStorage.getItem('aiCache');
        if (savedCache) {
            try {
                this.aiCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载AI缓存失败:', error);
            }
        }

        if (!this.aiCache.cache) {
            this.aiCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveAICache();
        }
    },

    /**
     * 保存AI缓存
     */
    saveAICache: function () {
        localStorage.setItem('aiCache', JSON.stringify(this.aiCache));
    },

    /**
     * 初始化AI世界
     */
    initAIWorld: function () {
        // 初始化行为树
        if (this.aiConfig.useBehaviorTree) {
            this.initBehaviorTree();
        }

        // 初始化状态机
        if (this.aiConfig.useStateMachine) {
            this.initStateMachine();
        }

        // 初始化效用AI
        if (this.aiConfig.useUtilityAI) {
            this.initUtilityAI();
        }

        // 初始化神经网络
        if (this.aiConfig.useNeuralNetwork) {
            this.initNeuralNetwork();
        }

        // 初始化遗传算法
        if (this.aiConfig.useGeneticAlgorithm) {
            this.initGeneticAlgorithm();
        }
    },

    /**
     * 初始化行为树
     */
    initBehaviorTree: function () {
        this.behaviorTree = {
            root: null,
            nodes: [],
            blackboard: {}
        };
    },

    /**
     * 初始化状态机
     */
    initStateMachine: function () {
        this.stateMachine = {
            currentState: null,
            states: {},
            transitions: {}
        };
    },

    /**
     * 初始化效用AI
     */
    initUtilityAI: function () {
        this.utilityAI = {
            actions: [],
            considerations: [],
            scores: {}
        };
    },

    /**
     * 初始化神经网络
     */
    initNeuralNetwork: function () {
        this.neuralNetwork = {
            layers: [],
            weights: [],
            biases: []
        };
    },

    /**
     * 初始化遗传算法
     */
    initGeneticAlgorithm: function () {
        this.geneticAlgorithm = {
            population: [],
            generation: 0,
            fitness: [],
            mutationRate: 0.1,
            crossoverRate: 0.8
        };
    },

    /**
     * 优化AI
     */
    optimizeAI: function () {
        // 启用路径查找
        if (this.aiConfig.usePathfinding) {
            this.enablePathfinding();
        }

        // 启用行为树
        if (this.aiConfig.useBehaviorTree) {
            this.enableBehaviorTree();
        }

        // 启用状态机
        if (this.aiConfig.useStateMachine) {
            this.enableStateMachine();
        }

        // 设置AI难度
        this.setAIDifficulty(this.aiConfig.aiDifficulty);
    },

    /**
     * 启用路径查找
     */
    enablePathfinding: function () {
        // 实现路径查找逻辑
    },

    /**
     * 启用行为树
     */
    enableBehaviorTree: function () {
        // 实现行为树逻辑
    },

    /**
     * 启用状态机
     */
    enableStateMachine: function () {
        // 实现状态机逻辑
    },

    /**
     * 设置AI难度
     * @param {string} difficulty - 难度级别
     */
    setAIDifficulty: function (difficulty) {
        if (!this.aiConfig.difficultyLevels.includes(difficulty)) {
            return;
        }

        this.aiConfig.aiDifficulty = difficulty;
        this.saveAIConfig();

        // 根据难度调整AI参数
        switch (difficulty) {
            case 'easy':
                this.aiConfig.pathfindingAlgorithm = 'BFS';
                this.aiConfig.pathfindingHeuristic = 'none';
                this.aiConfig.learningRate = 0.05;
                this.aiConfig.explorationRate = 0.2;
                break;
            case 'medium':
                this.aiConfig.pathfindingAlgorithm = 'A*';
                this.aiConfig.pathfindingHeuristic = 'manhattan';
                this.aiConfig.learningRate = 0.1;
                this.aiConfig.explorationRate = 0.1;
                break;
            case 'hard':
                this.aiConfig.pathfindingAlgorithm = 'A*';
                this.aiConfig.pathfindingHeuristic = 'euclidean';
                this.aiConfig.learningRate = 0.15;
                this.aiConfig.explorationRate = 0.05;
                break;
            case 'expert':
                this.aiConfig.pathfindingAlgorithm = 'D*';
                this.aiConfig.pathfindingHeuristic = 'euclidean';
                this.aiConfig.learningRate = 0.2;
                this.aiConfig.explorationRate = 0.01;
                break;
        }
    },

    /**
     * 路径查找
     * @param {Object} start - 起点
     * @param {Object} end - 终点
     * @returns {Array} 路径
     */
    findPath: function (start, end) {
        if (!this.aiConfig.usePathfinding) {
            return [];
        }

        const startTime = Date.now();

        let path = [];

        switch (this.aiConfig.pathfindingAlgorithm) {
            case 'BFS':
                path = this.bfsPathfinding(start, end);
                break;
            case 'DFS':
                path = this.dfsPathfinding(start, end);
                break;
            case 'A*':
                path = this.asteriskPathfinding(start, end);
                break;
            case 'D*':
                path = this.dstarPathfinding(start, end);
                break;
        }

        const endTime = Date.now();
        const pathfindingTime = endTime - startTime;

        // 更新统计
        this.aiStats.stats.totalPathfinding++;
        this.aiStats.stats.totalPathfindingTime += pathfindingTime;
        this.aiStats.stats.avgPathfindingTime =
            this.aiStats.stats.totalPathfindingTime / this.aiStats.stats.totalPathfinding;

        this.saveAIStats();

        return path;
    },

    /**
     * BFS路径查找
     * @param {Object} start - 起点
     * @param {Object} end - 终点
     * @returns {Array} 路径
     */
    bfsPathfinding: function (start, end) {
        // 实现BFS路径查找逻辑
        return [];
    },

    /**
     * DFS路径查找
     * @param {Object} start - 起点
     * @param {Object} end - 终点
     * @returns {Array} 路径
     */
    dfsPathfinding: function (start, end) {
        // 实现DFS路径查找逻辑
        return [];
    },

    /**
     * A*路径查找
     * @param {Object} start - 起点
     * @param {Object} end - 终点
     * @returns {Array} 路径
     */
    asteriskPathfinding: function (start, end) {
        // 实现A*路径查找逻辑
        return [];
    },

    /**
     * D*路径查找
     * @param {Object} start - 起点
     * @param {Object} end - 终点
     * @returns {Array} 路径
     */
    dstarPathfinding: function (start, end) {
        // 实现D*路径查找逻辑
        return [];
    },

    /**
     * 更新行为树
     */
    updateBehaviorTree: function () {
        // 实现行为树更新逻辑
    },

    /**
     * 更新状态机
     */
    updateStateMachine: function () {
        // 实现状态机更新逻辑
    },

    /**
     * 更新效用AI
     */
    updateUtilityAI: function () {
        // 实现效用AI更新逻辑
    },

    /**
     * 更新神经网络
     */
    updateNeuralNetwork: function () {
        // 实现神经网络更新逻辑
    },

    /**
     * 更新遗传算法
     */
    updateGeneticAlgorithm: function () {
        // 实现遗传算法更新逻辑
    },

    /**
     * 获取AI统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.aiStats.stats;
    },

    /**
     * 设置AI配置
     * @param {Object} config - 配置对象
     */
    setAIConfig: function (config) {
        this.aiConfig = { ...this.aiConfig, ...config };
        this.saveAIConfig();
    },

    /**
     * 获取AI配置
     * @returns {Object} 配置对象
     */
    getAIConfig: function () {
        return this.aiConfig;
    }
};

// 优化：游戏音频优化
const GameAudioOptimizer = {
    audioConfig: {},
    audioStats: {},
    audioCache: {},

    /**
     * 初始化游戏音频优化
     */
    init: function () {
        this.loadAudioConfig();
        this.loadAudioStats();
        this.loadAudioCache();
        this.initAudioContext();
        this.optimizeAudio();
    },

    /**
     * 加载音频配置
     */
    loadAudioConfig: function () {
        this.audioConfig = {
            enabled: true,
            masterVolume: 1.0,
            musicVolume: 0.7,
            sfxVolume: 0.8,
            voiceVolume: 0.9,
            maxConcurrentSounds: 32,
            maxSoundDuration: 60,
            useWebAudioAPI: true,
            useAudioCompression: false,
            useAudioStreaming: true,
            useAudioPool: true,
            audioPoolSize: 10,
            preloadSounds: true,
            lazyLoadSounds: false,
            useSpatialAudio: false,
            use3DAudio: false,
            useAudioEffects: true,
            useAudioFilters: false,
            useAudioNormalization: false,
            audioQuality: 'medium',
            qualityLevels: ['low', 'medium', 'high'],
            sampleRate: 44100,
            bufferSize: 4096,
            audioLatency: 'interactive'
        };

        const customConfig = localStorage.getItem('audioConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.audioConfig = { ...this.audioConfig, ...config };
            } catch (error) {
                console.error('加载音频配置失败:', error);
            }
        }
    },

    /**
     * 保存音频配置
     */
    saveAudioConfig: function () {
        localStorage.setItem('audioConfig', JSON.stringify(this.audioConfig));
    },

    /**
     * 加载音频统计
     */
    loadAudioStats: function () {
        const savedStats = localStorage.getItem('audioStats');
        if (savedStats) {
            try {
                this.audioStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载音频统计失败:', error);
            }
        }

        if (!this.audioStats.stats) {
            this.audioStats = {
                stats: {
                    totalSounds: 0,
                    activeSounds: 0,
                    totalMusic: 0,
                    activeMusic: 0,
                    totalSFX: 0,
                    activeSFX: 0,
                    totalVoice: 0,
                    activeVoice: 0,
                    totalPlayTime: 0,
                    avgPlayTime: 0,
                    cacheHits: 0,
                    cacheMisses: 0,
                    cacheHitRate: 0
                }
            };

            this.saveAudioStats();
        }
    },

    /**
     * 保存音频统计
     */
    saveAudioStats: function () {
        localStorage.setItem('audioStats', JSON.stringify(this.audioStats));
    },

    /**
     * 加载音频缓存
     */
    loadAudioCache: function () {
        const savedCache = localStorage.getItem('audioCache');
        if (savedCache) {
            try {
                this.audioCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载音频缓存失败:', error);
            }
        }

        if (!this.audioCache.cache) {
            this.audioCache = {
                cache: {},
                stats: {
                    size: 0,
                    maxSize: 100,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveAudioCache();
        }
    },

    /**
     * 保存音频缓存
     */
    saveAudioCache: function () {
        localStorage.setItem('audioCache', JSON.stringify(this.audioCache));
    },

    /**
     * 初始化音频上下文
     */
    initAudioContext: function () {
        if (!this.audioConfig.useWebAudioAPI) {
            return;
        }

        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.audioContext = new AudioContext({
                sampleRate: this.audioConfig.sampleRate,
                latencyHint: this.audioConfig.audioLatency
            });

            // 创建主音量节点
            this.masterGain = this.audioContext.createGain();
            this.masterGain.connect(this.audioContext.destination);
            this.masterGain.gain.value = this.audioConfig.masterVolume;

            // 创建音乐音量节点
            this.musicGain = this.audioContext.createGain();
            this.musicGain.connect(this.masterGain);
            this.musicGain.gain.value = this.audioConfig.musicVolume;

            // 创建音效音量节点
            this.sfxGain = this.audioContext.createGain();
            this.sfxGain.connect(this.masterGain);
            this.sfxGain.gain.value = this.audioConfig.sfxVolume;

            // 创建语音音量节点
            this.voiceGain = this.audioContext.createGain();
            this.voiceGain.connect(this.masterGain);
            this.voiceGain.gain.value = this.audioConfig.voiceVolume;

            // 初始化音频池
            if (this.audioConfig.useAudioPool) {
                this.initAudioPool();
            }
        } catch (error) {
            console.error('初始化音频上下文失败:', error);
        }
    },

    /**
     * 初始化音频池
     */
    initAudioPool: function () {
        this.audioPool = [];

        for (let i = 0; i < this.audioConfig.audioPoolSize; i++) {
            const audioSource = this.audioContext.createBufferSource();
            audioSource.connect(this.sfxGain);
            this.audioPool.push(audioSource);
        }
    },

    /**
     * 优化音频
     */
    optimizeAudio: function () {
        // 启用音频压缩
        if (this.audioConfig.useAudioCompression) {
            this.enableAudioCompression();
        }

        // 启用音频流式传输
        if (this.audioConfig.useAudioStreaming) {
            this.enableAudioStreaming();
        }

        // 启用空间音频
        if (this.audioConfig.useSpatialAudio) {
            this.enableSpatialAudio();
        }

        // 设置音频质量
        this.setAudioQuality(this.audioConfig.audioQuality);
    },

    /**
     * 启用音频压缩
     */
    enableAudioCompression: function () {
        // 实现音频压缩逻辑
    },

    /**
     * 启用音频流式传输
     */
    enableAudioStreaming: function () {
        // 实现音频流式传输逻辑
    },

    /**
     * 启用空间音频
     */
    enableSpatialAudio: function () {
        // 实现空间音频逻辑
    },

    /**
     * 设置音频质量
     * @param {string} quality - 质量级别
     */
    setAudioQuality: function (quality) {
        if (!this.audioConfig.qualityLevels.includes(quality)) {
            return;
        }

        this.audioConfig.audioQuality = quality;
        this.saveAudioConfig();

        // 根据质量级别调整音频参数
        switch (quality) {
            case 'low':
                this.audioConfig.sampleRate = 22050;
                this.audioConfig.bufferSize = 8192;
                this.audioConfig.useAudioCompression = true;
                this.audioConfig.useAudioStreaming = true;
                break;
            case 'medium':
                this.audioConfig.sampleRate = 44100;
                this.audioConfig.bufferSize = 4096;
                this.audioConfig.useAudioCompression = false;
                this.audioConfig.useAudioStreaming = true;
                break;
            case 'high':
                this.audioConfig.sampleRate = 48000;
                this.audioConfig.bufferSize = 2048;
                this.audioConfig.useAudioCompression = false;
                this.audioConfig.useAudioStreaming = false;
                break;
        }
    },

    /**
     * 播放声音
     * @param {string} soundId - 声音ID
     * @param {Object} options - 播放选项
     * @returns {Object} 播放结果
     */
    playSound: function (soundId, options) {
        if (!this.audioConfig.enabled) {
            return {
                success: false,
                error: '音频已禁用'
            };
        }

        options = options || {};

        // 检查并发声音数量
        if (this.audioStats.stats.activeSounds >= this.audioConfig.maxConcurrentSounds) {
            return {
                success: false,
                error: '达到最大并发声音数量'
            };
        }

        // 从缓存获取声音
        const cachedSound = this.getCachedSound(soundId);

        if (cachedSound) {
            // 使用缓存的声音
            this.playBuffer(cachedSound, options);
        } else {
            // 加载声音
            this.loadSound(soundId, options);
        }

        return {
            success: true,
            soundId: soundId
        };
    },

    /**
     * 播放缓冲区
     * @param {AudioBuffer} buffer - 音频缓冲区
     * @param {Object} options - 播放选项
     */
    playBuffer: function (buffer, options) {
        const audioSource = this.audioContext.createBufferSource();
        audioSource.buffer = buffer;

        // 创建增益节点
        const gainNode = this.audioContext.createGain();

        // 根据类型连接到不同的增益节点
        switch (options.type) {
            case 'music':
                gainNode.connect(this.musicGain);
                break;
            case 'sfx':
                gainNode.connect(this.sfxGain);
                break;
            case 'voice':
                gainNode.connect(this.voiceGain);
                break;
            default:
                gainNode.connect(this.sfxGain);
        }

        // 设置音量
        gainNode.gain.value = options.volume || 1.0;

        // 设置循环
        audioSource.loop = options.loop || false;

        // 设置播放速度
        audioSource.playbackRate.value = options.playbackRate || 1.0;

        // 播放
        audioSource.start(0, options.offset || 0);

        // 更新统计
        this.audioStats.stats.activeSounds++;

        if (options.type === 'music') {
            this.audioStats.stats.activeMusic++;
        } else if (options.type === 'sfx') {
            this.audioStats.stats.activeSFX++;
        } else if (options.type === 'voice') {
            this.audioStats.stats.activeVoice++;
        }

        // 监听播放结束
        audioSource.onended = () => {
            this.audioStats.stats.activeSounds--;

            if (options.type === 'music') {
                this.audioStats.stats.activeMusic--;
            } else if (options.type === 'sfx') {
                this.audioStats.stats.activeSFX--;
            } else if (options.type === 'voice') {
                this.audioStats.stats.activeVoice--;
            }

            this.saveAudioStats();
        };

        this.saveAudioStats();
    },

    /**
     * 加载声音
     * @param {string} soundId - 声音ID
     * @param {Object} options - 加载选项
     */
    loadSound: function (soundId, options) {
        // 实现声音加载逻辑
    },

    /**
     * 缓存声音
     * @param {string} soundId - 声音ID
     * @param {AudioBuffer} buffer - 音频缓冲区
     */
    cacheSound: function (soundId, buffer) {
        if (Object.keys(this.audioCache.cache).length >= this.audioCache.stats.maxSize) {
            // 删除最旧的缓存项
            const oldestKey = Object.keys(this.audioCache.cache)[0];
            delete this.audioCache.cache[oldestKey];
        }

        this.audioCache.cache[soundId] = {
            buffer: buffer,
            timestamp: Date.now()
        };

        this.audioCache.stats.size = Object.keys(this.audioCache.cache).length;
        this.saveAudioCache();
    },

    /**
     * 获取缓存声音
     * @param {string} soundId - 声音ID
     * @returns {AudioBuffer|null} 音频缓冲区
     */
    getCachedSound: function (soundId) {
        const cached = this.audioCache.cache[soundId];

        if (cached) {
            this.audioCache.stats.hits++;
        } else {
            this.audioCache.stats.misses++;
        }

        // 更新缓存命中率
        const total = this.audioCache.stats.hits + this.audioCache.stats.misses;
        this.audioCache.stats.hitRate = total > 0 ? (this.audioCache.stats.hits / total) * 100 : 0;

        this.saveAudioCache();

        return cached ? cached.buffer : null;
    },

    /**
     * 停止声音
     * @param {string} soundId - 声音ID
     */
    stopSound: function (soundId) {
        // 实现停止声音逻辑
    },

    /**
     * 暂停声音
     * @param {string} soundId - 声音ID
     */
    pauseSound: function (soundId) {
        // 实现暂停声音逻辑
    },

    /**
     * 恢复声音
     * @param {string} soundId - 声音ID
     */
    resumeSound: function (soundId) {
        // 实现恢复声音逻辑
    },

    /**
     * 设置主音量
     * @param {number} volume - 音量(0-1)
     */
    setMasterVolume: function (volume) {
        this.audioConfig.masterVolume = Math.max(0, Math.min(1, volume));

        if (this.masterGain) {
            this.masterGain.gain.value = this.audioConfig.masterVolume;
        }

        this.saveAudioConfig();
    },

    /**
     * 设置音乐音量
     * @param {number} volume - 音量(0-1)
     */
    setMusicVolume: function (volume) {
        this.audioConfig.musicVolume = Math.max(0, Math.min(1, volume));

        if (this.musicGain) {
            this.musicGain.gain.value = this.audioConfig.musicVolume;
        }

        this.saveAudioConfig();
    },

    /**
     * 设置音效音量
     * @param {number} volume - 音量(0-1)
     */
    setSFXVolume: function (volume) {
        this.audioConfig.sfxVolume = Math.max(0, Math.min(1, volume));

        if (this.sfxGain) {
            this.sfxGain.gain.value = this.audioConfig.sfxVolume;
        }

        this.saveAudioConfig();
    },

    /**
     * 设置语音音量
     * @param {number} volume - 音量(0-1)
     */
    setVoiceVolume: function (volume) {
        this.audioConfig.voiceVolume = Math.max(0, Math.min(1, volume));

        if (this.voiceGain) {
            this.voiceGain.gain.value = this.audioConfig.voiceVolume;
        }

        this.saveAudioConfig();
    },

    /**
     * 获取音频统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.audioStats.stats;
    },

    /**
     * 设置音频配置
     * @param {Object} config - 配置对象
     */
    setAudioConfig: function (config) {
        this.audioConfig = { ...this.audioConfig, ...config };
        this.saveAudioConfig();
    },

    /**
     * 获取音频配置
     * @returns {Object} 配置对象
     */
    getAudioConfig: function () {
        return this.audioConfig;
    }
};

// 优化：游戏输入优化
const GameInputOptimizer = {
    inputConfig: {},
    inputStats: {},
    inputCache: {},

    /**
     * 初始化游戏输入优化
     */
    init: function () {
        this.loadInputConfig();
        this.loadInputStats();
        this.loadInputCache();
        this.initInputSystem();
        this.optimizeInput();
    },

    /**
     * 加载输入配置
     */
    loadInputConfig: function () {
        this.inputConfig = {
            enabled: true,
            useKeyboard: true,
            useMouse: true,
            useTouch: true,
            useGamepad: true,
            useGyro: false,
            useAccelerometer: false,
            maxInputDelay: 16,
            inputSmoothing: true,
            smoothingFactor: 0.1,
            inputBuffering: true,
            bufferSize: 10,
            inputPrediction: true,
            predictionTime: 50,
            useInputMapping: true,
            useInputRemapping: true,
            useInputRecording: false,
            useInputPlayback: false,
            inputSensitivity: 1.0,
            deadZone: 0.1,
            repeatDelay: 500,
            repeatRate: 50,
            doubleTapTime: 300,
            longPressTime: 500
        };

        const customConfig = localStorage.getItem('inputConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.inputConfig = { ...this.inputConfig, ...config };
            } catch (error) {
                console.error('加载输入配置失败:', error);
            }
        }
    },

    /**
     * 保存输入配置
     */
    saveInputConfig: function () {
        localStorage.setItem('inputConfig', JSON.stringify(this.inputConfig));
    },

    /**
     * 加载输入统计
     */
    loadInputStats: function () {
        const savedStats = localStorage.getItem('inputStats');
        if (savedStats) {
            try {
                this.inputStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载输入统计失败:', error);
            }
        }

        if (!this.inputStats.stats) {
            this.inputStats = {
                stats: {
                    totalInputs: 0,
                    keyboardInputs: 0,
                    mouseInputs: 0,
                    touchInputs: 0,
                    gamepadInputs: 0,
                    gyroInputs: 0,
                    accelerometerInputs: 0,
                    avgInputDelay: 0,
                    maxInputDelay: 0,
                    minInputDelay: 0,
                    totalInputTime: 0
                }
            };

            this.saveInputStats();
        }
    },

    /**
     * 保存输入统计
     */
    saveInputStats: function () {
        localStorage.setItem('inputStats', JSON.stringify(this.inputStats));
    },

    /**
     * 加载输入缓存
     */
    loadInputCache: function () {
        const savedCache = localStorage.getItem('inputCache');
        if (savedCache) {
            try {
                this.inputCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载输入缓存失败:', error);
            }
        }

        if (!this.inputCache.cache) {
            this.inputCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveInputCache();
        }
    },

    /**
     * 保存输入缓存
     */
    saveInputCache: function () {
        localStorage.setItem('inputCache', JSON.stringify(this.inputCache));
    },

    /**
     * 初始化输入系统
     */
    initInputSystem: function () {
        // 初始化键盘输入
        if (this.inputConfig.useKeyboard) {
            this.initKeyboard();
        }

        // 初始化鼠标输入
        if (this.inputConfig.useMouse) {
            this.initMouse();
        }

        // 初始化触摸输入
        if (this.inputConfig.useTouch) {
            this.initTouch();
        }

        // 初始化游戏手柄输入
        if (this.inputConfig.useGamepad) {
            this.initGamepad();
        }

        // 初始化陀螺仪输入
        if (this.inputConfig.useGyro) {
            this.initGyro();
        }

        // 初始化加速度计输入
        if (this.inputConfig.useAccelerometer) {
            this.initAccelerometer();
        }

        // 初始化输入缓冲区
        if (this.inputConfig.inputBuffering) {
            this.inputBuffer = [];
        }
    },

    /**
     * 初始化键盘
     */
    initKeyboard: function () {
        this.keyboardState = {};
        this.keyboardMapping = {
            'ArrowLeft': 'left',
            'ArrowRight': 'right',
            'ArrowUp': 'up',
            'ArrowDown': 'down',
            'Space': 'jump',
            'KeyZ': 'attack',
            'KeyX': 'special'
        };

        document.addEventListener('keydown', (e) => this.handleKeyDown(e));
        document.addEventListener('keyup', (e) => this.handleKeyUp(e));
    },

    /**
     * 初始化鼠标
     */
    initMouse: function () {
        this.mouseState = {
            x: 0,
            y: 0,
            buttons: {},
            wheel: 0
        };

        document.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        document.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        document.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        document.addEventListener('wheel', (e) => this.handleMouseWheel(e));
    },

    /**
     * 初始化触摸
     */
    initTouch: function () {
        this.touchState = {
            touches: [],
            timestamp: 0
        };

        document.addEventListener('touchstart', (e) => this.handleTouchStart(e));
        document.addEventListener('touchmove', (e) => this.handleTouchMove(e));
        document.addEventListener('touchend', (e) => this.handleTouchEnd(e));
    },

    /**
     * 初始化游戏手柄
     */
    initGamepad: function () {
        this.gamepadState = {};
        this.gamepadMapping = {};

        window.addEventListener('gamepadconnected', (e) => this.handleGamepadConnected(e));
        window.addEventListener('gamepaddisconnected', (e) => this.handleGamepadDisconnected(e));
    },

    /**
     * 初始化陀螺仪
     */
    initGyro: function () {
        this.gyroState = {
            alpha: 0,
            beta: 0,
            gamma: 0,
            timestamp: 0
        };

        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', (e) => this.handleDeviceOrientation(e));
        }
    },

    /**
     * 初始化加速度计
     */
    initAccelerometer: function () {
        this.accelerometerState = {
            x: 0,
            y: 0,
            z: 0,
            timestamp: 0
        };

        if (window.DeviceMotionEvent) {
            window.addEventListener('devicemotion', (e) => this.handleDeviceMotion(e));
        }
    },

    /**
     * 优化输入
     */
    optimizeInput: function () {
        // 启用输入平滑
        if (this.inputConfig.inputSmoothing) {
            this.enableInputSmoothing();
        }

        // 启用输入缓冲
        if (this.inputConfig.inputBuffering) {
            this.enableInputBuffering();
        }

        // 启用输入预测
        if (this.inputConfig.inputPrediction) {
            this.enableInputPrediction();
        }
    },

    /**
     * 启用输入平滑
     */
    enableInputSmoothing: function () {
        // 实现输入平滑逻辑
    },

    /**
     * 启用输入缓冲
     */
    enableInputBuffering: function () {
        // 实现输入缓冲逻辑
    },

    /**
     * 启用输入预测
     */
    enableInputPrediction: function () {
        // 实现输入预测逻辑
    },

    /**
     * 处理键盘按下
     * @param {KeyboardEvent} e - 键盘事件
     */
    handleKeyDown: function (e) {
        if (!this.inputConfig.enabled || !this.inputConfig.useKeyboard) {
            return;
        }

        const startTime = Date.now();

        // 更新键盘状态
        this.keyboardState[e.code] = true;

        // 获取映射的动作
        const action = this.keyboardMapping[e.code];

        if (action) {
            // 添加到输入缓冲区
            if (this.inputConfig.inputBuffering) {
                this.addToInputBuffer({
                    type: 'keyboard',
                    action: action,
                    key: e.code,
                    timestamp: startTime
                });
            }

            // 更新统计
            this.inputStats.stats.totalInputs++;
            this.inputStats.stats.keyboardInputs++;
        }

        const endTime = Date.now();
        const delay = endTime - startTime;

        // 更新延迟统计
        this.inputStats.stats.avgInputDelay =
            (this.inputStats.stats.avgInputDelay + delay) / 2;
        this.inputStats.stats.maxInputDelay = Math.max(this.inputStats.stats.maxInputDelay, delay);
        this.inputStats.stats.minInputDelay = Math.min(this.inputStats.stats.minInputDelay, delay);

        this.saveInputStats();
    },

    /**
     * 处理键盘释放
     * @param {KeyboardEvent} e - 键盘事件
     */
    handleKeyUp: function (e) {
        if (!this.inputConfig.enabled || !this.inputConfig.useKeyboard) {
            return;
        }

        // 更新键盘状态
        this.keyboardState[e.code] = false;

        // 获取映射的动作
        const action = this.keyboardMapping[e.code];

        if (action) {
            // 添加到输入缓冲区
            if (this.inputConfig.inputBuffering) {
                this.addToInputBuffer({
                    type: 'keyboard',
                    action: action,
                    key: e.code,
                    pressed: false,
                    timestamp: Date.now()
                });
            }
        }

        this.saveInputStats();
    },

    /**
     * 处理鼠标移动
     * @param {MouseEvent} e - 鼠标事件
     */
    handleMouseMove: function (e) {
        if (!this.inputConfig.enabled || !this.inputConfig.useMouse) {
            return;
        }

        this.mouseState.x = e.clientX;
        this.mouseState.y = e.clientY;

        // 添加到输入缓冲区
        if (this.inputConfig.inputBuffering) {
            this.addToInputBuffer({
                type: 'mouse',
                action: 'move',
                x: e.clientX,
                y: e.clientY,
                timestamp: Date.now()
            });
        }

        this.inputStats.stats.totalInputs++;
        this.inputStats.stats.mouseInputs++;

        this.saveInputStats();
    },

    /**
     * 处理鼠标按下
     * @param {MouseEvent} e - 鼠标事件
     */
    handleMouseDown: function (e) {
        if (!this.inputConfig.enabled || !this.inputConfig.useMouse) {
            return;
        }

        this.mouseState.buttons[e.button] = true;

        // 添加到输入缓冲区
        if (this.inputConfig.inputBuffering) {
            this.addToInputBuffer({
                type: 'mouse',
                action: 'click',
                button: e.button,
                x: e.clientX,
                y: e.clientY,
                timestamp: Date.now()
            });
        }

        this.inputStats.stats.totalInputs++;
        this.inputStats.stats.mouseInputs++;

        this.saveInputStats();
    },

    /**
     * 处理鼠标释放
     * @param {MouseEvent} e - 鼠标事件
     */
    handleMouseUp: function (e) {
        if (!this.inputConfig.enabled || !this.inputConfig.useMouse) {
            return;
        }

        this.mouseState.buttons[e.button] = false;

        this.saveInputStats();
    },

    /**
     * 处理鼠标滚轮
     * @param {WheelEvent} e - 滚轮事件
     */
    handleMouseWheel: function (e) {
        if (!this.inputConfig.enabled || !this.inputConfig.useMouse) {
            return;
        }

        this.mouseState.wheel = e.deltaY;

        // 添加到输入缓冲区
        if (this.inputConfig.inputBuffering) {
            this.addToInputBuffer({
                type: 'mouse',
                action: 'wheel',
                delta: e.deltaY,
                timestamp: Date.now()
            });
        }

        this.inputStats.stats.totalInputs++;
        this.inputStats.stats.mouseInputs++;

        this.saveInputStats();
    },

    /**
     * 处理触摸开始
     * @param {TouchEvent} e - 触摸事件
     */
    handleTouchStart: function (e) {
        if (!this.inputConfig.enabled || !this.inputConfig.useTouch) {
            return;
        }

        // 添加到输入缓冲区
        if (this.inputConfig.inputBuffering) {
            for (const touch of e.touches) {
                this.addToInputBuffer({
                    type: 'touch',
                    action: 'start',
                    identifier: touch.identifier,
                    x: touch.clientX,
                    y: touch.clientY,
                    timestamp: Date.now()
                });
            }
        }

        this.inputStats.stats.totalInputs++;
        this.inputStats.stats.touchInputs++;

        this.saveInputStats();
    },

    /**
     * 处理触摸移动
     * @param {TouchEvent} e - 触摸事件
     */
    handleTouchMove: function (e) {
        if (!this.inputConfig.enabled || !this.inputConfig.useTouch) {
            return;
        }

        // 添加到输入缓冲区
        if (this.inputConfig.inputBuffering) {
            for (const touch of e.touches) {
                this.addToInputBuffer({
                    type: 'touch',
                    action: 'move',
                    identifier: touch.identifier,
                    x: touch.clientX,
                    y: touch.clientY,
                    timestamp: Date.now()
                });
            }
        }

        this.inputStats.stats.totalInputs++;
        this.inputStats.stats.touchInputs++;

        this.saveInputStats();
    },

    /**
     * 处理触摸结束
     * @param {TouchEvent} e - 触摸事件
     */
    handleTouchEnd: function (e) {
        if (!this.inputConfig.enabled || !this.inputConfig.useTouch) {
            return;
        }

        // 添加到输入缓冲区
        if (this.inputConfig.inputBuffering) {
            for (const touch of e.changedTouches) {
                this.addToInputBuffer({
                    type: 'touch',
                    action: 'end',
                    identifier: touch.identifier,
                    x: touch.clientX,
                    y: touch.clientY,
                    timestamp: Date.now()
                });
            }
        }

        this.saveInputStats();
    },

    /**
     * 处理游戏手柄连接
     * @param {GamepadEvent} e - 游戏手柄事件
     */
    handleGamepadConnected: function (e) {
        if (!this.inputConfig.enabled || !this.inputConfig.useGamepad) {
            return;
        }

        this.gamepadState[e.gamepad.index] = e.gamepad;

        this.inputStats.stats.totalInputs++;
        this.inputStats.stats.gamepadInputs++;

        this.saveInputStats();
    },

    /**
     * 处理游戏手柄断开
     * @param {GamepadEvent} e - 游戏手柄事件
     */
    handleGamepadDisconnected: function (e) {
        if (!this.inputConfig.enabled || !this.inputConfig.useGamepad) {
            return;
        }

        delete this.gamepadState[e.gamepad.index];

        this.saveInputStats();
    },

    /**
     * 处理设备方向
     * @param {DeviceOrientationEvent} e - 设备方向事件
     */
    handleDeviceOrientation: function (e) {
        if (!this.inputConfig.enabled || !this.inputConfig.useGyro) {
            return;
        }

        this.gyroState.alpha = e.alpha || 0;
        this.gyroState.beta = e.beta || 0;
        this.gyroState.gamma = e.gamma || 0;
        this.gyroState.timestamp = Date.now();

        this.inputStats.stats.totalInputs++;
        this.inputStats.stats.gyroInputs++;

        this.saveInputStats();
    },

    /**
     * 处理设备运动
     * @param {DeviceMotionEvent} e - 设备运动事件
     */
    handleDeviceMotion: function (e) {
        if (!this.inputConfig.enabled || !this.inputConfig.useAccelerometer) {
            return;
        }

        this.accelerometerState.x = e.acceleration.x || 0;
        this.accelerometerState.y = e.acceleration.y || 0;
        this.accelerometerState.z = e.acceleration.z || 0;
        this.accelerometerState.timestamp = Date.now();

        this.inputStats.stats.totalInputs++;
        this.inputStats.stats.accelerometerInputs++;

        this.saveInputStats();
    },

    /**
     * 添加到输入缓冲区
     * @param {Object} input - 输入对象
     */
    addToInputBuffer: function (input) {
        if (!this.inputBuffer) {
            return;
        }

        this.inputBuffer.push(input);

        // 限制缓冲区大小
        if (this.inputBuffer.length > this.inputConfig.bufferSize) {
            this.inputBuffer.shift();
        }
    },

    /**
     * 获取输入缓冲区
     * @returns {Array} 输入缓冲区
     */
    getInputBuffer: function () {
        return this.inputBuffer || [];
    },

    /**
     * 清空输入缓冲区
     */
    clearInputBuffer: function () {
        if (this.inputBuffer) {
            this.inputBuffer = [];
        }
    },

    /**
     * 获取输入统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.inputStats.stats;
    },

    /**
     * 设置输入配置
     * @param {Object} config - 配置对象
     */
    setInputConfig: function (config) {
        this.inputConfig = { ...this.inputConfig, ...config };
        this.saveInputConfig();
    },

    /**
     * 获取输入配置
     * @returns {Object} 配置对象
     */
    getInputConfig: function () {
        return this.inputConfig;
    }
};

// 优化：游戏性能优化
const GamePerformanceOptimizer = {
    perfConfig: {},
    perfStats: {},
    perfCache: {},

    /**
     * 初始化游戏性能优化
     */
    init: function () {
        this.loadPerfConfig();
        this.loadPerfStats();
        this.loadPerfCache();
        this.initPerformanceMonitor();
        this.optimizePerformance();
    },

    /**
     * 加载性能配置
     */
    loadPerfConfig: function () {
        this.perfConfig = {
            enabled: true,
            targetFPS: 60,
            minFPS: 30,
            maxFPS: 120,
            adaptiveQuality: true,
            qualityLevels: ['low', 'medium', 'high', 'ultra'],
            currentQuality: 'medium',
            useFrameSkipping: false,
            frameSkipInterval: 2,
            useTimeScaling: true,
            timeScale: 1.0,
            useObjectPooling: true,
            objectPoolSize: 100,
            useMemoryManagement: true,
            maxMemoryUsage: 512,
            useGarbageCollection: true,
            gcInterval: 60000,
            usePerformanceProfiling: true,
            profilingInterval: 1000,
            usePerformanceLogging: true,
            loggingInterval: 5000,
            usePerformanceAlerts: true,
            alertFPS: 30,
            alertMemory: 400,
            usePerformanceOptimization: true,
            optimizationInterval: 10000
        };

        const customConfig = localStorage.getItem('perfConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.perfConfig = { ...this.perfConfig, ...config };
            } catch (error) {
                console.error('加载性能配置失败:', error);
            }
        }
    },

    /**
     * 保存性能配置
     */
    savePerfConfig: function () {
        localStorage.setItem('perfConfig', JSON.stringify(this.perfConfig));
    },

    /**
     * 加载性能统计
     */
    loadPerfStats: function () {
        const savedStats = localStorage.getItem('perfStats');
        if (savedStats) {
            try {
                this.perfStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载性能统计失败:', error);
            }
        }

        if (!this.perfStats.stats) {
            this.perfStats = {
                stats: {
                    frameCount: 0,
                    lastFrameTime: 0,
                    fps: 0,
                    avgFPS: 0,
                    minFPS: 60,
                    maxFPS: 0,
                    frameTime: 0,
                    avgFrameTime: 0,
                    minFrameTime: 0,
                    maxFrameTime: 0,
                    memoryUsage: 0,
                    maxMemoryUsage: 0,
                    avgMemoryUsage: 0,
                    cpuUsage: 0,
                    avgCPUUsage: 0,
                    gpuUsage: 0,
                    avgGPUUsage: 0,
                    drawCalls: 0,
                    triangles: 0,
                    vertices: 0,
                    textures: 0,
                    shaders: 0,
                    physicsTime: 0,
                    avgPhysicsTime: 0,
                    renderTime: 0,
                    avgRenderTime: 0,
                    updateTime: 0,
                    avgUpdateTime: 0,
                    totalTime: 0,
                    avgTotalTime: 0
                }
            };

            this.savePerfStats();
        }
    },

    /**
     * 保存性能统计
     */
    savePerfStats: function () {
        localStorage.setItem('perfStats', JSON.stringify(this.perfStats));
    },

    /**
     * 加载性能缓存
     */
    loadPerfCache: function () {
        const savedCache = localStorage.getItem('perfCache');
        if (savedCache) {
            try {
                this.perfCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载性能缓存失败:', error);
            }
        }

        if (!this.perfCache.cache) {
            this.perfCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.savePerfCache();
        }
    },

    /**
     * 保存性能缓存
     */
    savePerfCache: function () {
        localStorage.setItem('perfCache', JSON.stringify(this.perfCache));
    },

    /**
     * 初始化性能监控
     */
    initPerformanceMonitor: function () {
        // 初始化帧率监控
        this.frameTimeHistory = [];
        this.fpsHistory = [];

        // 初始化内存监控
        this.memoryHistory = [];

        // 初始化CPU监控
        this.cpuHistory = [];

        // 初始化GPU监控
        this.gpuHistory = [];

        // 启动性能监控
        if (this.perfConfig.usePerformanceProfiling) {
            this.startPerformanceProfiling();
        }

        // 启动性能日志
        if (this.perfConfig.usePerformanceLogging) {
            this.startPerformanceLogging();
        }

        // 启动性能警报
        if (this.perfConfig.usePerformanceAlerts) {
            this.startPerformanceAlerts();
        }

        // 启动性能优化
        if (this.perfConfig.usePerformanceOptimization) {
            this.startPerformanceOptimization();
        }
    },

    /**
     * 启动性能分析
     */
    startPerformanceProfiling: function () {
        setInterval(() => {
            this.profilePerformance();
        }, this.perfConfig.profilingInterval);
    },

    /**
     * 启动性能日志
     */
    startPerformanceLogging: function () {
        setInterval(() => {
            this.logPerformance();
        }, this.perfConfig.loggingInterval);
    },

    /**
     * 启动性能警报
     */
    startPerformanceAlerts: function () {
        setInterval(() => {
            this.checkPerformanceAlerts();
        }, this.perfConfig.loggingInterval);
    },

    /**
     * 启动性能优化
     */
    startPerformanceOptimization: function () {
        setInterval(() => {
            this.optimizePerformance();
        }, this.perfConfig.optimizationInterval);
    },

    /**
     * 优化性能
     */
    optimizePerformance: function () {
        // 启用自适应质量
        if (this.perfConfig.adaptiveQuality) {
            this.enableAdaptiveQuality();
        }

        // 启用帧跳过
        if (this.perfConfig.useFrameSkipping) {
            this.enableFrameSkipping();
        }

        // 启用时间缩放
        if (this.perfConfig.useTimeScaling) {
            this.enableTimeScaling();
        }

        // 启用对象池
        if (this.perfConfig.useObjectPooling) {
            this.enableObjectPooling();
        }

        // 启用内存管理
        if (this.perfConfig.useMemoryManagement) {
            this.enableMemoryManagement();
        }

        // 启用垃圾回收
        if (this.perfConfig.useGarbageCollection) {
            this.enableGarbageCollection();
        }
    },

    /**
     * 启用自适应质量
     */
    enableAdaptiveQuality: function () {
        const fps = this.perfStats.stats.fps;
        const currentQuality = this.perfConfig.currentQuality;
        const qualityLevels = this.perfConfig.qualityLevels;
        const currentIndex = qualityLevels.indexOf(currentQuality);

        // FPS太低，降低质量
        if (fps < this.perfConfig.minFPS && currentIndex > 0) {
            this.setQuality(qualityLevels[currentIndex - 1]);
        }
        // FPS足够高，提高质量
        else if (fps > this.perfConfig.maxFPS && currentIndex < qualityLevels.length - 1) {
            this.setQuality(qualityLevels[currentIndex + 1]);
        }
    },

    /**
     * 启用帧跳过
     */
    enableFrameSkipping: function () {
        // 实现帧跳过逻辑
    },

    /**
     * 启用时间缩放
     */
    enableTimeScaling: function () {
        const fps = this.perfStats.stats.fps;
        const targetFPS = this.perfConfig.targetFPS;

        if (fps < targetFPS) {
            // 减慢游戏速度
            this.perfConfig.timeScale = Math.max(0.5, fps / targetFPS);
        } else {
            // 恢复正常速度
            this.perfConfig.timeScale = 1.0;
        }

        this.savePerfConfig();
    },

    /**
     * 启用对象池
     */
    enableObjectPooling: function () {
        // 实现对象池逻辑
    },

    /**
     * 启用内存管理
     */
    enableMemoryManagement: function () {
        // 实现内存管理逻辑
    },

    /**
     * 启用垃圾回收
     */
    enableGarbageCollection: function () {
        setInterval(() => {
            if (this.perfConfig.useGarbageCollection) {
                this.performGarbageCollection();
            }
        }, this.perfConfig.gcInterval);
    },

    /**
     * 执行垃圾回收
     */
    performGarbageCollection: function () {
        // 清空缓存
        this.clearCache();

        // 清空历史
        this.clearHistory();

        // 触发浏览器垃圾回收
        if (window.gc) {
            window.gc();
        }
    },

    /**
     * 设置质量
     * @param {string} quality - 质量级别
     */
    setQuality: function (quality) {
        if (!this.perfConfig.qualityLevels.includes(quality)) {
            return;
        }

        this.perfConfig.currentQuality = quality;
        this.savePerfConfig();

        // 根据质量级别调整性能参数
        switch (quality) {
            case 'low':
                this.perfConfig.targetFPS = 30;
                this.perfConfig.maxFPS = 60;
                this.perfConfig.useFrameSkipping = true;
                this.perfConfig.frameSkipInterval = 2;
                this.perfConfig.useTimeScaling = true;
                break;
            case 'medium':
                this.perfConfig.targetFPS = 60;
                this.perfConfig.maxFPS = 90;
                this.perfConfig.useFrameSkipping = false;
                this.perfConfig.useTimeScaling = false;
                break;
            case 'high':
                this.perfConfig.targetFPS = 60;
                this.perfConfig.maxFPS = 120;
                this.perfConfig.useFrameSkipping = false;
                this.perfConfig.useTimeScaling = false;
                break;
            case 'ultra':
                this.perfConfig.targetFPS = 120;
                this.perfConfig.maxFPS = 144;
                this.perfConfig.useFrameSkipping = false;
                this.perfConfig.useTimeScaling = false;
                break;
        }
    },

    /**
     * 分析性能
     */
    profilePerformance: function () {
        // 更新帧率统计
        this.updateFPS();

        // 更新内存统计
        this.updateMemory();

        // 更新CPU统计
        this.updateCPU();

        // 更新GPU统计
        this.updateGPU();
    },

    /**
     * 更新帧率
     */
    updateFPS: function () {
        const now = Date.now();
        const lastFrameTime = this.perfStats.stats.lastFrameTime;

        if (lastFrameTime > 0) {
            const delta = now - lastFrameTime;
            const fps = 1000 / delta;

            this.perfStats.stats.fps = fps;
            this.perfStats.stats.frameTime = delta;

            // 添加到历史
            this.frameTimeHistory.push(delta);
            this.fpsHistory.push(fps);

            // 限制历史大小
            if (this.frameTimeHistory.length > 100) {
                this.frameTimeHistory.shift();
            }

            if (this.fpsHistory.length > 100) {
                this.fpsHistory.shift();
            }

            // 更新统计
            this.perfStats.stats.minFPS = Math.min(this.perfStats.stats.minFPS, fps);
            this.perfStats.stats.maxFPS = Math.max(this.perfStats.stats.maxFPS, fps);
            this.perfStats.stats.avgFPS =
                this.fpsHistory.reduce((a, b) => a + b, 0) / this.fpsHistory.length;

            this.perfStats.stats.minFrameTime = Math.min(this.perfStats.stats.minFrameTime, delta);
            this.perfStats.stats.maxFrameTime = Math.max(this.perfStats.stats.maxFrameTime, delta);
            this.perfStats.stats.avgFrameTime =
                this.frameTimeHistory.reduce((a, b) => a + b, 0) / this.frameTimeHistory.length;
        }

        this.perfStats.stats.lastFrameTime = now;
        this.perfStats.stats.frameCount++;

        this.savePerfStats();
    },

    /**
     * 更新内存
     */
    updateMemory: function () {
        if (performance.memory) {
            const memoryUsage = performance.memory.usedJSHeapSize / 1024 / 1024;

            this.perfStats.stats.memoryUsage = memoryUsage;
            this.perfStats.stats.maxMemoryUsage = Math.max(
                this.perfStats.stats.maxMemoryUsage,
                memoryUsage
            );

            // 添加到历史
            this.memoryHistory.push(memoryUsage);

            // 限制历史大小
            if (this.memoryHistory.length > 100) {
                this.memoryHistory.shift();
            }

            // 更新统计
            this.perfStats.stats.avgMemoryUsage =
                this.memoryHistory.reduce((a, b) => a + b, 0) / this.memoryHistory.length;

            this.savePerfStats();
        }
    },

    /**
     * 更新CPU
     */
    updateCPU: function () {
        // 实现CPU使用率更新逻辑
    },

    /**
     * 更新GPU
     */
    updateGPU: function () {
        // 实现GPU使用率更新逻辑
    },

    /**
     * 日志性能
     */
    logPerformance: function () {
        console.log('性能统计:', this.perfStats.stats);
    },

    /**
     * 检查性能警报
     */
    checkPerformanceAlerts: function () {
        // 检查FPS警报
        if (this.perfStats.stats.fps < this.perfConfig.alertFPS) {
            console.warn('FPS警报:', this.perfStats.stats.fps);
        }

        // 检查内存警报
        if (this.perfStats.stats.memoryUsage > this.perfConfig.alertMemory) {
            console.warn('内存警报:', this.perfStats.stats.memoryUsage);
        }
    },

    /**
     * 清空缓存
     */
    clearCache: function () {
        this.perfCache.cache = {};
        this.perfCache.stats.size = 0;
        this.savePerfCache();
    },

    /**
     * 清空历史
     */
    clearHistory: function () {
        this.frameTimeHistory = [];
        this.fpsHistory = [];
        this.memoryHistory = [];
        this.cpuHistory = [];
        this.gpuHistory = [];
    },

    /**
     * 获取性能统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.perfStats.stats;
    },

    /**
     * 设置性能配置
     * @param {Object} config - 配置对象
     */
    setPerfConfig: function (config) {
        this.perfConfig = { ...this.perfConfig, ...config };
        this.savePerfConfig();
    },

    /**
     * 获取性能配置
     * @returns {Object} 配置对象
     */
    getPerfConfig: function () {
        return this.perfConfig;
    }
};

// 优化：游戏网络优化
const GameNetworkOptimizer = {
    networkConfig: {},
    networkStats: {},
    networkCache: {},

    /**
     * 初始化游戏网络优化
     */
    init: function () {
        this.loadNetworkConfig();
        this.loadNetworkStats();
        this.loadNetworkCache();
        this.initNetworkSystem();
        this.optimizeNetwork();
    },

    /**
     * 加载网络配置
     */
    loadNetworkConfig: function () {
        this.networkConfig = {
            enabled: true,
            useWebSocket: true,
            useHTTP: true,
            useHTTPS: true,
            useHTTP2: false,
            useHTTP3: false,
            useTCP: true,
            useUDP: false,
            useCompression: true,
            compressionLevel: 6,
            useEncryption: true,
            encryptionType: 'AES',
            useAuthentication: true,
            authenticationType: 'token',
            useCaching: true,
            cacheSize: 100,
            cacheTTL: 300000,
            useConnectionPooling: true,
            poolSize: 10,
            useKeepAlive: true,
            keepAliveInterval: 30000,
            useRetry: true,
            maxRetries: 3,
            retryDelay: 1000,
            useTimeout: true,
            connectionTimeout: 10000,
            requestTimeout: 30000,
            useRateLimiting: true,
            maxRequestsPerSecond: 10,
            useThrottling: false,
            throttleInterval: 1000,
            usePrioritization: true,
            priorityLevels: ['high', 'medium', 'low'],
            useLoadBalancing: false,
            loadBalancingAlgorithm: 'round-robin',
            useFailover: false,
            failoverStrategy: 'active-passive'
        };

        const customConfig = localStorage.getItem('networkConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.networkConfig = { ...this.networkConfig, ...config };
            } catch (error) {
                console.error('加载网络配置失败:', error);
            }
        }
    },

    /**
     * 保存网络配置
     */
    saveNetworkConfig: function () {
        localStorage.setItem('networkConfig', JSON.stringify(this.networkConfig));
    },

    /**
     * 加载网络统计
     */
    loadNetworkStats: function () {
        const savedStats = localStorage.getItem('networkStats');
        if (savedStats) {
            try {
                this.networkStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载网络统计失败:', error);
            }
        }

        if (!this.networkStats.stats) {
            this.networkStats = {
                stats: {
                    totalRequests: 0,
                    successfulRequests: 0,
                    failedRequests: 0,
                    totalResponses: 0,
                    totalBytesSent: 0,
                    totalBytesReceived: 0,
                    avgRequestTime: 0,
                    minRequestTime: 0,
                    maxRequestTime: 0,
                    avgResponseTime: 0,
                    minResponseTime: 0,
                    maxResponseTime: 0,
                    totalConnections: 0,
                    activeConnections: 0,
                    totalErrors: 0,
                    totalRetries: 0,
                    cacheHits: 0,
                    cacheMisses: 0,
                    cacheHitRate: 0
                }
            };

            this.saveNetworkStats();
        }
    },

    /**
     * 保存网络统计
     */
    saveNetworkStats: function () {
        localStorage.setItem('networkStats', JSON.stringify(this.networkStats));
    },

    /**
     * 加载网络缓存
     */
    loadNetworkCache: function () {
        const savedCache = localStorage.getItem('networkCache');
        if (savedCache) {
            try {
                this.networkCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载网络缓存失败:', error);
            }
        }

        if (!this.networkCache.cache) {
            this.networkCache = {
                cache: {},
                stats: {
                    size: 0,
                    maxSize: this.networkConfig.cacheSize,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveNetworkCache();
        }
    },

    /**
     * 保存网络缓存
     */
    saveNetworkCache: function () {
        localStorage.setItem('networkCache', JSON.stringify(this.networkCache));
    },

    /**
     * 初始化网络系统
     */
    initNetworkSystem: function () {
        // 初始化WebSocket
        if (this.networkConfig.useWebSocket) {
            this.initWebSocket();
        }

        // 初始化HTTP
        if (this.networkConfig.useHTTP || this.networkConfig.useHTTPS) {
            this.initHTTP();
        }

        // 初始化连接池
        if (this.networkConfig.useConnectionPooling) {
            this.initConnectionPool();
        }

        // 初始化请求队列
        this.requestQueue = [];
        this.requestHistory = [];
    },

    /**
     * 初始化WebSocket
     */
    initWebSocket: function () {
        this.webSocket = null;
        this.webSocketConnected = false;
        this.webSocketCallbacks = {};
    },

    /**
     * 初始化HTTP
     */
    initHTTP: function () {
        this.httpRequests = {};
        this.httpCallbacks = {};
    },

    /**
     * 初始化连接池
     */
    initConnectionPool: function () {
        this.connectionPool = [];
        this.activeConnections = 0;
    },

    /**
     * 优化网络
     */
    optimizeNetwork: function () {
        // 启用压缩
        if (this.networkConfig.useCompression) {
            this.enableCompression();
        }

        // 启用加密
        if (this.networkConfig.useEncryption) {
            this.enableEncryption();
        }

        // 启用认证
        if (this.networkConfig.useAuthentication) {
            this.enableAuthentication();
        }

        // 启用缓存
        if (this.networkConfig.useCaching) {
            this.enableCaching();
        }

        // 启用连接池
        if (this.networkConfig.useConnectionPooling) {
            this.enableConnectionPooling();
        }

        // 启用Keep-Alive
        if (this.networkConfig.useKeepAlive) {
            this.enableKeepAlive();
        }

        // 启用重试
        if (this.networkConfig.useRetry) {
            this.enableRetry();
        }

        // 启用超时
        if (this.networkConfig.useTimeout) {
            this.enableTimeout();
        }

        // 启用速率限制
        if (this.networkConfig.useRateLimiting) {
            this.enableRateLimiting();
        }

        // 启用优先级
        if (this.networkConfig.usePrioritization) {
            this.enablePrioritization();
        }
    },

    /**
     * 启用压缩
     */
    enableCompression: function () {
        // 实现压缩逻辑
    },

    /**
     * 启用加密
     */
    enableEncryption: function () {
        // 实现加密逻辑
    },

    /**
     * 启用认证
     */
    enableAuthentication: function () {
        // 实现认证逻辑
    },

    /**
     * 启用缓存
     */
    enableCaching: function () {
        // 实现缓存逻辑
    },

    /**
     * 启用连接池
     */
    enableConnectionPooling: function () {
        // 实现连接池逻辑
    },

    /**
     * 启用Keep-Alive
     */
    enableKeepAlive: function () {
        // 实现Keep-Alive逻辑
    },

    /**
     * 启用重试
     */
    enableRetry: function () {
        // 实现重试逻辑
    },

    /**
     * 启用超时
     */
    enableTimeout: function () {
        // 实现超时逻辑
    },

    /**
     * 启用速率限制
     */
    enableRateLimiting: function () {
        // 实现速率限制逻辑
    },

    /**
     * 启用优先级
     */
    enablePrioritization: function () {
        // 实现优先级逻辑
    },

    /**
     * 发送HTTP请求
     * @param {string} url - URL
     * @param {Object} options - 请求选项
     * @returns {Promise} 响应Promise
     */
    sendHTTPRequest: function (url, options) {
        if (!this.networkConfig.enabled) {
            return Promise.reject(new Error('网络已禁用'));
        }

        options = options || {};

        const startTime = Date.now();

        // 检查缓存
        if (this.networkConfig.useCaching && options.method === 'GET') {
            const cachedResponse = this.getCachedResponse(url, options);

            if (cachedResponse) {
                return Promise.resolve(cachedResponse);
            }
        }

        // 创建请求
        const request = {
            url: url,
            method: options.method || 'GET',
            headers: options.headers || {},
            body: options.body || null,
            priority: options.priority || 'medium',
            timestamp: startTime,
            retries: 0
        };

        // 添加到请求队列
        this.requestQueue.push(request);

        // 按优先级排序
        this.sortRequestQueue();

        // 处理请求
        return this.processRequest(request)
            .then(response => {
                const endTime = Date.now();
                const requestTime = endTime - startTime;

                // 更新统计
                this.networkStats.stats.totalRequests++;
                this.networkStats.stats.successfulRequests++;
                this.networkStats.stats.totalResponses++;
                this.networkStats.stats.avgRequestTime =
                    (this.networkStats.stats.avgRequestTime + requestTime) / 2;
                this.networkStats.stats.minRequestTime =
                    Math.min(this.networkStats.stats.minRequestTime, requestTime);
                this.networkStats.stats.maxRequestTime =
                    Math.max(this.networkStats.stats.maxRequestTime, requestTime);

                // 缓存响应
                if (this.networkConfig.useCaching && options.method === 'GET') {
                    this.cacheResponse(url, options, response);
                }

                this.saveNetworkStats();

                return response;
            })
            .catch(error => {
                const endTime = Date.now();
                const requestTime = endTime - startTime;

                // 更新统计
                this.networkStats.stats.totalRequests++;
                this.networkStats.stats.failedRequests++;
                this.networkStats.stats.totalErrors++;
                this.networkStats.stats.avgRequestTime =
                    (this.networkStats.stats.avgRequestTime + requestTime) / 2;
                this.networkStats.stats.minRequestTime =
                    Math.min(this.networkStats.stats.minRequestTime, requestTime);
                this.networkStats.stats.maxRequestTime =
                    Math.max(this.networkStats.stats.maxRequestTime, requestTime);

                this.saveNetworkStats();

                return Promise.reject(error);
            });
    },

    /**
     * 处理请求
     * @param {Object} request - 请求对象
     * @returns {Promise} 响应Promise
     */
    processRequest: function (request) {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();

            xhr.open(request.method, request.url, true);

            // 设置请求头
            for (const key in request.headers) {
                xhr.setRequestHeader(key, request.headers[key]);
            }

            // 设置超时
            if (this.networkConfig.useTimeout) {
                xhr.timeout = this.networkConfig.requestTimeout;
            }

            // 处理响应
            xhr.onload = () => {
                if (xhr.status >= 200 && xhr.status < 300) {
                    const response = {
                        status: xhr.status,
                        statusText: xhr.statusText,
                        headers: xhr.getAllResponseHeaders(),
                        body: xhr.responseText
                    };

                    resolve(response);
                } else {
                    reject(new Error(xhr.statusText));
                }
            };

            // 处理错误
            xhr.onerror = () => {
                reject(new Error('网络错误'));
            };

            // 处理超时
            xhr.ontimeout = () => {
                reject(new Error('请求超时'));
            };

            // 发送请求
            xhr.send(request.body);
        });
    },

    /**
     * 排序请求队列
     */
    sortRequestQueue: function () {
        const priorityOrder = {
            'high': 0,
            'medium': 1,
            'low': 2
        };

        this.requestQueue.sort((a, b) => {
            return priorityOrder[a.priority] - priorityOrder[b.priority];
        });
    },

    /**
     * 缓存响应
     * @param {string} url - URL
     * @param {Object} options - 请求选项
     * @param {Object} response - 响应对象
     */
    cacheResponse: function (url, options, response) {
        const cacheKey = this.getCacheKey(url, options);

        if (Object.keys(this.networkCache.cache).length >= this.networkConfig.cacheSize) {
            // 删除最旧的缓存项
            const oldestKey = Object.keys(this.networkCache.cache)[0];
            delete this.networkCache.cache[oldestKey];
        }

        this.networkCache.cache[cacheKey] = {
            response: response,
            timestamp: Date.now()
        };

        this.networkCache.stats.size = Object.keys(this.networkCache.cache).length;
        this.saveNetworkCache();
    },

    /**
     * 获取缓存响应
     * @param {string} url - URL
     * @param {Object} options - 请求选项
     * @returns {Object|null} 响应对象
     */
    getCachedResponse: function (url, options) {
        const cacheKey = this.getCacheKey(url, options);
        const cached = this.networkCache.cache[cacheKey];

        if (cached) {
            // 检查是否过期
            const age = Date.now() - cached.timestamp;

            if (age < this.networkConfig.cacheTTL) {
                this.networkCache.stats.hits++;
                this.networkStats.stats.cacheHits++;
            } else {
                delete this.networkCache.cache[cacheKey];
                this.networkCache.stats.size = Object.keys(this.networkCache.cache).length;
                this.networkCache.stats.misses++;
                this.networkStats.stats.cacheMisses++;
            }
        } else {
            this.networkCache.stats.misses++;
            this.networkStats.stats.cacheMisses++;
        }

        // 更新缓存命中率
        const total = this.networkCache.stats.hits + this.networkCache.stats.misses;
        this.networkCache.stats.hitRate = total > 0 ? (this.networkCache.stats.hits / total) * 100 : 0;
        this.networkStats.stats.cacheHitRate = this.networkCache.stats.hitRate;

        this.saveNetworkCache();
        this.saveNetworkStats();

        return cached ? cached.response : null;
    },

    /**
     * 获取缓存键
     * @param {string} url - URL
     * @param {Object} options - 请求选项
     * @returns {string} 缓存键
     */
    getCacheKey: function (url, options) {
        return url + JSON.stringify(options);
    },

    /**
     * 清空缓存
     */
    clearCache: function () {
        this.networkCache.cache = {};
        this.networkCache.stats.size = 0;
        this.saveNetworkCache();
    },

    /**
     * 获取网络统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.networkStats.stats;
    },

    /**
     * 设置网络配置
     * @param {Object} config - 配置对象
     */
    setNetworkConfig: function (config) {
        this.networkConfig = { ...this.networkConfig, ...config };
        this.saveNetworkConfig();
    },

    /**
     * 获取网络配置
     * @returns {Object} 配置对象
     */
    getNetworkConfig: function () {
        return this.networkConfig;
    }
};

// 优化：游戏存储优化
const GameStorageOptimizer = {
    storageConfig: {},
    storageStats: {},
    storageCache: {},

    /**
     * 初始化游戏存储优化
     */
    init: function () {
        this.loadStorageConfig();
        this.loadStorageStats();
        this.loadStorageCache();
        this.initStorageSystem();
        this.optimizeStorage();
    },

    /**
     * 加载存储配置
     */
    loadStorageConfig: function () {
        this.storageConfig = {
            enabled: true,
            useLocalStorage: true,
            useSessionStorage: true,
            useIndexedDB: false,
            useWebSQL: false,
            useCookie: false,
            useCompression: true,
            compressionLevel: 6,
            useEncryption: true,
            encryptionType: 'AES',
            useBackup: true,
            backupInterval: 300000,
            backupMaxCount: 10,
            useCache: true,
            cacheSize: 100,
            cacheTTL: 300000,
            useLazyLoading: true,
            usePrefetching: false,
            useBatchOperations: true,
            batchSize: 10,
            useTransaction: true,
            useAutoSave: true,
            autoSaveInterval: 60000,
            useAutoLoad: true,
            autoLoadInterval: 30000,
            useStorageQuota: true,
            maxStorageSize: 50,
            useGarbageCollection: true,
            gcInterval: 60000,
            useStorageMonitoring: true,
            monitoringInterval: 5000
        };

        const customConfig = localStorage.getItem('storageConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.storageConfig = { ...this.storageConfig, ...config };
            } catch (error) {
                console.error('加载存储配置失败:', error);
            }
        }
    },

    /**
     * 保存存储配置
     */
    saveStorageConfig: function () {
        localStorage.setItem('storageConfig', JSON.stringify(this.storageConfig));
    },

    /**
     * 加载存储统计
     */
    loadStorageStats: function () {
        const savedStats = localStorage.getItem('storageStats');
        if (savedStats) {
            try {
                this.storageStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载存储统计失败:', error);
            }
        }

        if (!this.storageStats.stats) {
            this.storageStats = {
                stats: {
                    totalOperations: 0,
                    readOperations: 0,
                    writeOperations: 0,
                    deleteOperations: 0,
                    totalBytesRead: 0,
                    totalBytesWritten: 0,
                    avgReadTime: 0,
                    avgWriteTime: 0,
                    avgDeleteTime: 0,
                    cacheHits: 0,
                    cacheMisses: 0,
                    cacheHitRate: 0,
                    storageUsed: 0,
                    storageAvailable: 0,
                    storageUsage: 0
                }
            };

            this.saveStorageStats();
        }
    },

    /**
     * 保存存储统计
     */
    saveStorageStats: function () {
        localStorage.setItem('storageStats', JSON.stringify(this.storageStats));
    },

    /**
     * 加载存储缓存
     */
    loadStorageCache: function () {
        const savedCache = localStorage.getItem('storageCache');
        if (savedCache) {
            try {
                this.storageCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载存储缓存失败:', error);
            }
        }

        if (!this.storageCache.cache) {
            this.storageCache = {
                cache: {},
                stats: {
                    size: 0,
                    maxSize: this.storageConfig.cacheSize,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveStorageCache();
        }
    },

    /**
     * 保存存储缓存
     */
    saveStorageCache: function () {
        localStorage.setItem('storageCache', JSON.stringify(this.storageCache));
    },

    /**
     * 初始化存储系统
     */
    initStorageSystem: function () {
        // 初始化localStorage
        if (this.storageConfig.useLocalStorage) {
            this.initLocalStorage();
        }

        // 初始化sessionStorage
        if (this.storageConfig.useSessionStorage) {
            this.initSessionStorage();
        }

        // 初始化IndexedDB
        if (this.storageConfig.useIndexedDB) {
            this.initIndexedDB();
        }

        // 初始化备份
        if (this.storageConfig.useBackup) {
            this.initBackup();
        }

        // 初始化自动保存
        if (this.storageConfig.useAutoSave) {
            this.initAutoSave();
        }

        // 初始化自动加载
        if (this.storageConfig.useAutoLoad) {
            this.initAutoLoad();
        }

        // 初始化垃圾回收
        if (this.storageConfig.useGarbageCollection) {
            this.initGarbageCollection();
        }

        // 初始化存储监控
        if (this.storageConfig.useStorageMonitoring) {
            this.initStorageMonitoring();
        }
    },

    /**
     * 初始化localStorage
     */
    initLocalStorage: function () {
        this.localStorage = window.localStorage;
    },

    /**
     * 初始化sessionStorage
     */
    initSessionStorage: function () {
        this.sessionStorage = window.sessionStorage;
    },

    /**
     * 初始化IndexedDB
     */
    initIndexedDB: function () {
        // 实现IndexedDB初始化逻辑
    },

    /**
     * 初始化备份
     */
    initBackup: function () {
        this.backups = [];

        setInterval(() => {
            if (this.storageConfig.useBackup) {
                this.backupStorage();
            }
        }, this.storageConfig.backupInterval);
    },

    /**
     * 初始化自动保存
     */
    initAutoSave: function () {
        setInterval(() => {
            if (this.storageConfig.useAutoSave) {
                this.autoSave();
            }
        }, this.storageConfig.autoSaveInterval);
    },

    /**
     * 初始化自动加载
     */
    initAutoLoad: function () {
        setInterval(() => {
            if (this.storageConfig.useAutoLoad) {
                this.autoLoad();
            }
        }, this.storageConfig.autoLoadInterval);
    },

    /**
     * 初始化垃圾回收
     */
    initGarbageCollection: function () {
        setInterval(() => {
            if (this.storageConfig.useGarbageCollection) {
                this.performGarbageCollection();
            }
        }, this.storageConfig.gcInterval);
    },

    /**
     * 初始化存储监控
     */
    initStorageMonitoring: function () {
        setInterval(() => {
            if (this.storageConfig.useStorageMonitoring) {
                this.monitorStorage();
            }
        }, this.storageConfig.monitoringInterval);
    },

    /**
     * 优化存储
     */
    optimizeStorage: function () {
        // 启用压缩
        if (this.storageConfig.useCompression) {
            this.enableCompression();
        }

        // 启用加密
        if (this.storageConfig.useEncryption) {
            this.enableEncryption();
        }

        // 启用缓存
        if (this.storageConfig.useCache) {
            this.enableCache();
        }

        // 启用懒加载
        if (this.storageConfig.useLazyLoading) {
            this.enableLazyLoading();
        }

        // 启用预取
        if (this.storageConfig.usePrefetching) {
            this.enablePrefetching();
        }

        // 启用批处理
        if (this.storageConfig.useBatchOperations) {
            this.enableBatchOperations();
        }

        // 启用事务
        if (this.storageConfig.useTransaction) {
            this.enableTransaction();
        }
    },

    /**
     * 启用压缩
     */
    enableCompression: function () {
        // 实现压缩逻辑
    },

    /**
     * 启用加密
     */
    enableEncryption: function () {
        // 实现加密逻辑
    },

    /**
     * 启用缓存
     */
    enableCache: function () {
        // 实现缓存逻辑
    },

    /**
     * 启用懒加载
     */
    enableLazyLoading: function () {
        // 实现懒加载逻辑
    },

    /**
     * 启用预取
     */
    enablePrefetching: function () {
        // 实现预取逻辑
    },

    /**
     * 启用批处理
     */
    enableBatchOperations: function () {
        // 实现批处理逻辑
    },

    /**
     * 启用事务
     */
    enableTransaction: function () {
        // 实现事务逻辑
    },

    /**
     * 保存数据
     * @param {string} key - 键
     * @param {any} value - 值
     * @param {Object} options - 选项
     * @returns {Promise} 保存Promise
     */
    save: function (key, value, options) {
        if (!this.storageConfig.enabled) {
            return Promise.reject(new Error('存储已禁用'));
        }

        options = options || {};

        const startTime = Date.now();

        // 序列化数据
        let serializedValue;

        try {
            serializedValue = JSON.stringify(value);
        } catch (error) {
            return Promise.reject(new Error('序列化失败'));
        }

        // 压缩数据
        if (this.storageConfig.useCompression) {
            serializedValue = this.compressData(serializedValue);
        }

        // 加密数据
        if (this.storageConfig.useEncryption) {
            serializedValue = this.encryptData(serializedValue);
        }

        // 保存到localStorage
        if (this.storageConfig.useLocalStorage && options.storage !== 'session') {
            this.localStorage.setItem(key, serializedValue);
        }

        // 保存到sessionStorage
        if (this.storageConfig.useSessionStorage && options.storage !== 'local') {
            this.sessionStorage.setItem(key, serializedValue);
        }

        // 缓存数据
        if (this.storageConfig.useCache) {
            this.cacheData(key, value);
        }

        const endTime = Date.now();
        const writeTime = endTime - startTime;

        // 更新统计
        this.storageStats.stats.totalOperations++;
        this.storageStats.stats.writeOperations++;
        this.storageStats.stats.totalBytesWritten += serializedValue.length;
        this.storageStats.stats.avgWriteTime =
            (this.storageStats.stats.avgWriteTime + writeTime) / 2;

        this.saveStorageStats();

        return Promise.resolve({ success: true });
    },

    /**
     * 加载数据
     * @param {string} key - 键
     * @param {Object} options - 选项
     * @returns {Promise} 加载Promise
     */
    load: function (key, options) {
        if (!this.storageConfig.enabled) {
            return Promise.reject(new Error('存储已禁用'));
        }

        options = options || {};

        const startTime = Date.now();

        // 检查缓存
        if (this.storageConfig.useCache) {
            const cachedValue = this.getCachedData(key);

            if (cachedValue) {
                return Promise.resolve(cachedValue);
            }
        }

        // 从localStorage加载
        let serializedValue;

        if (this.storageConfig.useLocalStorage && options.storage !== 'session') {
            serializedValue = this.localStorage.getItem(key);
        }

        // 从sessionStorage加载
        if (!serializedValue && this.storageConfig.useSessionStorage && options.storage !== 'local') {
            serializedValue = this.sessionStorage.getItem(key);
        }

        if (!serializedValue) {
            return Promise.reject(new Error('数据不存在'));
        }

        // 解密数据
        if (this.storageConfig.useEncryption) {
            serializedValue = this.decryptData(serializedValue);
        }

        // 解压数据
        if (this.storageConfig.useCompression) {
            serializedValue = this.decompressData(serializedValue);
        }

        // 反序列化数据
        let value;

        try {
            value = JSON.parse(serializedValue);
        } catch (error) {
            return Promise.reject(new Error('反序列化失败'));
        }

        // 缓存数据
        if (this.storageConfig.useCache) {
            this.cacheData(key, value);
        }

        const endTime = Date.now();
        const readTime = endTime - startTime;

        // 更新统计
        this.storageStats.stats.totalOperations++;
        this.storageStats.stats.readOperations++;
        this.storageStats.stats.totalBytesRead += serializedValue.length;
        this.storageStats.stats.avgReadTime =
            (this.storageStats.stats.avgReadTime + readTime) / 2;

        this.saveStorageStats();

        return Promise.resolve(value);
    },

    /**
     * 删除数据
     * @param {string} key - 键
     * @param {Object} options - 选项
     * @returns {Promise} 删除Promise
     */
    delete: function (key, options) {
        if (!this.storageConfig.enabled) {
            return Promise.reject(new Error('存储已禁用'));
        }

        options = options || {};

        const startTime = Date.now();

        // 从localStorage删除
        if (this.storageConfig.useLocalStorage && options.storage !== 'session') {
            this.localStorage.removeItem(key);
        }

        // 从sessionStorage删除
        if (this.storageConfig.useSessionStorage && options.storage !== 'local') {
            this.sessionStorage.removeItem(key);
        }

        // 从缓存删除
        if (this.storageConfig.useCache) {
            this.removeCachedData(key);
        }

        const endTime = Date.now();
        const deleteTime = endTime - startTime;

        // 更新统计
        this.storageStats.stats.totalOperations++;
        this.storageStats.stats.deleteOperations++;
        this.storageStats.stats.avgDeleteTime =
            (this.storageStats.stats.avgDeleteTime + deleteTime) / 2;

        this.saveStorageStats();

        return Promise.resolve({ success: true });
    },

    /**
     * 缓存数据
     * @param {string} key - 键
     * @param {any} value - 值
     */
    cacheData: function (key, value) {
        if (Object.keys(this.storageCache.cache).length >= this.storageConfig.cacheSize) {
            // 删除最旧的缓存项
            const oldestKey = Object.keys(this.storageCache.cache)[0];
            delete this.storageCache.cache[oldestKey];
        }

        this.storageCache.cache[key] = {
            value: value,
            timestamp: Date.now()
        };

        this.storageCache.stats.size = Object.keys(this.storageCache.cache).length;
        this.saveStorageCache();
    },

    /**
     * 获取缓存数据
     * @param {string} key - 键
     * @returns {any|null} 值
     */
    getCachedData: function (key) {
        const cached = this.storageCache.cache[key];

        if (cached) {
            // 检查是否过期
            const age = Date.now() - cached.timestamp;

            if (age < this.storageConfig.cacheTTL) {
                this.storageCache.stats.hits++;
                this.storageStats.stats.cacheHits++;
            } else {
                delete this.storageCache.cache[key];
                this.storageCache.stats.size = Object.keys(this.storageCache.cache).length;
                this.storageCache.stats.misses++;
                this.storageStats.stats.cacheMisses++;
            }
        } else {
            this.storageCache.stats.misses++;
            this.storageStats.stats.cacheMisses++;
        }

        // 更新缓存命中率
        const total = this.storageCache.stats.hits + this.storageCache.stats.misses;
        this.storageCache.stats.hitRate = total > 0 ? (this.storageCache.stats.hits / total) * 100 : 0;
        this.storageStats.stats.cacheHitRate = this.storageCache.stats.hitRate;

        this.saveStorageCache();
        this.saveStorageStats();

        return cached ? cached.value : null;
    },

    /**
     * 删除缓存数据
     * @param {string} key - 键
     */
    removeCachedData: function (key) {
        delete this.storageCache.cache[key];
        this.storageCache.stats.size = Object.keys(this.storageCache.cache).length;
        this.saveStorageCache();
    },

    /**
     * 压缩数据
     * @param {string} data - 数据
     * @returns {string} 压缩后的数据
     */
    compressData: function (data) {
        // 实现数据压缩逻辑
        return data;
    },

    /**
     * 解压数据
     * @param {string} data - 数据
     * @returns {string} 解压后的数据
     */
    decompressData: function (data) {
        // 实现数据解压逻辑
        return data;
    },

    /**
     * 加密数据
     * @param {string} data - 数据
     * @returns {string} 加密后的数据
     */
    encryptData: function (data) {
        // 实现数据加密逻辑
        return data;
    },

    /**
     * 解密数据
     * @param {string} data - 数据
     * @returns {string} 解密后的数据
     */
    decryptData: function (data) {
        // 实现数据解密逻辑
        return data;
    },

    /**
     * 备份存储
     */
    backupStorage: function () {
        // 实现存储备份逻辑
    },

    /**
     * 自动保存
     */
    autoSave: function () {
        // 实现自动保存逻辑
    },

    /**
     * 自动加载
     */
    autoLoad: function () {
        // 实现自动加载逻辑
    },

    /**
     * 执行垃圾回收
     */
    performGarbageCollection: function () {
        // 清空缓存
        this.clearCache();

        // 清空过期数据
        this.clearExpiredData();
    },

    /**
     * 清空缓存
     */
    clearCache: function () {
        this.storageCache.cache = {};
        this.storageCache.stats.size = 0;
        this.saveStorageCache();
    },

    /**
     * 清空过期数据
     */
    clearExpiredData: function () {
        // 实现清空过期数据逻辑
    },

    /**
     * 监控存储
     */
    monitorStorage: function () {
        // 计算存储使用量
        let totalSize = 0;

        for (const key in this.localStorage) {
            totalSize += this.localStorage.getItem(key).length;
        }

        this.storageStats.stats.storageUsed = totalSize;
        this.storageStats.stats.storageAvailable = this.storageConfig.maxStorageSize * 1024 * 1024 - totalSize;
        this.storageStats.stats.storageUsage = (totalSize / (this.storageConfig.maxStorageSize * 1024 * 1024)) * 100;

        this.saveStorageStats();
    },

    /**
     * 获取存储统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.storageStats.stats;
    },

    /**
     * 设置存储配置
     * @param {Object} config - 配置对象
     */
    setStorageConfig: function (config) {
        this.storageConfig = { ...this.storageConfig, ...config };
        this.saveStorageConfig();
    },

    /**
     * 获取存储配置
     * @returns {Object} 配置对象
     */
    getStorageConfig: function () {
        return this.storageConfig;
    }
};

// 优化：游戏安全优化
const GameSecurityOptimizer = {
    securityConfig: {},
    securityStats: {},
    securityCache: {},

    /**
     * 初始化游戏安全优化
     */
    init: function () {
        this.loadSecurityConfig();
        this.loadSecurityStats();
        this.loadSecurityCache();
        this.initSecuritySystem();
        this.optimizeSecurity();
    },

    /**
     * 加载安全配置
     */
    loadSecurityConfig: function () {
        this.securityConfig = {
            enabled: true,
            useAuthentication: true,
            authenticationType: 'token',
            tokenExpiration: 3600000,
            useAuthorization: true,
            authorizationType: 'role-based',
            useEncryption: true,
            encryptionType: 'AES',
            encryptionKeyLength: 256,
            useHashing: true,
            hashingAlgorithm: 'SHA-256',
            useSalt: true,
            saltLength: 16,
            useValidation: true,
            validationRules: {
                username: {
                    minLength: 3,
                    maxLength: 20,
                    pattern: '^[a-zA-Z0-9_]+$'
                },
                password: {
                    minLength: 8,
                    maxLength: 100,
                    pattern: '^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]+$'
                },
                email: {
                    pattern: '^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$'
                }
            },
            useCSRFProtection: true,
            useXSSProtection: true,
            useSQLInjectionProtection: true,
            useRateLimiting: true,
            maxRequestsPerMinute: 60,
            maxFailedAttempts: 5,
            lockoutDuration: 300000,
            useLogging: true,
            logLevel: 'info',
            logRetention: 7,
            useAudit: true,
            auditLevel: 'medium',
            useMonitoring: true,
            monitoringInterval: 60000,
            useAlerts: true,
            alertLevel: 'medium',
            useBackup: true,
            backupInterval: 86400000,
            backupRetention: 30
        };

        const customConfig = localStorage.getItem('securityConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.securityConfig = { ...this.securityConfig, ...config };
            } catch (error) {
                console.error('加载安全配置失败:', error);
            }
        }
    },

    /**
     * 保存安全配置
     */
    saveSecurityConfig: function () {
        localStorage.setItem('securityConfig', JSON.stringify(this.securityConfig));
    },

    /**
     * 加载安全统计
     */
    loadSecurityStats: function () {
        const savedStats = localStorage.getItem('securityStats');
        if (savedStats) {
            try {
                this.securityStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载安全统计失败:', error);
            }
        }

        if (!this.securityStats.stats) {
            this.securityStats = {
                stats: {
                    totalAuthAttempts: 0,
                    successfulAuthAttempts: 0,
                    failedAuthAttempts: 0,
                    totalAuthOperations: 0,
                    successfulAuthOperations: 0,
                    failedAuthOperations: 0,
                    totalEncryptionOperations: 0,
                    totalDecryptionOperations: 0,
                    totalHashingOperations: 0,
                    totalValidationOperations: 0,
                    successfulValidations: 0,
                    failedValidations: 0,
                    totalCSRFAttacks: 0,
                    blockedCSRFAttacks: 0,
                    totalXSSAttacks: 0,
                    blockedXSSAttacks: 0,
                    totalSQLInjectionAttacks: 0,
                    blockedSQLInjectionAttacks: 0,
                    totalRateLimitViolations: 0,
                    totalLockouts: 0,
                    totalLogs: 0,
                    totalAudits: 0,
                    totalAlerts: 0,
                    totalBackups: 0
                }
            };

            this.saveSecurityStats();
        }
    },

    /**
     * 保存安全统计
     */
    saveSecurityStats: function () {
        localStorage.setItem('securityStats', JSON.stringify(this.securityStats));
    },

    /**
     * 加载安全缓存
     */
    loadSecurityCache: function () {
        const savedCache = localStorage.getItem('securityCache');
        if (savedCache) {
            try {
                this.securityCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载安全缓存失败:', error);
            }
        }

        if (!this.securityCache.cache) {
            this.securityCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveSecurityCache();
        }
    },

    /**
     * 保存安全缓存
     */
    saveSecurityCache: function () {
        localStorage.setItem('securityCache', JSON.stringify(this.securityCache));
    },

    /**
     * 初始化安全系统
     */
    initSecuritySystem: function () {
        // 初始化认证
        if (this.securityConfig.useAuthentication) {
            this.initAuthentication();
        }

        // 初始化授权
        if (this.securityConfig.useAuthorization) {
            this.initAuthorization();
        }

        // 初始化加密
        if (this.securityConfig.useEncryption) {
            this.initEncryption();
        }

        // 初始化哈希
        if (this.securityConfig.useHashing) {
            this.initHashing();
        }

        // 初始化验证
        if (this.securityConfig.useValidation) {
            this.initValidation();
        }

        // 初始化CSRF保护
        if (this.securityConfig.useCSRFProtection) {
            this.initCSRFProtection();
        }

        // 初始化XSS保护
        if (this.securityConfig.useXSSProtection) {
            this.initXSSProtection();
        }

        // 初始化SQL注入保护
        if (this.securityConfig.useSQLInjectionProtection) {
            this.initSQLInjectionProtection();
        }

        // 初始化速率限制
        if (this.securityConfig.useRateLimiting) {
            this.initRateLimiting();
        }

        // 初始化日志
        if (this.securityConfig.useLogging) {
            this.initLogging();
        }

        // 初始化审计
        if (this.securityConfig.useAudit) {
            this.initAudit();
        }

        // 初始化监控
        if (this.securityConfig.useMonitoring) {
            this.initMonitoring();
        }

        // 初始化警报
        if (this.securityConfig.useAlerts) {
            this.initAlerts();
        }

        // 初始化备份
        if (this.securityConfig.useBackup) {
            this.initBackup();
        }
    },

    /**
     * 初始化认证
     */
    initAuthentication: function () {
        this.authTokens = {};
        this.failedAttempts = {};
        this.lockouts = {};
    },

    /**
     * 初始化授权
     */
    initAuthorization: function () {
        this.roles = {};
        this.permissions = {};
    },

    /**
     * 初始化加密
     */
    initEncryption: function () {
        this.encryptionKeys = {};
    },

    /**
     * 初始化哈希
     */
    initHashing: function () {
        this.salt = this.generateSalt();
    },

    /**
     * 初始化验证
     */
    initValidation: function () {
        this.validationCache = {};
    },

    /**
     * 初始化CSRF保护
     */
    initCSRFProtection: function () {
        this.csrfTokens = {};
    },

    /**
     * 初始化XSS保护
     */
    initXSSProtection: function () {
        this.xssPatterns = [
            /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
            /javascript:/gi,
            /on\w+\s*=/gi
        ];
    },

    /**
     * 初始化SQL注入保护
     */
    initSQLInjectionProtection: function () {
        this.sqlInjectionPatterns = [
            /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION)\b)/gi,
            /(\b(OR|AND)\s*\d+\s*=\s*\d+)/gi,
            /(\b(OR|AND)\s*['"].*['"]\s*=\s*['"].*['"])/gi
        ];
    },

    /**
     * 初始化速率限制
     */
    initRateLimiting: function () {
        this.requestCounts = {};
        this.requestHistory = {};
    },

    /**
     * 初始化日志
     */
    initLogging: function () {
        this.logs = [];
    },

    /**
     * 初始化审计
     */
    initAudit: function () {
        this.audits = [];
    },

    /**
     * 初始化监控
     */
    initMonitoring: function () {
        this.monitors = {};

        setInterval(() => {
            if (this.securityConfig.useMonitoring) {
                this.monitorSecurity();
            }
        }, this.securityConfig.monitoringInterval);
    },

    /**
     * 初始化警报
     */
    initAlerts: function () {
        this.alerts = [];
    },

    /**
     * 初始化备份
     */
    initBackup: function () {
        this.backups = [];

        setInterval(() => {
            if (this.securityConfig.useBackup) {
                this.backupSecurity();
            }
        }, this.securityConfig.backupInterval);
    },

    /**
     * 优化安全
     */
    optimizeSecurity: function () {
        // 启用认证
        if (this.securityConfig.useAuthentication) {
            this.enableAuthentication();
        }

        // 启用授权
        if (this.securityConfig.useAuthorization) {
            this.enableAuthorization();
        }

        // 启用加密
        if (this.securityConfig.useEncryption) {
            this.enableEncryption();
        }

        // 启用哈希
        if (this.securityConfig.useHashing) {
            this.enableHashing();
        }

        // 启用验证
        if (this.securityConfig.useValidation) {
            this.enableValidation();
        }

        // 启用CSRF保护
        if (this.securityConfig.useCSRFProtection) {
            this.enableCSRFProtection();
        }

        // 启用XSS保护
        if (this.securityConfig.useXSSProtection) {
            this.enableXSSProtection();
        }

        // 启用SQL注入保护
        if (this.securityConfig.useSQLInjectionProtection) {
            this.enableSQLInjectionProtection();
        }

        // 启用速率限制
        if (this.securityConfig.useRateLimiting) {
            this.enableRateLimiting();
        }
    },

    /**
     * 启用认证
     */
    enableAuthentication: function () {
        // 实现认证逻辑
    },

    /**
     * 启用授权
     */
    enableAuthorization: function () {
        // 实现授权逻辑
    },

    /**
     * 启用加密
     */
    enableEncryption: function () {
        // 实现加密逻辑
    },

    /**
     * 启用哈希
     */
    enableHashing: function () {
        // 实现哈希逻辑
    },

    /**
     * 启用验证
     */
    enableValidation: function () {
        // 实现验证逻辑
    },

    /**
     * 启用CSRF保护
     */
    enableCSRFProtection: function () {
        // 实现CSRF保护逻辑
    },

    /**
     * 启用XSS保护
     */
    enableXSSProtection: function () {
        // 实现XSS保护逻辑
    },

    /**
     * 启用SQL注入保护
     */
    enableSQLInjectionProtection: function () {
        // 实现SQL注入保护逻辑
    },

    /**
     * 启用速率限制
     */
    enableRateLimiting: function () {
        // 实现速率限制逻辑
    },

    /**
     * 生成盐
     * @returns {string} 盐
     */
    generateSalt: function () {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let salt = '';

        for (let i = 0; i < this.securityConfig.saltLength; i++) {
            salt += chars.charAt(Math.floor(Math.random() * chars.length));
        }

        return salt;
    },

    /**
     * 生成哈希
     * @param {string} data - 数据
     * @returns {string} 哈希
     */
    generateHash: function (data) {
        // 实现哈希生成逻辑
        return data;
    },

    /**
     * 验证输入
     * @param {string} type - 类型
     * @param {string} value - 值
     * @returns {Object} 验证结果
     */
    validateInput: function (type, value) {
        if (!this.securityConfig.useValidation) {
            return { valid: true };
        }

        const rules = this.securityConfig.validationRules[type];

        if (!rules) {
            return { valid: true };
        }

        // 检查最小长度
        if (rules.minLength && value.length < rules.minLength) {
            return { valid: false, error: '长度太短' };
        }

        // 检查最大长度
        if (rules.maxLength && value.length > rules.maxLength) {
            return { valid: false, error: '长度太长' };
        }

        // 检查模式
        if (rules.pattern && !new RegExp(rules.pattern).test(value)) {
            return { valid: false, error: '格式不正确' };
        }

        // 更新统计
        this.securityStats.stats.totalValidationOperations++;
        this.securityStats.stats.successfulValidations++;

        this.saveSecurityStats();

        return { valid: true };
    },

    /**
     * 检查XSS
     * @param {string} input - 输入
     * @returns {boolean} 是否包含XSS
     */
    checkXSS: function (input) {
        if (!this.securityConfig.useXSSProtection) {
            return false;
        }

        for (const pattern of this.xssPatterns) {
            if (pattern.test(input)) {
                this.securityStats.stats.totalXSSAttacks++;
                this.securityStats.stats.blockedXSSAttacks++;
                this.saveSecurityStats();
                return true;
            }
        }

        return false;
    },

    /**
     * 检查SQL注入
     * @param {string} input - 输入
     * @returns {boolean} 是否包含SQL注入
     */
    checkSQLInjection: function (input) {
        if (!this.securityConfig.useSQLInjectionProtection) {
            return false;
        }

        for (const pattern of this.sqlInjectionPatterns) {
            if (pattern.test(input)) {
                this.securityStats.stats.totalSQLInjectionAttacks++;
                this.securityStats.stats.blockedSQLInjectionAttacks++;
                this.saveSecurityStats();
                return true;
            }
        }

        return false;
    },

    /**
     * 检查速率限制
     * @param {string} identifier - 标识符
     * @returns {boolean} 是否超过速率限制
     */
    checkRateLimit: function (identifier) {
        if (!this.securityConfig.useRateLimiting) {
            return false;
        }

        const now = Date.now();
        const minute = Math.floor(now / 60000);

        if (!this.requestCounts[identifier]) {
            this.requestCounts[identifier] = {};
        }

        if (!this.requestCounts[identifier][minute]) {
            this.requestCounts[identifier][minute] = 0;
        }

        this.requestCounts[identifier][minute]++;

        // 清理旧数据
        for (const m in this.requestCounts[identifier]) {
            if (parseInt(m) < minute - 1) {
                delete this.requestCounts[identifier][m];
            }
        }

        // 检查是否超过限制
        if (this.requestCounts[identifier][minute] > this.securityConfig.maxRequestsPerMinute) {
            this.securityStats.stats.totalRateLimitViolations++;
            this.saveSecurityStats();
            return true;
        }

        return false;
    },

    /**
     * 记录日志
     * @param {string} level - 级别
     * @param {string} message - 消息
     */
    log: function (level, message) {
        if (!this.securityConfig.useLogging) {
            return;
        }

        const log = {
            level: level,
            message: message,
            timestamp: Date.now()
        };

        this.logs.push(log);

        // 限制日志数量
        if (this.logs.length > 1000) {
            this.logs.shift();
        }

        // 更新统计
        this.securityStats.stats.totalLogs++;

        this.saveSecurityStats();
    },

    /**
     * 审计
     * @param {string} action - 操作
     * @param {Object} data - 数据
     */
    audit: function (action, data) {
        if (!this.securityConfig.useAudit) {
            return;
        }

        const audit = {
            action: action,
            data: data,
            timestamp: Date.now()
        };

        this.audits.push(audit);

        // 限制审计数量
        if (this.audits.length > 1000) {
            this.audits.shift();
        }

        // 更新统计
        this.securityStats.stats.totalAudits++;

        this.saveSecurityStats();
    },

    /**
     * 监控安全
     */
    monitorSecurity: function () {
        // 实现安全监控逻辑
    },

    /**
     * 备份安全
     */
    backupSecurity: function () {
        // 实现安全备份逻辑

        // 更新统计
        this.securityStats.stats.totalBackups++;

        this.saveSecurityStats();
    },

    /**
     * 获取安全统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.securityStats.stats;
    },

    /**
     * 设置安全配置
     * @param {Object} config - 配置对象
     */
    setSecurityConfig: function (config) {
        this.securityConfig = { ...this.securityConfig, ...config };
        this.saveSecurityConfig();
    },

    /**
     * 获取安全配置
     * @returns {Object} 配置对象
     */
    getSecurityConfig: function () {
        return this.securityConfig;
    }
};

// 优化：游戏UI优化
const GameUIOptimizer = {
    uiConfig: {},
    uiStats: {},
    uiCache: {},

    /**
     * 初始化游戏UI优化
     */
    init: function () {
        this.loadUIConfig();
        this.loadUIStats();
        this.loadUICache();
        this.initUISystem();
        this.optimizeUI();
    },

    /**
     * 加载UI配置
     */
    loadUIConfig: function () {
        this.uiConfig = {
            enabled: true,
            useVirtualDOM: false,
            useReact: false,
            useVue: false,
            useAngular: false,
            useAnimation: true,
            animationDuration: 300,
            useTransition: true,
            transitionDuration: 200,
            useLazyLoading: true,
            lazyLoadThreshold: 100,
            usePrefetching: false,
            prefetchDistance: 200,
            useCaching: true,
            cacheSize: 100,
            cacheTTL: 300000,
            useThrottling: true,
            throttleInterval: 16,
            useDebouncing: true,
            debounceDelay: 100,
            useVirtualScrolling: false,
            virtualScrollItemSize: 50,
            useInfiniteScroll: false,
            useResponsive: true,
            breakpoints: {
                mobile: 768,
                tablet: 1024,
                desktop: 1440
            },
            useAdaptive: true,
            useAccessibility: true,
            useAccessibilityARIA: true,
            useAccessibilityKeyboard: true,
            useAccessibilityScreenReader: true,
            useTheme: true,
            themes: ['light', 'dark', 'auto'],
            currentTheme: 'auto',
            useLanguage: true,
            languages: ['en', 'zh', 'ja'],
            currentLanguage: 'zh',
            useNotifications: true,
            notificationDuration: 3000,
            useModals: true,
            useTooltips: true,
            tooltipDelay: 500,
            usePopovers: true,
            useDropdowns: true,
            useTabs: true,
            useAccordions: true,
            useCarousels: false,
            useSliders: false,
            useCharts: false,
            useGraphs: false
        };

        const customConfig = localStorage.getItem('uiConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.uiConfig = { ...this.uiConfig, ...config };
            } catch (error) {
                console.error('加载UI配置失败:', error);
            }
        }
    },

    /**
     * 保存UI配置
     */
    saveUIConfig: function () {
        localStorage.setItem('uiConfig', JSON.stringify(this.uiConfig));
    },

    /**
     * 加载UI统计
     */
    loadUIStats: function () {
        const savedStats = localStorage.getItem('uiStats');
        if (savedStats) {
            try {
                this.uiStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载UI统计失败:', error);
            }
        }

        if (!this.uiStats.stats) {
            this.uiStats = {
                stats: {
                    totalRenders: 0,
                    totalUpdates: 0,
                    totalAnimations: 0,
                    totalTransitions: 0,
                    totalLazyLoads: 0,
                    totalPrefetches: 0,
                    cacheHits: 0,
                    cacheMisses: 0,
                    cacheHitRate: 0,
                    totalThrottles: 0,
                    totalDebounces: 0,
                    totalVirtualScrolls: 0,
                    totalInfiniteScrolls: 0,
                    totalResponsiveChanges: 0,
                    totalThemeChanges: 0,
                    totalLanguageChanges: 0,
                    totalNotifications: 0,
                    totalModals: 0,
                    totalTooltips: 0,
                    totalPopovers: 0,
                    totalDropdowns: 0,
                    totalTabs: 0,
                    totalAccordions: 0
                }
            };

            this.saveUIStats();
        }
    },

    /**
     * 保存UI统计
     */
    saveUIStats: function () {
        localStorage.setItem('uiStats', JSON.stringify(this.uiStats));
    },

    /**
     * 加载UI缓存
     */
    loadUICache: function () {
        const savedCache = localStorage.getItem('uiCache');
        if (savedCache) {
            try {
                this.uiCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载UI缓存失败:', error);
            }
        }

        if (!this.uiCache.cache) {
            this.uiCache = {
                cache: {},
                stats: {
                    size: 0,
                    maxSize: this.uiConfig.cacheSize,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveUICache();
        }
    },

    /**
     * 保存UI缓存
     */
    saveUICache: function () {
        localStorage.setItem('uiCache', JSON.stringify(this.uiCache));
    },

    /**
     * 初始化UI系统
     */
    initUISystem: function () {
        // 初始化响应式
        if (this.uiConfig.useResponsive) {
            this.initResponsive();
        }

        // 初始化主题
        if (this.uiConfig.useTheme) {
            this.initTheme();
        }

        // 初始化语言
        if (this.uiConfig.useLanguage) {
            this.initLanguage();
        }

        // 初始化通知
        if (this.uiConfig.useNotifications) {
            this.initNotifications();
        }

        // 初始化模态框
        if (this.uiConfig.useModals) {
            this.initModals();
        }

        // 初始化工具提示
        if (this.uiConfig.useTooltips) {
            this.initTooltips();
        }

        // 初始化弹出框
        if (this.uiConfig.usePopovers) {
            this.initPopovers();
        }

        // 初始化下拉菜单
        if (this.uiConfig.useDropdowns) {
            this.initDropdowns();
        }

        // 初始化标签页
        if (this.uiConfig.useTabs) {
            this.initTabs();
        }

        // 初始化手风琴
        if (this.uiConfig.useAccordions) {
            this.initAccordions();
        }
    },

    /**
     * 初始化响应式
     */
    initResponsive: function () {
        this.currentBreakpoint = this.getBreakpoint();

        window.addEventListener('resize', () => {
            this.handleResize();
        });
    },

    /**
     * 初始化主题
     */
    initTheme: function () {
        this.applyTheme(this.uiConfig.currentTheme);
    },

    /**
     * 初始化语言
     */
    initLanguage: function () {
        this.applyLanguage(this.uiConfig.currentLanguage);
    },

    /**
     * 初始化通知
     */
    initNotifications: function () {
        this.notifications = [];
    },

    /**
     * 初始化模态框
     */
    initModals: function () {
        this.modals = [];
    },

    /**
     * 初始化工具提示
     */
    initTooltips: function () {
        this.tooltips = [];
    },

    /**
     * 初始化弹出框
     */
    initPopovers: function () {
        this.popovers = [];
    },

    /**
     * 初始化下拉菜单
     */
    initDropdowns: function () {
        this.dropdowns = [];
    },

    /**
     * 初始化标签页
     */
    initTabs: function () {
        this.tabs = [];
    },

    /**
     * 初始化手风琴
     */
    initAccordions: function () {
        this.accordions = [];
    },

    /**
     * 优化UI
     */
    optimizeUI: function () {
        // 启用动画
        if (this.uiConfig.useAnimation) {
            this.enableAnimation();
        }

        // 启用过渡
        if (this.uiConfig.useTransition) {
            this.enableTransition();
        }

        // 启用懒加载
        if (this.uiConfig.useLazyLoading) {
            this.enableLazyLoading();
        }

        // 启用预取
        if (this.uiConfig.usePrefetching) {
            this.enablePrefetching();
        }

        // 启用缓存
        if (this.uiConfig.useCaching) {
            this.enableCaching();
        }

        // 启用节流
        if (this.uiConfig.useThrottling) {
            this.enableThrottling();
        }

        // 启用防抖
        if (this.uiConfig.useDebouncing) {
            this.enableDebouncing();
        }

        // 启用虚拟滚动
        if (this.uiConfig.useVirtualScrolling) {
            this.enableVirtualScrolling();
        }

        // 启用无限滚动
        if (this.uiConfig.useInfiniteScroll) {
            this.enableInfiniteScroll();
        }

        // 启用响应式
        if (this.uiConfig.useResponsive) {
            this.enableResponsive();
        }

        // 启用自适应
        if (this.uiConfig.useAdaptive) {
            this.enableAdaptive();
        }

        // 启用无障碍
        if (this.uiConfig.useAccessibility) {
            this.enableAccessibility();
        }
    },

    /**
     * 启用动画
     */
    enableAnimation: function () {
        // 实现动画逻辑
    },

    /**
     * 启用过渡
     */
    enableTransition: function () {
        // 实现过渡逻辑
    },

    /**
     * 启用懒加载
     */
    enableLazyLoading: function () {
        // 实现懒加载逻辑
    },

    /**
     * 启用预取
     */
    enablePrefetching: function () {
        // 实现预取逻辑
    },

    /**
     * 启用缓存
     */
    enableCaching: function () {
        // 实现缓存逻辑
    },

    /**
     * 启用节流
     */
    enableThrottling: function () {
        // 实现节流逻辑
    },

    /**
     * 启用防抖
     */
    enableDebouncing: function () {
        // 实现防抖逻辑
    },

    /**
     * 启用虚拟滚动
     */
    enableVirtualScrolling: function () {
        // 实现虚拟滚动逻辑
    },

    /**
     * 启用无限滚动
     */
    enableInfiniteScroll: function () {
        // 实现无限滚动逻辑
    },

    /**
     * 启用响应式
     */
    enableResponsive: function () {
        // 实现响应式逻辑
    },

    /**
     * 启用自适应
     */
    enableAdaptive: function () {
        // 实现自适应逻辑
    },

    /**
     * 启用无障碍
     */
    enableAccessibility: function () {
        // 实现无障碍逻辑
    },

    /**
     * 获取断点
     * @returns {string} 断点
     */
    getBreakpoint: function () {
        const width = window.innerWidth;

        if (width < this.uiConfig.breakpoints.mobile) {
            return 'mobile';
        } else if (width < this.uiConfig.breakpoints.tablet) {
            return 'tablet';
        } else if (width < this.uiConfig.breakpoints.desktop) {
            return 'desktop';
        } else {
            return 'large';
        }
    },

    /**
     * 处理调整大小
     */
    handleResize: function () {
        const newBreakpoint = this.getBreakpoint();

        if (newBreakpoint !== this.currentBreakpoint) {
            this.currentBreakpoint = newBreakpoint;

            // 更新统计
            this.uiStats.stats.totalResponsiveChanges++;

            this.saveUIStats();
        }
    },

    /**
     * 应用主题
     * @param {string} theme - 主题
     */
    applyTheme: function (theme) {
        if (!this.uiConfig.themes.includes(theme)) {
            return;
        }

        this.uiConfig.currentTheme = theme;
        this.saveUIConfig();

        // 应用主题到DOM
        if (theme === 'auto') {
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            document.documentElement.setAttribute('data-theme', prefersDark ? 'dark' : 'light');
        } else {
            document.documentElement.setAttribute('data-theme', theme);
        }

        // 更新统计
        this.uiStats.stats.totalThemeChanges++;

        this.saveUIStats();
    },

    /**
     * 应用语言
     * @param {string} language - 语言
     */
    applyLanguage: function (language) {
        if (!this.uiConfig.languages.includes(language)) {
            return;
        }

        this.uiConfig.currentLanguage = language;
        this.saveUIConfig();

        // 应用语言到DOM
        document.documentElement.setAttribute('lang', language);

        // 更新统计
        this.uiStats.stats.totalLanguageChanges++;

        this.saveUIStats();
    },

    /**
     * 显示通知
     * @param {string} message - 消息
     * @param {string} type - 类型
     */
    showNotification: function (message, type) {
        if (!this.uiConfig.useNotifications) {
            return;
        }

        const notification = {
            id: 'notification_' + Date.now(),
            message: message,
            type: type || 'info',
            timestamp: Date.now()
        };

        this.notifications.push(notification);

        // 更新统计
        this.uiStats.stats.totalNotifications++;

        this.saveUIStats();

        // 自动隐藏
        setTimeout(() => {
            this.hideNotification(notification.id);
        }, this.uiConfig.notificationDuration);
    },

    /**
     * 隐藏通知
     * @param {string} id - ID
     */
    hideNotification: function (id) {
        const index = this.notifications.findIndex(n => n.id === id);

        if (index !== -1) {
            this.notifications.splice(index, 1);
        }
    },

    /**
     * 显示模态框
     * @param {string} content - 内容
     */
    showModal: function (content) {
        if (!this.uiConfig.useModals) {
            return;
        }

        const modal = {
            id: 'modal_' + Date.now(),
            content: content,
            timestamp: Date.now()
        };

        this.modals.push(modal);

        // 更新统计
        this.uiStats.stats.totalModals++;

        this.saveUIStats();
    },

    /**
     * 隐藏模态框
     * @param {string} id - ID
     */
    hideModal: function (id) {
        const index = this.modals.findIndex(m => m.id === id);

        if (index !== -1) {
            this.modals.splice(index, 1);
        }
    },

    /**
     * 获取UI统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.uiStats.stats;
    },

    /**
     * 设置UI配置
     * @param {Object} config - 配置对象
     */
    setUIConfig: function (config) {
        this.uiConfig = { ...this.uiConfig, ...config };
        this.saveUIConfig();
    },

    /**
     * 获取UI配置
     * @returns {Object} 配置对象
     */
    getUIConfig: function () {
        return this.uiConfig;
    }
};

// 优化：游戏动画优化
const GameAnimationOptimizer = {
    animationConfig: {},
    animationStats: {},
    animationCache: {},

    /**
     * 初始化游戏动画优化
     */
    init: function () {
        this.loadAnimationConfig();
        this.loadAnimationStats();
        this.loadAnimationCache();
        this.initAnimationSystem();
        this.optimizeAnimation();
    },

    /**
     * 加载动画配置
     */
    loadAnimationConfig: function () {
        this.animationConfig = {
            enabled: true,
            useCSSAnimations: true,
            useJSAnimations: true,
            useWebAnimationsAPI: false,
            useCanvasAnimations: false,
            useSVGAnimations: false,
            useGPUAcceleration: true,
            useRequestAnimationFrame: true,
            useIntersectionObserver: true,
            useLazyLoading: true,
            lazyLoadThreshold: 100,
            usePrefetching: false,
            prefetchDistance: 200,
            useCaching: true,
            cacheSize: 100,
            cacheTTL: 300000,
            useThrottling: true,
            throttleInterval: 16,
            useDebouncing: true,
            debounceDelay: 100,
            defaultDuration: 300,
            defaultEasing: 'ease',
            defaultDelay: 0,
            defaultFill: 'forwards',
            defaultIteration: 1,
            defaultDirection: 'normal',
            useSpriteSheets: false,
            spriteSheetSize: 1024,
            useFrameSkipping: false,
            frameSkipInterval: 2,
            useTimeScaling: true,
            timeScale: 1.0,
            useInterpolation: true,
            interpolationType: 'linear',
            useBlending: true,
            blendingMode: 'normal',
            useCompositing: true,
            compositingOperation: 'source-over',
            useTransforms: true,
            useTransitions: true,
            transitionDuration: 200,
            useKeyframes: true,
            useSequences: true,
            useTimelines: true,
            useStateMachines: false,
            useBlendTrees: false
        };

        const customConfig = localStorage.getItem('animationConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.animationConfig = { ...this.animationConfig, ...config };
            } catch (error) {
                console.error('加载动画配置失败:', error);
            }
        }
    },

    /**
     * 保存动画配置
     */
    saveAnimationConfig: function () {
        localStorage.setItem('animationConfig', JSON.stringify(this.animationConfig));
    },

    /**
     * 加载动画统计
     */
    loadAnimationStats: function () {
        const savedStats = localStorage.getItem('animationStats');
        if (savedStats) {
            try {
                this.animationStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载动画统计失败:', error);
            }
        }

        if (!this.animationStats.stats) {
            this.animationStats = {
                stats: {
                    totalAnimations: 0,
                    activeAnimations: 0,
                    completedAnimations: 0,
                    cancelledAnimations: 0,
                    totalFrames: 0,
                    totalDuration: 0,
                    avgDuration: 0,
                    totalCSSAnimations: 0,
                    totalJSAnimations: 0,
                    totalWebAnimationsAPIAnimations: 0,
                    totalCanvasAnimations: 0,
                    totalSVGAnimations: 0,
                    cacheHits: 0,
                    cacheMisses: 0,
                    cacheHitRate: 0,
                    totalThrottles: 0,
                    totalDebounces: 0,
                    totalLazyLoads: 0,
                    totalPrefetches: 0,
                    totalSpriteSheets: 0,
                    totalFrameSkips: 0,
                    totalTimeScales: 0,
                    totalInterpolations: 0,
                    totalBlends: 0,
                    totalComposites: 0,
                    totalTransforms: 0,
                    totalTransitions: 0,
                    totalKeyframes: 0,
                    totalSequences: 0,
                    totalTimelines: 0
                }
            };

            this.saveAnimationStats();
        }
    },

    /**
     * 保存动画统计
     */
    saveAnimationStats: function () {
        localStorage.setItem('animationStats', JSON.stringify(this.animationStats));
    },

    /**
     * 加载动画缓存
     */
    loadAnimationCache: function () {
        const savedCache = localStorage.getItem('animationCache');
        if (savedCache) {
            try {
                this.animationCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载动画缓存失败:', error);
            }
        }

        if (!this.animationCache.cache) {
            this.animationCache = {
                cache: {},
                stats: {
                    size: 0,
                    maxSize: this.animationConfig.cacheSize,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveAnimationCache();
        }
    },

    /**
     * 保存动画缓存
     */
    saveAnimationCache: function () {
        localStorage.setItem('animationCache', JSON.stringify(this.animationCache));
    },

    /**
     * 初始化动画系统
     */
    initAnimationSystem: function () {
        // 初始化动画队列
        this.animationQueue = [];

        // 初始化动画时间轴
        this.timelines = [];

        // 初始化动画序列
        this.sequences = [];

        // 初始化动画关键帧
        this.keyframes = {};

        // 初始化动画状态
        this.animationState = {
            playing: false,
            paused: false,
            currentTime: 0,
            totalTime: 0
        };

        // 启动动画循环
        if (this.animationConfig.useRequestAnimationFrame) {
            this.startAnimationLoop();
        }
    },

    /**
     * 启动动画循环
     */
    startAnimationLoop: function () {
        const animate = (timestamp) => {
            if (this.animationConfig.enabled) {
                this.updateAnimations(timestamp);
            }

            requestAnimationFrame(animate);
        };

        requestAnimationFrame(animate);
    },

    /**
     * 优化动画
     */
    optimizeAnimation: function () {
        // 启用CSS动画
        if (this.animationConfig.useCSSAnimations) {
            this.enableCSSAnimations();
        }

        // 启用JS动画
        if (this.animationConfig.useJSAnimations) {
            this.enableJSAnimations();
        }

        // 启用Web Animations API
        if (this.animationConfig.useWebAnimationsAPI) {
            this.enableWebAnimationsAPI();
        }

        // 启用Canvas动画
        if (this.animationConfig.useCanvasAnimations) {
            this.enableCanvasAnimations();
        }

        // 启用SVG动画
        if (this.animationConfig.useSVGAnimations) {
            this.enableSVGAnimations();
        }

        // 启用GPU加速
        if (this.animationConfig.useGPUAcceleration) {
            this.enableGPUAcceleration();
        }

        // 启用懒加载
        if (this.animationConfig.useLazyLoading) {
            this.enableLazyLoading();
        }

        // 启用预取
        if (this.animationConfig.usePrefetching) {
            this.enablePrefetching();
        }

        // 启用缓存
        if (this.animationConfig.useCaching) {
            this.enableCaching();
        }

        // 启用节流
        if (this.animationConfig.useThrottling) {
            this.enableThrottling();
        }

        // 启用防抖
        if (this.animationConfig.useDebouncing) {
            this.enableDebouncing();
        }

        // 启用精灵表
        if (this.animationConfig.useSpriteSheets) {
            this.enableSpriteSheets();
        }

        // 启用帧跳过
        if (this.animationConfig.useFrameSkipping) {
            this.enableFrameSkipping();
        }

        // 启用时间缩放
        if (this.animationConfig.useTimeScaling) {
            this.enableTimeScaling();
        }

        // 启用插值
        if (this.animationConfig.useInterpolation) {
            this.enableInterpolation();
        }

        // 启用混合
        if (this.animationConfig.useBlending) {
            this.enableBlending();
        }

        // 启用合成
        if (this.animationConfig.useCompositing) {
            this.enableCompositing();
        }
    },

    /**
     * 启用CSS动画
     */
    enableCSSAnimations: function () {
        // 实现CSS动画逻辑
    },

    /**
     * 启用JS动画
     */
    enableJSAnimations: function () {
        // 实现JS动画逻辑
    },

    /**
     * 启用Web Animations API
     */
    enableWebAnimationsAPI: function () {
        // 实现Web Animations API逻辑
    },

    /**
     * 启用Canvas动画
     */
    enableCanvasAnimations: function () {
        // 实现Canvas动画逻辑
    },

    /**
     * 启用SVG动画
     */
    enableSVGAnimations: function () {
        // 实现SVG动画逻辑
    },

    /**
     * 启用GPU加速
     */
    enableGPUAcceleration: function () {
        // 实现GPU加速逻辑
    },

    /**
     * 启用懒加载
     */
    enableLazyLoading: function () {
        // 实现懒加载逻辑
    },

    /**
     * 启用预取
     */
    enablePrefetching: function () {
        // 实现预取逻辑
    },

    /**
     * 启用缓存
     */
    enableCaching: function () {
        // 实现缓存逻辑
    },

    /**
     * 启用节流
     */
    enableThrottling: function () {
        // 实现节流逻辑
    },

    /**
     * 启用防抖
     */
    enableDebouncing: function () {
        // 实现防抖逻辑
    },

    /**
     * 启用精灵表
     */
    enableSpriteSheets: function () {
        // 实现精灵表逻辑
    },

    /**
     * 启用帧跳过
     */
    enableFrameSkipping: function () {
        // 实现帧跳过逻辑
    },

    /**
     * 启用时间缩放
     */
    enableTimeScaling: function () {
        // 实现时间缩放逻辑
    },

    /**
     * 启用插值
     */
    enableInterpolation: function () {
        // 实现插值逻辑
    },

    /**
     * 启用混合
     */
    enableBlending: function () {
        // 实现混合逻辑
    },

    /**
     * 启用合成
     */
    enableCompositing: function () {
        // 实现合成逻辑
    },

    /**
     * 更新动画
     * @param {number} timestamp - 时间戳
     */
    updateAnimations: function (timestamp) {
        const deltaTime = timestamp - this.animationState.lastTimestamp;

        // 应用时间缩放
        const scaledDelta = deltaTime * this.animationConfig.timeScale;

        // 更新动画状态
        this.animationState.currentTime += scaledDelta;
        this.animationState.totalTime += scaledDelta;

        // 更新活动动画
        for (const animation of this.animationQueue) {
            if (animation.active) {
                this.updateAnimation(animation, scaledDelta);
            }
        }

        this.animationState.lastTimestamp = timestamp;
    },

    /**
     * 更新动画
     * @param {Object} animation - 动画对象
     * @param {number} deltaTime - 时间增量
     */
    updateAnimation: function (animation, deltaTime) {
        // 更新动画进度
        animation.progress += deltaTime / animation.duration;

        // 应用插值
        if (this.animationConfig.useInterpolation) {
            animation.currentValue = this.interpolate(
                animation.from,
                animation.to,
                animation.progress,
                this.animationConfig.interpolationType
            );
        }

        // 应用动画
        this.applyAnimation(animation);

        // 检查是否完成
        if (animation.progress >= 1) {
            this.completeAnimation(animation);
        }
    },

    /**
     * 插值
     * @param {number} from - 起始值
     * @param {number} to - 结束值
     * @param {number} progress - 进度
     * @param {string} type - 类型
     * @returns {number} 插值结果
     */
    interpolate: function (from, to, progress, type) {
        switch (type) {
            case 'linear':
                return from + (to - from) * progress;
            case 'ease':
                return this.easeInOutQuad(progress) * (to - from) + from;
            case 'ease-in':
                return this.easeInQuad(progress) * (to - from) + from;
            case 'ease-out':
                return this.easeOutQuad(progress) * (to - from) + from;
            default:
                return from + (to - from) * progress;
        }
    },

    /**
     * 缓入
     * @param {number} t - 时间
     * @returns {number} 缓入结果
     */
    easeInQuad: function (t) {
        return t * t;
    },

    /**
     * 缓出
     * @param {number} t - 时间
     * @returns {number} 缓出结果
     */
    easeOutQuad: function (t) {
        return t * (2 - t);
    },

    /**
     * 缓入缓出
     * @param {number} t - 时间
     * @returns {number} 缓入缓出结果
     */
    easeInOutQuad: function (t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    },

    /**
     * 应用动画
     * @param {Object} animation - 动画对象
     */
    applyAnimation: function (animation) {
        // 应用动画到目标元素
        const target = document.querySelector(animation.target);

        if (target) {
            switch (animation.property) {
                case 'opacity':
                    target.style.opacity = animation.currentValue;
                    break;
                case 'transform':
                    target.style.transform = `translate(${animation.currentValue}px, 0)`;
                    break;
                default:
                    target.style[animation.property] = animation.currentValue;
            }
        }
    },

    /**
     * 完成动画
     * @param {Object} animation - 动画对象
     */
    completeAnimation: function (animation) {
        animation.active = false;
        animation.completed = true;

        // 更新统计
        this.animationStats.stats.completedAnimations++;
        this.animationStats.stats.activeAnimations--;

        this.saveAnimationStats();

        // 调用完成回调
        if (animation.onComplete) {
            animation.onComplete();
        }
    },

    /**
     * 创建动画
     * @param {Object} options - 动画选项
     * @returns {Object} 动画对象
     */
    createAnimation: function (options) {
        if (!this.animationConfig.enabled) {
            return null;
        }

        const animation = {
            id: 'animation_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            target: options.target,
            property: options.property,
            from: options.from,
            to: options.to,
            duration: options.duration || this.animationConfig.defaultDuration,
            easing: options.easing || this.animationConfig.defaultEasing,
            delay: options.delay || this.animationConfig.defaultDelay,
            fill: options.fill || this.animationConfig.defaultFill,
            iteration: options.iteration || this.animationConfig.defaultIteration,
            direction: options.direction || this.animationConfig.defaultDirection,
            progress: 0,
            currentValue: options.from,
            active: true,
            completed: false,
            onCreate: options.onCreate,
            onUpdate: options.onUpdate,
            onComplete: options.onComplete,
            onCancel: options.onCancel
        };

        // 添加到队列
        this.animationQueue.push(animation);

        // 更新统计
        this.animationStats.stats.totalAnimations++;
        this.animationStats.stats.activeAnimations++;

        // 根据类型更新统计
        if (options.type === 'css') {
            this.animationStats.stats.totalCSSAnimations++;
        } else if (options.type === 'js') {
            this.animationStats.stats.totalJSAnimations++;
        }

        this.saveAnimationStats();

        // 调用创建回调
        if (animation.onCreate) {
            animation.onCreate(animation);
        }

        return animation;
    },

    /**
     * 取消动画
     * @param {string} animationId - 动画ID
     */
    cancelAnimation: function (animationId) {
        const index = this.animationQueue.findIndex(a => a.id === animationId);

        if (index !== -1) {
            const animation = this.animationQueue[index];
            animation.active = false;
            animation.cancelled = true;

            // 更新统计
            this.animationStats.stats.cancelledAnimations++;
            this.animationStats.stats.activeAnimations--;

            this.saveAnimationStats();

            // 调用取消回调
            if (animation.onCancel) {
                animation.onCancel(animation);
            }
        }
    },

    /**
     * 获取动画统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.animationStats.stats;
    },

    /**
     * 设置动画配置
     * @param {Object} config - 配置对象
     */
    setAnimationConfig: function (config) {
        this.animationConfig = { ...this.animationConfig, ...config };
        this.saveAnimationConfig();
    },

    /**
     * 获取动画配置
     * @returns {Object} 配置对象
     */
    getAnimationConfig: function () {
        return this.animationConfig;
    }
};

// 优化：游戏数据优化
const GameDataOptimizer = {
    dataConfig: {},
    dataStats: {},
    dataCache: {},

    /**
     * 初始化游戏数据优化
     */
    init: function () {
        this.loadDataConfig();
        this.loadDataStats();
        this.loadDataCache();
        this.initDataSystem();
        this.optimizeData();
    },

    /**
     * 加载数据配置
     */
    loadDataConfig: function () {
        this.dataConfig = {
            enabled: true,
            useCompression: true,
            compressionLevel: 6,
            useEncryption: true,
            encryptionType: 'AES',
            encryptionKeyLength: 256,
            useValidation: true,
            validationRules: {},
            useSanitization: true,
            useNormalization: true,
            useCaching: true,
            cacheSize: 100,
            cacheTTL: 300000,
            useLazyLoading: true,
            lazyLoadThreshold: 100,
            usePrefetching: false,
            prefetchDistance: 200,
            useThrottling: true,
            throttleInterval: 16,
            useDebouncing: true,
            debounceDelay: 100,
            useBatchProcessing: true,
            batchSize: 10,
            useStreaming: false,
            usePagination: true,
            pageSize: 20,
            useIndexing: true,
            usePartitioning: false,
            useSharding: false,
            useReplication: false,
            useBackup: true,
            backupInterval: 86400000,
            backupRetention: 30,
            useVersioning: true,
            maxVersions: 10,
            useArchiving: true,
            archiveInterval: 604800000,
            archiveRetention: 365,
            usePurging: true,
            purgeInterval: 2592000000,
            purgeRetention: 90,
            useMonitoring: true,
            monitoringInterval: 60000,
            useLogging: true,
            logLevel: 'info',
            logRetention: 7
        };

        const customConfig = localStorage.getItem('dataConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.dataConfig = { ...this.dataConfig, ...config };
            } catch (error) {
                console.error('加载数据配置失败:', error);
            }
        }
    },

    /**
     * 保存数据配置
     */
    saveDataConfig: function () {
        localStorage.setItem('dataConfig', JSON.stringify(this.dataConfig));
    },

    /**
     * 加载数据统计
     */
    loadDataStats: function () {
        const savedStats = localStorage.getItem('dataStats');
        if (savedStats) {
            try {
                this.dataStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载数据统计失败:', error);
            }
        }

        if (!this.dataStats.stats) {
            this.dataStats = {
                stats: {
                    totalOperations: 0,
                    readOperations: 0,
                    writeOperations: 0,
                    updateOperations: 0,
                    deleteOperations: 0,
                    totalBytesRead: 0,
                    totalBytesWritten: 0,
                    avgReadTime: 0,
                    avgWriteTime: 0,
                    avgUpdateTime: 0,
                    avgDeleteTime: 0,
                    cacheHits: 0,
                    cacheMisses: 0,
                    cacheHitRate: 0,
                    totalCompressions: 0,
                    totalDecompressions: 0,
                    totalEncryptions: 0,
                    totalDecryptions: 0,
                    totalValidations: 0,
                    successfulValidations: 0,
                    failedValidations: 0,
                    totalSanitizations: 0,
                    totalNormalizations: 0,
                    totalLazyLoads: 0,
                    totalPrefetches: 0,
                    totalThrottles: 0,
                    totalDebounces: 0,
                    totalBatchProcesses: 0,
                    totalStreams: 0,
                    totalPaginations: 0,
                    totalBackups: 0,
                    totalVersions: 0,
                    totalArchives: 0,
                    totalPurges: 0,
                    totalLogs: 0
                }
            };

            this.saveDataStats();
        }
    },

    /**
     * 保存数据统计
     */
    saveDataStats: function () {
        localStorage.setItem('dataStats', JSON.stringify(this.dataStats));
    },

    /**
     * 加载数据缓存
     */
    loadDataCache: function () {
        const savedCache = localStorage.getItem('dataCache');
        if (savedCache) {
            try {
                this.dataCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载数据缓存失败:', error);
            }
        }

        if (!this.dataCache.cache) {
            this.dataCache = {
                cache: {},
                stats: {
                    size: 0,
                    maxSize: this.dataConfig.cacheSize,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveDataCache();
        }
    },

    /**
     * 保存数据缓存
     */
    saveDataCache: function () {
        localStorage.setItem('dataCache', JSON.stringify(this.dataCache));
    },

    /**
     * 初始化数据系统
     */
    initDataSystem: function () {
        // 初始化数据存储
        this.dataStore = {};

        // 初始化数据索引
        this.dataIndex = {};

        // 初始化数据版本
        this.dataVersions = {};

        // 初始化数据备份
        this.dataBackups = [];

        // 初始化数据归档
        this.dataArchives = [];

        // 初始化数据日志
        this.dataLogs = [];

        // 初始化批处理队列
        this.batchQueue = [];

        // 启动备份
        if (this.dataConfig.useBackup) {
            this.startBackup();
        }

        // 启动归档
        if (this.dataConfig.useArchiving) {
            this.startArchiving();
        }

        // 启动清理
        if (this.dataConfig.usePurging) {
            this.startPurging();
        }

        // 启动监控
        if (this.dataConfig.useMonitoring) {
            this.startMonitoring();
        }
    },

    /**
     * 启动备份
     */
    startBackup: function () {
        setInterval(() => {
            if (this.dataConfig.useBackup) {
                this.backupData();
            }
        }, this.dataConfig.backupInterval);
    },

    /**
     * 启动归档
     */
    startArchiving: function () {
        setInterval(() => {
            if (this.dataConfig.useArchiving) {
                this.archiveData();
            }
        }, this.dataConfig.archiveInterval);
    },

    /**
     * 启动清理
     */
    startPurging: function () {
        setInterval(() => {
            if (this.dataConfig.usePurging) {
                this.purgeData();
            }
        }, this.dataConfig.purgeInterval);
    },

    /**
     * 启动监控
     */
    startMonitoring: function () {
        setInterval(() => {
            if (this.dataConfig.useMonitoring) {
                this.monitorData();
            }
        }, this.dataConfig.monitoringInterval);
    },

    /**
     * 优化数据
     */
    optimizeData: function () {
        // 启用压缩
        if (this.dataConfig.useCompression) {
            this.enableCompression();
        }

        // 启用加密
        if (this.dataConfig.useEncryption) {
            this.enableEncryption();
        }

        // 启用验证
        if (this.dataConfig.useValidation) {
            this.enableValidation();
        }

        // 启用清理
        if (this.dataConfig.useSanitization) {
            this.enableSanitization();
        }

        // 启用规范化
        if (this.dataConfig.useNormalization) {
            this.enableNormalization();
        }

        // 启用缓存
        if (this.dataConfig.useCaching) {
            this.enableCaching();
        }

        // 启用懒加载
        if (this.dataConfig.useLazyLoading) {
            this.enableLazyLoading();
        }

        // 启用预取
        if (this.dataConfig.usePrefetching) {
            this.enablePrefetching();
        }

        // 启用节流
        if (this.dataConfig.useThrottling) {
            this.enableThrottling();
        }

        // 启用防抖
        if (this.dataConfig.useDebouncing) {
            this.enableDebouncing();
        }

        // 启用批处理
        if (this.dataConfig.useBatchProcessing) {
            this.enableBatchProcessing();
        }

        // 启用流式处理
        if (this.dataConfig.useStreaming) {
            this.enableStreaming();
        }

        // 启用分页
        if (this.dataConfig.usePagination) {
            this.enablePagination();
        }

        // 启用索引
        if (this.dataConfig.useIndexing) {
            this.enableIndexing();
        }
    },

    /**
     * 启用压缩
     */
    enableCompression: function () {
        // 实现压缩逻辑
    },

    /**
     * 启用加密
     */
    enableEncryption: function () {
        // 实现加密逻辑
    },

    /**
     * 启用验证
     */
    enableValidation: function () {
        // 实现验证逻辑
    },

    /**
     * 启用清理
     */
    enableSanitization: function () {
        // 实现清理逻辑
    },

    /**
     * 启用规范化
     */
    enableNormalization: function () {
        // 实现规范化逻辑
    },

    /**
     * 启用缓存
     */
    enableCaching: function () {
        // 实现缓存逻辑
    },

    /**
     * 启用懒加载
     */
    enableLazyLoading: function () {
        // 实现懒加载逻辑
    },

    /**
     * 启用预取
     */
    enablePrefetching: function () {
        // 实现预取逻辑
    },

    /**
     * 启用节流
     */
    enableThrottling: function () {
        // 实现节流逻辑
    },

    /**
     * 启用防抖
     */
    enableDebouncing: function () {
        // 实现防抖逻辑
    },

    /**
     * 启用批处理
     */
    enableBatchProcessing: function () {
        // 实现批处理逻辑
    },

    /**
     * 启用流式处理
     */
    enableStreaming: function () {
        // 实现流式处理逻辑
    },

    /**
     * 启用分页
     */
    enablePagination: function () {
        // 实现分页逻辑
    },

    /**
     * 启用索引
     */
    enableIndexing: function () {
        // 实现索引逻辑
    },

    /**
     * 保存数据
     * @param {string} key - 键
     * @param {any} value - 值
     * @param {Object} options - 选项
     * @returns {Promise} 保存Promise
     */
    save: function (key, value, options) {
        if (!this.dataConfig.enabled) {
            return Promise.reject(new Error('数据已禁用'));
        }

        options = options || {};

        const startTime = Date.now();

        // 序列化数据
        let serializedValue;

        try {
            serializedValue = JSON.stringify(value);
        } catch (error) {
            return Promise.reject(new Error('序列化失败'));
        }

        // 规范化数据
        if (this.dataConfig.useNormalization) {
            serializedValue = this.normalizeData(serializedValue);
        }

        // 清理数据
        if (this.dataConfig.useSanitization) {
            serializedValue = this.sanitizeData(serializedValue);
        }

        // 验证数据
        if (this.dataConfig.useValidation) {
            const validationResult = this.validateData(key, serializedValue, options);

            if (!validationResult.valid) {
                return Promise.reject(new Error(validationResult.error));
            }
        }

        // 压缩数据
        if (this.dataConfig.useCompression) {
            serializedValue = this.compressData(serializedValue);
        }

        // 加密数据
        if (this.dataConfig.useEncryption) {
            serializedValue = this.encryptData(serializedValue);
        }

        // 保存版本
        if (this.dataConfig.useVersioning) {
            this.saveVersion(key, value);
        }

        // 保存数据
        this.dataStore[key] = serializedValue;

        // 缓存数据
        if (this.dataConfig.useCaching) {
            this.cacheData(key, value);
        }

        const endTime = Date.now();
        const writeTime = endTime - startTime;

        // 更新统计
        this.dataStats.stats.totalOperations++;
        this.dataStats.stats.writeOperations++;
        this.dataStats.stats.totalBytesWritten += serializedValue.length;
        this.dataStats.stats.avgWriteTime =
            (this.dataStats.stats.avgWriteTime + writeTime) / 2;

        this.saveDataStats();

        return Promise.resolve({ success: true });
    },

    /**
     * 加载数据
     * @param {string} key - 键
     * @param {Object} options - 选项
     * @returns {Promise} 加载Promise
     */
    load: function (key, options) {
        if (!this.dataConfig.enabled) {
            return Promise.reject(new Error('数据已禁用'));
        }

        options = options || {};

        const startTime = Date.now();

        // 检查缓存
        if (this.dataConfig.useCaching) {
            const cachedValue = this.getCachedData(key);

            if (cachedValue) {
                return Promise.resolve(cachedValue);
            }
        }

        // 加载数据
        let serializedValue = this.dataStore[key];

        if (!serializedValue) {
            return Promise.reject(new Error('数据不存在'));
        }

        // 解密数据
        if (this.dataConfig.useEncryption) {
            serializedValue = this.decryptData(serializedValue);
        }

        // 解压数据
        if (this.dataConfig.useCompression) {
            serializedValue = this.decompressData(serializedValue);
        }

        // 反序列化数据
        let value;

        try {
            value = JSON.parse(serializedValue);
        } catch (error) {
            return Promise.reject(new Error('反序列化失败'));
        }

        // 缓存数据
        if (this.dataConfig.useCaching) {
            this.cacheData(key, value);
        }

        const endTime = Date.now();
        const readTime = endTime - startTime;

        // 更新统计
        this.dataStats.stats.totalOperations++;
        this.dataStats.stats.readOperations++;
        this.dataStats.stats.totalBytesRead += serializedValue.length;
        this.dataStats.stats.avgReadTime =
            (this.dataStats.stats.avgReadTime + readTime) / 2;

        this.saveDataStats();

        return Promise.resolve(value);
    },

    /**
     * 删除数据
     * @param {string} key - 键
     * @param {Object} options - 选项
     * @returns {Promise} 删除Promise
     */
    delete: function (key, options) {
        if (!this.dataConfig.enabled) {
            return Promise.reject(new Error('数据已禁用'));
        }

        options = options || {};

        const startTime = Date.now();

        // 删除数据
        delete this.dataStore[key];

        // 删除缓存
        if (this.dataConfig.useCaching) {
            this.removeCachedData(key);
        }

        const endTime = Date.now();
        const deleteTime = endTime - startTime;

        // 更新统计
        this.dataStats.stats.totalOperations++;
        this.dataStats.stats.deleteOperations++;
        this.dataStats.stats.avgDeleteTime =
            (this.dataStats.stats.avgDeleteTime + deleteTime) / 2;

        this.saveDataStats();

        return Promise.resolve({ success: true });
    },

    /**
     * 缓存数据
     * @param {string} key - 键
     * @param {any} value - 值
     */
    cacheData: function (key, value) {
        if (Object.keys(this.dataCache.cache).length >= this.dataConfig.cacheSize) {
            // 删除最旧的缓存项
            const oldestKey = Object.keys(this.dataCache.cache)[0];
            delete this.dataCache.cache[oldestKey];
        }

        this.dataCache.cache[key] = {
            value: value,
            timestamp: Date.now()
        };

        this.dataCache.stats.size = Object.keys(this.dataCache.cache).length;
        this.saveDataCache();
    },

    /**
     * 获取缓存数据
     * @param {string} key - 键
     * @returns {any|null} 值
     */
    getCachedData: function (key) {
        const cached = this.dataCache.cache[key];

        if (cached) {
            // 检查是否过期
            const age = Date.now() - cached.timestamp;

            if (age < this.dataConfig.cacheTTL) {
                this.dataCache.stats.hits++;
                this.dataStats.stats.cacheHits++;
            } else {
                delete this.dataCache.cache[key];
                this.dataCache.stats.size = Object.keys(this.dataCache.cache).length;
                this.dataCache.stats.misses++;
                this.dataStats.stats.cacheMisses++;
            }
        } else {
            this.dataCache.stats.misses++;
            this.dataStats.stats.cacheMisses++;
        }

        // 更新缓存命中率
        const total = this.dataCache.stats.hits + this.dataCache.stats.misses;
        this.dataCache.stats.hitRate = total > 0 ? (this.dataCache.stats.hits / total) * 100 : 0;
        this.dataStats.stats.cacheHitRate = this.dataCache.stats.hitRate;

        this.saveDataCache();
        this.saveDataStats();

        return cached ? cached.value : null;
    },

    /**
     * 删除缓存数据
     * @param {string} key - 键
     */
    removeCachedData: function (key) {
        delete this.dataCache.cache[key];
        this.dataCache.stats.size = Object.keys(this.dataCache.cache).length;
        this.saveDataCache();
    },

    /**
     * 保存版本
     * @param {string} key - 键
     * @param {any} value - 值
     */
    saveVersion: function (key, value) {
        if (!this.dataVersions[key]) {
            this.dataVersions[key] = [];
        }

        this.dataVersions[key].push({
            value: value,
            timestamp: Date.now()
        });

        // 限制版本数量
        if (this.dataVersions[key].length > this.dataConfig.maxVersions) {
            this.dataVersions[key].shift();
        }

        // 更新统计
        this.dataStats.stats.totalVersions++;

        this.saveDataStats();
    },

    /**
     * 备份数据
     */
    backupData: function () {
        const backup = {
            data: { ...this.dataStore },
            timestamp: Date.now()
        };

        this.dataBackups.push(backup);

        // 限制备份数量
        if (this.dataBackups.length > this.dataConfig.backupRetention) {
            this.dataBackups.shift();
        }

        // 更新统计
        this.dataStats.stats.totalBackups++;

        this.saveDataStats();
    },

    /**
     * 归档数据
     */
    archiveData: function () {
        // 实现归档逻辑

        // 更新统计
        this.dataStats.stats.totalArchives++;

        this.saveDataStats();
    },

    /**
     * 清理数据
     */
    purgeData: function () {
        // 实现清理逻辑

        // 更新统计
        this.dataStats.stats.totalPurges++;

        this.saveDataStats();
    },

    /**
     * 监控数据
     */
    monitorData: function () {
        // 实现监控逻辑
    },

    /**
     * 获取数据统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.dataStats.stats;
    },

    /**
     * 设置数据配置
     * @param {Object} config - 配置对象
     */
    setDataConfig: function (config) {
        this.dataConfig = { ...this.dataConfig, ...config };
        this.saveDataConfig();
    },

    /**
     * 获取数据配置
     * @returns {Object} 配置对象
     */
    getDataConfig: function () {
        return this.dataConfig;
    }
};

// 优化：游戏日志优化
const GameLogOptimizer = {
    logConfig: {},
    logStats: {},
    logCache: {},

    /**
     * 初始化游戏日志优化
     */
    init: function () {
        this.loadLogConfig();
        this.loadLogStats();
        this.loadLogCache();
        this.initLogSystem();
        this.optimizeLog();
    },

    /**
     * 加载日志配置
     */
    loadLogConfig: function () {
        this.logConfig = {
            enabled: true,
            logLevel: 'info',
            logLevels: ['debug', 'info', 'warn', 'error', 'fatal'],
            useConsole: true,
            useFile: false,
            useRemote: false,
            useBuffer: true,
            bufferSize: 1000,
            bufferFlushInterval: 5000,
            useCompression: true,
            compressionLevel: 6,
            useEncryption: true,
            encryptionType: 'AES',
            useTimestamp: true,
            timestampFormat: 'YYYY-MM-DD HH:mm:ss',
            useColors: true,
            colors: {
                debug: '#00BFFF',
                info: '#00FF00',
                warn: '#FFA500',
                error: '#FF0000',
                fatal: '#800080'
            },
            useFormatting: true,
            format: '[{timestamp}] [{level}] {message}',
            useContext: true,
            useStacktrace: true,
            stacktraceDepth: 5,
            useFiltering: true,
            filters: [],
            useRouting: true,
            routes: {},
            useAggregation: true,
            aggregationInterval: 60000,
            useAlerting: true,
            alertRules: [],
            useRetention: true,
            retentionPeriod: 7,
            useArchiving: true,
            archiveInterval: 86400000,
            archiveRetention: 30,
            usePurging: true,
            purgeInterval: 2592000000,
            purgeRetention: 90,
            useMonitoring: true,
            monitoringInterval: 60000
        };

        const customConfig = localStorage.getItem('logConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.logConfig = { ...this.logConfig, ...config };
            } catch (error) {
                console.error('加载日志配置失败:', error);
            }
        }
    },

    /**
     * 保存日志配置
     */
    saveLogConfig: function () {
        localStorage.setItem('logConfig', JSON.stringify(this.logConfig));
    },

    /**
     * 加载日志统计
     */
    loadLogStats: function () {
        const savedStats = localStorage.getItem('logStats');
        if (savedStats) {
            try {
                this.logStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载日志统计失败:', error);
            }
        }

        if (!this.logStats.stats) {
            this.logStats = {
                stats: {
                    totalLogs: 0,
                    debugLogs: 0,
                    infoLogs: 0,
                    warnLogs: 0,
                    errorLogs: 0,
                    fatalLogs: 0,
                    totalBytes: 0,
                    avgLogSize: 0,
                    totalFlushes: 0,
                    totalBuffers: 0,
                    totalCompressions: 0,
                    totalEncryptions: 0,
                    totalAggregations: 0,
                    totalAlerts: 0,
                    totalArchives: 0,
                    totalPurges: 0,
                    totalMonitors: 0
                }
            };

            this.saveLogStats();
        }
    },

    /**
     * 保存日志统计
     */
    saveLogStats: function () {
        localStorage.setItem('logStats', JSON.stringify(this.logStats));
    },

    /**
     * 加载日志缓存
     */
    loadLogCache: function () {
        const savedCache = localStorage.getItem('logCache');
        if (savedCache) {
            try {
                this.logCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载日志缓存失败:', error);
            }
        }

        if (!this.logCache.cache) {
            this.logCache = {
                cache: {},
                stats: {
                    size: 0,
                    maxSize: this.logConfig.bufferSize,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveLogCache();
        }
    },

    /**
     * 保存日志缓存
     */
    saveLogCache: function () {
        localStorage.setItem('logCache', JSON.stringify(this.logCache));
    },

    /**
     * 初始化日志系统
     */
    initLogSystem: function () {
        // 初始化日志缓冲区
        this.logBuffer = [];

        // 初始化日志存储
        this.logStore = {};

        // 初始化日志聚合
        this.logAggregations = {};

        // 初始化日志归档
        this.logArchives = [];

        // 启动缓冲区刷新
        if (this.logConfig.useBuffer) {
            this.startBufferFlush();
        }

        // 启动聚合
        if (this.logConfig.useAggregation) {
            this.startAggregation();
        }

        // 启动归档
        if (this.logConfig.useArchiving) {
            this.startArchiving();
        }

        // 启动清理
        if (this.logConfig.usePurging) {
            this.startPurging();
        }

        // 启动监控
        if (this.logConfig.useMonitoring) {
            this.startMonitoring();
        }
    },

    /**
     * 启动缓冲区刷新
     */
    startBufferFlush: function () {
        setInterval(() => {
            if (this.logConfig.useBuffer) {
                this.flushBuffer();
            }
        }, this.logConfig.bufferFlushInterval);
    },

    /**
     * 启动聚合
     */
    startAggregation: function () {
        setInterval(() => {
            if (this.logConfig.useAggregation) {
                this.aggregateLogs();
            }
        }, this.logConfig.aggregationInterval);
    },

    /**
     * 启动归档
     */
    startArchiving: function () {
        setInterval(() => {
            if (this.logConfig.useArchiving) {
                this.archiveLogs();
            }
        }, this.logConfig.archiveInterval);
    },

    /**
     * 启动清理
     */
    startPurging: function () {
        setInterval(() => {
            if (this.logConfig.usePurging) {
                this.purgeLogs();
            }
        }, this.logConfig.purgeInterval);
    },

    /**
     * 启动监控
     */
    startMonitoring: function () {
        setInterval(() => {
            if (this.logConfig.useMonitoring) {
                this.monitorLogs();
            }
        }, this.logConfig.monitoringInterval);
    },

    /**
     * 优化日志
     */
    optimizeLog: function () {
        // 启用压缩
        if (this.logConfig.useCompression) {
            this.enableCompression();
        }

        // 启用加密
        if (this.logConfig.useEncryption) {
            this.enableEncryption();
        }

        // 启用过滤
        if (this.logConfig.useFiltering) {
            this.enableFiltering();
        }

        // 启用路由
        if (this.logConfig.useRouting) {
            this.enableRouting();
        }

        // 启用警报
        if (this.logConfig.useAlerting) {
            this.enableAlerting();
        }
    },

    /**
     * 启用压缩
     */
    enableCompression: function () {
        // 实现压缩逻辑
    },

    /**
     * 启用加密
     */
    enableEncryption: function () {
        // 实现加密逻辑
    },

    /**
     * 启用过滤
     */
    enableFiltering: function () {
        // 实现过滤逻辑
    },

    /**
     * 启用路由
     */
    enableRouting: function () {
        // 实现路由逻辑
    },

    /**
     * 启用警报
     */
    enableAlerting: function () {
        // 实现警报逻辑
    },

    /**
     * 记录日志
     * @param {string} level - 级别
     * @param {string} message - 消息
     * @param {Object} context - 上下文
     */
    log: function (level, message, context) {
        if (!this.logConfig.enabled) {
            return;
        }

        // 检查日志级别
        const levelIndex = this.logConfig.logLevels.indexOf(level);
        const configLevelIndex = this.logConfig.logLevels.indexOf(this.logConfig.logLevel);

        if (levelIndex < configLevelIndex) {
            return;
        }

        // 创建日志对象
        const log = {
            id: 'log_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            level: level,
            message: message,
            context: context || {},
            timestamp: Date.now()
        };

        // 添加堆栈跟踪
        if (this.logConfig.useStacktrace) {
            log.stacktrace = this.getStacktrace(this.logConfig.stacktraceDepth);
        }

        // 格式化日志
        if (this.logConfig.useFormatting) {
            log.formatted = this.formatLog(log);
        }

        // 添加到缓冲区
        if (this.logConfig.useBuffer) {
            this.addToBuffer(log);
        }

        // 输出到控制台
        if (this.logConfig.useConsole) {
            this.logToConsole(log);
        }

        // 更新统计
        this.updateStats(log);

        // 检查警报
        if (this.logConfig.useAlerting) {
            this.checkAlerts(log);
        }
    },

    /**
     * 获取堆栈跟踪
     * @param {number} depth - 深度
     * @returns {string} 堆栈跟踪
     */
    getStacktrace: function (depth) {
        const stack = new Error().stack;
        const lines = stack.split('\n').slice(2, depth + 2);
        return lines.join('\n');
    },

    /**
     * 格式化日志
     * @param {Object} log - 日志对象
     * @returns {string} 格式化日志
     */
    formatLog: function (log) {
        let formatted = this.logConfig.format;

        // 替换时间戳
        if (this.logConfig.useTimestamp) {
            const timestamp = this.formatTimestamp(log.timestamp);
            formatted = formatted.replace('{timestamp}', timestamp);
        }

        // 替换级别
        formatted = formatted.replace('{level}', log.level.toUpperCase());

        // 替换消息
        formatted = formatted.replace('{message}', log.message);

        // 替换上下文
        if (this.logConfig.useContext && Object.keys(log.context).length > 0) {
            formatted += ' ' + JSON.stringify(log.context);
        }

        return formatted;
    },

    /**
     * 格式化时间戳
     * @param {number} timestamp - 时间戳
     * @returns {string} 格式化时间戳
     */
    formatTimestamp: function (timestamp) {
        const date = new Date(timestamp);

        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');

        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    },

    /**
     * 添加到缓冲区
     * @param {Object} log - 日志对象
     */
    addToBuffer: function (log) {
        this.logBuffer.push(log);

        // 检查缓冲区大小
        if (this.logBuffer.length >= this.logConfig.bufferSize) {
            this.flushBuffer();
        }
    },

    /**
     * 刷新缓冲区
     */
    flushBuffer: function () {
        if (this.logBuffer.length === 0) {
            return;
        }

        // 压缩日志
        if (this.logConfig.useCompression) {
            this.logBuffer = this.compressLogs(this.logBuffer);
        }

        // 加密日志
        if (this.logConfig.useEncryption) {
            this.logBuffer = this.encryptLogs(this.logBuffer);
        }

        // 保存日志
        for (const log of this.logBuffer) {
            this.saveLog(log);
        }

        // 清空缓冲区
        this.logBuffer = [];

        // 更新统计
        this.logStats.stats.totalFlushes++;

        this.saveLogStats();
    },

    /**
     * 保存日志
     * @param {Object} log - 日志对象
     */
    saveLog: function (log) {
        if (!this.logStore[log.level]) {
            this.logStore[log.level] = [];
        }

        this.logStore[log.level].push(log);

        // 限制日志数量
        if (this.logStore[log.level].length > 1000) {
            this.logStore[log.level].shift();
        }
    },

    /**
     * 记录到控制台
     * @param {Object} log - 日志对象
     */
    logToConsole: function (log) {
        const message = log.formatted || log.message;
        const color = this.logConfig.colors[log.level];

        // 使用颜色
        if (this.logConfig.useColors && color) {
            console.log(`%c${message}`, `color: ${color}`);
        } else {
            console.log(message);
        }

        // 输出堆栈跟踪
        if (this.logConfig.useStacktrace && log.stacktrace) {
            console.log(log.stacktrace);
        }
    },

    /**
     * 更新统计
     * @param {Object} log - 日志对象
     */
    updateStats: function (log) {
        this.logStats.stats.totalLogs++;
        this.logStats.stats[log.level + 'Logs']++;
        this.logStats.stats.totalBytes += JSON.stringify(log).length;
        this.logStats.stats.avgLogSize =
            this.logStats.stats.totalBytes / this.logStats.stats.totalLogs;

        this.saveLogStats();
    },

    /**
     * 检查警报
     * @param {Object} log - 日志对象
     */
    checkAlerts: function (log) {
        for (const rule of this.logConfig.alertRules) {
            if (this.matchAlertRule(log, rule)) {
                this.triggerAlert(rule, log);
            }
        }
    },

    /**
     * 匹配警报规则
     * @param {Object} log - 日志对象
     * @param {Object} rule - 规则对象
     * @returns {boolean} 是否匹配
     */
    matchAlertRule: function (log, rule) {
        if (rule.level && log.level !== rule.level) {
            return false;
        }

        if (rule.message && !log.message.includes(rule.message)) {
            return false;
        }

        return true;
    },

    /**
     * 触发警报
     * @param {Object} rule - 规则对象
     * @param {Object} log - 日志对象
     */
    triggerAlert: function (rule, log) {
        // 更新统计
        this.logStats.stats.totalAlerts++;

        this.saveLogStats();

        // 实现警报触发逻辑
    },

    /**
     * 聚合日志
     */
    aggregateLogs: function () {
        // 实现日志聚合逻辑

        // 更新统计
        this.logStats.stats.totalAggregations++;

        this.saveLogStats();
    },

    /**
     * 归档日志
     */
    archiveLogs: function () {
        // 实现日志归档逻辑

        // 更新统计
        this.logStats.stats.totalArchives++;

        this.saveLogStats();
    },

    /**
     * 清理日志
     */
    purgeLogs: function () {
        // 实现日志清理逻辑

        // 更新统计
        this.logStats.stats.totalPurges++;

        this.saveLogStats();
    },

    /**
     * 监控日志
     */
    monitorLogs: function () {
        // 实现日志监控逻辑

        // 更新统计
        this.logStats.stats.totalMonitors++;

        this.saveLogStats();
    },

    /**
     * 获取日志统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.logStats.stats;
    },

    /**
     * 设置日志配置
     * @param {Object} config - 配置对象
     */
    setLogConfig: function (config) {
        this.logConfig = { ...this.logConfig, ...config };
        this.saveLogConfig();
    },

    /**
     * 获取日志配置
     * @returns {Object} 配置对象
     */
    getLogConfig: function () {
        return this.logConfig;
    }
};

// 优化：游戏测试优化
const GameTestOptimizer = {
    testConfig: {},
    testStats: {},
    testCache: {},

    /**
     * 初始化游戏测试优化
     */
    init: function () {
        this.loadTestConfig();
        this.loadTestStats();
        this.loadTestCache();
        this.initTestSystem();
        this.optimizeTest();
    },

    /**
     * 加载测试配置
     */
    loadTestConfig: function () {
        this.testConfig = {
            enabled: true,
            useUnitTests: true,
            useIntegrationTests: true,
            useE2ETests: false,
            usePerformanceTests: false,
            useSecurityTests: false,
            useAccessibilityTests: false,
            useCompatibilityTests: false,
            useRegressionTests: true,
            useSmokeTests: true,
            useSanityTests: true,
            useAcceptanceTests: false,
            useAutomatedTests: true,
            useManualTests: false,
            useParallelTesting: false,
            maxParallelTests: 4,
            useTestIsolation: true,
            useTestMocking: true,
            useTestStubbing: true,
            useTestSpying: false,
            useTestFaking: false,
            useTestCoverage: true,
            coverageThreshold: 80,
            useTestReporting: true,
            reportFormat: 'json',
            useTestLogging: true,
            logLevel: 'info',
            useTestDebugging: true,
            useTestProfiling: false,
            useTestBenchmarking: false,
            useTestCI: false,
            useTestCD: false,
            useTestMonitoring: true,
            monitoringInterval: 60000,
            useTestAlerts: true,
            alertRules: [],
            useTestRetry: true,
            maxRetries: 3,
            retryDelay: 1000,
            useTestTimeout: true,
            defaultTimeout: 5000
        };

        const customConfig = localStorage.getItem('testConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.testConfig = { ...this.testConfig, ...config };
            } catch (error) {
                console.error('加载测试配置失败:', error);
            }
        }
    },

    /**
     * 保存测试配置
     */
    saveTestConfig: function () {
        localStorage.setItem('testConfig', JSON.stringify(this.testConfig));
    },

    /**
     * 加载测试统计
     */
    loadTestStats: function () {
        const savedStats = localStorage.getItem('testStats');
        if (savedStats) {
            try {
                this.testStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载测试统计失败:', error);
            }
        }

        if (!this.testStats.stats) {
            this.testStats = {
                stats: {
                    totalTests: 0,
                    passedTests: 0,
                    failedTests: 0,
                    skippedTests: 0,
                    totalAssertions: 0,
                    passedAssertions: 0,
                    failedAssertions: 0,
                    totalUnitTests: 0,
                    totalIntegrationTests: 0,
                    totalE2ETests: 0,
                    totalPerformanceTests: 0,
                    totalSecurityTests: 0,
                    totalAccessibilityTests: 0,
                    totalCompatibilityTests: 0,
                    totalRegressionTests: 0,
                    totalSmokeTests: 0,
                    totalSanityTests: 0,
                    totalAcceptanceTests: 0,
                    totalAutomatedTests: 0,
                    totalManualTests: 0,
                    totalTestRuns: 0,
                    avgTestDuration: 0,
                    totalTestDuration: 0,
                    codeCoverage: 0,
                    totalRetries: 0,
                    totalTimeouts: 0,
                    totalAlerts: 0,
                    totalMonitors: 0
                }
            };

            this.saveTestStats();
        }
    },

    /**
     * 保存测试统计
     */
    saveTestStats: function () {
        localStorage.setItem('testStats', JSON.stringify(this.testStats));
    },

    /**
     * 加载测试缓存
     */
    loadTestCache: function () {
        const savedCache = localStorage.getItem('testCache');
        if (savedCache) {
            try {
                this.testCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载测试缓存失败:', error);
            }
        }

        if (!this.testCache.cache) {
            this.testCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveTestCache();
        }
    },

    /**
     * 保存测试缓存
     */
    saveTestCache: function () {
        localStorage.setItem('testCache', JSON.stringify(this.testCache));
    },

    /**
     * 初始化测试系统
     */
    initTestSystem: function () {
        // 初始化测试套件
        this.testSuites = {};

        // 初始化测试用例
        this.testCases = {};

        // 初始化测试结果
        this.testResults = [];

        // 初始化测试报告
        this.testReports = [];

        // 启动监控
        if (this.testConfig.useTestMonitoring) {
            this.startMonitoring();
        }
    },

    /**
     * 启动监控
     */
    startMonitoring: function () {
        setInterval(() => {
            if (this.testConfig.useTestMonitoring) {
                this.monitorTests();
            }
        }, this.testConfig.monitoringInterval);
    },

    /**
     * 优化测试
     */
    optimizeTest: function () {
        // 启用并行测试
        if (this.testConfig.useParallelTesting) {
            this.enableParallelTesting();
        }

        // 启用测试隔离
        if (this.testConfig.useTestIsolation) {
            this.enableTestIsolation();
        }

        // 启用测试模拟
        if (this.testConfig.useTestMocking) {
            this.enableTestMocking();
        }

        // 启用测试存根
        if (this.testConfig.useTestStubbing) {
            this.enableTestStubbing();
        }

        // 启用测试覆盖率
        if (this.testConfig.useTestCoverage) {
            this.enableTestCoverage();
        }

        // 启用测试重试
        if (this.testConfig.useTestRetry) {
            this.enableTestRetry();
        }

        // 启用测试超时
        if (this.testConfig.useTestTimeout) {
            this.enableTestTimeout();
        }
    },

    /**
     * 启用并行测试
     */
    enableParallelTesting: function () {
        // 实现并行测试逻辑
    },

    /**
     * 启用测试隔离
     */
    enableTestIsolation: function () {
        // 实现测试隔离逻辑
    },

    /**
     * 启用测试模拟
     */
    enableTestMocking: function () {
        // 实现测试模拟逻辑
    },

    /**
     * 启用测试存根
     */
    enableTestStubbing: function () {
        // 实现测试存根逻辑
    },

    /**
     * 启用测试覆盖率
     */
    enableTestCoverage: function () {
        // 实现测试覆盖率逻辑
    },

    /**
     * 启用测试重试
     */
    enableTestRetry: function () {
        // 实现测试重试逻辑
    },

    /**
     * 启用测试超时
     */
    enableTestTimeout: function () {
        // 实现测试超时逻辑
    },

    /**
     * 创建测试套件
     * @param {string} name - 名称
     * @param {Object} options - 选项
     * @returns {Object} 测试套件
     */
    createTestSuite: function (name, options) {
        if (!this.testConfig.enabled) {
            return null;
        }

        const suite = {
            id: 'suite_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            name: name,
            options: options || {},
            tests: [],
            beforeAll: options.beforeAll || null,
            afterAll: options.afterAll || null,
            beforeEach: options.beforeEach || null,
            afterEach: options.afterEach || null
        };

        this.testSuites[suite.id] = suite;

        return suite;
    },

    /**
     * 创建测试用例
     * @param {string} suiteId - 套件ID
     * @param {string} name - 名称
     * @param {Function} testFn - 测试函数
     * @param {Object} options - 选项
     * @returns {Object} 测试用例
     */
    createTestCase: function (suiteId, name, testFn, options) {
        if (!this.testConfig.enabled) {
            return null;
        }

        const suite = this.testSuites[suiteId];

        if (!suite) {
            return null;
        }

        const testCase = {
            id: 'test_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            suiteId: suiteId,
            name: name,
            testFn: testFn,
            options: options || {},
            type: options.type || 'unit',
            retries: 0,
            timeout: options.timeout || this.testConfig.defaultTimeout
        };

        suite.tests.push(testCase);
        this.testCases[testCase.id] = testCase;

        return testCase;
    },

    /**
     * 运行测试套件
     * @param {string} suiteId - 套件ID
     * @returns {Promise} 测试结果Promise
     */
    runTestSuite: function (suiteId) {
        if (!this.testConfig.enabled) {
            return Promise.reject(new Error('测试已禁用'));
        }

        const suite = this.testSuites[suiteId];

        if (!suite) {
            return Promise.reject(new Error('测试套件不存在'));
        }

        const startTime = Date.now();

        // 运行beforeAll钩子
        if (suite.beforeAll) {
            suite.beforeAll();
        }

        // 运行所有测试
        const testPromises = suite.tests.map(test => this.runTestCase(test.id));

        return Promise.all(testPromises)
            .then(results => {
                // 运行afterAll钩子
                if (suite.afterAll) {
                    suite.afterAll();
                }

                const endTime = Date.now();
                const duration = endTime - startTime;

                // 创建测试结果
                const suiteResult = {
                    suiteId: suiteId,
                    suiteName: suite.name,
                    results: results,
                    startTime: startTime,
                    endTime: endTime,
                    duration: duration
                };

                this.testResults.push(suiteResult);

                // 更新统计
                this.updateStats(suiteResult);

                return suiteResult;
            });
    },

    /**
     * 运行测试用例
     * @param {string} testId - 测试ID
     * @returns {Promise} 测试结果Promise
     */
    runTestCase: function (testId) {
        if (!this.testConfig.enabled) {
            return Promise.reject(new Error('测试已禁用'));
        }

        const testCase = this.testCases[testId];

        if (!testCase) {
            return Promise.reject(new Error('测试用例不存在'));
        }

        const startTime = Date.now();

        // 运行beforeEach钩子
        if (testCase.beforeEach) {
            testCase.beforeEach();
        }

        // 运行测试
        return this.runTestWithRetry(testCase)
            .then(result => {
                // 运行afterEach钩子
                if (testCase.afterEach) {
                    testCase.afterEach();
                }

                const endTime = Date.now();
                const duration = endTime - startTime;

                // 创建测试结果
                const testResult = {
                    testId: testId,
                    testName: testCase.name,
                    suiteId: testCase.suiteId,
                    type: testCase.type,
                    passed: result.passed,
                    error: result.error,
                    startTime: startTime,
                    endTime: endTime,
                    duration: duration,
                    retries: testCase.retries
                };

                return testResult;
            });
    },

    /**
     * 带重试运行测试
     * @param {Object} testCase - 测试用例
     * @returns {Promise} 测试结果Promise
     */
    runTestWithRetry: function (testCase) {
        return this.runTestWithTimeout(testCase)
            .catch(error => {
                // 检查是否需要重试
                if (this.testConfig.useTestRetry && testCase.retries < this.testConfig.maxRetries) {
                    testCase.retries++;

                    // 更新统计
                    this.testStats.stats.totalRetries++;

                    this.saveTestStats();

                    // 延迟重试
                    return new Promise(resolve => {
                        setTimeout(() => {
                            resolve(this.runTestWithRetry(testCase));
                        }, this.testConfig.retryDelay);
                    });
                }

                throw error;
            });
    },

    /**
     * 带超时运行测试
     * @param {Object} testCase - 测试用例
     * @returns {Promise} 测试结果Promise
     */
    runTestWithTimeout: function (testCase) {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('测试超时'));

                // 更新统计
                this.testStats.stats.totalTimeouts++;

                this.saveTestStats();
            }, testCase.timeout);

            // 运行测试
            testCase.testFn()
                .then(() => {
                    clearTimeout(timeout);
                    resolve({ passed: true });
                })
                .catch(error => {
                    clearTimeout(timeout);
                    reject(error);
                });
        });
    },

    /**
     * 断言
     * @param {any} actual - 实际值
     * @param {any} expected - 期望值
     * @param {string} message - 消息
     */
    assert: function (actual, expected, message) {
        if (actual !== expected) {
            throw new Error(message || `断言失败: 期望 ${expected}, 实际 ${actual}`);
        }

        // 更新统计
        this.testStats.stats.totalAssertions++;
        this.testStats.stats.passedAssertions++;

        this.saveTestStats();
    },

    /**
     * 断言相等
     * @param {any} actual - 实际值
     * @param {any} expected - 期望值
     * @param {string} message - 消息
     */
    assertEqual: function (actual, expected, message) {
        if (JSON.stringify(actual) !== JSON.stringify(expected)) {
            throw new Error(message || `断言失败: 期望 ${JSON.stringify(expected)}, 实际 ${JSON.stringify(actual)}`);
        }

        // 更新统计
        this.testStats.stats.totalAssertions++;
        this.testStats.stats.passedAssertions++;

        this.saveTestStats();
    },

    /**
     * 断言为真
     * @param {any} value - 值
     * @param {string} message - 消息
     */
    assertTrue: function (value, message) {
        if (!value) {
            throw new Error(message || `断言失败: 期望 true, 实际 ${value}`);
        }

        // 更新统计
        this.testStats.stats.totalAssertions++;
        this.testStats.stats.passedAssertions++;

        this.saveTestStats();
    },

    /**
     * 断言为假
     * @param {any} value - 值
     * @param {string} message - 消息
     */
    assertFalse: function (value, message) {
        if (value) {
            throw new Error(message || `断言失败: 期望 false, 实际 ${value}`);
        }

        // 更新统计
        this.testStats.stats.totalAssertions++;
        this.testStats.stats.passedAssertions++;

        this.saveTestStats();
    },

    /**
     * 更新统计
     * @param {Object} suiteResult - 套件结果
     */
    updateStats: function (suiteResult) {
        this.testStats.stats.totalTestRuns++;
        this.testStats.stats.totalTestDuration += suiteResult.duration;
        this.testStats.stats.avgTestDuration =
            this.testStats.stats.totalTestDuration / this.testStats.stats.totalTestRuns;

        for (const result of suiteResult.results) {
            this.testStats.stats.totalTests++;

            if (result.passed) {
                this.testStats.stats.passedTests++;
            } else {
                this.testStats.stats.failedTests++;
            }

            // 更新类型统计
            this.testStats.stats['total' + result.type.charAt(0).toUpperCase() + result.type.slice(1) + 'Tests']++;
        }

        this.saveTestStats();
    },

    /**
     * 监控测试
     */
    monitorTests: function () {
        // 实现测试监控逻辑

        // 更新统计
        this.testStats.stats.totalMonitors++;

        this.saveTestStats();
    },

    /**
     * 获取测试统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.testStats.stats;
    },

    /**
     * 设置测试配置
     * @param {Object} config - 配置对象
     */
    setTestConfig: function (config) {
        this.testConfig = { ...this.testConfig, ...config };
        this.saveTestConfig();
    },

    /**
     * 获取测试配置
     * @returns {Object} 配置对象
     */
    getTestConfig: function () {
        return this.testConfig;
    }
};

// 优化：游戏构建优化
const GameBuildOptimizer = {
    buildConfig: {},
    buildStats: {},
    buildCache: {},

    /**
     * 初始化游戏构建优化
     */
    init: function () {
        this.loadBuildConfig();
        this.loadBuildStats();
        this.loadBuildCache();
        this.initBuildSystem();
        this.optimizeBuild();
    },

    /**
     * 加载构建配置
     */
    loadBuildConfig: function () {
        this.buildConfig = {
            enabled: true,
            useMinification: true,
            useCompression: true,
            compressionLevel: 6,
            useTreeShaking: true,
            useCodeSplitting: true,
            useLazyLoading: true,
            usePrefetching: false,
            useCaching: true,
            cacheStrategy: 'content-hash',
            useSourceMaps: false,
            sourceMapType: 'eval',
            useOptimization: true,
            optimizationLevel: 'medium',
            useBundling: true,
            bundler: 'webpack',
            useTranspilation: true,
            target: 'es5',
            usePolyfills: true,
            useAssetOptimization: true,
            assetOptimizationLevel: 'medium',
            useImageOptimization: true,
            imageOptimizationFormat: 'webp',
            useFontOptimization: true,
            fontSubsetting: true,
            useCSSOptimization: true,
            cssOptimizationLevel: 'medium',
            useHTMLMinification: true,
            useJSMinification: true,
            useJSONMinification: false,
            useXMLMinification: false,
            useParallelBuild: true,
            maxParallelBuilds: 4,
            useIncrementalBuild: true,
            useWatchMode: false,
            useHotReload: false,
            useDevServer: false,
            useProductionBuild: true,
            useDevelopmentBuild: false,
            useAnalyze: false,
            useLinting: true,
            useTypeChecking: true,
            useTesting: true,
            useCI: false,
            useCD: false,
            useVersioning: true,
            versioningStrategy: 'semantic',
            useChangelog: true,
            useReleaseNotes: true,
            useDeployment: false,
            deploymentTarget: 'github-pages'
        };

        const customConfig = localStorage.getItem('buildConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.buildConfig = { ...this.buildConfig, ...config };
            } catch (error) {
                console.error('加载构建配置失败:', error);
            }
        }
    },

    /**
     * 保存构建配置
     */
    saveBuildConfig: function () {
        localStorage.setItem('buildConfig', JSON.stringify(this.buildConfig));
    },

    /**
     * 加载构建统计
     */
    loadBuildStats: function () {
        const savedStats = localStorage.getItem('buildStats');
        if (savedStats) {
            try {
                this.buildStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载构建统计失败:', error);
            }
        }

        if (!this.buildStats.stats) {
            this.buildStats = {
                stats: {
                    totalBuilds: 0,
                    successfulBuilds: 0,
                    failedBuilds: 0,
                    totalBuildTime: 0,
                    avgBuildTime: 0,
                    minBuildTime: 0,
                    maxBuildTime: 0,
                    totalMinifications: 0,
                    totalCompressions: 0,
                    totalTreeShakings: 0,
                    totalCodeSplittings: 0,
                    totalLazyLoadings: 0,
                    totalPrefetchings: 0,
                    totalCachings: 0,
                    totalSourceMaps: 0,
                    totalOptimizations: 0,
                    totalBundlings: 0,
                    totalTranspilations: 0,
                    totalPolyfills: 0,
                    totalAssetOptimizations: 0,
                    totalImageOptimizations: 0,
                    totalFontOptimizations: 0,
                    totalCSSOptimizations: 0,
                    totalHTMLMinifications: 0,
                    totalJSMinifications: 0,
                    totalLintings: 0,
                    totalTypeCheckings: 0,
                    totalTestings: 0,
                    totalVersionings: 0,
                    totalChangelogs: 0,
                    totalReleaseNotes: 0
                }
            };

            this.saveBuildStats();
        }
    },

    /**
     * 保存构建统计
     */
    saveBuildStats: function () {
        localStorage.setItem('buildStats', JSON.stringify(this.buildStats));
    },

    /**
     * 加载构建缓存
     */
    loadBuildCache: function () {
        const savedCache = localStorage.getItem('buildCache');
        if (savedCache) {
            try {
                this.buildCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载构建缓存失败:', error);
            }
        }

        if (!this.buildCache.cache) {
            this.buildCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveBuildCache();
        }
    },

    /**
     * 保存构建缓存
     */
    saveBuildCache: function () {
        localStorage.setItem('buildCache', JSON.stringify(this.buildCache));
    },

    /**
     * 初始化构建系统
     */
    initBuildSystem: function () {
        // 初始化构建队列
        this.buildQueue = [];

        // 初始化构建历史
        this.buildHistory = [];

        // 初始化构建结果
        this.buildResults = [];
    },

    /**
     * 优化构建
     */
    optimizeBuild: function () {
        // 启用压缩
        if (this.buildConfig.useMinification) {
            this.enableMinification();
        }

        // 启用压缩
        if (this.buildConfig.useCompression) {
            this.enableCompression();
        }

        // 启用Tree Shaking
        if (this.buildConfig.useTreeShaking) {
            this.enableTreeShaking();
        }

        // 启用代码分割
        if (this.buildConfig.useCodeSplitting) {
            this.enableCodeSplitting();
        }

        // 启用懒加载
        if (this.buildConfig.useLazyLoading) {
            this.enableLazyLoading();
        }

        // 启用预取
        if (this.buildConfig.usePrefetching) {
            this.enablePrefetching();
        }

        // 启用缓存
        if (this.buildConfig.useCaching) {
            this.enableCaching();
        }

        // 启用优化
        if (this.buildConfig.useOptimization) {
            this.enableOptimization();
        }

        // 启用打包
        if (this.buildConfig.useBundling) {
            this.enableBundling();
        }

        // 启用转译
        if (this.buildConfig.useTranspilation) {
            this.enableTranspilation();
        }

        // 启用Polyfills
        if (this.buildConfig.usePolyfills) {
            this.enablePolyfills();
        }

        // 启用资源优化
        if (this.buildConfig.useAssetOptimization) {
            this.enableAssetOptimization();
        }

        // 启用图片优化
        if (this.buildConfig.useImageOptimization) {
            this.enableImageOptimization();
        }

        // 启用字体优化
        if (this.buildConfig.useFontOptimization) {
            this.enableFontOptimization();
        }

        // 启用CSS优化
        if (this.buildConfig.useCSSOptimization) {
            this.enableCSSOptimization();
        }

        // 启用HTML压缩
        if (this.buildConfig.useHTMLMinification) {
            this.enableHTMLMinification();
        }

        // 启用JS压缩
        if (this.buildConfig.useJSMinification) {
            this.enableJSMinification();
        }
    },

    /**
     * 启用压缩
     */
    enableMinification: function () {
        // 实现压缩逻辑
    },

    /**
     * 启用压缩
     */
    enableCompression: function () {
        // 实现压缩逻辑
    },

    /**
     * 启用Tree Shaking
     */
    enableTreeShaking: function () {
        // 实现Tree Shaking逻辑
    },

    /**
     * 启用代码分割
     */
    enableCodeSplitting: function () {
        // 实现代码分割逻辑
    },

    /**
     * 启用懒加载
     */
    enableLazyLoading: function () {
        // 实现懒加载逻辑
    },

    /**
     * 启用预取
     */
    enablePrefetching: function () {
        // 实现预取逻辑
    },

    /**
     * 启用缓存
     */
    enableCaching: function () {
        // 实现缓存逻辑
    },

    /**
     * 启用优化
     */
    enableOptimization: function () {
        // 实现优化逻辑
    },

    /**
     * 启用打包
     */
    enableBundling: function () {
        // 实现打包逻辑
    },

    /**
     * 启用转译
     */
    enableTranspilation: function () {
        // 实现转译逻辑
    },

    /**
     * 启用Polyfills
     */
    enablePolyfills: function () {
        // 实现Polyfills逻辑
    },

    /**
     * 启用资源优化
     */
    enableAssetOptimization: function () {
        // 实现资源优化逻辑
    },

    /**
     * 启用图片优化
     */
    enableImageOptimization: function () {
        // 实现图片优化逻辑
    },

    /**
     * 启用字体优化
     */
    enableFontOptimization: function () {
        // 实现字体优化逻辑
    },

    /**
     * 启用CSS优化
     */
    enableCSSOptimization: function () {
        // 实现CSS优化逻辑
    },

    /**
     * 启用HTML压缩
     */
    enableHTMLMinification: function () {
        // 实现HTML压缩逻辑
    },

    /**
     * 启用JS压缩
     */
    enableJSMinification: function () {
        // 实现JS压缩逻辑
    },

    /**
     * 创建构建
     * @param {Object} options - 构建选项
     * @returns {Promise} 构建结果Promise
     */
    createBuild: function (options) {
        if (!this.buildConfig.enabled) {
            return Promise.reject(new Error('构建已禁用'));
        }

        options = options || {};

        const build = {
            id: 'build_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            options: options,
            status: 'pending',
            startTime: Date.now(),
            endTime: null,
            duration: null,
            result: null,
            error: null
        };

        this.buildQueue.push(build);

        // 更新统计
        this.buildStats.stats.totalBuilds++;

        this.saveBuildStats();

        // 执行构建
        return this.executeBuild(build);
    },

    /**
     * 执行构建
     * @param {Object} build - 构建对象
     * @returns {Promise} 构建结果Promise
     */
    executeBuild: function (build) {
        build.status = 'building';

        return new Promise((resolve, reject) => {
            try {
                // 压缩代码
                if (this.buildConfig.useMinification) {
                    this.minifyCode(build);
                }

                // 压缩文件
                if (this.buildConfig.useCompression) {
                    this.compressFiles(build);
                }

                // Tree Shaking
                if (this.buildConfig.useTreeShaking) {
                    this.treeShake(build);
                }

                // 代码分割
                if (this.buildConfig.useCodeSplitting) {
                    this.codeSplit(build);
                }

                // 懒加载
                if (this.buildConfig.useLazyLoading) {
                    this.lazyLoad(build);
                }

                // 预取
                if (this.buildConfig.usePrefetching) {
                    this.prefetch(build);
                }

                // 缓存
                if (this.buildConfig.useCaching) {
                    this.cacheBuild(build);
                }

                // 优化
                if (this.buildConfig.useOptimization) {
                    this.optimizeBuild(build);
                }

                // 打包
                if (this.buildConfig.useBundling) {
                    this.bundle(build);
                }

                // 转译
                if (this.buildConfig.useTranspilation) {
                    this.transpile(build);
                }

                // Polyfills
                if (this.buildConfig.usePolyfills) {
                    this.addPolyfills(build);
                }

                // 资源优化
                if (this.buildConfig.useAssetOptimization) {
                    this.optimizeAssets(build);
                }

                // 图片优化
                if (this.buildConfig.useImageOptimization) {
                    this.optimizeImages(build);
                }

                // 字体优化
                if (this.buildConfig.useFontOptimization) {
                    this.optimizeFonts(build);
                }

                // CSS优化
                if (this.buildConfig.useCSSOptimization) {
                    this.optimizeCSS(build);
                }

                // HTML压缩
                if (this.buildConfig.useHTMLMinification) {
                    this.minifyHTML(build);
                }

                // JS压缩
                if (this.buildConfig.useJSMinification) {
                    this.minifyJS(build);
                }

                // Linting
                if (this.buildConfig.useLinting) {
                    this.lint(build);
                }

                // 类型检查
                if (this.buildConfig.useTypeChecking) {
                    this.typeCheck(build);
                }

                // 测试
                if (this.buildConfig.useTesting) {
                    this.test(build);
                }

                // 版本控制
                if (this.buildConfig.useVersioning) {
                    this.version(build);
                }

                // 更新日志
                if (this.buildConfig.useChangelog) {
                    this.updateChangelog(build);
                }

                // 更新发布说明
                if (this.buildConfig.useReleaseNotes) {
                    this.updateReleaseNotes(build);
                }

                // 构建成功
                build.status = 'completed';
                build.endTime = Date.now();
                build.duration = build.endTime - build.startTime;
                build.result = { success: true };

                // 更新统计
                this.buildStats.stats.successfulBuilds++;
                this.buildStats.stats.totalBuildTime += build.duration;
                this.buildStats.stats.avgBuildTime =
                    this.buildStats.stats.totalBuildTime / this.buildStats.stats.successfulBuilds;
                this.buildStats.stats.minBuildTime = Math.min(this.buildStats.stats.minBuildTime, build.duration);
                this.buildStats.stats.maxBuildTime = Math.max(this.buildStats.stats.maxBuildTime, build.duration);

                this.saveBuildStats();

                resolve(build);
            } catch (error) {
                // 构建失败
                build.status = 'failed';
                build.endTime = Date.now();
                build.duration = build.endTime - build.startTime;
                build.error = error.message;

                // 更新统计
                this.buildStats.stats.failedBuilds++;

                this.saveBuildStats();

                reject(error);
            }
        });
    },

    /**
     * 压缩代码
     * @param {Object} build - 构建对象
     */
    minifyCode: function (build) {
        // 实现代码压缩逻辑

        // 更新统计
        this.buildStats.stats.totalMinifications++;

        this.saveBuildStats();
    },

    /**
     * 压缩文件
     * @param {Object} build - 构建对象
     */
    compressFiles: function (build) {
        // 实现文件压缩逻辑

        // 更新统计
        this.buildStats.stats.totalCompressions++;

        this.saveBuildStats();
    },

    /**
     * Tree Shaking
     * @param {Object} build - 构建对象
     */
    treeShake: function (build) {
        // 实现Tree Shaking逻辑

        // 更新统计
        this.buildStats.stats.totalTreeShakings++;

        this.saveBuildStats();
    },

    /**
     * 代码分割
     * @param {Object} build - 构建对象
     */
    codeSplit: function (build) {
        // 实现代码分割逻辑

        // 更新统计
        this.buildStats.stats.totalCodeSplittings++;

        this.saveBuildStats();
    },

    /**
     * 懒加载
     * @param {Object} build - 构建对象
     */
    lazyLoad: function (build) {
        // 实现懒加载逻辑

        // 更新统计
        this.buildStats.stats.totalLazyLoadings++;

        this.saveBuildStats();
    },

    /**
     * 预取
     * @param {Object} build - 构建对象
     */
    prefetch: function (build) {
        // 实现预取逻辑

        // 更新统计
        this.buildStats.stats.totalPrefetchings++;

        this.saveBuildStats();
    },

    /**
     * 缓存构建
     * @param {Object} build - 构建对象
     */
    cacheBuild: function (build) {
        // 实现缓存逻辑

        // 更新统计
        this.buildStats.stats.totalCachings++;

        this.saveBuildStats();
    },

    /**
     * 优化构建
     * @param {Object} build - 构建对象
     */
    optimizeBuild: function (build) {
        // 实现优化逻辑

        // 更新统计
        this.buildStats.stats.totalOptimizations++;

        this.saveBuildStats();
    },

    /**
     * 打包
     * @param {Object} build - 构建对象
     */
    bundle: function (build) {
        // 实现打包逻辑

        // 更新统计
        this.buildStats.stats.totalBundlings++;

        this.saveBuildStats();
    },

    /**
     * 转译
     * @param {Object} build - 构建对象
     */
    transpile: function (build) {
        // 实现转译逻辑

        // 更新统计
        this.buildStats.stats.totalTranspilations++;

        this.saveBuildStats();
    },

    /**
     * 添加Polyfills
     * @param {Object} build - 构建对象
     */
    addPolyfills: function (build) {
        // 实现Polyfills逻辑

        // 更新统计
        this.buildStats.stats.totalPolyfills++;

        this.saveBuildStats();
    },

    /**
     * 优化资源
     * @param {Object} build - 构建对象
     */
    optimizeAssets: function (build) {
        // 实现资源优化逻辑

        // 更新统计
        this.buildStats.stats.totalAssetOptimizations++;

        this.saveBuildStats();
    },

    /**
     * 优化图片
     * @param {Object} build - 构建对象
     */
    optimizeImages: function (build) {
        // 实现图片优化逻辑

        // 更新统计
        this.buildStats.stats.totalImageOptimizations++;

        this.saveBuildStats();
    },

    /**
     * 优化字体
     * @param {Object} build - 构建对象
     */
    optimizeFonts: function (build) {
        // 实现字体优化逻辑

        // 更新统计
        this.buildStats.stats.totalFontOptimizations++;

        this.saveBuildStats();
    },

    /**
     * 优化CSS
     * @param {Object} build - 构建对象
     */
    optimizeCSS: function (build) {
        // 实现CSS优化逻辑

        // 更新统计
        this.buildStats.stats.totalCSSOptimizations++;

        this.saveBuildStats();
    },

    /**
     * 压缩HTML
     * @param {Object} build - 构建对象
     */
    minifyHTML: function (build) {
        // 实现HTML压缩逻辑

        // 更新统计
        this.buildStats.stats.totalHTMLMinifications++;

        this.saveBuildStats();
    },

    /**
     * 压缩JS
     * @param {Object} build - 构建对象
     */
    minifyJS: function (build) {
        // 实现JS压缩逻辑

        // 更新统计
        this.buildStats.stats.totalJSMinifications++;

        this.saveBuildStats();
    },

    /**
     * Lint
     * @param {Object} build - 构建对象
     */
    lint: function (build) {
        // 实现Lint逻辑

        // 更新统计
        this.buildStats.stats.totalLintings++;

        this.saveBuildStats();
    },

    /**
     * 类型检查
     * @param {Object} build - 构建对象
     */
    typeCheck: function (build) {
        // 实现类型检查逻辑

        // 更新统计
        this.buildStats.stats.totalTypeCheckings++;

        this.saveBuildStats();
    },

    /**
     * 测试
     * @param {Object} build - 构建对象
     */
    test: function (build) {
        // 实现测试逻辑

        // 更新统计
        this.buildStats.stats.totalTestings++;

        this.saveBuildStats();
    },

    /**
     * 版本控制
     * @param {Object} build - 构建对象
     */
    version: function (build) {
        // 实现版本控制逻辑

        // 更新统计
        this.buildStats.stats.totalVersionings++;

        this.saveBuildStats();
    },

    /**
     * 更新日志
     * @param {Object} build - 构建对象
     */
    updateChangelog: function (build) {
        // 实现更新日志逻辑

        // 更新统计
        this.buildStats.stats.totalChangelogs++;

        this.saveBuildStats();
    },

    /**
     * 更新发布说明
     * @param {Object} build - 构建对象
     */
    updateReleaseNotes: function (build) {
        // 实现更新发布说明逻辑

        // 更新统计
        this.buildStats.stats.totalReleaseNotes++;

        this.saveBuildStats();
    },

    /**
     * 获取构建统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.buildStats.stats;
    },

    /**
     * 设置构建配置
     * @param {Object} config - 配置对象
     */
    setBuildConfig: function (config) {
        this.buildConfig = { ...this.buildConfig, ...config };
        this.saveBuildConfig();
    },

    /**
     * 获取构建配置
     * @returns {Object} 配置对象
     */
    getBuildConfig: function () {
        return this.buildConfig;
    }
};

// 优化：游戏部署优化
const GameDeploymentOptimizer = {
    deploymentConfig: {},
    deploymentStats: {},
    deploymentCache: {},

    /**
     * 初始化游戏部署优化
     */
    init: function () {
        this.loadDeploymentConfig();
        this.loadDeploymentStats();
        this.loadDeploymentCache();
        this.initDeploymentSystem();
        this.optimizeDeployment();
    },

    /**
     * 加载部署配置
     */
    loadDeploymentConfig: function () {
        this.deploymentConfig = {
            enabled: true,
            useCI: false,
            ciProvider: 'github-actions',
            useCD: false,
            cdProvider: 'github-pages',
            useVersioning: true,
            versioningStrategy: 'semantic',
            useRollback: true,
            maxRollbacks: 5,
            useBlueGreen: false,
            useCanary: false,
            useStaging: true,
            useProduction: true,
            useMonitoring: true,
            monitoringInterval: 60000,
            useLogging: true,
            logLevel: 'info',
            useAlerting: true,
            alertRules: [],
            useHealthChecks: true,
            healthCheckInterval: 30000,
            useLoadBalancing: false,
            loadBalancingAlgorithm: 'round-robin',
            useAutoScaling: false,
            minInstances: 1,
            maxInstances: 10,
            useContainerization: false,
            containerProvider: 'docker',
            useOrchestration: false,
            orchestrationProvider: 'kubernetes',
            useSSL: true,
            sslProvider: 'letsencrypt',
            useCDN: false,
            cdnProvider: 'cloudflare',
            useCache: true,
            cacheStrategy: 'content-hash',
            useCompression: true,
            compressionLevel: 6,
            useOptimization: true,
            optimizationLevel: 'medium',
            useBackup: true,
            backupInterval: 86400000,
            backupRetention: 30,
            useDisasterRecovery: false,
            disasterRecoveryStrategy: 'active-passive',
            useSecurity: true,
            securityLevel: 'medium',
            useCompliance: false,
            complianceStandards: [],
            useAnalytics: false,
            analyticsProvider: 'google-analytics'
        };

        const customConfig = localStorage.getItem('deploymentConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.deploymentConfig = { ...this.deploymentConfig, ...config };
            } catch (error) {
                console.error('加载部署配置失败:', error);
            }
        }
    },

    /**
     * 保存部署配置
     */
    saveDeploymentConfig: function () {
        localStorage.setItem('deploymentConfig', JSON.stringify(this.deploymentConfig));
    },

    /**
     * 加载部署统计
     */
    loadDeploymentStats: function () {
        const savedStats = localStorage.getItem('deploymentStats');
        if (savedStats) {
            try {
                this.deploymentStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载部署统计失败:', error);
            }
        }

        if (!this.deploymentStats.stats) {
            this.deploymentStats = {
                stats: {
                    totalDeployments: 0,
                    successfulDeployments: 0,
                    failedDeployments: 0,
                    totalRollbacks: 0,
                    totalDeploymentTime: 0,
                    avgDeploymentTime: 0,
                    minDeploymentTime: 0,
                    maxDeploymentTime: 0,
                    totalHealthChecks: 0,
                    successfulHealthChecks: 0,
                    failedHealthChecks: 0,
                    totalBackups: 0,
                    totalRestores: 0,
                    totalAlerts: 0,
                    totalMonitors: 0,
                    totalLogs: 0,
                    totalSSLRequests: 0,
                    successfulSSLRequests: 0,
                    failedSSLRequests: 0,
                    totalCDNRequests: 0,
                    successfulCDNRequests: 0,
                    failedCDNRequests: 0,
                    totalCacheHits: 0,
                    totalCacheMisses: 0,
                    cacheHitRate: 0,
                    totalCompressions: 0,
                    totalOptimizations: 0,
                    totalSecurityChecks: 0,
                    successfulSecurityChecks: 0,
                    failedSecurityChecks: 0
                }
            };

            this.saveDeploymentStats();
        }
    },

    /**
     * 保存部署统计
     */
    saveDeploymentStats: function () {
        localStorage.setItem('deploymentStats', JSON.stringify(this.deploymentStats));
    },

    /**
     * 加载部署缓存
     */
    loadDeploymentCache: function () {
        const savedCache = localStorage.getItem('deploymentCache');
        if (savedCache) {
            try {
                this.deploymentCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载部署缓存失败:', error);
            }
        }

        if (!this.deploymentCache.cache) {
            this.deploymentCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveDeploymentCache();
        }
    },

    /**
     * 保存部署缓存
     */
    saveDeploymentCache: function () {
        localStorage.setItem('deploymentCache', JSON.stringify(this.deploymentCache));
    },

    /**
     * 初始化部署系统
     */
    initDeploymentSystem: function () {
        // 初始化部署队列
        this.deploymentQueue = [];

        // 初始化部署历史
        this.deploymentHistory = [];

        // 初始化回滚历史
        this.rollbackHistory = [];

        // 初始化健康检查
        this.healthChecks = [];

        // 启动健康检查
        if (this.deploymentConfig.useHealthChecks) {
            this.startHealthChecks();
        }

        // 启动监控
        if (this.deploymentConfig.useMonitoring) {
            this.startMonitoring();
        }

        // 启动备份
        if (this.deploymentConfig.useBackup) {
            this.startBackup();
        }
    },

    /**
     * 启动健康检查
     */
    startHealthChecks: function () {
        setInterval(() => {
            if (this.deploymentConfig.useHealthChecks) {
                this.performHealthChecks();
            }
        }, this.deploymentConfig.healthCheckInterval);
    },

    /**
     * 启动监控
     */
    startMonitoring: function () {
        setInterval(() => {
            if (this.deploymentConfig.useMonitoring) {
                this.monitorDeployment();
            }
        }, this.deploymentConfig.monitoringInterval);
    },

    /**
     * 启动备份
     */
    startBackup: function () {
        setInterval(() => {
            if (this.deploymentConfig.useBackup) {
                this.backupDeployment();
            }
        }, this.deploymentConfig.backupInterval);
    },

    /**
     * 优化部署
     */
    optimizeDeployment: function () {
        // 启用CI
        if (this.deploymentConfig.useCI) {
            this.enableCI();
        }

        // 启用CD
        if (this.deploymentConfig.useCD) {
            this.enableCD();
        }

        // 启用版本控制
        if (this.deploymentConfig.useVersioning) {
            this.enableVersioning();
        }

        // 启用回滚
        if (this.deploymentConfig.useRollback) {
            this.enableRollback();
        }

        // 启用蓝绿部署
        if (this.deploymentConfig.useBlueGreen) {
            this.enableBlueGreen();
        }

        // 启用金丝雀部署
        if (this.deploymentConfig.useCanary) {
            this.enableCanary();
        }

        // 启用负载均衡
        if (this.deploymentConfig.useLoadBalancing) {
            this.enableLoadBalancing();
        }

        // 启用自动扩展
        if (this.deploymentConfig.useAutoScaling) {
            this.enableAutoScaling();
        }

        // 启用容器化
        if (this.deploymentConfig.useContainerization) {
            this.enableContainerization();
        }

        // 启用编排
        if (this.deploymentConfig.useOrchestration) {
            this.enableOrchestration();
        }

        // 启用SSL
        if (this.deploymentConfig.useSSL) {
            this.enableSSL();
        }

        // 启用CDN
        if (this.deploymentConfig.useCDN) {
            this.enableCDN();
        }

        // 启用缓存
        if (this.deploymentConfig.useCache) {
            this.enableCache();
        }

        // 启用压缩
        if (this.deploymentConfig.useCompression) {
            this.enableCompression();
        }

        // 启用优化
        if (this.deploymentConfig.useOptimization) {
            this.enableOptimization();
        }

        // 启用安全
        if (this.deploymentConfig.useSecurity) {
            this.enableSecurity();
        }
    },

    /**
     * 启用CI
     */
    enableCI: function () {
        // 实现CI逻辑
    },

    /**
     * 启用CD
     */
    enableCD: function () {
        // 实现CD逻辑
    },

    /**
     * 启用版本控制
     */
    enableVersioning: function () {
        // 实现版本控制逻辑
    },

    /**
     * 启用回滚
     */
    enableRollback: function () {
        // 实现回滚逻辑
    },

    /**
     * 启用蓝绿部署
     */
    enableBlueGreen: function () {
        // 实现蓝绿部署逻辑
    },

    /**
     * 启用金丝雀部署
     */
    enableCanary: function () {
        // 实现金丝雀部署逻辑
    },

    /**
     * 启用负载均衡
     */
    enableLoadBalancing: function () {
        // 实现负载均衡逻辑
    },

    /**
     * 启用自动扩展
     */
    enableAutoScaling: function () {
        // 实现自动扩展逻辑
    },

    /**
     * 启用容器化
     */
    enableContainerization: function () {
        // 实现容器化逻辑
    },

    /**
     * 启用编排
     */
    enableOrchestration: function () {
        // 实现编排逻辑
    },

    /**
     * 启用SSL
     */
    enableSSL: function () {
        // 实现SSL逻辑
    },

    /**
     * 启用CDN
     */
    enableCDN: function () {
        // 实现CDN逻辑
    },

    /**
     * 启用缓存
     */
    enableCache: function () {
        // 实现缓存逻辑
    },

    /**
     * 启用压缩
     */
    enableCompression: function () {
        // 实现压缩逻辑
    },

    /**
     * 启用优化
     */
    enableOptimization: function () {
        // 实现优化逻辑
    },

    /**
     * 启用安全
     */
    enableSecurity: function () {
        // 实现安全逻辑
    },

    /**
     * 创建部署
     * @param {Object} options - 部署选项
     * @returns {Promise} 部署结果Promise
     */
    createDeployment: function (options) {
        if (!this.deploymentConfig.enabled) {
            return Promise.reject(new Error('部署已禁用'));
        }

        options = options || {};

        const deployment = {
            id: 'deployment_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            options: options,
            status: 'pending',
            startTime: Date.now(),
            endTime: null,
            duration: null,
            result: null,
            error: null,
            version: options.version || '1.0.0',
            environment: options.environment || 'production'
        };

        this.deploymentQueue.push(deployment);

        // 更新统计
        this.deploymentStats.stats.totalDeployments++;

        this.saveDeploymentStats();

        // 执行部署
        return this.executeDeployment(deployment);
    },

    /**
     * 执行部署
     * @param {Object} deployment - 部署对象
     * @returns {Promise} 部署结果Promise
     */
    executeDeployment: function (deployment) {
        deployment.status = 'deploying';

        return new Promise((resolve, reject) => {
            try {
                // 版本控制
                if (this.deploymentConfig.useVersioning) {
                    this.versionDeployment(deployment);
                }

                // 备份
                if (this.deploymentConfig.useBackup) {
                    this.backupDeployment(deployment);
                }

                // 健康检查
                if (this.deploymentConfig.useHealthChecks) {
                    this.performHealthChecks(deployment);
                }

                // SSL
                if (this.deploymentConfig.useSSL) {
                    this.setupSSL(deployment);
                }

                // CDN
                if (this.deploymentConfig.useCDN) {
                    this.setupCDN(deployment);
                }

                // 缓存
                if (this.deploymentConfig.useCache) {
                    this.setupCache(deployment);
                }

                // 压缩
                if (this.deploymentConfig.useCompression) {
                    this.compressDeployment(deployment);
                }

                // 优化
                if (this.deploymentConfig.useOptimization) {
                    this.optimizeDeployment(deployment);
                }

                // 安全
                if (this.deploymentConfig.useSecurity) {
                    this.secureDeployment(deployment);
                }

                // 部署成功
                deployment.status = 'completed';
                deployment.endTime = Date.now();
                deployment.duration = deployment.endTime - deployment.startTime;
                deployment.result = { success: true };

                // 添加到历史
                this.deploymentHistory.push(deployment);

                // 更新统计
                this.deploymentStats.stats.successfulDeployments++;
                this.deploymentStats.stats.totalDeploymentTime += deployment.duration;
                this.deploymentStats.stats.avgDeploymentTime =
                    this.deploymentStats.stats.totalDeploymentTime / this.deploymentStats.stats.successfulDeployments;
                this.deploymentStats.stats.minDeploymentTime = Math.min(this.deploymentStats.stats.minDeploymentTime, deployment.duration);
                this.deploymentStats.stats.maxDeploymentTime = Math.max(this.deploymentStats.stats.maxDeploymentTime, deployment.duration);

                this.saveDeploymentStats();

                resolve(deployment);
            } catch (error) {
                // 部署失败
                deployment.status = 'failed';
                deployment.endTime = Date.now();
                deployment.duration = deployment.endTime - deployment.startTime;
                deployment.error = error.message;

                // 回滚
                if (this.deploymentConfig.useRollback) {
                    this.rollbackDeployment(deployment);
                }

                // 更新统计
                this.deploymentStats.stats.failedDeployments++;

                this.saveDeploymentStats();

                reject(error);
            }
        });
    },

    /**
     * 版本控制
     * @param {Object} deployment - 部署对象
     */
    versionDeployment: function (deployment) {
        // 实现版本控制逻辑
    },

    /**
     * 备份部署
     * @param {Object} deployment - 部署对象
     */
    backupDeployment: function (deployment) {
        // 实现备份逻辑

        // 更新统计
        this.deploymentStats.stats.totalBackups++;

        this.saveDeploymentStats();
    },

    /**
     * 执行健康检查
     * @param {Object} deployment - 部署对象
     */
    performHealthChecks: function (deployment) {
        // 实现健康检查逻辑

        // 更新统计
        this.deploymentStats.stats.totalHealthChecks++;
        this.deploymentStats.stats.successfulHealthChecks++;

        this.saveDeploymentStats();
    },

    /**
     * 设置SSL
     * @param {Object} deployment - 部署对象
     */
    setupSSL: function (deployment) {
        // 实现SSL设置逻辑

        // 更新统计
        this.deploymentStats.stats.totalSSLRequests++;
        this.deploymentStats.stats.successfulSSLRequests++;

        this.saveDeploymentStats();
    },

    /**
     * 设置CDN
     * @param {Object} deployment - 部署对象
     */
    setupCDN: function (deployment) {
        // 实现CDN设置逻辑

        // 更新统计
        this.deploymentStats.stats.totalCDNRequests++;
        this.deploymentStats.stats.successfulCDNRequests++;

        this.saveDeploymentStats();
    },

    /**
     * 设置缓存
     * @param {Object} deployment - 部署对象
     */
    setupCache: function (deployment) {
        // 实现缓存设置逻辑
    },

    /**
     * 压缩部署
     * @param {Object} deployment - 部署对象
     */
    compressDeployment: function (deployment) {
        // 实现压缩逻辑

        // 更新统计
        this.deploymentStats.stats.totalCompressions++;

        this.saveDeploymentStats();
    },

    /**
     * 优化部署
     * @param {Object} deployment - 部署对象
     */
    optimizeDeployment: function (deployment) {
        // 实现优化逻辑

        // 更新统计
        this.deploymentStats.stats.totalOptimizations++;

        this.saveDeploymentStats();
    },

    /**
     * 安全部署
     * @param {Object} deployment - 部署对象
     */
    secureDeployment: function (deployment) {
        // 实现安全逻辑

        // 更新统计
        this.deploymentStats.stats.totalSecurityChecks++;
        this.deploymentStats.stats.successfulSecurityChecks++;

        this.saveDeploymentStats();
    },

    /**
     * 回滚部署
     * @param {Object} deployment - 部署对象
     */
    rollbackDeployment: function (deployment) {
        // 实现回滚逻辑

        // 添加到回滚历史
        this.rollbackHistory.push({
            deploymentId: deployment.id,
            timestamp: Date.now()
        });

        // 更新统计
        this.deploymentStats.stats.totalRollbacks++;

        this.saveDeploymentStats();
    },

    /**
     * 监控部署
     */
    monitorDeployment: function () {
        // 实现监控逻辑

        // 更新统计
        this.deploymentStats.stats.totalMonitors++;

        this.saveDeploymentStats();
    },

    /**
     * 获取部署统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.deploymentStats.stats;
    },

    /**
     * 设置部署配置
     * @param {Object} config - 配置对象
     */
    setDeploymentConfig: function (config) {
        this.deploymentConfig = { ...this.deploymentConfig, ...config };
        this.saveDeploymentConfig();
    },

    /**
     * 获取部署配置
     * @returns {Object} 配置对象
     */
    getDeploymentConfig: function () {
        return this.deploymentConfig;
    }
};

// 优化：游戏运维优化
const GameOperationsOptimizer = {
    operationsConfig: {},
    operationsStats: {},
    operationsCache: {},

    /**
     * 初始化游戏运维优化
     */
    init: function () {
        this.loadOperationsConfig();
        this.loadOperationsStats();
        this.loadOperationsCache();
        this.initOperationsSystem();
        this.optimizeOperations();
    },

    /**
     * 加载运维配置
     */
    loadOperationsConfig: function () {
        this.operationsConfig = {
            enabled: true,
            useMonitoring: true,
            monitoringInterval: 60000,
            useLogging: true,
            logLevel: 'info',
            useAlerting: true,
            alertRules: [],
            useIncidentManagement: true,
            incidentSeverityLevels: ['low', 'medium', 'high', 'critical'],
            useChangeManagement: true,
            changeApprovalRequired: false,
            useProblemManagement: true,
            useKnowledgeManagement: true,
            useAssetManagement: true,
            useConfigurationManagement: true,
            useReleaseManagement: true,
            useCapacityManagement: false,
            useAvailabilityManagement: true,
            availabilityTarget: 99.9,
            usePerformanceManagement: true,
            performanceThresholds: {
                responseTime: 1000,
                throughput: 1000,
                errorRate: 0.01
            },
            useSecurityManagement: true,
            securityLevel: 'medium',
            useComplianceManagement: false,
            complianceStandards: [],
            useCostManagement: false,
            costTrackingEnabled: false,
            useResourceManagement: true,
            useAutomation: false,
            automationLevel: 'low',
            useOrchestration: false,
            useScheduling: true,
            schedulingInterval: 3600000,
            useReporting: true,
            reportFrequency: 'daily',
            useAnalytics: false,
            analyticsProvider: 'custom',
            useBackup: true,
            backupInterval: 86400000,
            backupRetention: 30,
            useDisasterRecovery: false,
            disasterRecoveryStrategy: 'active-passive',
            useMaintenance: true,
            maintenanceWindow: '02:00-04:00',
            useScaling: false,
            autoScalingEnabled: false,
            minInstances: 1,
            maxInstances: 10
        };

        const customConfig = localStorage.getItem('operationsConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.operationsConfig = { ...this.operationsConfig, ...config };
            } catch (error) {
                console.error('加载运维配置失败:', error);
            }
        }
    },

    /**
     * 保存运维配置
     */
    saveOperationsConfig: function () {
        localStorage.setItem('operationsConfig', JSON.stringify(this.operationsConfig));
    },

    /**
     * 加载运维统计
     */
    loadOperationsStats: function () {
        const savedStats = localStorage.getItem('operationsStats');
        if (savedStats) {
            try {
                this.operationsStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载运维统计失败:', error);
            }
        }

        if (!this.operationsStats.stats) {
            this.operationsStats = {
                stats: {
                    totalIncidents: 0,
                    resolvedIncidents: 0,
                    unresolvedIncidents: 0,
                    totalChanges: 0,
                    successfulChanges: 0,
                    failedChanges: 0,
                    totalProblems: 0,
                    resolvedProblems: 0,
                    unresolvedProblems: 0,
                    totalKnowledgeArticles: 0,
                    totalAssets: 0,
                    totalConfigurations: 0,
                    totalReleases: 0,
                    totalBackups: 0,
                    totalRestores: 0,
                    totalMaintenanceWindows: 0,
                    totalScalings: 0,
                    totalAlerts: 0,
                    totalMonitors: 0,
                    totalLogs: 0,
                    totalReports: 0,
                    availability: 100,
                    avgResponseTime: 0,
                    avgThroughput: 0,
                    avgErrorRate: 0,
                    totalCost: 0,
                    avgCost: 0
                }
            };

            this.saveOperationsStats();
        }
    },

    /**
     * 保存运维统计
     */
    saveOperationsStats: function () {
        localStorage.setItem('operationsStats', JSON.stringify(this.operationsStats));
    },

    /**
     * 加载运维缓存
     */
    loadOperationsCache: function () {
        const savedCache = localStorage.getItem('operationsCache');
        if (savedCache) {
            try {
                this.operationsCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载运维缓存失败:', error);
            }
        }

        if (!this.operationsCache.cache) {
            this.operationsCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveOperationsCache();
        }
    },

    /**
     * 保存运维缓存
     */
    saveOperationsCache: function () {
        localStorage.setItem('operationsCache', JSON.stringify(this.operationsCache));
    },

    /**
     * 初始化运维系统
     */
    initOperationsSystem: function () {
        // 初始化事件
        this.incidents = [];

        // 初始化变更
        this.changes = [];

        // 初始化问题
        this.problems = [];

        // 初始化知识库
        this.knowledgeBase = [];

        // 初始化资产
        this.assets = [];

        // 初始化配置
        this.configurations = {};

        // 初始化发布
        this.releases = [];

        // 启动监控
        if (this.operationsConfig.useMonitoring) {
            this.startMonitoring();
        }

        // 启动备份
        if (this.operationsConfig.useBackup) {
            this.startBackup();
        }

        // 启动维护
        if (this.operationsConfig.useMaintenance) {
            this.startMaintenance();
        }

        // 启动扩展
        if (this.operationsConfig.useScaling) {
            this.startScaling();
        }

        // 启动调度
        if (this.operationsConfig.useScheduling) {
            this.startScheduling();
        }

        // 启动报告
        if (this.operationsConfig.useReporting) {
            this.startReporting();
        }
    },

    /**
     * 启动监控
     */
    startMonitoring: function () {
        setInterval(() => {
            if (this.operationsConfig.useMonitoring) {
                this.monitorSystem();
            }
        }, this.operationsConfig.monitoringInterval);
    },

    /**
     * 启动备份
     */
    startBackup: function () {
        setInterval(() => {
            if (this.operationsConfig.useBackup) {
                this.backupSystem();
            }
        }, this.operationsConfig.backupInterval);
    },

    /**
     * 启动维护
     */
    startMaintenance: function () {
        // 实现维护逻辑
    },

    /**
     * 启动扩展
     */
    startScaling: function () {
        // 实现扩展逻辑
    },

    /**
     * 启动调度
     */
    startScheduling: function () {
        setInterval(() => {
            if (this.operationsConfig.useScheduling) {
                this.runScheduledTasks();
            }
        }, this.operationsConfig.schedulingInterval);
    },

    /**
     * 启动报告
     */
    startReporting: function () {
        setInterval(() => {
            if (this.operationsConfig.useReporting) {
                this.generateReports();
            }
        }, 86400000); // 每天一次
    },

    /**
     * 优化运维
     */
    optimizeOperations: function () {
        // 启用监控
        if (this.operationsConfig.useMonitoring) {
            this.enableMonitoring();
        }

        // 启用日志
        if (this.operationsConfig.useLogging) {
            this.enableLogging();
        }

        // 启用警报
        if (this.operationsConfig.useAlerting) {
            this.enableAlerting();
        }

        // 启用事件管理
        if (this.operationsConfig.useIncidentManagement) {
            this.enableIncidentManagement();
        }

        // 启用变更管理
        if (this.operationsConfig.useChangeManagement) {
            this.enableChangeManagement();
        }

        // 启用问题管理
        if (this.operationsConfig.useProblemManagement) {
            this.enableProblemManagement();
        }

        // 启用知识管理
        if (this.operationsConfig.useKnowledgeManagement) {
            this.enableKnowledgeManagement();
        }

        // 启用资产管理
        if (this.operationsConfig.useAssetManagement) {
            this.enableAssetManagement();
        }

        // 启用配置管理
        if (this.operationsConfig.useConfigurationManagement) {
            this.enableConfigurationManagement();
        }

        // 启用发布管理
        if (this.operationsConfig.useReleaseManagement) {
            this.enableReleaseManagement();
        }

        // 启用可用性管理
        if (this.operationsConfig.useAvailabilityManagement) {
            this.enableAvailabilityManagement();
        }

        // 启用性能管理
        if (this.operationsConfig.usePerformanceManagement) {
            this.enablePerformanceManagement();
        }

        // 启用安全管理
        if (this.operationsConfig.useSecurityManagement) {
            this.enableSecurityManagement();
        }

        // 启用成本管理
        if (this.operationsConfig.useCostManagement) {
            this.enableCostManagement();
        }

        // 启用资源管理
        if (this.operationsConfig.useResourceManagement) {
            this.enableResourceManagement();
        }

        // 启用自动化
        if (this.operationsConfig.useAutomation) {
            this.enableAutomation();
        }

        // 启用编排
        if (this.operationsConfig.useOrchestration) {
            this.enableOrchestration();
        }
    },

    /**
     * 启用监控
     */
    enableMonitoring: function () {
        // 实现监控逻辑
    },

    /**
     * 启用日志
     */
    enableLogging: function () {
        // 实现日志逻辑
    },

    /**
     * 启用警报
     */
    enableAlerting: function () {
        // 实现警报逻辑
    },

    /**
     * 启用事件管理
     */
    enableIncidentManagement: function () {
        // 实现事件管理逻辑
    },

    /**
     * 启用变更管理
     */
    enableChangeManagement: function () {
        // 实现变更管理逻辑
    },

    /**
     * 启用问题管理
     */
    enableProblemManagement: function () {
        // 实现问题管理逻辑
    },

    /**
     * 启用知识管理
     */
    enableKnowledgeManagement: function () {
        // 实现知识管理逻辑
    },

    /**
     * 启用资产管理
     */
    enableAssetManagement: function () {
        // 实现资产管理逻辑
    },

    /**
     * 启用配置管理
     */
    enableConfigurationManagement: function () {
        // 实现配置管理逻辑
    },

    /**
     * 启用发布管理
     */
    enableReleaseManagement: function () {
        // 实现发布管理逻辑
    },

    /**
     * 启用可用性管理
     */
    enableAvailabilityManagement: function () {
        // 实现可用性管理逻辑
    },

    /**
     * 启用性能管理
     */
    enablePerformanceManagement: function () {
        // 实现性能管理逻辑
    },

    /**
     * 启用安全管理
     */
    enableSecurityManagement: function () {
        // 实现安全管理逻辑
    },

    /**
     * 启用成本管理
     */
    enableCostManagement: function () {
        // 实现成本管理逻辑
    },

    /**
     * 启用资源管理
     */
    enableResourceManagement: function () {
        // 实现资源管理逻辑
    },

    /**
     * 启用自动化
     */
    enableAutomation: function () {
        // 实现自动化逻辑
    },

    /**
     * 启用编排
     */
    enableOrchestration: function () {
        // 实现编排逻辑
    },

    /**
     * 创建事件
     * @param {Object} options - 事件选项
     * @returns {Object} 事件对象
     */
    createIncident: function (options) {
        if (!this.operationsConfig.enabled) {
            return null;
        }

        const incident = {
            id: 'incident_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            title: options.title,
            description: options.description,
            severity: options.severity || 'medium',
            status: 'open',
            priority: options.priority || 'medium',
            assignee: options.assignee || null,
            createdAt: Date.now(),
            updatedAt: Date.now(),
            resolvedAt: null,
            resolution: null,
            tags: options.tags || [],
            metadata: options.metadata || {}
        };

        this.incidents.push(incident);

        // 更新统计
        this.operationsStats.stats.totalIncidents++;

        this.saveOperationsStats();

        return incident;
    },

    /**
     * 解决事件
     * @param {string} incidentId - 事件ID
     * @param {string} resolution - 解决方案
     * @returns {boolean} 是否成功
     */
    resolveIncident: function (incidentId, resolution) {
        const incident = this.incidents.find(i => i.id === incidentId);

        if (!incident) {
            return false;
        }

        incident.status = 'resolved';
        incident.resolvedAt = Date.now();
        incident.resolution = resolution;
        incident.updatedAt = Date.now();

        // 更新统计
        this.operationsStats.stats.resolvedIncidents++;
        this.operationsStats.stats.unresolvedIncidents--;

        this.saveOperationsStats();

        return true;
    },

    /**
     * 创建变更
     * @param {Object} options - 变更选项
     * @returns {Object} 变更对象
     */
    createChange: function (options) {
        if (!this.operationsConfig.enabled) {
            return null;
        }

        const change = {
            id: 'change_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            title: options.title,
            description: options.description,
            type: options.type || 'normal',
            status: 'pending',
            priority: options.priority || 'medium',
            requester: options.requester || null,
            approver: options.approver || null,
            scheduledFor: options.scheduledFor || null,
            completedAt: null,
            result: null,
            rollbackPlan: options.rollbackPlan || null,
            createdAt: Date.now(),
            updatedAt: Date.now(),
            tags: options.tags || [],
            metadata: options.metadata || {}
        };

        this.changes.push(change);

        // 更新统计
        this.operationsStats.stats.totalChanges++;

        this.saveOperationsStats();

        return change;
    },

    /**
     * 监控系统
     */
    monitorSystem: function () {
        // 实现系统监控逻辑

        // 更新统计
        this.operationsStats.stats.totalMonitors++;

        this.saveOperationsStats();
    },

    /**
     * 备份系统
     */
    backupSystem: function () {
        // 实现系统备份逻辑

        // 更新统计
        this.operationsStats.stats.totalBackups++;

        this.saveOperationsStats();
    },

    /**
     * 运行计划任务
     */
    runScheduledTasks: function () {
        // 实现计划任务逻辑
    },

    /**
     * 生成报告
     */
    generateReports: function () {
        // 实现报告生成逻辑

        // 更新统计
        this.operationsStats.stats.totalReports++;

        this.saveOperationsStats();
    },

    /**
     * 获取运维统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.operationsStats.stats;
    },

    /**
     * 设置运维配置
     * @param {Object} config - 配置对象
     */
    setOperationsConfig: function (config) {
        this.operationsConfig = { ...this.operationsConfig, ...config };
        this.saveOperationsConfig();
    },

    /**
     * 获取运维配置
     * @returns {Object} 配置对象
     */
    getOperationsConfig: function () {
        return this.operationsConfig;
    }
};

// 优化：游戏维护优化
const GameMaintenanceOptimizer = {
    maintenanceConfig: {},
    maintenanceStats: {},
    maintenanceCache: {},

    /**
     * 初始化游戏维护优化
     */
    init: function () {
        this.loadMaintenanceConfig();
        this.loadMaintenanceStats();
        this.loadMaintenanceCache();
        this.initMaintenanceSystem();
        this.optimizeMaintenance();
    },

    /**
     * 加载维护配置
     */
    loadMaintenanceConfig: function () {
        this.maintenanceConfig = {
            enabled: true,
            useScheduledMaintenance: true,
            maintenanceWindow: '02:00-04:00',
            maintenanceFrequency: 'weekly',
            usePredictiveMaintenance: false,
            usePreventiveMaintenance: true,
            useCorrectiveMaintenance: true,
            useAdaptiveMaintenance: false,
            useRollingMaintenance: false,
            maintenanceDuration: 7200000,
            useDowntime: true,
            maxDowntime: 3600000,
            useNotifications: true,
            notificationLeadTime: 86400000,
            notificationChannels: ['email', 'sms'],
            useApproval: true,
            approvalRequired: true,
            approvers: [],
            useRollback: true,
            maxRollbacks: 3,
            useValidation: true,
            validationRequired: true,
            useTesting: true,
            testingRequired: true,
            useDocumentation: true,
            documentationRequired: true,
            useBackup: true,
            backupRequired: true,
            backupRetention: 30,
            useMonitoring: true,
            monitoringInterval: 30000,
            useLogging: true,
            logLevel: 'info',
            useAlerting: true,
            alertRules: [],
            useReporting: true,
            reportFrequency: 'weekly',
            useAutomation: false,
            automationLevel: 'low',
            useOrchestration: false,
            useScheduling: true,
            schedulingInterval: 3600000,
            useVersioning: true,
            versioningStrategy: 'semantic',
            usePatching: true,
            patchingStrategy: 'rolling',
            useUpgrades: true,
            upgradeStrategy: 'blue-green',
            useMigration: false,
            migrationStrategy: 'offline'
        };

        const customConfig = localStorage.getItem('maintenanceConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.maintenanceConfig = { ...this.maintenanceConfig, ...config };
            } catch (error) {
                console.error('加载维护配置失败:', error);
            }
        }
    },

    /**
     * 保存维护配置
     */
    saveMaintenanceConfig: function () {
        localStorage.setItem('maintenanceConfig', JSON.stringify(this.maintenanceConfig));
    },

    /**
     * 加载维护统计
     */
    loadMaintenanceStats: function () {
        const savedStats = localStorage.getItem('maintenanceStats');
        if (savedStats) {
            try {
                this.maintenanceStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载维护统计失败:', error);
            }
        }

        if (!this.maintenanceStats.stats) {
            this.maintenanceStats = {
                stats: {
                    totalMaintenances: 0,
                    scheduledMaintenances: 0,
                    unscheduledMaintenances: 0,
                    preventiveMaintenances: 0,
                    correctiveMaintenances: 0,
                    adaptiveMaintenances: 0,
                    rollingMaintenances: 0,
                    successfulMaintenances: 0,
                    failedMaintenances: 0,
                    totalDowntime: 0,
                    avgDowntime: 0,
                    minDowntime: 0,
                    maxDowntime: 0,
                    totalRollbacks: 0,
                    successfulRollbacks: 0,
                    failedRollbacks: 0,
                    totalPatches: 0,
                    successfulPatches: 0,
                    failedPatches: 0,
                    totalUpgrades: 0,
                    successfulUpgrades: 0,
                    failedUpgrades: 0,
                    totalMigrations: 0,
                    successfulMigrations: 0,
                    failedMigrations: 0,
                    totalBackups: 0,
                    totalRestores: 0,
                    totalNotifications: 0,
                    totalAlerts: 0,
                    totalMonitors: 0,
                    totalLogs: 0,
                    totalReports: 0
                }
            };

            this.saveMaintenanceStats();
        }
    },

    /**
     * 保存维护统计
     */
    saveMaintenanceStats: function () {
        localStorage.setItem('maintenanceStats', JSON.stringify(this.maintenanceStats));
    },

    /**
     * 加载维护缓存
     */
    loadMaintenanceCache: function () {
        const savedCache = localStorage.getItem('maintenanceCache');
        if (savedCache) {
            try {
                this.maintenanceCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载维护缓存失败:', error);
            }
        }

        if (!this.maintenanceCache.cache) {
            this.maintenanceCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveMaintenanceCache();
        }
    },

    /**
     * 保存维护缓存
     */
    saveMaintenanceCache: function () {
        localStorage.setItem('maintenanceCache', JSON.stringify(this.maintenanceCache));
    },

    /**
     * 初始化维护系统
     */
    initMaintenanceSystem: function () {
        // 初始化维护队列
        this.maintenanceQueue = [];

        // 初始化维护历史
        this.maintenanceHistory = [];

        // 初始化回滚历史
        this.rollbackHistory = [];

        // 初始化补丁历史
        this.patchHistory = [];

        // 初始化升级历史
        this.upgradeHistory = [];

        // 启动调度
        if (this.maintenanceConfig.useScheduling) {
            this.startScheduling();
        }

        // 启动监控
        if (this.maintenanceConfig.useMonitoring) {
            this.startMonitoring();
        }

        // 启动备份
        if (this.maintenanceConfig.useBackup) {
            this.startBackup();
        }
    },

    /**
     * 启动调度
     */
    startScheduling: function () {
        setInterval(() => {
            if (this.maintenanceConfig.useScheduling) {
                this.runScheduledMaintenance();
            }
        }, this.maintenanceConfig.schedulingInterval);
    },

    /**
     * 启动监控
     */
    startMonitoring: function () {
        setInterval(() => {
            if (this.maintenanceConfig.useMonitoring) {
                this.monitorMaintenance();
            }
        }, this.maintenanceConfig.monitoringInterval);
    },

    /**
     * 启动备份
     */
    startBackup: function () {
        // 实现备份逻辑
    },

    /**
     * 优化维护
     */
    optimizeMaintenance: function () {
        // 启用计划维护
        if (this.maintenanceConfig.useScheduledMaintenance) {
            this.enableScheduledMaintenance();
        }

        // 启用预测性维护
        if (this.maintenanceConfig.usePredictiveMaintenance) {
            this.enablePredictiveMaintenance();
        }

        // 启用预防性维护
        if (this.maintenanceConfig.usePreventiveMaintenance) {
            this.enablePreventiveMaintenance();
        }

        // 启用纠正性维护
        if (this.maintenanceConfig.useCorrectiveMaintenance) {
            this.enableCorrectiveMaintenance();
        }

        // 启用自适应维护
        if (this.maintenanceConfig.useAdaptiveMaintenance) {
            this.enableAdaptiveMaintenance();
        }

        // 启用滚动维护
        if (this.maintenanceConfig.useRollingMaintenance) {
            this.enableRollingMaintenance();
        }

        // 启用补丁
        if (this.maintenanceConfig.usePatching) {
            this.enablePatching();
        }

        // 启用升级
        if (this.maintenanceConfig.useUpgrades) {
            this.enableUpgrades();
        }

        // 启用迁移
        if (this.maintenanceConfig.useMigration) {
            this.enableMigration();
        }

        // 启用通知
        if (this.maintenanceConfig.useNotifications) {
            this.enableNotifications();
        }

        // 启用批准
        if (this.maintenanceConfig.useApproval) {
            this.enableApproval();
        }

        // 启用回滚
        if (this.maintenanceConfig.useRollback) {
            this.enableRollback();
        }

        // 启用验证
        if (this.maintenanceConfig.useValidation) {
            this.enableValidation();
        }

        // 启用测试
        if (this.maintenanceConfig.useTesting) {
            this.enableTesting();
        }

        // 启用文档
        if (this.maintenanceConfig.useDocumentation) {
            this.enableDocumentation();
        }
    },

    /**
     * 启用计划维护
     */
    enableScheduledMaintenance: function () {
        // 实现计划维护逻辑
    },

    /**
     * 启用预测性维护
     */
    enablePredictiveMaintenance: function () {
        // 实现预测性维护逻辑
    },

    /**
     * 启用预防性维护
     */
    enablePreventiveMaintenance: function () {
        // 实现预防性维护逻辑
    },

    /**
     * 启用纠正性维护
     */
    enableCorrectiveMaintenance: function () {
        // 实现纠正性维护逻辑
    },

    /**
     * 启用自适应维护
     */
    enableAdaptiveMaintenance: function () {
        // 实现自适应维护逻辑
    },

    /**
     * 启用滚动维护
     */
    enableRollingMaintenance: function () {
        // 实现滚动维护逻辑
    },

    /**
     * 启用补丁
     */
    enablePatching: function () {
        // 实现补丁逻辑
    },

    /**
     * 启用升级
     */
    enableUpgrades: function () {
        // 实现升级逻辑
    },

    /**
     * 启用迁移
     */
    enableMigration: function () {
        // 实现迁移逻辑
    },

    /**
     * 启用通知
     */
    enableNotifications: function () {
        // 实现通知逻辑
    },

    /**
     * 启用批准
     */
    enableApproval: function () {
        // 实现批准逻辑
    },

    /**
     * 启用回滚
     */
    enableRollback: function () {
        // 实现回滚逻辑
    },

    /**
     * 启用验证
     */
    enableValidation: function () {
        // 实现验证逻辑
    },

    /**
     * 启用测试
     */
    enableTesting: function () {
        // 实现测试逻辑
    },

    /**
     * 启用文档
     */
    enableDocumentation: function () {
        // 实现文档逻辑
    },

    /**
     * 创建维护
     * @param {Object} options - 维护选项
     * @returns {Promise} 维护结果Promise
     */
    createMaintenance: function (options) {
        if (!this.maintenanceConfig.enabled) {
            return Promise.reject(new Error('维护已禁用'));
        }

        options = options || {};

        const maintenance = {
            id: 'maintenance_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            options: options,
            type: options.type || 'preventive',
            status: 'pending',
            scheduledFor: options.scheduledFor || null,
            startTime: null,
            endTime: null,
            duration: null,
            result: null,
            error: null,
            approved: false,
            approvedBy: null,
            approvedAt: null,
            validated: false,
            validatedBy: null,
            validatedAt: null,
            tested: false,
            testedBy: null,
            testedAt: null,
            documented: false,
            documentedBy: null,
            documentedAt: null,
            createdAt: Date.now(),
            updatedAt: Date.now()
        };

        this.maintenanceQueue.push(maintenance);

        // 更新统计
        this.maintenanceStats.stats.totalMaintenances++;

        this.saveMaintenanceStats();

        // 执行维护
        return this.executeMaintenance(maintenance);
    },

    /**
     * 执行维护
     * @param {Object} maintenance - 维护对象
     * @returns {Promise} 维护结果Promise
     */
    executeMaintenance: function (maintenance) {
        maintenance.status = 'in-progress';
        maintenance.startTime = Date.now();

        return new Promise((resolve, reject) => {
            try {
                // 批准
                if (this.maintenanceConfig.useApproval && this.maintenanceConfig.approvalRequired) {
                    this.approveMaintenance(maintenance);
                }

                // 备份
                if (this.maintenanceConfig.useBackup && this.maintenanceConfig.backupRequired) {
                    this.backupMaintenance(maintenance);
                }

                // 通知
                if (this.maintenanceConfig.useNotifications) {
                    this.notifyMaintenance(maintenance);
                }

                // 验证
                if (this.maintenanceConfig.useValidation && this.maintenanceConfig.validationRequired) {
                    this.validateMaintenance(maintenance);
                }

                // 测试
                if (this.maintenanceConfig.useTesting && this.maintenanceConfig.testingRequired) {
                    this.testMaintenance(maintenance);
                }

                // 补丁
                if (this.maintenanceConfig.usePatching) {
                    this.patchMaintenance(maintenance);
                }

                // 升级
                if (this.maintenanceConfig.useUpgrades) {
                    this.upgradeMaintenance(maintenance);
                }

                // 迁移
                if (this.maintenanceConfig.useMigration) {
                    this.migrateMaintenance(maintenance);
                }

                // 文档
                if (this.maintenanceConfig.useDocumentation && this.maintenanceConfig.documentationRequired) {
                    this.documentMaintenance(maintenance);
                }

                // 维护成功
                maintenance.status = 'completed';
                maintenance.endTime = Date.now();
                maintenance.duration = maintenance.endTime - maintenance.startTime;
                maintenance.result = { success: true };

                // 添加到历史
                this.maintenanceHistory.push(maintenance);

                // 更新统计
                this.maintenanceStats.stats.successfulMaintenances++;
                this.maintenanceStats.stats.totalDowntime += maintenance.duration;
                this.maintenanceStats.stats.avgDowntime =
                    this.maintenanceStats.stats.totalDowntime / this.maintenanceStats.stats.successfulMaintenances;
                this.maintenanceStats.stats.minDowntime = Math.min(this.maintenanceStats.stats.minDowntime, maintenance.duration);
                this.maintenanceStats.stats.maxDowntime = Math.max(this.maintenanceStats.stats.maxDowntime, maintenance.duration);

                this.saveMaintenanceStats();

                resolve(maintenance);
            } catch (error) {
                // 维护失败
                maintenance.status = 'failed';
                maintenance.endTime = Date.now();
                maintenance.duration = maintenance.endTime - maintenance.startTime;
                maintenance.error = error.message;

                // 回滚
                if (this.maintenanceConfig.useRollback) {
                    this.rollbackMaintenance(maintenance);
                }

                // 更新统计
                this.maintenanceStats.stats.failedMaintenances++;

                this.saveMaintenanceStats();

                reject(error);
            }
        });
    },

    /**
     * 批准维护
     * @param {Object} maintenance - 维护对象
     */
    approveMaintenance: function (maintenance) {
        // 实现批准逻辑

        maintenance.approved = true;
        maintenance.approvedAt = Date.now();
    },

    /**
     * 备份维护
     * @param {Object} maintenance - 维护对象
     */
    backupMaintenance: function (maintenance) {
        // 实现备份逻辑

        // 更新统计
        this.maintenanceStats.stats.totalBackups++;

        this.saveMaintenanceStats();
    },

    /**
     * 通知维护
     * @param {Object} maintenance - 维护对象
     */
    notifyMaintenance: function (maintenance) {
        // 实现通知逻辑

        // 更新统计
        this.maintenanceStats.stats.totalNotifications++;

        this.saveMaintenanceStats();
    },

    /**
     * 验证维护
     * @param {Object} maintenance - 维护对象
     */
    validateMaintenance: function (maintenance) {
        // 实现验证逻辑

        maintenance.validated = true;
        maintenance.validatedAt = Date.now();
    },

    /**
     * 测试维护
     * @param {Object} maintenance - 维护对象
     */
    testMaintenance: function (maintenance) {
        // 实现测试逻辑

        maintenance.tested = true;
        maintenance.testedAt = Date.now();
    },

    /**
     * 补丁维护
     * @param {Object} maintenance - 维护对象
     */
    patchMaintenance: function (maintenance) {
        // 实现补丁逻辑

        // 更新统计
        this.maintenanceStats.stats.totalPatches++;
        this.maintenanceStats.stats.successfulPatches++;

        this.saveMaintenanceStats();
    },

    /**
     * 升级维护
     * @param {Object} maintenance - 维护对象
     */
    upgradeMaintenance: function (maintenance) {
        // 实现升级逻辑

        // 更新统计
        this.maintenanceStats.stats.totalUpgrades++;
        this.maintenanceStats.stats.successfulUpgrades++;

        this.saveMaintenanceStats();
    },

    /**
     * 迁移维护
     * @param {Object} maintenance - 维护对象
     */
    migrateMaintenance: function (maintenance) {
        // 实现迁移逻辑

        // 更新统计
        this.maintenanceStats.stats.totalMigrations++;
        this.maintenanceStats.stats.successfulMigrations++;

        this.saveMaintenanceStats();
    },

    /**
     * 文档维护
     * @param {Object} maintenance - 维护对象
     */
    documentMaintenance: function (maintenance) {
        // 实现文档逻辑

        maintenance.documented = true;
        maintenance.documentedAt = Date.now();
    },

    /**
     * 回滚维护
     * @param {Object} maintenance - 维护对象
     */
    rollbackMaintenance: function (maintenance) {
        // 实现回滚逻辑

        // 添加到回滚历史
        this.rollbackHistory.push({
            maintenanceId: maintenance.id,
            timestamp: Date.now()
        });

        // 更新统计
        this.maintenanceStats.stats.totalRollbacks++;
        this.maintenanceStats.stats.successfulRollbacks++;

        this.saveMaintenanceStats();
    },

    /**
     * 运行计划维护
     */
    runScheduledMaintenance: function () {
        // 实现计划维护逻辑
    },

    /**
     * 监控维护
     */
    monitorMaintenance: function () {
        // 实现监控逻辑

        // 更新统计
        this.maintenanceStats.stats.totalMonitors++;

        this.saveMaintenanceStats();
    },

    /**
     * 获取维护统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.maintenanceStats.stats;
    },

    /**
     * 设置维护配置
     * @param {Object} config - 配置对象
     */
    setMaintenanceConfig: function (config) {
        this.maintenanceConfig = { ...this.maintenanceConfig, ...config };
        this.saveMaintenanceConfig();
    },

    /**
     * 获取维护配置
     * @returns {Object} 配置对象
     */
    getMaintenanceConfig: function () {
        return this.maintenanceConfig;
    }
};

// 优化：游戏更新优化
const GameUpdateOptimizer = {
    updateConfig: {},
    updateStats: {},
    updateCache: {},

    /**
     * 初始化游戏更新优化
     */
    init: function () {
        this.loadUpdateConfig();
        this.loadUpdateStats();
        this.loadUpdateCache();
        this.initUpdateSystem();
        this.optimizeUpdate();
    },

    /**
     * 加载更新配置
     */
    loadUpdateConfig: function () {
        this.updateConfig = {
            enabled: true,
            useAutoUpdate: false,
            updateCheckInterval: 86400000,
            updateCheckUrl: null,
            useIncrementalUpdates: true,
            useDeltaUpdates: true,
            useBackgroundUpdates: false,
            useSilentUpdates: false,
            useForcedUpdates: false,
            useRollingUpdates: true,
            updateStrategy: 'rolling',
            useVersioning: true,
            versioningStrategy: 'semantic',
            currentVersion: '1.0.0',
            useChangelog: true,
            useReleaseNotes: true,
            useNotifications: true,
            notificationChannels: ['in-app'],
            useBackup: true,
            backupBeforeUpdate: true,
            backupRetention: 3,
            useValidation: true,
            validationRequired: true,
            useTesting: true,
            testingRequired: false,
            useRollback: true,
            maxRollbacks: 3,
            useDowntime: true,
            maxDowntime: 300000,
            useStaging: true,
            useCanary: false,
            canaryPercentage: 10,
            useApproval: true,
            approvalRequired: false,
            approvers: [],
            useMonitoring: true,
            monitoringInterval: 30000,
            useLogging: true,
            logLevel: 'info',
            useAlerting: true,
            alertRules: [],
            useReporting: true,
            reportFrequency: 'weekly',
            useAnalytics: false,
            analyticsProvider: 'custom',
            useCDN: false,
            cdnProvider: 'cloudflare',
            useCompression: true,
            compressionLevel: 6,
            useEncryption: true,
            encryptionType: 'AES'
        };

        const customConfig = localStorage.getItem('updateConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.updateConfig = { ...this.updateConfig, ...config };
            } catch (error) {
                console.error('加载更新配置失败:', error);
            }
        }
    },

    /**
     * 保存更新配置
     */
    saveUpdateConfig: function () {
        localStorage.setItem('updateConfig', JSON.stringify(this.updateConfig));
    },

    /**
     * 加载更新统计
     */
    loadUpdateStats: function () {
        const savedStats = localStorage.getItem('updateStats');
        if (savedStats) {
            try {
                this.updateStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载更新统计失败:', error);
            }
        }

        if (!this.updateStats.stats) {
            this.updateStats = {
                stats: {
                    totalUpdates: 0,
                    successfulUpdates: 0,
                    failedUpdates: 0,
                    cancelledUpdates: 0,
                    totalUpdateChecks: 0,
                    availableUpdates: 0,
                    downloadedUpdates: 0,
                    installedUpdates: 0,
                    totalIncrementalUpdates: 0,
                    totalDeltaUpdates: 0,
                    totalBackgroundUpdates: 0,
                    totalSilentUpdates: 0,
                    totalForcedUpdates: 0,
                    totalRollingUpdates: 0,
                    totalRollbacks: 0,
                    successfulRollbacks: 0,
                    failedRollbacks: 0,
                    totalBackups: 0,
                    totalRestores: 0,
                    totalDowntime: 0,
                    avgDowntime: 0,
                    minDowntime: 0,
                    maxDowntime: 0,
                    totalStagingUpdates: 0,
                    totalCanaryUpdates: 0,
                    totalApprovals: 0,
                    totalNotifications: 0,
                    totalAlerts: 0,
                    totalMonitors: 0,
                    totalLogs: 0,
                    totalReports: 0
                }
            };

            this.saveUpdateStats();
        }
    },

    /**
     * 保存更新统计
     */
    saveUpdateStats: function () {
        localStorage.setItem('updateStats', JSON.stringify(this.updateStats));
    },

    /**
     * 加载更新缓存
     */
    loadUpdateCache: function () {
        const savedCache = localStorage.getItem('updateCache');
        if (savedCache) {
            try {
                this.updateCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载更新缓存失败:', error);
            }
        }

        if (!this.updateCache.cache) {
            this.updateCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveUpdateCache();
        }
    },

    /**
     * 保存更新缓存
     */
    saveUpdateCache: function () {
        localStorage.setItem('updateCache', JSON.stringify(this.updateCache));
    },

    /**
     * 初始化更新系统
     */
    initUpdateSystem: function () {
        // 初始化更新队列
        this.updateQueue = [];

        // 初始化更新历史
        this.updateHistory = [];

        // 初始化回滚历史
        this.rollbackHistory = [];

        // 初始化可用更新
        this.availableUpdates = [];

        // 启动自动更新检查
        if (this.updateConfig.useAutoUpdate) {
            this.startAutoUpdateCheck();
        }

        // 启动监控
        if (this.updateConfig.useMonitoring) {
            this.startMonitoring();
        }
    },

    /**
     * 启动自动更新检查
     */
    startAutoUpdateCheck: function () {
        setInterval(() => {
            if (this.updateConfig.useAutoUpdate) {
                this.checkForUpdates();
            }
        }, this.updateConfig.updateCheckInterval);
    },

    /**
     * 启动监控
     */
    startMonitoring: function () {
        setInterval(() => {
            if (this.updateConfig.useMonitoring) {
                this.monitorUpdate();
            }
        }, this.updateConfig.monitoringInterval);
    },

    /**
     * 优化更新
     */
    optimizeUpdate: function () {
        // 启用增量更新
        if (this.updateConfig.useIncrementalUpdates) {
            this.enableIncrementalUpdates();
        }

        // 启用Delta更新
        if (this.updateConfig.useDeltaUpdates) {
            this.enableDeltaUpdates();
        }

        // 启用后台更新
        if (this.updateConfig.useBackgroundUpdates) {
            this.enableBackgroundUpdates();
        }

        // 启用静默更新
        if (this.updateConfig.useSilentUpdates) {
            this.enableSilentUpdates();
        }

        // 启用强制更新
        if (this.updateConfig.useForcedUpdates) {
            this.enableForcedUpdates();
        }

        // 启用滚动更新
        if (this.updateConfig.useRollingUpdates) {
            this.enableRollingUpdates();
        }

        // 启用版本控制
        if (this.updateConfig.useVersioning) {
            this.enableVersioning();
        }

        // 启用通知
        if (this.updateConfig.useNotifications) {
            this.enableNotifications();
        }

        // 启用备份
        if (this.updateConfig.useBackup) {
            this.enableBackup();
        }

        // 启用验证
        if (this.updateConfig.useValidation) {
            this.enableValidation();
        }

        // 启用测试
        if (this.updateConfig.useTesting) {
            this.enableTesting();
        }

        // 启用回滚
        if (this.updateConfig.useRollback) {
            this.enableRollback();
        }

        // 启用暂存
        if (this.updateConfig.useStaging) {
            this.enableStaging();
        }

        // 启用金丝雀
        if (this.updateConfig.useCanary) {
            this.enableCanary();
        }

        // 启用批准
        if (this.updateConfig.useApproval) {
            this.enableApproval();
        }

        // 启用CDN
        if (this.updateConfig.useCDN) {
            this.enableCDN();
        }

        // 启用压缩
        if (this.updateConfig.useCompression) {
            this.enableCompression();
        }

        // 启用加密
        if (this.updateConfig.useEncryption) {
            this.enableEncryption();
        }
    },

    /**
     * 启用增量更新
     */
    enableIncrementalUpdates: function () {
        // 实现增量更新逻辑
    },

    /**
     * 启用Delta更新
     */
    enableDeltaUpdates: function () {
        // 实现Delta更新逻辑
    },

    /**
     * 启用后台更新
     */
    enableBackgroundUpdates: function () {
        // 实现后台更新逻辑
    },

    /**
     * 启用静默更新
     */
    enableSilentUpdates: function () {
        // 实现静默更新逻辑
    },

    /**
     * 启用强制更新
     */
    enableForcedUpdates: function () {
        // 实现强制更新逻辑
    },

    /**
     * 启用滚动更新
     */
    enableRollingUpdates: function () {
        // 实现滚动更新逻辑
    },

    /**
     * 启用版本控制
     */
    enableVersioning: function () {
        // 实现版本控制逻辑
    },

    /**
     * 启用通知
     */
    enableNotifications: function () {
        // 实现通知逻辑
    },

    /**
     * 启用备份
     */
    enableBackup: function () {
        // 实现备份逻辑
    },

    /**
     * 启用验证
     */
    enableValidation: function () {
        // 实现验证逻辑
    },

    /**
     * 启用测试
     */
    enableTesting: function () {
        // 实现测试逻辑
    },

    /**
     * 启用回滚
     */
    enableRollback: function () {
        // 实现回滚逻辑
    },

    /**
     * 启用暂存
     */
    enableStaging: function () {
        // 实现暂存逻辑
    },

    /**
     * 启用金丝雀
     */
    enableCanary: function () {
        // 实现金丝雀逻辑
    },

    /**
     * 启用批准
     */
    enableApproval: function () {
        // 实现批准逻辑
    },

    /**
     * 启用CDN
     */
    enableCDN: function () {
        // 实现CDN逻辑
    },

    /**
     * 启用压缩
     */
    enableCompression: function () {
        // 实现压缩逻辑
    },

    /**
     * 启用加密
     */
    enableEncryption: function () {
        // 实现加密逻辑
    },

    /**
     * 检查更新
     * @returns {Promise} 更新检查Promise
     */
    checkForUpdates: function () {
        if (!this.updateConfig.enabled) {
            return Promise.reject(new Error('更新已禁用'));
        }

        // 更新统计
        this.updateStats.stats.totalUpdateChecks++;

        this.saveUpdateStats();

        // 检查是否有可用更新
        if (this.availableUpdates.length > 0) {
            return Promise.resolve({
                hasUpdate: true,
                updates: this.availableUpdates
            });
        }

        return Promise.resolve({
            hasUpdate: false,
            updates: []
        });
    },

    /**
     * 创建更新
     * @param {Object} options - 更新选项
     * @returns {Promise} 更新结果Promise
     */
    createUpdate: function (options) {
        if (!this.updateConfig.enabled) {
            return Promise.reject(new Error('更新已禁用'));
        }

        options = options || {};

        const update = {
            id: 'update_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            version: options.version || '1.0.0',
            type: options.type || 'minor',
            status: 'pending',
            description: options.description || '',
            changelog: options.changelog || '',
            releaseNotes: options.releaseNotes || '',
            downloadUrl: options.downloadUrl || '',
            checksum: options.checksum || '',
            size: options.size || 0,
            mandatory: options.mandatory || false,
            scheduledFor: options.scheduledFor || null,
            startTime: null,
            endTime: null,
            duration: null,
            result: null,
            error: null,
            approved: false,
            approvedBy: null,
            approvedAt: null,
            validated: false,
            validatedBy: null,
            validatedAt: null,
            tested: false,
            testedBy: null,
            testedAt: null,
            backedUp: false,
            backedUpBy: null,
            backedUpAt: null,
            createdAt: Date.now(),
            updatedAt: Date.now()
        };

        this.updateQueue.push(update);

        // 更新统计
        this.updateStats.stats.totalUpdates++;

        this.saveUpdateStats();

        // 执行更新
        return this.executeUpdate(update);
    },

    /**
     * 执行更新
     * @param {Object} update - 更新对象
     * @returns {Promise} 更新结果Promise
     */
    executeUpdate: function (update) {
        update.status = 'downloading';
        update.startTime = Date.now();

        return new Promise((resolve, reject) => {
            try {
                // 备份
                if (this.updateConfig.useBackup && this.updateConfig.backupBeforeUpdate) {
                    this.backupUpdate(update);
                }

                // 下载
                this.downloadUpdate(update);

                // 验证
                if (this.updateConfig.useValidation && this.updateConfig.validationRequired) {
                    this.validateUpdate(update);
                }

                // 测试
                if (this.updateConfig.useTesting && this.updateConfig.testingRequired) {
                    this.testUpdate(update);
                }

                // 批准
                if (this.updateConfig.useApproval && this.updateConfig.approvalRequired) {
                    this.approveUpdate(update);
                }

                // 安装
                this.installUpdate(update);

                // 通知
                if (this.updateConfig.useNotifications) {
                    this.notifyUpdate(update);
                }

                // 更新成功
                update.status = 'completed';
                update.endTime = Date.now();
                update.duration = update.endTime - update.startTime;
                update.result = { success: true };

                // 更新当前版本
                this.updateConfig.currentVersion = update.version;
                this.saveUpdateConfig();

                // 添加到历史
                this.updateHistory.push(update);

                // 更新统计
                this.updateStats.stats.successfulUpdates++;
                this.updateStats.stats.installedUpdates++;
                this.updateStats.stats.totalDowntime += update.duration;
                this.updateStats.stats.avgDowntime =
                    this.updateStats.stats.totalDowntime / this.updateStats.stats.successfulUpdates;
                this.updateStats.stats.minDowntime = Math.min(this.updateStats.stats.minDowntime, update.duration);
                this.updateStats.stats.maxDowntime = Math.max(this.updateStats.stats.maxDowntime, update.duration);

                this.saveUpdateStats();

                resolve(update);
            } catch (error) {
                // 更新失败
                update.status = 'failed';
                update.endTime = Date.now();
                update.duration = update.endTime - update.startTime;
                update.error = error.message;

                // 回滚
                if (this.updateConfig.useRollback) {
                    this.rollbackUpdate(update);
                }

                // 更新统计
                this.updateStats.stats.failedUpdates++;

                this.saveUpdateStats();

                reject(error);
            }
        });
    },

    /**
     * 备份更新
     * @param {Object} update - 更新对象
     */
    backupUpdate: function (update) {
        // 实现备份逻辑

        update.backedUp = true;
        update.backedUpAt = Date.now();

        // 更新统计
        this.updateStats.stats.totalBackups++;

        this.saveUpdateStats();
    },

    /**
     * 下载更新
     * @param {Object} update - 更新对象
     */
    downloadUpdate: function (update) {
        // 实现下载逻辑

        update.status = 'downloaded';

        // 更新统计
        this.updateStats.stats.downloadedUpdates++;

        this.saveUpdateStats();
    },

    /**
     * 验证更新
     * @param {Object} update - 更新对象
     */
    validateUpdate: function (update) {
        // 实现验证逻辑

        update.validated = true;
        update.validatedAt = Date.now();
    },

    /**
     * 测试更新
     * @param {Object} update - 更新对象
     */
    testUpdate: function (update) {
        // 实现测试逻辑

        update.tested = true;
        update.testedAt = Date.now();
    },

    /**
     * 批准更新
     * @param {Object} update - 更新对象
     */
    approveUpdate: function (update) {
        // 实现批准逻辑

        update.approved = true;
        update.approvedAt = Date.now();

        // 更新统计
        this.updateStats.stats.totalApprovals++;

        this.saveUpdateStats();
    },

    /**
     * 安装更新
     * @param {Object} update - 更新对象
     */
    installUpdate: function (update) {
        // 实现安装逻辑

        update.status = 'installing';
    },

    /**
     * 通知更新
     * @param {Object} update - 更新对象
     */
    notifyUpdate: function (update) {
        // 实现通知逻辑

        // 更新统计
        this.updateStats.stats.totalNotifications++;

        this.saveUpdateStats();
    },

    /**
     * 回滚更新
     * @param {Object} update - 更新对象
     */
    rollbackUpdate: function (update) {
        // 实现回滚逻辑

        // 添加到回滚历史
        this.rollbackHistory.push({
            updateId: update.id,
            timestamp: Date.now()
        });

        // 更新统计
        this.updateStats.stats.totalRollbacks++;
        this.updateStats.stats.successfulRollbacks++;

        this.saveUpdateStats();
    },

    /**
     * 监控更新
     */
    monitorUpdate: function () {
        // 实现监控逻辑

        // 更新统计
        this.updateStats.stats.totalMonitors++;

        this.saveUpdateStats();
    },

    /**
     * 获取更新统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.updateStats.stats;
    },

    /**
     * 设置更新配置
     * @param {Object} config - 配置对象
     */
    setUpdateConfig: function (config) {
        this.updateConfig = { ...this.updateConfig, ...config };
        this.saveUpdateConfig();
    },

    /**
     * 获取更新配置
     * @returns {Object} 配置对象
     */
    getUpdateConfig: function () {
        return this.updateConfig;
    }
};

// 优化：游戏升级优化
const GameUpgradeOptimizer = {
    upgradeConfig: {},
    upgradeStats: {},
    upgradeCache: {},

    /**
     * 初始化游戏升级优化
     */
    init: function () {
        this.loadUpgradeConfig();
        this.loadUpgradeStats();
        this.loadUpgradeCache();
        this.initUpgradeSystem();
        this.optimizeUpgrade();
    },

    /**
     * 加载升级配置
     */
    loadUpgradeConfig: function () {
        this.upgradeConfig = {
            enabled: true,
            useAutoUpgrade: false,
            upgradeCheckInterval: 604800000,
            upgradeCheckUrl: null,
            useIncrementalUpgrade: true,
            useDeltaUpgrade: true,
            useBackgroundUpgrade: false,
            useSilentUpgrade: false,
            useForcedUpgrade: false,
            useRollingUpgrade: true,
            upgradeStrategy: 'blue-green',
            useVersioning: true,
            versioningStrategy: 'semantic',
            currentVersion: '1.0.0',
            useChangelog: true,
            useReleaseNotes: true,
            useNotifications: true,
            notificationChannels: ['in-app', 'email'],
            useBackup: true,
            backupBeforeUpgrade: true,
            backupRetention: 5,
            useValidation: true,
            validationRequired: true,
            useTesting: true,
            testingRequired: true,
            useRollback: true,
            maxRollbacks: 5,
            useDowntime: true,
            maxDowntime: 600000,
            useStaging: true,
            useCanary: true,
            canaryPercentage: 20,
            useApproval: true,
            approvalRequired: true,
            approvers: [],
            useMonitoring: true,
            monitoringInterval: 30000,
            useLogging: true,
            logLevel: 'info',
            useAlerting: true,
            alertRules: [],
            useReporting: true,
            reportFrequency: 'weekly',
            useAnalytics: false,
            analyticsProvider: 'custom',
            useCDN: false,
            cdnProvider: 'cloudflare',
            useCompression: true,
            compressionLevel: 6,
            useEncryption: true,
            encryptionType: 'AES',
            useMigration: true,
            migrationStrategy: 'online',
            useDataMigration: true,
            dataBackupRequired: true,
            useSchemaMigration: true,
            schemaValidationRequired: true,
            useFeatureFlags: false,
            featureFlagStrategy: 'percentage',
            useAATesting: false,
            useABTesting: false,
            useCanaryRelease: true,
            canaryReleasePercentage: 10,
            useBlueGreenDeployment: true,
            useZeroDowntime: false,
            zeroDowntimeStrategy: 'rolling'
        };

        const customConfig = localStorage.getItem('upgradeConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.upgradeConfig = { ...this.upgradeConfig, ...config };
            } catch (error) {
                console.error('加载升级配置失败:', error);
            }
        }
    },

    /**
     * 保存升级配置
     */
    saveUpgradeConfig: function () {
        localStorage.setItem('upgradeConfig', JSON.stringify(this.upgradeConfig));
    },

    /**
     * 加载升级统计
     */
    loadUpgradeStats: function () {
        const savedStats = localStorage.getItem('upgradeStats');
        if (savedStats) {
            try {
                this.upgradeStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载升级统计失败:', error);
            }
        }

        if (!this.upgradeStats.stats) {
            this.upgradeStats = {
                stats: {
                    totalUpgrades: 0,
                    successfulUpgrades: 0,
                    failedUpgrades: 0,
                    cancelledUpgrades: 0,
                    totalUpgradeChecks: 0,
                    availableUpgrades: 0,
                    downloadedUpgrades: 0,
                    installedUpgrades: 0,
                    totalIncrementalUpgrades: 0,
                    totalDeltaUpgrades: 0,
                    totalBackgroundUpgrades: 0,
                    totalSilentUpgrades: 0,
                    totalForcedUpgrades: 0,
                    totalRollingUpgrades: 0,
                    totalBlueGreenUpgrades: 0,
                    totalRollbacks: 0,
                    successfulRollbacks: 0,
                    failedRollbacks: 0,
                    totalBackups: 0,
                    totalRestores: 0,
                    totalDowntime: 0,
                    avgDowntime: 0,
                    minDowntime: 0,
                    maxDowntime: 0,
                    totalStagingUpgrades: 0,
                    totalCanaryUpgrades: 0,
                    totalApprovals: 0,
                    totalNotifications: 0,
                    totalAlerts: 0,
                    totalMonitors: 0,
                    totalLogs: 0,
                    totalReports: 0,
                    totalMigrations: 0,
                    successfulMigrations: 0,
                    failedMigrations: 0,
                    totalDataMigrations: 0,
                    successfulDataMigrations: 0,
                    failedDataMigrations: 0,
                    totalSchemaMigrations: 0,
                    successfulSchemaMigrations: 0,
                    failedSchemaMigrations: 0,
                    totalFeatureFlags: 0,
                    totalAATests: 0,
                    totalABTests: 0,
                    totalCanaryReleases: 0,
                    totalZeroDowntimeUpgrades: 0
                }
            };

            this.saveUpgradeStats();
        }
    },

    /**
     * 保存升级统计
     */
    saveUpgradeStats: function () {
        localStorage.setItem('upgradeStats', JSON.stringify(this.upgradeStats));
    },

    /**
     * 加载升级缓存
     */
    loadUpgradeCache: function () {
        const savedCache = localStorage.getItem('upgradeCache');
        if (savedCache) {
            try {
                this.upgradeCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载升级缓存失败:', error);
            }
        }

        if (!this.upgradeCache.cache) {
            this.upgradeCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveUpgradeCache();
        }
    },

    /**
     * 保存升级缓存
     */
    saveUpgradeCache: function () {
        localStorage.setItem('upgradeCache', JSON.stringify(this.upgradeCache));
    },

    /**
     * 初始化升级系统
     */
    initUpgradeSystem: function () {
        // 初始化升级队列
        this.upgradeQueue = [];

        // 初始化升级历史
        this.upgradeHistory = [];

        // 初始化回滚历史
        this.rollbackHistory = [];

        // 初始化可用升级
        this.availableUpgrades = [];

        // 初始化功能标志
        this.featureFlags = {};

        // 启动自动升级检查
        if (this.upgradeConfig.useAutoUpgrade) {
            this.startAutoUpgradeCheck();
        }

        // 启动监控
        if (this.upgradeConfig.useMonitoring) {
            this.startMonitoring();
        }
    },

    /**
     * 启动自动升级检查
     */
    startAutoUpgradeCheck: function () {
        setInterval(() => {
            if (this.upgradeConfig.useAutoUpgrade) {
                this.checkForUpgrades();
            }
        }, this.upgradeConfig.upgradeCheckInterval);
    },

    /**
     * 启动监控
     */
    startMonitoring: function () {
        setInterval(() => {
            if (this.upgradeConfig.useMonitoring) {
                this.monitorUpgrade();
            }
        }, this.upgradeConfig.monitoringInterval);
    },

    /**
     * 优化升级
     */
    optimizeUpgrade: function () {
        // 启用增量升级
        if (this.upgradeConfig.useIncrementalUpgrade) {
            this.enableIncrementalUpgrade();
        }

        // 启用Delta升级
        if (this.upgradeConfig.useDeltaUpgrade) {
            this.enableDeltaUpgrade();
        }

        // 启用后台升级
        if (this.upgradeConfig.useBackgroundUpgrade) {
            this.enableBackgroundUpgrade();
        }

        // 启用静默升级
        if (this.upgradeConfig.useSilentUpgrade) {
            this.enableSilentUpgrade();
        }

        // 启用强制升级
        if (this.upgradeConfig.useForcedUpgrade) {
            this.enableForcedUpgrade();
        }

        // 启用滚动升级
        if (this.upgradeConfig.useRollingUpgrade) {
            this.enableRollingUpgrade();
        }

        // 启用蓝绿部署
        if (this.upgradeConfig.useBlueGreenDeployment) {
            this.enableBlueGreenDeployment();
        }

        // 启用版本控制
        if (this.upgradeConfig.useVersioning) {
            this.enableVersioning();
        }

        // 启用通知
        if (this.upgradeConfig.useNotifications) {
            this.enableNotifications();
        }

        // 启用备份
        if (this.upgradeConfig.useBackup) {
            this.enableBackup();
        }

        // 启用验证
        if (this.upgradeConfig.useValidation) {
            this.enableValidation();
        }

        // 启用测试
        if (this.upgradeConfig.useTesting) {
            this.enableTesting();
        }

        // 启用回滚
        if (this.upgradeConfig.useRollback) {
            this.enableRollback();
        }

        // 启用暂存
        if (this.upgradeConfig.useStaging) {
            this.enableStaging();
        }

        // 启用金丝雀
        if (this.upgradeConfig.useCanary) {
            this.enableCanary();
        }

        // 启用批准
        if (this.upgradeConfig.useApproval) {
            this.enableApproval();
        }

        // 启用迁移
        if (this.upgradeConfig.useMigration) {
            this.enableMigration();
        }

        // 启用数据迁移
        if (this.upgradeConfig.useDataMigration) {
            this.enableDataMigration();
        }

        // 启用架构迁移
        if (this.upgradeConfig.useSchemaMigration) {
            this.enableSchemaMigration();
        }

        // 启用功能标志
        if (this.upgradeConfig.useFeatureFlags) {
            this.enableFeatureFlags();
        }

        // 启用AA测试
        if (this.upgradeConfig.useAATesting) {
            this.enableAATesting();
        }

        // 启用AB测试
        if (this.upgradeConfig.useABTesting) {
            this.enableABTesting();
        }

        // 启用金丝雀发布
        if (this.upgradeConfig.useCanaryRelease) {
            this.enableCanaryRelease();
        }

        // 启用零停机
        if (this.upgradeConfig.useZeroDowntime) {
            this.enableZeroDowntime();
        }
    },

    /**
     * 启用增量升级
     */
    enableIncrementalUpgrade: function () {
        // 实现增量升级逻辑
    },

    /**
     * 启用Delta升级
     */
    enableDeltaUpgrade: function () {
        // 实现Delta升级逻辑
    },

    /**
     * 启用后台升级
     */
    enableBackgroundUpgrade: function () {
        // 实现后台升级逻辑
    },

    /**
     * 启用静默升级
     */
    enableSilentUpgrade: function () {
        // 实现静默升级逻辑
    },

    /**
     * 启用强制升级
     */
    enableForcedUpgrade: function () {
        // 实现强制升级逻辑
    },

    /**
     * 启用滚动升级
     */
    enableRollingUpgrade: function () {
        // 实现滚动升级逻辑
    },

    /**
     * 启用蓝绿部署
     */
    enableBlueGreenDeployment: function () {
        // 实现蓝绿部署逻辑
    },

    /**
     * 启用版本控制
     */
    enableVersioning: function () {
        // 实现版本控制逻辑
    },

    /**
     * 启用通知
     */
    enableNotifications: function () {
        // 实现通知逻辑
    },

    /**
     * 启用备份
     */
    enableBackup: function () {
        // 实现备份逻辑
    },

    /**
     * 启用验证
     */
    enableValidation: function () {
        // 实现验证逻辑
    },

    /**
     * 启用测试
     */
    enableTesting: function () {
        // 实现测试逻辑
    },

    /**
     * 启用回滚
     */
    enableRollback: function () {
        // 实现回滚逻辑
    },

    /**
     * 启用暂存
     */
    enableStaging: function () {
        // 实现暂存逻辑
    },

    /**
     * 启用金丝雀
     */
    enableCanary: function () {
        // 实现金丝雀逻辑
    },

    /**
     * 启用批准
     */
    enableApproval: function () {
        // 实现批准逻辑
    },

    /**
     * 启用迁移
     */
    enableMigration: function () {
        // 实现迁移逻辑
    },

    /**
     * 启用数据迁移
     */
    enableDataMigration: function () {
        // 实现数据迁移逻辑
    },

    /**
     * 启用架构迁移
     */
    enableSchemaMigration: function () {
        // 实现架构迁移逻辑
    },

    /**
     * 启用功能标志
     */
    enableFeatureFlags: function () {
        // 实现功能标志逻辑
    },

    /**
     * 启用AA测试
     */
    enableAATesting: function () {
        // 实现AA测试逻辑
    },

    /**
     * 启用AB测试
     */
    enableABTesting: function () {
        // 实现AB测试逻辑
    },

    /**
     * 启用金丝雀发布
     */
    enableCanaryRelease: function () {
        // 实现金丝雀发布逻辑
    },

    /**
     * 启用零停机
     */
    enableZeroDowntime: function () {
        // 实现零停机逻辑
    },

    /**
     * 检查升级
     * @returns {Promise} 升级检查Promise
     */
    checkForUpgrades: function () {
        if (!this.upgradeConfig.enabled) {
            return Promise.reject(new Error('升级已禁用'));
        }

        // 更新统计
        this.upgradeStats.stats.totalUpgradeChecks++;

        this.saveUpgradeStats();

        // 检查是否有可用升级
        if (this.availableUpgrades.length > 0) {
            return Promise.resolve({
                hasUpgrade: true,
                upgrades: this.availableUpgrades
            });
        }

        return Promise.resolve({
            hasUpgrade: false,
            upgrades: []
        });
    },

    /**
     * 创建升级
     * @param {Object} options - 升级选项
     * @returns {Promise} 升级结果Promise
     */
    createUpgrade: function (options) {
        if (!this.upgradeConfig.enabled) {
            return Promise.reject(new Error('升级已禁用'));
        }

        options = options || {};

        const upgrade = {
            id: 'upgrade_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            version: options.version || '1.0.0',
            type: options.type || 'major',
            status: 'pending',
            description: options.description || '',
            changelog: options.changelog || '',
            releaseNotes: options.releaseNotes || '',
            downloadUrl: options.downloadUrl || '',
            checksum: options.checksum || '',
            size: options.size || 0,
            mandatory: options.mandatory || false,
            scheduledFor: options.scheduledFor || null,
            startTime: null,
            endTime: null,
            duration: null,
            result: null,
            error: null,
            approved: false,
            approvedBy: null,
            approvedAt: null,
            validated: false,
            validatedBy: null,
            validatedAt: null,
            tested: false,
            testedBy: null,
            testedAt: null,
            backedUp: false,
            backedUpBy: null,
            backedUpAt: null,
            migrated: false,
            migratedBy: null,
            migratedAt: null,
            dataMigrated: false,
            dataMigratedBy: null,
            dataMigratedAt: null,
            schemaMigrated: false,
            schemaMigratedBy: null,
            schemaMigratedAt: null,
            createdAt: Date.now(),
            updatedAt: Date.now()
        };

        this.upgradeQueue.push(upgrade);

        // 更新统计
        this.upgradeStats.stats.totalUpgrades++;

        this.saveUpgradeStats();

        // 执行升级
        return this.executeUpgrade(upgrade);
    },

    /**
     * 执行升级
     * @param {Object} upgrade - 升级对象
     * @returns {Promise} 升级结果Promise
     */
    executeUpgrade: function (upgrade) {
        upgrade.status = 'downloading';
        upgrade.startTime = Date.now();

        return new Promise((resolve, reject) => {
            try {
                // 备份
                if (this.upgradeConfig.useBackup && this.upgradeConfig.backupBeforeUpgrade) {
                    this.backupUpgrade(upgrade);
                }

                // 下载
                this.downloadUpgrade(upgrade);

                // 验证
                if (this.upgradeConfig.useValidation && this.upgradeConfig.validationRequired) {
                    this.validateUpgrade(upgrade);
                }

                // 测试
                if (this.upgradeConfig.useTesting && this.upgradeConfig.testingRequired) {
                    this.testUpgrade(upgrade);
                }

                // 批准
                if (this.upgradeConfig.useApproval && this.upgradeConfig.approvalRequired) {
                    this.approveUpgrade(upgrade);
                }

                // 迁移
                if (this.upgradeConfig.useMigration) {
                    this.migrateUpgrade(upgrade);
                }

                // 数据迁移
                if (this.upgradeConfig.useDataMigration) {
                    this.dataMigrateUpgrade(upgrade);
                }

                // 架构迁移
                if (this.upgradeConfig.useSchemaMigration) {
                    this.schemaMigrateUpgrade(upgrade);
                }

                // 安装
                this.installUpgrade(upgrade);

                // 通知
                if (this.upgradeConfig.useNotifications) {
                    this.notifyUpgrade(upgrade);
                }

                // 升级成功
                upgrade.status = 'completed';
                upgrade.endTime = Date.now();
                upgrade.duration = upgrade.endTime - upgrade.startTime;
                upgrade.result = { success: true };

                // 更新当前版本
                this.upgradeConfig.currentVersion = upgrade.version;
                this.saveUpgradeConfig();

                // 添加到历史
                this.upgradeHistory.push(upgrade);

                // 更新统计
                this.upgradeStats.stats.successfulUpgrades++;
                this.upgradeStats.stats.installedUpgrades++;
                this.upgradeStats.stats.totalDowntime += upgrade.duration;
                this.upgradeStats.stats.avgDowntime =
                    this.upgradeStats.stats.totalDowntime / this.upgradeStats.stats.successfulUpgrades;
                this.upgradeStats.stats.minDowntime = Math.min(this.upgradeStats.stats.minDowntime, upgrade.duration);
                this.upgradeStats.stats.maxDowntime = Math.max(this.upgradeStats.stats.maxDowntime, upgrade.duration);

                this.saveUpgradeStats();

                resolve(upgrade);
            } catch (error) {
                // 升级失败
                upgrade.status = 'failed';
                upgrade.endTime = Date.now();
                upgrade.duration = upgrade.endTime - upgrade.startTime;
                upgrade.error = error.message;

                // 回滚
                if (this.upgradeConfig.useRollback) {
                    this.rollbackUpgrade(upgrade);
                }

                // 更新统计
                this.upgradeStats.stats.failedUpgrades++;

                this.saveUpgradeStats();

                reject(error);
            }
        });
    },

    /**
     * 备份升级
     * @param {Object} upgrade - 升级对象
     */
    backupUpgrade: function (upgrade) {
        // 实现备份逻辑

        upgrade.backedUp = true;
        upgrade.backedUpAt = Date.now();

        // 更新统计
        this.upgradeStats.stats.totalBackups++;

        this.saveUpgradeStats();
    },

    /**
     * 下载升级
     * @param {Object} upgrade - 升级对象
     */
    downloadUpgrade: function (upgrade) {
        // 实现下载逻辑

        upgrade.status = 'downloaded';

        // 更新统计
        this.upgradeStats.stats.downloadedUpgrades++;

        this.saveUpgradeStats();
    },

    /**
     * 验证升级
     * @param {Object} upgrade - 升级对象
     */
    validateUpgrade: function (upgrade) {
        // 实现验证逻辑

        upgrade.validated = true;
        upgrade.validatedAt = Date.now();
    },

    /**
     * 测试升级
     * @param {Object} upgrade - 升级对象
     */
    testUpgrade: function (upgrade) {
        // 实现测试逻辑

        upgrade.tested = true;
        upgrade.testedAt = Date.now();
    },

    /**
     * 批准升级
     * @param {Object} upgrade - 升级对象
     */
    approveUpgrade: function (upgrade) {
        // 实现批准逻辑

        upgrade.approved = true;
        upgrade.approvedAt = Date.now();

        // 更新统计
        this.upgradeStats.stats.totalApprovals++;

        this.saveUpgradeStats();
    },

    /**
     * 迁移升级
     * @param {Object} upgrade - 升级对象
     */
    migrateUpgrade: function (upgrade) {
        // 实现迁移逻辑

        upgrade.migrated = true;
        upgrade.migratedAt = Date.now();

        // 更新统计
        this.upgradeStats.stats.totalMigrations++;
        this.upgradeStats.stats.successfulMigrations++;

        this.saveUpgradeStats();
    },

    /**
     * 数据迁移升级
     * @param {Object} upgrade - 升级对象
     */
    dataMigrateUpgrade: function (upgrade) {
        // 实现数据迁移逻辑

        upgrade.dataMigrated = true;
        upgrade.dataMigratedAt = Date.now();

        // 更新统计
        this.upgradeStats.stats.totalDataMigrations++;
        this.upgradeStats.stats.successfulDataMigrations++;

        this.saveUpgradeStats();
    },

    /**
     * 架构迁移升级
     * @param {Object} upgrade - 升级对象
     */
    schemaMigrateUpgrade: function (upgrade) {
        // 实现架构迁移逻辑

        upgrade.schemaMigrated = true;
        upgrade.schemaMigratedAt = Date.now();

        // 更新统计
        this.upgradeStats.stats.totalSchemaMigrations++;
        this.upgradeStats.stats.successfulSchemaMigrations++;

        this.saveUpgradeStats();
    },

    /**
     * 安装升级
     * @param {Object} upgrade - 升级对象
     */
    installUpgrade: function (upgrade) {
        // 实现安装逻辑

        upgrade.status = 'installing';
    },

    /**
     * 通知升级
     * @param {Object} upgrade - 升级对象
     */
    notifyUpgrade: function (upgrade) {
        // 实现通知逻辑

        // 更新统计
        this.upgradeStats.stats.totalNotifications++;

        this.saveUpgradeStats();
    },

    /**
     * 回滚升级
     * @param {Object} upgrade - 升级对象
     */
    rollbackUpgrade: function (upgrade) {
        // 实现回滚逻辑

        // 添加到回滚历史
        this.rollbackHistory.push({
            upgradeId: upgrade.id,
            timestamp: Date.now()
        });

        // 更新统计
        this.upgradeStats.stats.totalRollbacks++;
        this.upgradeStats.stats.successfulRollbacks++;

        this.saveUpgradeStats();
    },

    /**
     * 监控升级
     */
    monitorUpgrade: function () {
        // 实现监控逻辑

        // 更新统计
        this.upgradeStats.stats.totalMonitors++;

        this.saveUpgradeStats();
    },

    /**
     * 获取升级统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.upgradeStats.stats;
    },

    /**
     * 设置升级配置
     * @param {Object} config - 配置对象
     */
    setUpgradeConfig: function (config) {
        this.upgradeConfig = { ...this.upgradeConfig, ...config };
        this.saveUpgradeConfig();
    },

    /**
     * 获取升级配置
     * @returns {Object} 配置对象
     */
    getUpgradeConfig: function () {
        return this.upgradeConfig;
    }
};

// 优化：游戏成就优化
const GameAchievementOptimizer = {
    achievementConfig: {},
    achievementStats: {},
    achievementCache: {},

    /**
     * 初始化游戏成就优化
     */
    init: function () {
        this.loadAchievementConfig();
        this.loadAchievementStats();
        this.loadAchievementCache();
        this.initAchievementSystem();
        this.optimizeAchievement();
    },

    /**
     * 加载成就配置
     */
    loadAchievementConfig: function () {
        this.achievementConfig = {
            enabled: true,
            useAutoUnlock: true,
            useNotifications: true,
            notificationChannels: ['in-app'],
            useProgressTracking: true,
            useMilestones: true,
            useRewards: true,
            rewardTypes: ['points', 'badges', 'titles'],
            useLeaderboards: false,
            useSocialSharing: false,
            useAnalytics: false,
            useValidation: true,
            validationRequired: true,
            useTesting: false,
            useVersioning: true,
            versioningStrategy: 'semantic',
            currentVersion: '1.0.0',
            useBackup: true,
            backupBeforeUpdate: true,
            backupRetention: 10,
            useRollback: true,
            maxRollbacks: 5,
            useMonitoring: true,
            monitoringInterval: 60000,
            useLogging: true,
            logLevel: 'info',
            useAlerting: true,
            alertRules: [],
            useReporting: true,
            reportFrequency: 'weekly'
        };

        const customConfig = localStorage.getItem('achievementConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.achievementConfig = { ...this.achievementConfig, ...config };
            } catch (error) {
                console.error('加载成就配置失败:', error);
            }
        }
    },

    /**
     * 保存成就配置
     */
    saveAchievementConfig: function () {
        localStorage.setItem('achievementConfig', JSON.stringify(this.achievementConfig));
    },

    /**
     * 加载成就统计
     */
    loadAchievementStats: function () {
        const savedStats = localStorage.getItem('achievementStats');
        if (savedStats) {
            try {
                this.achievementStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载成就统计失败:', error);
            }
        }

        if (!this.achievementStats.stats) {
            this.achievementStats = {
                stats: {
                    totalAchievements: 0,
                    unlockedAchievements: 0,
                    lockedAchievements: 0,
                    totalUnlocks: 0,
                    totalRewards: 0,
                    totalPoints: 0,
                    totalBadges: 0,
                    totalTitles: 0,
                    totalProgressUpdates: 0,
                    totalMilestones: 0,
                    totalNotifications: 0,
                    totalValidations: 0,
                    totalTests: 0,
                    totalBackups: 0,
                    totalRestores: 0,
                    totalRollbacks: 0,
                    totalAlerts: 0,
                    totalMonitors: 0,
                    totalLogs: 0,
                    totalReports: 0
                }
            };

            this.saveAchievementStats();
        }
    },

    /**
     * 保存成就统计
     */
    saveAchievementStats: function () {
        localStorage.setItem('achievementStats', JSON.stringify(this.achievementStats));
    },

    /**
     * 加载成就缓存
     */
    loadAchievementCache: function () {
        const savedCache = localStorage.getItem('achievementCache');
        if (savedCache) {
            try {
                this.achievementCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载成就缓存失败:', error);
            }
        }

        if (!this.achievementCache.cache) {
            this.achievementCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveAchievementCache();
        }
    },

    /**
     * 保存成就缓存
     */
    saveAchievementCache: function () {
        localStorage.setItem('achievementCache', JSON.stringify(this.achievementCache));
    },

    /**
     * 初始化成就系统
     */
    initAchievementSystem: function () {
        // 初始化成就列表
        this.achievements = {};

        // 初始化成就进度
        this.achievementProgress = {};

        // 初始化里程碑
        this.milestones = {};

        // 初始化奖励
        this.rewards = {};

        // 初始化成就历史
        this.achievementHistory = [];

        // 启动监控
        if (this.achievementConfig.useMonitoring) {
            this.startMonitoring();
        }
    },

    /**
     * 启动监控
     */
    startMonitoring: function () {
        setInterval(() => {
            if (this.achievementConfig.useMonitoring) {
                this.monitorAchievement();
            }
        }, this.achievementConfig.monitoringInterval);
    },

    /**
     * 优化成就
     */
    optimizeAchievement: function () {
        // 启用自动解锁
        if (this.achievementConfig.useAutoUnlock) {
            this.enableAutoUnlock();
        }

        // 启用通知
        if (this.achievementConfig.useNotifications) {
            this.enableNotifications();
        }

        // 启用进度跟踪
        if (this.achievementConfig.useProgressTracking) {
            this.enableProgressTracking();
        }

        // 启用里程碑
        if (this.achievementConfig.useMilestones) {
            this.enableMilestones();
        }

        // 启用奖励
        if (this.achievementConfig.useRewards) {
            this.enableRewards();
        }

        // 启用排行榜
        if (this.achievementConfig.useLeaderboards) {
            this.enableLeaderboards();
        }

        // 启用社交分享
        if (this.achievementConfig.useSocialSharing) {
            this.enableSocialSharing();
        }

        // 启用分析
        if (this.achievementConfig.useAnalytics) {
            this.enableAnalytics();
        }

        // 启用验证
        if (this.achievementConfig.useValidation) {
            this.enableValidation();
        }

        // 启用测试
        if (this.achievementConfig.useTesting) {
            this.enableTesting();
        }
    },

    /**
     * 启用自动解锁
     */
    enableAutoUnlock: function () {
        // 实现自动解锁逻辑
    },

    /**
     * 启用通知
     */
    enableNotifications: function () {
        // 实现通知逻辑
    },

    /**
     * 启用进度跟踪
     */
    enableProgressTracking: function () {
        // 实现进度跟踪逻辑
    },

    /**
     * 启用里程碑
     */
    enableMilestones: function () {
        // 实现里程碑逻辑
    },

    /**
     * 启用奖励
     */
    enableRewards: function () {
        // 实现奖励逻辑
    },

    /**
     * 启用排行榜
     */
    enableLeaderboards: function () {
        // 实现排行榜逻辑
    },

    /**
     * 启用社交分享
     */
    enableSocialSharing: function () {
        // 实现社交分享逻辑
    },

    /**
     * 启用分析
     */
    enableAnalytics: function () {
        // 实现分析逻辑
    },

    /**
     * 启用验证
     */
    enableValidation: function () {
        // 实现验证逻辑
    },

    /**
     * 启用测试
     */
    enableTesting: function () {
        // 实现测试逻辑
    },

    /**
     * 创建成就
     * @param {Object} options - 成就选项
     * @returns {Object} 成就对象
     */
    createAchievement: function (options) {
        if (!this.achievementConfig.enabled) {
            return null;
        }

        const achievement = {
            id: 'achievement_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            name: options.name,
            description: options.description,
            type: options.type || 'progress',
            category: options.category || 'general',
            icon: options.icon || null,
            requirements: options.requirements || {},
            rewards: options.rewards || {},
            progress: 0,
            maxProgress: options.maxProgress || 100,
            unlocked: false,
            unlockedAt: null,
            hidden: options.hidden || false,
            repeatable: options.repeatable || false,
            createdAt: Date.now(),
            updatedAt: Date.now()
        };

        this.achievements[achievement.id] = achievement;

        // 更新统计
        this.achievementStats.stats.totalAchievements++;

        this.saveAchievementStats();

        return achievement;
    },

    /**
     * 解锁成就
     * @param {string} achievementId - 成就ID
     * @returns {boolean} 是否成功
     */
    unlockAchievement: function (achievementId) {
        if (!this.achievementConfig.enabled) {
            return false;
        }

        const achievement = this.achievements[achievementId];

        if (!achievement) {
            return false;
        }

        if (achievement.unlocked && !achievement.repeatable) {
            return false;
        }

        // 验证成就
        if (this.achievementConfig.useValidation && this.achievementConfig.validationRequired) {
            const validationResult = this.validateAchievement(achievement);

            if (!validationResult.valid) {
                return false;
            }
        }

        // 解锁成就
        achievement.unlocked = true;
        achievement.unlockedAt = Date.now();
        achievement.updatedAt = Date.now();

        // 添加到历史
        this.achievementHistory.push({
            achievementId: achievementId,
            unlockedAt: Date.now()
        });

        // 发送通知
        if (this.achievementConfig.useNotifications) {
            this.notifyAchievement(achievement);
        }

        // 发放奖励
        if (this.achievementConfig.useRewards) {
            this.grantRewards(achievement);
        }

        // 更新统计
        this.achievementStats.stats.totalUnlocks++;
        this.achievementStats.stats.unlockedAchievements++;
        this.achievementStats.stats.totalNotifications++;

        this.saveAchievementStats();

        return true;
    },

    /**
     * 更新成就进度
     * @param {string} achievementId - 成就ID
     * @param {number} progress - 进度
     * @returns {boolean} 是否成功
     */
    updateAchievementProgress: function (achievementId, progress) {
        if (!this.achievementConfig.enabled) {
            return false;
        }

        const achievement = this.achievements[achievementId];

        if (!achievement) {
            return false;
        }

        achievement.progress = Math.min(progress, achievement.maxProgress);
        achievement.updatedAt = Date.now();

        // 更新统计
        this.achievementStats.stats.totalProgressUpdates++;

        this.saveAchievementStats();

        // 检查是否完成
        if (achievement.progress >= achievement.maxProgress && !achievement.unlocked) {
            return this.unlockAchievement(achievementId);
        }

        return true;
    },

    /**
     * 验证成就
     * @param {Object} achievement - 成就对象
     * @returns {Object} 验证结果
     */
    validateAchievement: function (achievement) {
        // 实现验证逻辑

        // 更新统计
        this.achievementStats.stats.totalValidations++;

        this.saveAchievementStats();

        return { valid: true };
    },

    /**
     * 通知成就
     * @param {Object} achievement - 成就对象
     */
    notifyAchievement: function (achievement) {
        // 实现通知逻辑
    },

    /**
     * 发放奖励
     * @param {Object} achievement - 成就对象
     */
    grantRewards: function (achievement) {
        // 实现奖励发放逻辑

        // 更新统计
        this.achievementStats.stats.totalRewards++;

        for (const reward of achievement.rewards) {
            if (reward.type === 'points') {
                this.achievementStats.stats.totalPoints += reward.amount;
            } else if (reward.type === 'badges') {
                this.achievementStats.stats.totalBadges++;
            } else if (reward.type === 'titles') {
                this.achievementStats.stats.totalTitles++;
            }
        }

        this.saveAchievementStats();
    },

    /**
     * 监控成就
     */
    monitorAchievement: function () {
        // 实现监控逻辑

        // 更新统计
        this.achievementStats.stats.totalMonitors++;

        this.saveAchievementStats();
    },

    /**
     * 获取成就统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.achievementStats.stats;
    },

    /**
     * 设置成就配置
     * @param {Object} config - 配置对象
     */
    setAchievementConfig: function (config) {
        this.achievementConfig = { ...this.achievementConfig, ...config };
        this.saveAchievementConfig();
    },

    /**
     * 获取成就配置
     * @returns {Object} 配置对象
     */
    getAchievementConfig: function () {
        return this.achievementConfig;
    }
};

// 优化：游戏排行榜优化
const GameLeaderboardOptimizer = {
    leaderboardConfig: {},
    leaderboardStats: {},
    leaderboardCache: {},

    /**
     * 初始化游戏排行榜优化
     */
    init: function () {
        this.loadLeaderboardConfig();
        this.loadLeaderboardStats();
        this.loadLeaderboardCache();
        this.initLeaderboardSystem();
        this.optimizeLeaderboard();
    },

    /**
     * 加载排行榜配置
     */
    loadLeaderboardConfig: function () {
        this.leaderboardConfig = {
            enabled: true,
            useGlobalLeaderboard: true,
            useLocalLeaderboard: true,
            useFriendsLeaderboard: false,
            useWeeklyLeaderboard: false,
            useMonthlyLeaderboard: false,
            useAllTimeLeaderboard: true,
            usePagination: true,
            pageSize: 20,
            maxPageSize: 100,
            useCaching: true,
            cacheSize: 1000,
            cacheTTL: 300000,
            useRealTimeUpdates: false,
            updateInterval: 60000,
            useValidation: true,
            validationRequired: true,
            useAntiCheat: true,
            antiCheatLevel: 'medium',
            useFiltering: true,
            filters: [],
            useSorting: true,
            sortBy: 'score',
            sortOrder: 'desc',
            useRanking: true,
            rankingAlgorithm: 'standard',
            useTieBreaking: true,
            tieBreakingAlgorithm: 'time',
            usePruning: true,
            pruningInterval: 2592000000,
            pruningThreshold: 30,
            useArchiving: true,
            archiveInterval: 7776000000,
            archiveRetention: 365,
            useAnalytics: false,
            analyticsProvider: 'custom',
            useNotifications: false,
            notificationChannels: [],
            useBackup: true,
            backupInterval: 86400000,
            backupRetention: 30,
            useRollback: true,
            maxRollbacks: 5,
            useMonitoring: true,
            monitoringInterval: 60000,
            useLogging: true,
            logLevel: 'warn',
            useAlerting: true,
            alertRules: [],
            useReporting: true,
            reportFrequency: 'weekly'
        };

        const customConfig = localStorage.getItem('leaderboardConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.leaderboardConfig = { ...this.leaderboardConfig, ...config };
            } catch (error) {
                console.error('加载排行榜配置失败:', error);
            }
        }
    },

    /**
     * 保存排行榜配置
     */
    saveLeaderboardConfig: function () {
        localStorage.setItem('leaderboardConfig', JSON.stringify(this.leaderboardConfig));
    },

    /**
     * 加载排行榜统计
     */
    loadLeaderboardStats: function () {
        const savedStats = localStorage.getItem('leaderboardStats');
        if (savedStats) {
            try {
                this.leaderboardStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载排行榜统计失败:', error);
            }
        }

        if (!this.leaderboardStats.stats) {
            this.leaderboardStats = {
                stats: {
                    totalEntries: 0,
                    globalEntries: 0,
                    localEntries: 0,
                    friendsEntries: 0,
                    weeklyEntries: 0,
                    monthlyEntries: 0,
                    allTimeEntries: 0,
                    totalUpdates: 0,
                    totalQueries: 0,
                    totalValidations: 0,
                    successfulValidations: 0,
                    failedValidations: 0,
                    totalAntiCheatChecks: 0,
                    successfulAntiCheatChecks: 0,
                    failedAntiCheatChecks: 0,
                    totalPrunes: 0,
                    totalArchives: 0,
                    totalBackups: 0,
                    totalRestores: 0,
                    totalRollbacks: 0,
                    totalAlerts: 0,
                    totalMonitors: 0,
                    totalLogs: 0,
                    totalReports: 0,
                    cacheHits: 0,
                    cacheMisses: 0,
                    cacheHitRate: 0
                }
            };

            this.saveLeaderboardStats();
        }
    },

    /**
     * 保存排行榜统计
     */
    saveLeaderboardStats: function () {
        localStorage.setItem('leaderboardStats', JSON.stringify(this.leaderboardStats));
    },

    /**
     * 加载排行榜缓存
     */
    loadLeaderboardCache: function () {
        const savedCache = localStorage.getItem('leaderboardCache');
        if (savedCache) {
            try {
                this.leaderboardCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载排行榜缓存失败:', error);
            }
        }

        if (!this.leaderboardCache.cache) {
            this.leaderboardCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveLeaderboardCache();
        }
    },

    /**
     * 保存排行榜缓存
     */
    saveLeaderboardCache: function () {
        localStorage.setItem('leaderboardCache', JSON.stringify(this.leaderboardCache));
    },

    /**
     * 初始化排行榜系统
     */
    initLeaderboardSystem: function () {
        // 初始化排行榜
        this.leaderboards = {
            global: [],
            local: [],
            friends: [],
            weekly: [],
            monthly: [],
            allTime: []
        };

        // 初始化排行榜历史
        this.leaderboardHistory = [];

        // 启动实时更新
        if (this.leaderboardConfig.useRealTimeUpdates) {
            this.startRealTimeUpdates();
        }

        // 启动监控
        if (this.leaderboardConfig.useMonitoring) {
            this.startMonitoring();
        }

        // 启动备份
        if (this.leaderboardConfig.useBackup) {
            this.startBackup();
        }

        // 启动清理
        if (this.leaderboardConfig.usePruning) {
            this.startPruning();
        }

        // 启动归档
        if (this.leaderboardConfig.useArchiving) {
            this.startArchiving();
        }
    },

    /**
     * 启动实时更新
     */
    startRealTimeUpdates: function () {
        setInterval(() => {
            if (this.leaderboardConfig.useRealTimeUpdates) {
                this.updateLeaderboards();
            }
        }, this.leaderboardConfig.updateInterval);
    },

    /**
     * 启动监控
     */
    startMonitoring: function () {
        setInterval(() => {
            if (this.leaderboardConfig.useMonitoring) {
                this.monitorLeaderboard();
            }
        }, this.leaderboardConfig.monitoringInterval);
    },

    /**
     * 启动备份
     */
    startBackup: function () {
        setInterval(() => {
            if (this.leaderboardConfig.useBackup) {
                this.backupLeaderboard();
            }
        }, this.leaderboardConfig.backupInterval);
    },

    /**
     * 启动清理
     */
    startPruning: function () {
        setInterval(() => {
            if (this.leaderboardConfig.usePruning) {
                this.pruneLeaderboard();
            }
        }, this.leaderboardConfig.pruningInterval);
    },

    /**
     * 启动归档
     */
    startArchiving: function () {
        setInterval(() => {
            if (this.leaderboardConfig.useArchiving) {
                this.archiveLeaderboard();
            }
        }, this.leaderboardConfig.archiveInterval);
    },

    /**
     * 优化排行榜
     */
    optimizeLeaderboard: function () {
        // 启用缓存
        if (this.leaderboardConfig.useCaching) {
            this.enableCaching();
        }

        // 启用验证
        if (this.leaderboardConfig.useValidation) {
            this.enableValidation();
        }

        // 启用反作弊
        if (this.leaderboardConfig.useAntiCheat) {
            this.enableAntiCheat();
        }

        // 启用过滤
        if (this.leaderboardConfig.useFiltering) {
            this.enableFiltering();
        }

        // 启用排序
        if (this.leaderboardConfig.useSorting) {
            this.enableSorting();
        }

        // 启用排名
        if (this.leaderboardConfig.useRanking) {
            this.enableRanking();
        }

        // 启用平局决胜
        if (this.leaderboardConfig.useTieBreaking) {
            this.enableTieBreaking();
        }
    },

    /**
     * 启用缓存
     */
    enableCaching: function () {
        // 实现缓存逻辑
    },

    /**
     * 启用验证
     */
    enableValidation: function () {
        // 实现验证逻辑
    },

    /**
     * 启用反作弊
     */
    enableAntiCheat: function () {
        // 实现反作弊逻辑
    },

    /**
     * 启用过滤
     */
    enableFiltering: function () {
        // 实现过滤逻辑
    },

    /**
     * 启用排序
     */
    enableSorting: function () {
        // 实现排序逻辑
    },

    /**
     * 启用排名
     */
    enableRanking: function () {
        // 实现排名逻辑
    },

    /**
     * 启用平局决胜
     */
    enableTieBreaking: function () {
        // 实现平局决胜逻辑
    },

    /**
     * 添加排行榜条目
     * @param {Object} entry - 排行榜条目
     * @returns {boolean} 是否成功
     */
    addEntry: function (entry) {
        if (!this.leaderboardConfig.enabled) {
            return false;
        }

        // 验证条目
        if (this.leaderboardConfig.useValidation && this.leaderboardConfig.validationRequired) {
            const validationResult = this.validateEntry(entry);

            if (!validationResult.valid) {
                return false;
            }
        }

        // 反作弊检查
        if (this.leaderboardConfig.useAntiCheat) {
            const antiCheatResult = this.antiCheatCheck(entry);

            if (!antiCheatResult.valid) {
                return false;
            }
        }

        // 添加到全局排行榜
        if (this.leaderboardConfig.useGlobalLeaderboard) {
            this.leaderboards.global.push(entry);
        }

        // 添加到本地排行榜
        if (this.leaderboardConfig.useLocalLeaderboard) {
            this.leaderboards.local.push(entry);
        }

        // 添加到好友排行榜
        if (this.leaderboardConfig.useFriendsLeaderboard) {
            this.leaderboards.friends.push(entry);
        }

        // 添加到周排行榜
        if (this.leaderboardConfig.useWeeklyLeaderboard) {
            this.leaderboards.weekly.push(entry);
        }

        // 添加到月排行榜
        if (this.leaderboardConfig.useMonthlyLeaderboard) {
            this.leaderboards.monthly.push(entry);
        }

        // 添加到全时排行榜
        if (this.leaderboardConfig.useAllTimeLeaderboard) {
            this.leaderboards.allTime.push(entry);
        }

        // 更新统计
        this.leaderboardStats.stats.totalEntries++;

        this.saveLeaderboardStats();

        // 更新排行榜
        this.updateLeaderboards();

        return true;
    },

    /**
     * 获取排行榜
     * @param {string} type - 类型
     * @param {Object} options - 选项
     * @returns {Array} 排行榜
     */
    getLeaderboard: function (type, options) {
        if (!this.leaderboardConfig.enabled) {
            return [];
        }

        options = options || {};

        // 检查缓存
        if (this.leaderboardConfig.useCaching) {
            const cached = this.getCachedLeaderboard(type, options);

            if (cached) {
                return cached;
            }
        }

        // 获取排行榜
        let leaderboard = this.leaderboards[type] || [];

        // 过滤
        if (this.leaderboardConfig.useFiltering) {
            leaderboard = this.filterLeaderboard(leaderboard, options);
        }

        // 排序
        if (this.leaderboardConfig.useSorting) {
            leaderboard = this.sortLeaderboard(leaderboard, options);
        }

        // 排名
        if (this.leaderboardConfig.useRanking) {
            leaderboard = this.rankLeaderboard(leaderboard, options);
        }

        // 分页
        if (this.leaderboardConfig.usePagination) {
            leaderboard = this.paginateLeaderboard(leaderboard, options);
        }

        // 缓存排行榜
        if (this.leaderboardConfig.useCaching) {
            this.cacheLeaderboard(type, options, leaderboard);
        }

        // 更新统计
        this.leaderboardStats.stats.totalQueries++;

        this.saveLeaderboardStats();

        return leaderboard;
    },

    /**
     * 验证条目
     * @param {Object} entry - 条目
     * @returns {Object} 验证结果
     */
    validateEntry: function (entry) {
        // 实现验证逻辑

        // 更新统计
        this.leaderboardStats.stats.totalValidations++;
        this.leaderboardStats.stats.successfulValidations++;

        this.saveLeaderboardStats();

        return { valid: true };
    },

    /**
     * 反作弊检查
     * @param {Object} entry - 条目
     * @returns {Object} 反作弊结果
     */
    antiCheatCheck: function (entry) {
        // 实现反作弊检查逻辑

        // 更新统计
        this.leaderboardStats.stats.totalAntiCheatChecks++;
        this.leaderboardStats.stats.successfulAntiCheatChecks++;

        this.saveLeaderboardStats();

        return { valid: true };
    },

    /**
     * 过滤排行榜
     * @param {Array} leaderboard - 排行榜
     * @param {Object} options - 选项
     * @returns {Array} 过滤后的排行榜
     */
    filterLeaderboard: function (leaderboard, options) {
        // 实现过滤逻辑
        return leaderboard;
    },

    /**
     * 排序排行榜
     * @param {Array} leaderboard - 排行榜
     * @param {Object} options - 选项
     * @returns {Array} 排序后的排行榜
     */
    sortLeaderboard: function (leaderboard, options) {
        const sortBy = options.sortBy || this.leaderboardConfig.sortBy;
        const sortOrder = options.sortOrder || this.leaderboardConfig.sortOrder;

        return leaderboard.sort((a, b) => {
            if (sortOrder === 'asc') {
                return a[sortBy] - b[sortBy];
            } else {
                return b[sortBy] - a[sortBy];
            }
        });
    },

    /**
     * 排名排行榜
     * @param {Array} leaderboard - 排行榜
     * @param {Object} options - 选项
     * @returns {Array} 排名后的排行榜
     */
    rankLeaderboard: function (leaderboard, options) {
        // 实现排名逻辑
        return leaderboard.map((entry, index) => ({
            ...entry,
            rank: index + 1
        }));
    },

    /**
     * 分页排行榜
     * @param {Array} leaderboard - 排行榜
     * @param {Object} options - 选项
     * @returns {Array} 分页后的排行榜
     */
    paginateLeaderboard: function (leaderboard, options) {
        const page = options.page || 1;
        const pageSize = options.pageSize || this.leaderboardConfig.pageSize;

        const startIndex = (page - 1) * pageSize;
        const endIndex = startIndex + pageSize;

        return leaderboard.slice(startIndex, endIndex);
    },

    /**
     * 更新排行榜
     */
    updateLeaderboards: function () {
        // 实现更新逻辑

        // 更新统计
        this.leaderboardStats.stats.totalUpdates++;

        this.saveLeaderboardStats();
    },

    /**
     * 缓存排行榜
     * @param {string} type - 类型
     * @param {Object} options - 选项
     * @param {Array} leaderboard - 排行榜
     */
    cacheLeaderboard: function (type, options, leaderboard) {
        const cacheKey = this.getLeaderboardCacheKey(type, options);

        this.leaderboardCache.cache[cacheKey] = {
            leaderboard: leaderboard,
            timestamp: Date.now()
        };

        this.leaderboardCache.stats.size = Object.keys(this.leaderboardCache.cache).length;
        this.saveLeaderboardCache();
    },

    /**
     * 获取缓存排行榜
     * @param {string} type - 类型
     * @param {Object} options - 选项
     * @returns {Array|null} 排行榜
     */
    getCachedLeaderboard: function (type, options) {
        const cacheKey = this.getLeaderboardCacheKey(type, options);
        const cached = this.leaderboardCache.cache[cacheKey];

        if (cached) {
            // 检查是否过期
            const age = Date.now() - cached.timestamp;

            if (age < this.leaderboardConfig.cacheTTL) {
                this.leaderboardCache.stats.hits++;
                this.leaderboardStats.stats.cacheHits++;
            } else {
                delete this.leaderboardCache.cache[cacheKey];
                this.leaderboardCache.stats.size = Object.keys(this.leaderboardCache.cache).length;
                this.leaderboardCache.stats.misses++;
                this.leaderboardStats.stats.cacheMisses++;
            }
        } else {
            this.leaderboardCache.stats.misses++;
            this.leaderboardStats.stats.cacheMisses++;
        }

        // 更新缓存命中率
        const total = this.leaderboardCache.stats.hits + this.leaderboardCache.stats.misses;
        this.leaderboardCache.stats.hitRate = total > 0 ? (this.leaderboardCache.stats.hits / total) * 100 : 0;
        this.leaderboardStats.stats.cacheHitRate = this.leaderboardCache.stats.hitRate;

        this.saveLeaderboardCache();
        this.saveLeaderboardStats();

        return cached ? cached.leaderboard : null;
    },

    /**
     * 获取排行榜缓存键
     * @param {string} type - 类型
     * @param {Object} options - 选项
     * @returns {string} 缓存键
     */
    getLeaderboardCacheKey: function (type, options) {
        return type + JSON.stringify(options);
    },

    /**
     * 清理排行榜
     */
    pruneLeaderboard: function () {
        // 实现清理逻辑

        // 更新统计
        this.leaderboardStats.stats.totalPrunes++;

        this.saveLeaderboardStats();
    },

    /**
     * 归档排行榜
     */
    archiveLeaderboard: function () {
        // 实现归档逻辑

        // 更新统计
        this.leaderboardStats.stats.totalArchives++;

        this.saveLeaderboardStats();
    },

    /**
     * 备份排行榜
     */
    backupLeaderboard: function () {
        // 实现备份逻辑

        // 更新统计
        this.leaderboardStats.stats.totalBackups++;

        this.saveLeaderboardStats();
    },

    /**
     * 监控排行榜
     */
    monitorLeaderboard: function () {
        // 实现监控逻辑

        // 更新统计
        this.leaderboardStats.stats.totalMonitors++;

        this.saveLeaderboardStats();
    },

    /**
     * 获取排行榜统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.leaderboardStats.stats;
    },

    /**
     * 设置排行榜配置
     * @param {Object} config - 配置对象
     */
    setLeaderboardConfig: function (config) {
        this.leaderboardConfig = { ...this.leaderboardConfig, ...config };
        this.saveLeaderboardConfig();
    },

    /**
     * 获取排行榜配置
     * @returns {Object} 配置对象
     */
    getLeaderboardConfig: function () {
        return this.leaderboardConfig;
    }
};

// 优化：游戏社交优化
const GameSocialOptimizer = {
    socialConfig: {},
    socialStats: {},
    socialCache: {},

    /**
     * 初始化游戏社交优化
     */
    init: function () {
        this.loadSocialConfig();
        this.loadSocialStats();
        this.loadSocialCache();
        this.initSocialSystem();
        this.optimizeSocial();
    },

    /**
     * 加载社交配置
     */
    loadSocialConfig: function () {
        this.socialConfig = {
            enabled: true,
            useFriends: true,
            maxFriends: 1000,
            useFriendRequests: true,
            maxFriendRequests: 100,
            useFriendGroups: false,
            maxFriendGroups: 10,
            useChat: false,
            maxChatHistory: 100,
            useVoiceChat: false,
            useVideoChat: false,
            useMessaging: false,
            maxMessageHistory: 1000,
            useNotifications: true,
            notificationChannels: ['in-app'],
            usePrivacy: true,
            privacyLevels: ['public', 'friends', 'private'],
            useBlocking: true,
            useReporting: true,
            reportingCategories: ['harassment', 'spam', 'cheating', 'other'],
            useSharing: true,
            shareTypes: ['achievement', 'score', 'screenshot'],
            useGifts: false,
            giftTypes: ['points', 'items'],
            useEvents: false,
            eventTypes: ['tournament', 'challenge'],
            useClans: false,
            maxClans: 100,
            useClanChat: false,
            useClanWars: false,
            useLeaderboards: true,
            useSocialGraph: false,
            useRecommendations: false,
            recommendationAlgorithm: 'collaborative',
            useAnalytics: false,
            analyticsProvider: 'custom',
            useModeration: true,
            moderationLevel: 'medium',
            useAutoModeration: false,
            autoModerationRules: [],
            useBackup: true,
            backupInterval: 86400000,
            backupRetention: 30,
            useRollback: true,
            maxRollbacks: 5,
            useMonitoring: true,
            monitoringInterval: 60000,
            useLogging: true,
            logLevel: 'warn',
            useAlerting: true,
            alertRules: [],
            useReporting: true,
            reportFrequency: 'weekly'
        };

        const customConfig = localStorage.getItem('socialConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.socialConfig = { ...this.socialConfig, ...config };
            } catch (error) {
                console.error('加载社交配置失败:', error);
            }
        }
    },

    /**
     * 保存社交配置
     */
    saveSocialConfig: function () {
        localStorage.setItem('socialConfig', JSON.stringify(this.socialConfig));
    },

    /**
     * 加载社交统计
     */
    loadSocialStats: function () {
        const savedStats = localStorage.getItem('socialStats');
        if (savedStats) {
            try {
                this.socialStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载社交统计失败:', error);
            }
        }

        if (!this.socialStats.stats) {
            this.socialStats = {
                stats: {
                    totalFriends: 0,
                    totalFriendRequests: 0,
                    pendingFriendRequests: 0,
                    acceptedFriendRequests: 0,
                    rejectedFriendRequests: 0,
                    totalFriendGroups: 0,
                    totalMessages: 0,
                    sentMessages: 0,
                    receivedMessages: 0,
                    totalChats: 0,
                    totalVoiceChats: 0,
                    totalVideoChats: 0,
                    totalShares: 0,
                    totalGifts: 0,
                    sentGifts: 0,
                    receivedGifts: 0,
                    totalEvents: 0,
                    totalClans: 0,
                    totalClanMembers: 0,
                    totalClanWars: 0,
                    totalBlocks: 0,
                    totalReports: 0,
                    totalModerations: 0,
                    totalValidations: 0,
                    totalBackups: 0,
                    totalRestores: 0,
                    totalRollbacks: 0,
                    totalAlerts: 0,
                    totalMonitors: 0,
                    totalLogs: 0,
                    totalReports: 0
                }
            };

            this.saveSocialStats();
        }
    },

    /**
     * 保存社交统计
     */
    saveSocialStats: function () {
        localStorage.setItem('socialStats', JSON.stringify(this.socialStats));
    },

    /**
     * 加载社交缓存
     */
    loadSocialCache: function () {
        const savedCache = localStorage.getItem('socialCache');
        if (savedCache) {
            try {
                this.socialCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载社交缓存失败:', error);
            }
        }

        if (!this.socialCache.cache) {
            this.socialCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveSocialCache();
        }
    },

    /**
     * 保存社交缓存
     */
    saveSocialCache: function () {
        localStorage.setItem('socialCache', JSON.stringify(this.socialCache));
    },

    /**
     * 初始化社交系统
     */
    initSocialSystem: function () {
        // 初始化好友
        this.friends = {};

        // 初始化好友请求
        this.friendRequests = {};

        // 初始化好友组
        this.friendGroups = {};

        // 初始化聊天
        this.chats = {};

        // 初始化消息
        this.messages = {};

        // 初始化屏蔽
        this.blocks = {};

        // 初始化举报
        this.reports = {};

        // 初始化分享
        this.shares = {};

        // 初始化礼物
        this.gifts = {};

        // 初始化事件
        this.events = {};

        // 初始化公会
        this.clans = {};

        // 启动监控
        if (this.socialConfig.useMonitoring) {
            this.startMonitoring();
        }

        // 启动备份
        if (this.socialConfig.useBackup) {
            this.startBackup();
        }
    },

    /**
     * 启动监控
     */
    startMonitoring: function () {
        setInterval(() => {
            if (this.socialConfig.useMonitoring) {
                this.monitorSocial();
            }
        }, this.socialConfig.monitoringInterval);
    },

    /**
     * 启动备份
     */
    startBackup: function () {
        setInterval(() => {
            if (this.socialConfig.useBackup) {
                this.backupSocial();
            }
        }, this.socialConfig.backupInterval);
    },

    /**
     * 优化社交
     */
    optimizeSocial: function () {
        // 启用隐私
        if (this.socialConfig.usePrivacy) {
            this.enablePrivacy();
        }

        // 启用屏蔽
        if (this.socialConfig.useBlocking) {
            this.enableBlocking();
        }

        // 启用举报
        if (this.socialConfig.useReporting) {
            this.enableReporting();
        }

        // 启用分享
        if (this.socialConfig.useSharing) {
            this.enableSharing();
        }

        // 启用礼物
        if (this.socialConfig.useGifts) {
            this.enableGifts();
        }

        // 启用事件
        if (this.socialConfig.useEvents) {
            this.enableEvents();
        }

        // 启用公会
        if (this.socialConfig.useClans) {
            this.enableClans();
        }

        // 启用排行榜
        if (this.socialConfig.useLeaderboards) {
            this.enableLeaderboards();
        }

        // 启用社交图谱
        if (this.socialConfig.useSocialGraph) {
            this.enableSocialGraph();
        }

        // 启用推荐
        if (this.socialConfig.useRecommendations) {
            this.enableRecommendations();
        }

        // 启用审核
        if (this.socialConfig.useModeration) {
            this.enableModeration();
        }

        // 启用自动审核
        if (this.socialConfig.useAutoModeration) {
            this.enableAutoModeration();
        }
    },

    /**
     * 启用隐私
     */
    enablePrivacy: function () {
        // 实现隐私逻辑
    },

    /**
     * 启用屏蔽
     */
    enableBlocking: function () {
        // 实现屏蔽逻辑
    },

    /**
     * 启用举报
     */
    enableReporting: function () {
        // 实现举报逻辑
    },

    /**
     * 启用分享
     */
    enableSharing: function () {
        // 实现分享逻辑
    },

    /**
     * 启用礼物
     */
    enableGifts: function () {
        // 实现礼物逻辑
    },

    /**
     * 启用事件
     */
    enableEvents: function () {
        // 实现事件逻辑
    },

    /**
     * 启用公会
     */
    enableClans: function () {
        // 实现公会逻辑
    },

    /**
     * 启用排行榜
     */
    enableLeaderboards: function () {
        // 实现排行榜逻辑
    },

    /**
     * 启用社交图谱
     */
    enableSocialGraph: function () {
        // 实现社交图谱逻辑
    },

    /**
     * 启用推荐
     */
    enableRecommendations: function () {
        // 实现推荐逻辑
    },

    /**
     * 启用审核
     */
    enableModeration: function () {
        // 实现审核逻辑
    },

    /**
     * 启用自动审核
     */
    enableAutoModeration: function () {
        // 实现自动审核逻辑
    },

    /**
     * 添加好友
     * @param {string} userId - 用户ID
     * @returns {boolean} 是否成功
     */
    addFriend: function (userId) {
        if (!this.socialConfig.enabled) {
            return false;
        }

        // 检查好友数量
        if (Object.keys(this.friends).length >= this.socialConfig.maxFriends) {
            return false;
        }

        // 检查是否已经是好友
        if (this.friends[userId]) {
            return false;
        }

        // 添加好友
        this.friends[userId] = {
            userId: userId,
            addedAt: Date.now(),
            status: 'active'
        };

        // 更新统计
        this.socialStats.stats.totalFriends++;

        this.saveSocialStats();

        return true;
    },

    /**
     * 移除好友
     * @param {string} userId - 用户ID
     * @returns {boolean} 是否成功
     */
    removeFriend: function (userId) {
        if (!this.friends[userId]) {
            return false;
        }

        delete this.friends[userId];

        // 更新统计
        this.socialStats.stats.totalFriends--;

        this.saveSocialStats();

        return true;
    },

    /**
     * 发送好友请求
     * @param {string} userId - 用户ID
     * @returns {boolean} 是否成功
     */
    sendFriendRequest: function (userId) {
        if (!this.socialConfig.enabled) {
            return false;
        }

        // 检查好友请求数量
        if (Object.keys(this.friendRequests).length >= this.socialConfig.maxFriendRequests) {
            return false;
        }

        // 检查是否已经发送过请求
        if (this.friendRequests[userId]) {
            return false;
        }

        // 发送好友请求
        this.friendRequests[userId] = {
            userId: userId,
            sentAt: Date.now(),
            status: 'pending'
        };

        // 更新统计
        this.socialStats.stats.totalFriendRequests++;
        this.socialStats.stats.pendingFriendRequests++;

        this.saveSocialStats();

        return true;
    },

    /**
     * 接受好友请求
     * @param {string} userId - 用户ID
     * @returns {boolean} 是否成功
     */
    acceptFriendRequest: function (userId) {
        if (!this.friendRequests[userId]) {
            return false;
        }

        // 添加好友
        this.addFriend(userId);

        // 更新请求状态
        this.friendRequests[userId].status = 'accepted';
        this.friendRequests[userId].acceptedAt = Date.now();

        // 更新统计
        this.socialStats.stats.pendingFriendRequests--;
        this.socialStats.stats.acceptedFriendRequests++;

        this.saveSocialStats();

        return true;
    },

    /**
     * 拒绝好友请求
     * @param {string} userId - 用户ID
     * @returns {boolean} 是否成功
     */
    rejectFriendRequest: function (userId) {
        if (!this.friendRequests[userId]) {
            return false;
        }

        // 更新请求状态
        this.friendRequests[userId].status = 'rejected';
        this.friendRequests[userId].rejectedAt = Date.now();

        // 更新统计
        this.socialStats.stats.pendingFriendRequests--;
        this.socialStats.stats.rejectedFriendRequests++;

        this.saveSocialStats();

        return true;
    },

    /**
     * 发送消息
     * @param {string} userId - 用户ID
     * @param {string} message - 消息
     * @returns {boolean} 是否成功
     */
    sendMessage: function (userId, message) {
        if (!this.socialConfig.enabled) {
            return false;
        }

        // 检查是否是好友
        if (!this.friends[userId]) {
            return false;
        }

        // 创建消息
        const messageId = 'message_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        this.messages[messageId] = {
            id: messageId,
            from: 'me',
            to: userId,
            message: message,
            timestamp: Date.now(),
            status: 'sent'
        };

        // 更新统计
        this.socialStats.stats.totalMessages++;
        this.socialStats.stats.sentMessages++;

        this.saveSocialStats();

        return true;
    },

    /**
     * 接收消息
     * @param {string} userId - 用户ID
     * @param {string} message - 消息
     * @returns {boolean} 是否成功
     */
    receiveMessage: function (userId, message) {
        if (!this.socialConfig.enabled) {
            return false;
        }

        // 创建消息
        const messageId = 'message_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        this.messages[messageId] = {
            id: messageId,
            from: userId,
            to: 'me',
            message: message,
            timestamp: Date.now(),
            status: 'received'
        };

        // 更新统计
        this.socialStats.stats.totalMessages++;
        this.socialStats.stats.receivedMessages++;

        this.saveSocialStats();

        return true;
    },

    /**
     * 屏蔽用户
     * @param {string} userId - 用户ID
     * @returns {boolean} 是否成功
     */
    blockUser: function (userId) {
        if (!this.socialConfig.enabled) {
            return false;
        }

        this.blocks[userId] = {
            userId: userId,
            blockedAt: Date.now,
            reason: 'user_blocked'
        };

        // 更新统计
        this.socialStats.stats.totalBlocks++;

        this.saveSocialStats();

        return true;
    },

    /**
     * 解除屏蔽
     * @param {string} userId - 用户ID
     * @returns {boolean} 是否成功
     */
    unblockUser: function (userId) {
        if (!this.blocks[userId]) {
            return false;
        }

        delete this.blocks[userId];

        // 更新统计
        this.socialStats.stats.totalBlocks--;

        this.saveSocialStats();

        return true;
    },

    /**
     * 举报用户
     * @param {string} userId - 用户ID
     * @param {string} category - 类别
     * @param {string} reason - 原因
     * @returns {boolean} 是否成功
     */
    reportUser: function (userId, category, reason) {
        if (!this.socialConfig.enabled) {
            return false;
        }

        const reportId = 'report_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        this.reports[reportId] = {
            id: reportId,
            userId: userId,
            category: category,
            reason: reason,
            status: 'pending',
            reportedAt: Date.now(),
            reviewedAt: null,
            reviewedBy: null,
            action: null
        };

        // 更新统计
        this.socialStats.stats.totalReports++;

        this.saveSocialStats();

        return true;
    },

    /**
     * 分享内容
     * @param {string} type - 类型
     * @param {Object} data - 数据
     * @returns {boolean} 是否成功
     */
    shareContent: function (type, data) {
        if (!this.socialConfig.enabled) {
            return false;
        }

        if (!this.socialConfig.shareTypes.includes(type)) {
            return false;
        }

        const shareId = 'share_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        this.shares[shareId] = {
            id: shareId,
            type: type,
            data: data,
            sharedAt: Date.now(),
            status: 'shared'
        };

        // 更新统计
        this.socialStats.stats.totalShares++;

        this.saveSocialStats();

        return true;
    },

    /**
     * 发送礼物
     * @param {string} userId - 用户ID
     * @param {string} giftType - 礼物类型
     * @param {Object} giftData - 礼物数据
     * @returns {boolean} 是否成功
     */
    sendGift: function (userId, giftType, giftData) {
        if (!this.socialConfig.enabled) {
            return false;
        }

        if (!this.socialConfig.giftTypes.includes(giftType)) {
            return false;
        }

        const giftId = 'gift_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        this.gifts[giftId] = {
            id: giftId,
            from: 'me',
            to: userId,
            type: giftType,
            data: giftData,
            sentAt: Date.now(),
            status: 'sent'
        };

        // 更新统计
        this.socialStats.stats.totalGifts++;
        this.socialStats.stats.sentGifts++;

        this.saveSocialStats();

        return true;
    },

    /**
     * 接收礼物
     * @param {string} userId - 用户ID
     * @param {string} giftType - 礼物类型
     * @param {Object} giftData - 礼物数据
     * @returns {boolean} 是否成功
     */
    receiveGift: function (userId, giftType, giftData) {
        if (!this.socialConfig.enabled) {
            return false;
        }

        const giftId = 'gift_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        this.gifts[giftId] = {
            id: giftId,
            from: userId,
            to: 'me',
            type: giftType,
            data: giftData,
            receivedAt: Date.now(),
            status: 'received'
        };

        // 更新统计
        this.socialStats.stats.totalGifts++;
        this.socialStats.stats.receivedGifts++;

        this.saveSocialStats();

        return true;
    },

    /**
     * 监控社交
     */
    monitorSocial: function () {
        // 实现监控逻辑

        // 更新统计
        this.socialStats.stats.totalMonitors++;

        this.saveSocialStats();
    },

    /**
     * 备份社交
     */
    backupSocial: function () {
        // 实现备份逻辑

        // 更新统计
        this.socialStats.stats.totalBackups++;

        this.saveSocialStats();
    },

    /**
     * 获取社交统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.socialStats.stats;
    },

    /**
     * 设置社交配置
     * @param {Object} config - 配置对象
     */
    setSocialConfig: function (config) {
        this.socialConfig = { ...this.socialConfig, ...config };
        this.saveSocialConfig();
    },

    /**
     * 获取社交配置
     * @returns {Object} 配置对象
     */
    getSocialConfig: function () {
        return this.socialConfig;
    }
};

// 优化：游戏通知优化
const GameNotificationOptimizer = {
    notificationConfig: {},
    notificationStats: {},
    notificationCache: {},

    /**
     * 初始化游戏通知优化
     */
    init: function () {
        this.loadNotificationConfig();
        this.loadNotificationStats();
        this.loadNotificationCache();
        this.initNotificationSystem();
        this.optimizeNotification();
    },

    /**
     * 加载通知配置
     */
    loadNotificationConfig: function () {
        this.notificationConfig = {
            enabled: true,
            useInAppNotifications: true,
            usePushNotifications: false,
            useEmailNotifications: false,
            useSMSNotifications: false,
            useWebhookNotifications: false,
            useBrowserNotifications: true,
            useSoundNotifications: true,
            useVibrationNotifications: false,
            useBadgeNotifications: false,
            useToastNotifications: true,
            useModalNotifications: false,
            usePopupNotifications: false,
            useBannerNotifications: false,
            useNotificationQueue: true,
            maxQueueSize: 100,
            queueFlushInterval: 1000,
            useNotificationHistory: true,
            maxHistorySize: 1000,
            useNotificationFiltering: true,
            filters: [],
            useNotificationPrioritization: true,
            priorityLevels: ['low', 'medium', 'high', 'urgent'],
            useNotificationGrouping: true,
            groupingInterval: 5000,
            useNotificationThrottling: true,
            throttleInterval: 1000,
            useNotificationBatching: false,
            batchSize: 10,
            useNotificationScheduling: true,
            schedulingInterval: 60000,
            useNotificationPersistence: true,
            persistenceDuration: 86400000,
            useNotificationAnalytics: false,
            analyticsProvider: 'custom',
            useNotificationTesting: false,
            useNotificationValidation: true,
            validationRequired: true,
            useBackup: true,
            backupInterval: 86400000,
            backupRetention: 30,
            useRollback: true,
            maxRollbacks: 5,
            useMonitoring: true,
            monitoringInterval: 60000,
            useLogging: true,
            logLevel: 'warn',
            useAlerting: true,
            alertRules: [],
            useReporting: true,
            reportFrequency: 'weekly'
        };

        const customConfig = localStorage.getItem('notificationConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.notificationConfig = { ...this.notificationConfig, ...config };
            } catch (error) {
                console.error('加载通知配置失败:', error);
            }
        }
    },

    /**
     * 保存通知配置
     */
    saveNotificationConfig: function () {
        localStorage.setItem('notificationConfig', JSON.stringify(this.notificationConfig));
    },

    /**
     * 加载通知统计
     */
    loadNotificationStats: function () {
        const savedStats = localStorage.getItem('notificationStats');
        if (savedStats) {
            try {
                this.notificationStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载通知统计失败:', error);
            }
        }

        if (!this.notificationStats.stats) {
            this.notificationStats = {
                stats: {
                    totalNotifications: 0,
                    inAppNotifications: 0,
                    pushNotifications: 0,
                    emailNotifications: 0,
                    smsNotifications: 0,
                    webhookNotifications: 0,
                    browserNotifications: 0,
                    soundNotifications: 0,
                    vibrationNotifications: 0,
                    badgeNotifications: 0,
                    toastNotifications: 0,
                    modalNotifications: 0,
                    popupNotifications: 0,
                    bannerNotifications: 0,
                    sentNotifications: 0,
                    deliveredNotifications: 0,
                    readNotifications: 0,
                    clickedNotifications: 0,
                    dismissedNotifications: 0,
                    expiredNotifications: 0,
                    totalQueueFlushes: 0,
                    totalGroupings: 0,
                    totalThrottles: 0,
                    totalBatches: 0,
                    totalSchedules: 0,
                    totalValidations: 0,
                    successfulValidations: 0,
                    failedValidations: 0,
                    totalBackups: 0,
                    totalRestores: 0,
                    totalRollbacks: 0,
                    totalAlerts: 0,
                    totalMonitors: 0,
                    totalLogs: 0,
                    totalReports: 0
                }
            };

            this.saveNotificationStats();
        }
    },

    /**
     * 保存通知统计
     */
    saveNotificationStats: function () {
        localStorage.setItem('notificationStats', JSON.stringify(this.notificationStats));
    },

    /**
     * 加载通知缓存
     */
    loadNotificationCache: function () {
        const savedCache = localStorage.getItem('notificationCache');
        if (savedCache) {
            try {
                this.notificationCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载通知缓存失败:', error);
            }
        }

        if (!this.notificationCache.cache) {
            this.notificationCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveNotificationCache();
        }
    },

    /**
     * 保存通知缓存
     */
    saveNotificationCache: function () {
        localStorage.setItem('notificationCache', JSON.stringify(this.notificationCache));
    },

    /**
     * 初始化通知系统
     */
    initNotificationSystem: function () {
        // 初始化通知队列
        this.notificationQueue = [];

        // 初始化通知历史
        this.notificationHistory = [];

        // 初始化通知组
        this.notificationGroups = {};

        // 初始化浏览器通知权限
        this.browserNotificationPermission = 'default';

        // 请求浏览器通知权限
        if (this.notificationConfig.useBrowserNotifications) {
            this.requestBrowserNotificationPermission();
        }

        // 启动队列刷新
        if (this.notificationConfig.useNotificationQueue) {
            this.startQueueFlush();
        }

        // 启动分组
        if (this.notificationConfig.useNotificationGrouping) {
            this.startGrouping();
        }

        // 启动调度
        if (this.notificationConfig.useNotificationScheduling) {
            this.startScheduling();
        }

        // 启动监控
        if (this.notificationConfig.useMonitoring) {
            this.startMonitoring();
        }

        // 启动备份
        if (this.notificationConfig.useBackup) {
            this.startBackup();
        }
    },

    /**
     * 请求浏览器通知权限
     */
    requestBrowserNotificationPermission: function () {
        if ('Notification' in window) {
            Notification.requestPermission().then(permission => {
                this.browserNotificationPermission = permission;
            });
        }
    },

    /**
     * 启动队列刷新
     */
    startQueueFlush: function () {
        setInterval(() => {
            if (this.notificationConfig.useNotificationQueue) {
                this.flushNotificationQueue();
            }
        }, this.notificationConfig.queueFlushInterval);
    },

    /**
     * 启动分组
     */
    startGrouping: function () {
        setInterval(() => {
            if (this.notificationConfig.useNotificationGrouping) {
                this.groupNotifications();
            }
        }, this.notificationConfig.groupingInterval);
    },

    /**
     * 启动调度
     */
    startScheduling: function () {
        setInterval(() => {
            if (this.notificationConfig.useNotificationScheduling) {
                this.scheduleNotifications();
            }
        }, this.notificationConfig.schedulingInterval);
    },

    /**
     * 启动监控
     */
    startMonitoring: function () {
        setInterval(() => {
            if (this.notificationConfig.useMonitoring) {
                this.monitorNotification();
            }
        }, this.notificationConfig.monitoringInterval);
    },

    /**
     * 启动备份
     */
    startBackup: function () {
        setInterval(() => {
            if (this.notificationConfig.useBackup) {
                this.backupNotification();
            }
        }, this.notificationConfig.backupInterval);
    },

    /**
     * 优化通知
     */
    optimizeNotification: function () {
        // 启用应用内通知
        if (this.notificationConfig.useInAppNotifications) {
            this.enableInAppNotifications();
        }

        // 启用推送通知
        if (this.notificationConfig.usePushNotifications) {
            this.enablePushNotifications();
        }

        // 启用邮件通知
        if (this.notificationConfig.useEmailNotifications) {
            this.enableEmailNotifications();
        }

        // 启用短信通知
        if (this.notificationConfig.useSMSNotifications) {
            this.enableSMSNotifications();
        }

        // 启用Webhook通知
        if (this.notificationConfig.useWebhookNotifications) {
            this.enableWebhookNotifications();
        }

        // 启用浏览器通知
        if (this.notificationConfig.useBrowserNotifications) {
            this.enableBrowserNotifications();
        }

        // 启用声音通知
        if (this.notificationConfig.useSoundNotifications) {
            this.enableSoundNotifications();
        }

        // 启用振动通知
        if (this.notificationConfig.useVibrationNotifications) {
            this.enableVibrationNotifications();
        }

        // 启用徽章通知
        if (this.notificationConfig.useBadgeNotifications) {
            this.enableBadgeNotifications();
        }

        // 启用Toast通知
        if (this.notificationConfig.useToastNotifications) {
            this.enableToastNotifications();
        }

        // 启用模态框通知
        if (this.notificationConfig.useModalNotifications) {
            this.enableModalNotifications();
        }

        // 启用弹窗通知
        if (this.notificationConfig.usePopupNotifications) {
            this.enablePopupNotifications();
        }

        // 启用横幅通知
        if (this.notificationConfig.useBannerNotifications) {
            this.enableBannerNotifications();
        }

        // 启用过滤
        if (this.notificationConfig.useNotificationFiltering) {
            this.enableNotificationFiltering();
        }

        // 启用优先级
        if (this.notificationConfig.useNotificationPrioritization) {
            this.enableNotificationPrioritization();
        }

        // 启用分组
        if (this.notificationConfig.useNotificationGrouping) {
            this.enableNotificationGrouping();
        }

        // 启用限流
        if (this.notificationConfig.useNotificationThrottling) {
            this.enableNotificationThrottling();
        }

        // 启用批量
        if (this.notificationConfig.useNotificationBatching) {
            this.enableNotificationBatching();
        }

        // 启用调度
        if (this.notificationConfig.useNotificationScheduling) {
            this.enableNotificationScheduling();
        }

        // 启用持久化
        if (this.notificationConfig.useNotificationPersistence) {
            this.enableNotificationPersistence();
        }

        // 启用验证
        if (this.notificationConfig.useNotificationValidation) {
            this.enableNotificationValidation();
        }
    },

    /**
     * 启用应用内通知
     */
    enableInAppNotifications: function () {
        // 实现应用内通知逻辑
    },

    /**
     * 启用推送通知
     */
    enablePushNotifications: function () {
        // 实现推送通知逻辑
    },

    /**
     * 启用邮件通知
     */
    enableEmailNotifications: function () {
        // 实现邮件通知逻辑
    },

    /**
     * 启用短信通知
     */
    enableSMSNotifications: function () {
        // 实现短信通知逻辑
    },

    /**
     * 启用Webhook通知
     */
    enableWebhookNotifications: function () {
        // 实现Webhook通知逻辑
    },

    /**
     * 启用浏览器通知
     */
    enableBrowserNotifications: function () {
        // 实现浏览器通知逻辑
    },

    /**
     * 启用声音通知
     */
    enableSoundNotifications: function () {
        // 实现声音通知逻辑
    },

    /**
     * 启用振动通知
     */
    enableVibrationNotifications: function () {
        // 实现振动通知逻辑
    },

    /**
     * 启用徽章通知
     */
    enableBadgeNotifications: function () {
        // 实现徽章通知逻辑
    },

    /**
     * 启用Toast通知
     */
    enableToastNotifications: function () {
        // 实现Toast通知逻辑
    },

    /**
     * 启用模态框通知
     */
    enableModalNotifications: function () {
        // 实现模态框通知逻辑
    },

    /**
     * 启用弹窗通知
     */
    enablePopupNotifications: function () {
        // 实现弹窗通知逻辑
    },

    /**
     * 启用横幅通知
     */
    enableBannerNotifications: function () {
        // 实现横幅通知逻辑
    },

    /**
     * 启用过滤
     */
    enableNotificationFiltering: function () {
        // 实现过滤逻辑
    },

    /**
     * 启用优先级
     */
    enableNotificationPrioritization: function () {
        // 实现优先级逻辑
    },

    /**
     * 启用分组
     */
    enableNotificationGrouping: function () {
        // 实现分组逻辑
    },

    /**
     * 启用限流
     */
    enableNotificationThrottling: function () {
        // 实现限流逻辑
    },

    /**
     * 启用批量
     */
    enableNotificationBatching: function () {
        // 实现批量逻辑
    },

    /**
     * 启用调度
     */
    enableNotificationScheduling: function () {
        // 实现调度逻辑
    },

    /**
     * 启用持久化
     */
    enableNotificationPersistence: function () {
        // 实现持久化逻辑
    },

    /**
     * 启用验证
     */
    enableNotificationValidation: function () {
        // 实现验证逻辑
    },

    /**
     * 发送通知
     * @param {Object} options - 通知选项
     * @returns {boolean} 是否成功
     */
    sendNotification: function (options) {
        if (!this.notificationConfig.enabled) {
            return false;
        }

        // 验证通知
        if (this.notificationConfig.useNotificationValidation && this.notificationConfig.validationRequired) {
            const validationResult = this.validateNotification(options);

            if (!validationResult.valid) {
                return false;
            }
        }

        const notification = {
            id: 'notification_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            type: options.type || 'info',
            title: options.title || '',
            message: options.message || '',
            priority: options.priority || 'medium',
            channels: options.channels || ['in-app'],
            data: options.data || {},
            scheduledFor: options.scheduledFor || null,
            expiresAt: options.expiresAt || null,
            read: false,
            clicked: false,
            dismissed: false,
            createdAt: Date.now(),
            sentAt: null,
            deliveredAt: null,
            readAt: null,
            clickedAt: null,
            dismissedAt: null
        };

        // 添加到队列
        if (this.notificationConfig.useNotificationQueue) {
            this.notificationQueue.push(notification);
        } else {
            // 立即发送
            this.deliverNotification(notification);
        }

        // 更新统计
        this.notificationStats.stats.totalNotifications++;

        this.saveNotificationStats();

        return true;
    },

    /**
     * 发送通知
     * @param {Object} notification - 通知对象
     */
    deliverNotification: function (notification) {
        // 更新状态
        notification.status = 'sending';
        notification.sentAt = Date.now();

        // 应用内通知
        if (notification.channels.includes('in-app') && this.notificationConfig.useInAppNotifications) {
            this.sendInAppNotification(notification);
        }

        // 浏览器通知
        if (notification.channels.includes('browser') && this.notificationConfig.useBrowserNotifications) {
            this.sendBrowserNotification(notification);
        }

        // 声音通知
        if (notification.channels.includes('sound') && this.notificationConfig.useSoundNotifications) {
            this.sendSoundNotification(notification);
        }

        // 振动通知
        if (notification.channels.includes('vibration') && this.notificationConfig.useVibrationNotifications) {
            this.sendVibrationNotification(notification);
        }

        // Toast通知
        if (notification.channels.includes('toast') && this.notificationConfig.useToastNotifications) {
            this.sendToastNotification(notification);
        }

        // 更新状态
        notification.status = 'delivered';
        notification.deliveredAt = Date.now();

        // 添加到历史
        this.notificationHistory.push(notification);

        // 限制历史大小
        if (this.notificationHistory.length > this.notificationConfig.maxHistorySize) {
            this.notificationHistory.shift();
        }

        // 更新统计
        this.notificationStats.stats.sentNotifications++;
        this.notificationStats.stats.deliveredNotifications++;

        this.saveNotificationStats();
    },

    /**
     * 发送应用内通知
     * @param {Object} notification - 通知对象
     */
    sendInAppNotification: function (notification) {
        // 实现应用内通知逻辑

        // 更新统计
        this.notificationStats.stats.inAppNotifications++;

        this.saveNotificationStats();
    },

    /**
     * 发送浏览器通知
     * @param {Object} notification - 通知对象
     */
    sendBrowserNotification: function (notification) {
        if ('Notification' in window && this.browserNotificationPermission === 'granted') {
            new Notification(notification.title, {
                body: notification.message,
                icon: notification.data.icon || null,
                tag: notification.id,
                data: notification.data
            });

            // 更新统计
            this.notificationStats.stats.browserNotifications++;

            this.saveNotificationStats();
        }
    },

    /**
     * 发送声音通知
     * @param {Object} notification - 通知对象
     */
    sendSoundNotification: function (notification) {
        // 实现声音通知逻辑

        // 更新统计
        this.notificationStats.stats.soundNotifications++;

        this.saveNotificationStats();
    },

    /**
     * 发送振动通知
     * @param {Object} notification - 通知对象
     */
    sendVibrationNotification: function (notification) {
        if ('vibrate' in navigator) {
            navigator.vibrate([200, 100, 200]);

            // 更新统计
            this.notificationStats.stats.vibrationNotifications++;

            this.saveNotificationStats();
        }
    },

    /**
     * 发送Toast通知
     * @param {Object} notification - 通知对象
     */
    sendToastNotification: function (notification) {
        // 实现Toast通知逻辑

        // 更新统计
        this.notificationStats.stats.toastNotifications++;

        this.saveNotificationStats();
    },

    /**
     * 刷新通知队列
     */
    flushNotificationQueue: function () {
        if (this.notificationQueue.length === 0) {
            return;
        }

        // 按优先级排序
        this.notificationQueue.sort((a, b) => {
            const priorityOrder = {
                'urgent': 0,
                'high': 1,
                'medium': 2,
                'low': 3
            };
            return priorityOrder[a.priority] - priorityOrder[b.priority];
        });

        // 处理队列
        while (this.notificationQueue.length > 0) {
            const notification = this.notificationQueue.shift();
            this.deliverNotification(notification);
        }

        // 更新统计
        this.notificationStats.stats.totalQueueFlushes++;

        this.saveNotificationStats();
    },

    /**
     * 分组通知
     */
    groupNotifications: function () {
        // 实现分组逻辑

        // 更新统计
        this.notificationStats.stats.totalGroupings++;

        this.saveNotificationStats();
    },

    /**
     * 调度通知
     */
    scheduleNotifications: function () {
        // 实现调度逻辑

        // 更新统计
        this.notificationStats.stats.totalSchedules++;

        this.saveNotificationStats();
    },

    /**
     * 验证通知
     * @param {Object} notification - 通知对象
     * @returns {Object} 验证结果
     */
    validateNotification: function (notification) {
        // 实现验证逻辑

        // 更新统计
        this.notificationStats.stats.totalValidations++;
        this.notificationStats.stats.successfulValidations++;

        this.saveNotificationStats();

        return { valid: true };
    },

    /**
     * 标记通知已读
     * @param {string} notificationId - 通知ID
     * @returns {boolean} 是否成功
     */
    markAsRead: function (notificationId) {
        const notification = this.notificationHistory.find(n => n.id === notificationId);

        if (!notification) {
            return false;
        }

        notification.read = true;
        notification.readAt = Date.now();

        // 更新统计
        this.notificationStats.stats.readNotifications++;

        this.saveNotificationStats();

        return true;
    },

    /**
     * 标记通知已点击
     * @param {string} notificationId - 通知ID
     * @returns {boolean} 是否成功
     */
    markAsClicked: function (notificationId) {
        const notification = this.notificationHistory.find(n => n.id === notificationId);

        if (!notification) {
            return false;
        }

        notification.clicked = true;
        notification.clickedAt = Date.now();

        // 更新统计
        this.notificationStats.stats.clickedNotifications++;

        this.notificationStats.stats.readNotifications++;

        this.saveNotificationStats();

        return true;
    },

    /**
     * 标记通知已忽略
     * @param {string} notificationId - 通知ID
     * @returns {boolean} 是否成功
     */
    markAsDismissed: function (notificationId) {
        const notification = this.notificationHistory.find(n => n.id === notificationId);

        if (!notification) {
            return false;
        }

        notification.dismissed = true;
        notification.dismissedAt = Date.now();

        // 更新统计
        this.notificationStats.stats.dismissedNotifications++;

        this.saveNotificationStats();

        return true;
    },

    /**
     * 监控通知
     */
    monitorNotification: function () {
        // 实现监控逻辑

        // 更新统计
        this.notificationStats.stats.totalMonitors++;

        this.saveNotificationStats();
    },

    /**
     * 备份通知
     */
    backupNotification: function () {
        // 实现备份逻辑

        // 更新统计
        this.notificationStats.stats.totalBackups++;

        this.saveNotificationStats();
    },

    /**
     * 获取通知统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.notificationStats.stats;
    },

    /**
     * 设置通知配置
     * @param {Object} config - 配置对象
     */
    setNotificationConfig: function (config) {
        this.notificationConfig = { ...this.notificationConfig, ...config };
        this.saveNotificationConfig();
    },

    /**
     * 获取通知配置
     * @returns {Object} 配置对象
     */
    getNotificationConfig: function () {
        return this.notificationConfig;
    }
};

// 优化：游戏反馈优化
const GameFeedbackOptimizer = {
    feedbackConfig: {},
    feedbackStats: {},
    feedbackCache: {},

    /**
     * 初始化游戏反馈优化
     */
    init: function () {
        this.loadFeedbackConfig();
        this.loadFeedbackStats();
        this.loadFeedbackCache();
        this.initFeedbackSystem();
        this.optimizeFeedback();
    },

    /**
     * 加载反馈配置
     */
    loadFeedbackConfig: function () {
        this.feedbackConfig = {
            enabled: true,
            useFeedbackCollection: true,
            feedbackTypes: ['bug', 'suggestion', 'complaint', 'praise', 'question'],
            useFeedbackCategories: true,
            categories: ['gameplay', 'performance', 'ui', 'audio', 'graphics', 'network', 'other'],
            useFeedbackPrioritization: true,
            priorityLevels: ['low', 'medium', 'high', 'critical'],
            useFeedbackValidation: true,
            validationRequired: true,
            useFeedbackFiltering: true,
            filters: [],
            useFeedbackAnalytics: false,
            analyticsProvider: 'custom',
            useFeedbackTesting: false,
            useFeedbackModeration: true,
            moderationLevel: 'medium',
            useAutoModeration: false,
            autoModerationRules: [],
            useFeedbackEscalation: true,
            escalationRules: [],
            useFeedbackNotifications: true,
            notificationChannels: ['in-app'],
            useFeedbackResponse: true,
            responseTimeSLA: 86400000,
            useFeedbackFollowUp: true,
            followUpInterval: 604800000,
            useFeedbackClosure: true,
            closureInterval: 2592000000,
            useFeedbackHistory: true,
            maxHistorySize: 1000,
            useFeedbackBackup: true,
            backupInterval: 86400000,
            backupRetention: 30,
            useFeedbackRollback: true,
            maxRollbacks: 5,
            useFeedbackMonitoring: true,
            monitoringInterval: 60000,
            useFeedbackLogging: true,
            logLevel: 'warn',
            useFeedbackAlerting: true,
            alertRules: [],
            useFeedbackReporting: true,
            reportFrequency: 'weekly'
        };

        const customConfig = localStorage.getItem('feedbackConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.feedbackConfig = { ...this.feedbackConfig, ...config };
            } catch (error) {
                console.error('加载反馈配置失败:', error);
            }
        }
    },

    /**
     * 保存反馈配置
     */
    saveFeedbackConfig: function () {
        localStorage.setItem('feedbackConfig', JSON.stringify(this.feedbackConfig));
    },

    /**
     * 加载反馈统计
     */
    loadFeedbackStats: function () {
        const savedStats = localStorage.getItem('feedbackStats');
        if (savedStats) {
            try {
                this.feedbackStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载反馈统计失败:', error);
            }
        }

        if (!this.feedbackStats.stats) {
            this.feedbackStats = {
                stats: {
                    totalFeedback: 0,
                    bugFeedback: 0,
                    suggestionFeedback: 0,
                    complaintFeedback: 0,
                    praiseFeedback: 0,
                    questionFeedback: 0,
                    totalValidations: 0,
                    successfulValidations: 0,
                    failedValidations: 0,
                    totalModerations: 0,
                    totalEscalations: 0,
                    totalResponses: 0,
                    averageResponseTime: 0,
                    totalFollowUps: 0,
                    totalClosures: 0,
                    averageClosureTime: 0,
                    openFeedback: 0,
                    inProgressFeedback: 0,
                    resolvedFeedback: 0,
                    closedFeedback: 0,
                    totalBackups: 0,
                    totalRestores: 0,
                    totalRollbacks: 0,
                    totalAlerts: 0,
                    totalMonitors: 0,
                    totalLogs: 0,
                    totalReports: 0
                }
            };

            this.saveFeedbackStats();
        }
    },

    /**
     * 保存反馈统计
     */
    saveFeedbackStats: function () {
        localStorage.setItem('feedbackStats', JSON.stringify(this.feedbackStats));
    },

    /**
     * 加载反馈缓存
     */
    loadFeedbackCache: function () {
        const savedCache = localStorage.getItem('feedbackCache');
        if (savedCache) {
            try {
                this.feedbackCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载反馈缓存失败:', error);
            }
        }

        if (!this.feedbackCache.cache) {
            this.feedbackCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveFeedbackCache();
        }
    },

    /**
     * 保存反馈缓存
     */
    saveFeedbackCache: function () {
        localStorage.setItem('feedbackCache', JSON.stringify(this.feedbackCache));
    },

    /**
     * 初始化反馈系统
     */
    initFeedbackSystem: function () {
        // 初始化反馈
        this.feedbacks = {};

        // 初始化反馈历史
        this.feedbackHistory = [];

        // 启动监控
        if (this.feedbackConfig.useFeedbackMonitoring) {
            this.startMonitoring();
        }

        // 启动备份
        if (this.feedbackConfig.useFeedbackBackup) {
            this.startBackup();
        }

        // 启动跟进
        if (this.feedbackConfig.useFeedbackFollowUp) {
            this.startFollowUp();
        }

        // 启动关闭
        if (this.feedbackConfig.useFeedbackClosure) {
            this.startClosure();
        }
    },

    /**
     * 启动监控
     */
    startMonitoring: function () {
        setInterval(() => {
            if (this.feedbackConfig.useFeedbackMonitoring) {
                this.monitorFeedback();
            }
        }, this.feedbackConfig.monitoringInterval);
    },

    /**
     * 启动备份
     */
    startBackup: function () {
        setInterval(() => {
            if (this.feedbackConfig.useFeedbackBackup) {
                this.backupFeedback();
            }
        }, this.feedbackConfig.backupInterval);
    },

    /**
     * 启动跟进
     */
    startFollowUp: function () {
        setInterval(() => {
            if (this.feedbackConfig.useFeedbackFollowUp) {
                this.followUpFeedback();
            }
        }, this.feedbackConfig.followUpInterval);
    },

    /**
     * 启动关闭
     */
    startClosure: function () {
        setInterval(() => {
            if (this.feedbackConfig.useFeedbackClosure) {
                this.closeFeedback();
            }
        }, this.feedbackConfig.closureInterval);
    },

    /**
     * 优化反馈
     */
    optimizeFeedback: function () {
        // 启用收集
        if (this.feedbackConfig.useFeedbackCollection) {
            this.enableFeedbackCollection();
        }

        // 启用分类
        if (this.feedbackConfig.useFeedbackCategories) {
            this.enableFeedbackCategories();
        }

        // 启用优先级
        if (this.feedbackConfig.useFeedbackPrioritization) {
            this.enableFeedbackPrioritization();
        }

        // 启用验证
        if (this.feedbackConfig.useFeedbackValidation) {
            this.enableFeedbackValidation();
        }

        // 启用过滤
        if (this.feedbackConfig.useFeedbackFiltering) {
            this.enableFeedbackFiltering();
        }

        // 启用审核
        if (this.feedbackConfig.useFeedbackModeration) {
            this.enableFeedbackModeration();
        }

        // 启用自动审核
        if (this.feedbackConfig.useAutoModeration) {
            this.enableAutoModeration();
        }

        // 启用升级
        if (this.feedbackConfig.useFeedbackEscalation) {
            this.enableFeedbackEscalation();
        }

        // 启用通知
        if (this.feedbackConfig.useFeedbackNotifications) {
            this.enableFeedbackNotifications();
        }

        // 启用响应
        if (this.feedbackConfig.useFeedbackResponse) {
            this.enableFeedbackResponse();
        }

        // 启用跟进
        if (this.feedbackConfig.useFeedbackFollowUp) {
            this.enableFeedbackFollowUp();
        }

        // 启用关闭
        if (this.feedbackConfig.useFeedbackClosure) {
            this.enableFeedbackClosure();
        }
    },

    /**
     * 启用收集
     */
    enableFeedbackCollection: function () {
        // 实现收集逻辑
    },

    /**
     * 启用分类
     */
    enableFeedbackCategories: function () {
        // 实现分类逻辑
    },

    /**
     * 启用优先级
     */
    enableFeedbackPrioritization: function () {
        // 实现优先级逻辑
    },

    /**
     * 启用验证
     */
    enableFeedbackValidation: function () {
        // 实现验证逻辑
    },

    /**
     * 启用过滤
     */
    enableFeedbackFiltering: function () {
        // 实现过滤逻辑
    },

    /**
     * 启用审核
     */
    enableFeedbackModeration: function () {
        // 实现审核逻辑
    },

    /**
     * 启用自动审核
     */
    enableAutoModeration: function () {
        // 实现自动审核逻辑
    },

    /**
     * 启用升级
     */
    enableFeedbackEscalation: function () {
        // 实现升级逻辑
    },

    /**
     * 启用通知
     */
    enableFeedbackNotifications: function () {
        // 实现通知逻辑
    },

    /**
     * 启用响应
     */
    enableFeedbackResponse: function () {
        // 实现响应逻辑
    },

    /**
     * 启用跟进
     */
    enableFeedbackFollowUp: function () {
        // 实现跟进逻辑
    },

    /**
     * 启用关闭
     */
    enableFeedbackClosure: function () {
        // 实现关闭逻辑
    },

    /**
     * 提交反馈
     * @param {Object} feedback - 反馈对象
     * @returns {boolean} 是否成功
     */
    submitFeedback: function (feedback) {
        if (!this.feedbackConfig.enabled) {
            return false;
        }

        // 验证反馈
        if (this.feedbackConfig.useFeedbackValidation && this.feedbackConfig.validationRequired) {
            const validationResult = this.validateFeedback(feedback);

            if (!validationResult.valid) {
                return false;
            }
        }

        const feedbackId = 'feedback_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        this.feedbacks[feedbackId] = {
            id: feedbackId,
            type: feedback.type || 'suggestion',
            category: feedback.category || 'other',
            title: feedback.title || '',
            description: feedback.description || '',
            priority: feedback.priority || 'medium',
            status: 'open',
            userId: feedback.userId || 'anonymous',
            email: feedback.email || '',
            attachments: feedback.attachments || [],
            metadata: feedback.metadata || {},
            createdAt: Date.now(),
            updatedAt: Date.now(),
            validatedAt: null,
            moderatedAt: null,
            escalatedAt: null,
            respondedAt: null,
            followedUpAt: null,
            closedAt: null,
            responses: [],
            followUps: []
        };

        // 添加到历史
        this.feedbackHistory.push(this.feedbacks[feedbackId]);

        // 限制历史大小
        if (this.feedbackHistory.length > this.feedbackConfig.maxHistorySize) {
            this.feedbackHistory.shift();
        }

        // 更新统计
        this.feedbackStats.stats.totalFeedback++;
        this.feedbackStats.stats[feedback.type + 'Feedback']++;
        this.feedbackStats.stats.openFeedback++;

        this.saveFeedbackStats();

        return true;
    },

    /**
     * 验证反馈
     * @param {Object} feedback - 反馈对象
     * @returns {Object} 验证结果
     */
    validateFeedback: function (feedback) {
        // 实现验证逻辑

        // 更新统计
        this.feedbackStats.stats.totalValidations++;
        this.feedbackStats.stats.successfulValidations++;

        this.saveFeedbackStats();

        return { valid: true };
    },

    /**
     * 审核反馈
     * @param {string} feedbackId - 反馈ID
     * @param {Object} moderationData - 审核数据
     * @returns {boolean} 是否成功
     */
    moderateFeedback: function (feedbackId, moderationData) {
        const feedback = this.feedbacks[feedbackId];

        if (!feedback) {
            return false;
        }

        feedback.moderatedAt = Date.now();
        feedback.moderationData = moderationData;

        // 更新统计
        this.feedbackStats.stats.totalModerations++;

        this.saveFeedbackStats();

        return true;
    },

    /**
     * 升级反馈
     * @param {string} feedbackId - 反馈ID
     * @param {Object} escalationData - 升级数据
     * @returns {boolean} 是否成功
     */
    escalateFeedback: function (feedbackId, escalationData) {
        const feedback = this.feedbacks[feedbackId];

        if (!feedback) {
            return false;
        }

        feedback.escalatedAt = Date.now();
        feedback.escalationData = escalationData;

        // 更新统计
        this.feedbackStats.stats.totalEscalations++;

        this.saveFeedbackStats();

        return true;
    },

    /**
     * 响应反馈
     * @param {string} feedbackId - 反馈ID
     * @param {Object} responseData - 响应数据
     * @returns {boolean} 是否成功
     */
    respondFeedback: function (feedbackId, responseData) {
        const feedback = this.feedbacks[feedbackId];

        if (!feedback) {
            return false;
        }

        feedback.respondedAt = Date.now();
        feedback.responses.push(responseData);

        // 更新统计
        this.feedbackStats.stats.totalResponses++;

        // 计算平均响应时间
        const responseTime = feedback.respondedAt - feedback.createdAt;
        const totalResponseTime = this.feedbackStats.stats.averageResponseTime * (this.feedbackStats.stats.totalResponses - 1) + responseTime;
        this.feedbackStats.stats.averageResponseTime = totalResponseTime / this.feedbackStats.stats.totalResponses;

        this.saveFeedbackStats();

        return true;
    },

    /**
     * 跟进反馈
     * @param {string} feedbackId - 反馈ID
     * @param {Object} followUpData - 跟进数据
     * @returns {boolean} 是否成功
     */
    followUpFeedbackItem: function (feedbackId, followUpData) {
        const feedback = this.feedbacks[feedbackId];

        if (!feedback) {
            return false;
        }

        feedback.followedUpAt = Date.now();
        feedback.followUps.push(followUpData);

        // 更新统计
        this.feedbackStats.stats.totalFollowUps++;

        this.saveFeedbackStats();

        return true;
    },

    /**
     * 关闭反馈
     * @param {string} feedbackId - 反馈ID
     * @param {Object} closureData - 关闭数据
     * @returns {boolean} 是否成功
     */
    closeFeedbackItem: function (feedbackId, closureData) {
        const feedback = this.feedbacks[feedbackId];

        if (!feedback) {
            return false;
        }

        feedback.status = 'closed';
        feedback.closedAt = Date.now();
        feedback.closureData = closureData;

        // 更新统计
        this.feedbackStats.stats.totalClosures++;
        this.feedbackStats.stats.closedFeedback++;
        this.feedbackStats.stats.openFeedback--;

        // 计算平均关闭时间
        const closureTime = feedback.closedAt - feedback.createdAt;
        const totalClosureTime = this.feedbackStats.stats.averageClosureTime * (this.feedbackStats.stats.totalClosures - 1) + closureTime;
        this.feedbackStats.stats.averageClosureTime = totalClosureTime / this.feedbackStats.stats.totalClosures;

        this.saveFeedbackStats();

        return true;
    },

    /**
     * 跟进反馈
     */
    followUpFeedback: function () {
        // 实现跟进逻辑
    },

    /**
     * 关闭反馈
     */
    closeFeedback: function () {
        // 实现关闭逻辑
    },

    /**
     * 监控反馈
     */
    monitorFeedback: function () {
        // 实现监控逻辑

        // 更新统计
        this.feedbackStats.stats.totalMonitors++;

        this.saveFeedbackStats();
    },

    /**
     * 备份反馈
     */
    backupFeedback: function () {
        // 实现备份逻辑

        // 更新统计
        this.feedbackStats.stats.totalBackups++;

        this.saveFeedbackStats();
    },

    /**
     * 获取反馈统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.feedbackStats.stats;
    },

    /**
     * 设置反馈配置
     * @param {Object} config - 配置对象
     */
    setFeedbackConfig: function (config) {
        this.feedbackConfig = { ...this.feedbackConfig, ...config };
        this.saveFeedbackConfig();
    },

    /**
     * 获取反馈配置
     * @returns {Object} 配置对象
     */
    getFeedbackConfig: function () {
        return this.feedbackConfig;
    }
};

// 优化：游戏帮助优化
const GameHelpOptimizer = {
    helpConfig: {},
    helpStats: {},
    helpCache: {},

    /**
     * 初始化游戏帮助优化
     */
    init: function () {
        this.loadHelpConfig();
        this.loadHelpStats();
        this.loadHelpCache();
        this.initHelpSystem();
        this.optimizeHelp();
    },

    /**
     * 加载帮助配置
     */
    loadHelpConfig: function () {
        this.helpConfig = {
            enabled: true,
            useHelpTopics: true,
            helpTopics: [],
            useHelpCategories: true,
            categories: ['getting-started', 'gameplay', 'controls', 'tips', 'troubleshooting'],
            useHelpSearch: true,
            searchAlgorithm: 'fuzzy',
            useHelpIndexing: true,
            indexingInterval: 86400000,
            useHelpSuggestions: false,
            suggestionAlgorithm: 'collaborative',
            useHelpFeedback: true,
            feedbackTypes: ['helpful', 'not-helpful', 'needs-improvement'],
            useHelpAnalytics: false,
            analyticsProvider: 'custom',
            useHelpTesting: false,
            useHelpModeration: true,
            moderationLevel: 'medium',
            useAutoModeration: false,
            autoModerationRules: [],
            useHelpNotifications: true,
            notificationChannels: ['in-app'],
            useHelpBackup: true,
            backupInterval: 86400000,
            backupRetention: 30,
            useHelpRollback: true,
            maxRollbacks: 5,
            useHelpMonitoring: true,
            monitoringInterval: 60000,
            useHelpLogging: true,
            logLevel: 'warn',
            useHelpAlerting: true,
            alertRules: [],
            useHelpReporting: true,
            reportFrequency: 'weekly'
        };

        const customConfig = localStorage.getItem('helpConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.helpConfig = { ...this.helpConfig, ...config };
            } catch (error) {
                console.error('加载帮助配置失败:', error);
            }
        }
    },

    /**
     * 保存帮助配置
     */
    saveHelpConfig: function () {
        localStorage.setItem('helpConfig', JSON.stringify(this.helpConfig));
    },

    /**
     * 加载帮助统计
     */
    loadHelpStats: function () {
        const savedStats = localStorage.getItem('helpStats');
        if (savedStats) {
            try {
                this.helpStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载帮助统计失败:', error);
            }
        }

        if (!this.helpStats.stats) {
            this.helpStats = {
                stats: {
                    totalHelpViews: 0,
                    totalHelpSearches: 0,
                    successfulSearches: 0,
                    failedSearches: 0,
                    totalHelpFeedback: 0,
                    helpfulFeedback: 0,
                    notHelpfulFeedback: 0,
                    needsImprovementFeedback: 0,
                    totalHelpTopics: 0,
                    totalHelpCategories: 0,
                    totalHelpIndexings: 0,
                    totalHelpSuggestions: 0,
                    totalModerations: 0,
                    totalBackups: 0,
                    totalRestores: 0,
                    totalRollbacks: 0,
                    totalAlerts: 0,
                    totalMonitors: 0,
                    totalLogs: 0,
                    totalReports: 0
                }
            };

            this.saveHelpStats();
        }
    },

    /**
     * 保存帮助统计
     */
    saveHelpStats: function () {
        localStorage.setItem('helpStats', JSON.stringify(this.helpStats));
    },

    /**
     * 加载帮助缓存
     */
    loadHelpCache: function () {
        const savedCache = localStorage.getItem('helpCache');
        if (savedCache) {
            try {
                this.helpCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载帮助缓存失败:', error);
            }
        }

        if (!this.helpCache.cache) {
            this.helpCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveHelpCache();
        }
    },

    /**
     * 保存帮助缓存
     */
    saveHelpCache: function () {
        localStorage.setItem('helpCache', JSON.stringify(this.helpCache));
    },

    /**
     * 初始化帮助系统
     */
    initHelpSystem: function () {
        // 初始化帮助主题
        this.helpTopics = {};

        // 初始化帮助索引
        this.helpIndex = {};

        // 初始化帮助历史
        this.helpHistory = [];

        // 初始化帮助搜索历史
        this.searchHistory = [];

        // 启动索引
        if (this.helpConfig.useHelpIndexing) {
            this.startIndexing();
        }

        // 启动监控
        if (this.helpConfig.useHelpMonitoring) {
            this.startMonitoring();
        }

        // 启动备份
        if (this.helpConfig.useHelpBackup) {
            this.startBackup();
        }
    },

    /**
     * 启动索引
     */
    startIndexing: function () {
        setInterval(() => {
            if (this.helpConfig.useHelpIndexing) {
                this.indexHelp();
            }
        }, this.helpConfig.indexingInterval);
    },

    /**
     * 启动监控
     */
    startMonitoring: function () {
        setInterval(() => {
            if (this.helpConfig.useHelpMonitoring) {
                this.monitorHelp();
            }
        }, this.helpConfig.monitoringInterval);
    },

    /**
     * 启动备份
     */
    startBackup: function () {
        setInterval(() => {
            if (this.helpConfig.useHelpBackup) {
                this.backupHelp();
            }
        }, this.helpConfig.backupInterval);
    },

    /**
     * 优化帮助
     */
    optimizeHelp: function () {
        // 启用主题
        if (this.helpConfig.useHelpTopics) {
            this.enableHelpTopics();
        }

        // 启用分类
        if (this.helpConfig.useHelpCategories) {
            this.enableHelpCategories();
        }

        // 启用搜索
        if (this.helpConfig.useHelpSearch) {
            this.enableHelpSearch();
        }

        // 启用索引
        if (this.helpConfig.useHelpIndexing) {
            this.enableHelpIndexing();
        }

        // 启用建议
        if (this.helpConfig.useHelpSuggestions) {
            this.enableHelpSuggestions();
        }

        // 启用反馈
        if (this.helpConfig.useHelpFeedback) {
            this.enableHelpFeedback();
        }

        // 启用审核
        if (this.helpConfig.useHelpModeration) {
            this.enableHelpModeration();
        }

        // 启用自动审核
        if (this.helpConfig.useAutoModeration) {
            this.enableAutoModeration();
        }

        // 启用通知
        if (this.helpConfig.useHelpNotifications) {
            this.enableHelpNotifications();
        }
    },

    /**
     * 启用主题
     */
    enableHelpTopics: function () {
        // 实现主题逻辑
    },

    /**
     * 启用分类
     */
    enableHelpCategories: function () {
        // 实现分类逻辑
    },

    /**
     * 启用搜索
     */
    enableHelpSearch: function () {
        // 实现搜索逻辑
    },

    /**
     * 启用索引
     */
    enableHelpIndexing: function () {
        // 实现索引逻辑
    },

    /**
     * 启用建议
     */
    enableHelpSuggestions: function () {
        // 实现建议逻辑
    },

    /**
     * 启用反馈
     */
    enableHelpFeedback: function () {
        // 实现反馈逻辑
    },

    /**
     * 启用审核
     */
    enableHelpModeration: function () {
        // 实现审核逻辑
    },

    /**
     * 启用自动审核
     */
    enableAutoModeration: function () {
        // 实现自动审核逻辑
    },

    /**
     * 启用通知
     */
    enableHelpNotifications: function () {
        // 实现通知逻辑
    },

    /**
     * 添加帮助主题
     * @param {Object} topic - 主题对象
     * @returns {boolean} 是否成功
     */
    addHelpTopic: function (topic) {
        if (!this.helpConfig.enabled) {
            return false;
        }

        const topicId = 'topic_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        this.helpTopics[topicId] = {
            id: topicId,
            title: topic.title || '',
            content: topic.content || '',
            category: topic.category || 'other',
            tags: topic.tags || [],
            order: topic.order || 0,
            published: topic.published !== undefined ? topic.published : true,
            createdAt: Date.now(),
            updatedAt: Date.now(),
            views: 0,
            helpful: 0,
            notHelpful: 0,
            needsImprovement: 0
        };

        // 更新统计
        this.helpStats.stats.totalHelpTopics++;

        this.saveHelpStats();

        return true;
    },

    /**
     * 获取帮助主题
     * @param {string} topicId - 主题ID
     * @returns {Object|null} 主题对象
     */
    getHelpTopic: function (topicId) {
        const topic = this.helpTopics[topicId];

        if (!topic) {
            return null;
        }

        // 更新查看次数
        topic.views++;

        // 添加到历史
        this.helpHistory.push({
            topicId: topicId,
            viewedAt: Date.now()
        });

        // 更新统计
        this.helpStats.stats.totalHelpViews++;

        this.saveHelpStats();

        return topic;
    },

    /**
     * 搜索帮助
     * @param {string} query - 搜索查询
     * @returns {Array} 搜索结果
     */
    searchHelp: function (query) {
        if (!this.helpConfig.enabled) {
            return [];
        }

        // 添加到搜索历史
        this.searchHistory.push({
            query: query,
            searchedAt: Date.now()
        });

        // 实现搜索逻辑
        const results = [];

        // 更新统计
        this.helpStats.stats.totalHelpSearches++;

        if (results.length > 0) {
            this.helpStats.stats.successfulSearches++;
        } else {
            this.helpStats.stats.failedSearches++;
        }

        this.saveHelpStats();

        return results;
    },

    /**
     * 提交帮助反馈
     * @param {string} topicId - 主题ID
     * @param {string} feedbackType - 反馈类型
     * @returns {boolean} 是否成功
     */
    submitHelpFeedback: function (topicId, feedbackType) {
        if (!this.helpConfig.enabled) {
            return false;
        }

        if (!this.helpConfig.feedbackTypes.includes(feedbackType)) {
            return false;
        }

        const topic = this.helpTopics[topicId];

        if (!topic) {
            return false;
        }

        // 更新反馈统计
        topic[feedbackType]++;

        // 更新全局统计
        this.helpStats.stats.totalHelpFeedback++;
        this.helpStats.stats[feedbackType + 'Feedback']++;

        this.saveHelpStats();

        return true;
    },

    /**
     * 索引帮助
     */
    indexHelp: function () {
        // 实现索引逻辑

        // 更新统计
        this.helpStats.stats.totalHelpIndexings++;

        this.saveHelpStats();
    },

    /**
     * 监控帮助
     */
    monitorHelp: function () {
        // 实现监控逻辑

        // 更新统计
        this.helpStats.stats.totalMonitors++;

        this.saveHelpStats();
    },

    /**
     * 备份帮助
     */
    backupHelp: function () {
        // 实现备份逻辑

        // 更新统计
        this.helpStats.stats.totalBackups++;

        this.saveHelpStats();
    },

    /**
     * 获取帮助统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.helpStats.stats;
    },

    /**
     * 设置帮助配置
     * @param {Object} config - 配置对象
     */
    setHelpConfig: function (config) {
        this.helpConfig = { ...this.helpConfig, ...config };
        this.saveHelpConfig();
    },

    /**
     * 获取帮助配置
     * @returns {Object} 配置对象
     */
    getHelpConfig: function () {
        return this.helpConfig;
    }
};

// 优化：游戏教程优化
const GameTutorialOptimizer = {
    tutorialConfig: {},
    tutorialStats: {},
    tutorialCache: {},

    /**
     * 初始化游戏教程优化
     */
    init: function () {
        this.loadTutorialConfig();
        this.loadTutorialStats();
        this.loadTutorialCache();
        this.initTutorialSystem();
        this.optimizeTutorial();
    },

    /**
     * 加载教程配置
     */
    loadTutorialConfig: function () {
        this.tutorialConfig = {
            enabled: true,
            useTutorialSteps: true,
            maxSteps: 50,
            useTutorialProgress: true,
            useTutorialCompletion: true,
            useTutorialSkip: true,
            skipConfirmation: true,
            useTutorialResume: true,
            resumeInterval: 300000,
            useTutorialHints: true,
            hintInterval: 10000,
            useTutorialGuidance: true,
            guidanceStyle: 'overlay',
            useTutorialInteractive: true,
            interactiveMode: 'guided',
            useTutorialTesting: false,
            useTutorialAnalytics: false,
            analyticsProvider: 'custom',
            useTutorialFeedback: true,
            feedbackTypes: ['helpful', 'not-helpful', 'needs-improvement'],
            useTutorialNotifications: true,
            notificationChannels: ['in-app'],
            useTutorialBackup: true,
            backupInterval: 86400000,
            backupRetention: 30,
            useTutorialRollback: true,
            maxRollbacks: 5,
            useTutorialMonitoring: true,
            monitoringInterval: 60000,
            useTutorialLogging: true,
            logLevel: 'warn',
            useTutorialAlerting: true,
            alertRules: [],
            useTutorialReporting: true,
            reportFrequency: 'weekly'
        };

        const customConfig = localStorage.getItem('tutorialConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.tutorialConfig = { ...this.tutorialConfig, ...config };
            } catch (error) {
                console.error('加载教程配置失败:', error);
            }
        }
    },

    /**
     * 保存教程配置
     */
    saveTutorialConfig: function () {
        localStorage.setItem('tutorialConfig', JSON.stringify(this.tutorialConfig));
    },

    /**
     * 加载教程统计
     */
    loadTutorialStats: function () {
        const savedStats = localStorage.getItem('tutorialStats');
        if (savedStats) {
            try {
                this.tutorialStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载教程统计失败:', error);
            }
        }

        if (!this.tutorialStats.stats) {
            this.tutorialStats = {
                stats: {
                    totalTutorials: 0,
                    completedTutorials: 0,
                    skippedTutorials: 0,
                    resumedTutorials: 0,
                    abandonedTutorials: 0,
                    totalSteps: 0,
                    completedSteps: 0,
                    skippedSteps: 0,
                    totalHints: 0,
                    totalGuidance: 0,
                    totalInteractions: 0,
                    averageCompletionTime: 0,
                    totalTutorialFeedback: 0,
                    helpfulFeedback: 0,
                    notHelpfulFeedback: 0,
                    needsImprovementFeedback: 0,
                    totalBackups: 0,
                    totalRestores: 0,
                    totalRollbacks: 0,
                    totalAlerts: 0,
                    totalMonitors: 0,
                    totalLogs: 0,
                    totalReports: 0
                }
            };

            this.saveTutorialStats();
        }
    },

    /**
     * 保存教程统计
     */
    saveTutorialStats: function () {
        localStorage.setItem('tutorialStats', JSON.stringify(this.tutorialStats));
    },

    /**
     * 加载教程缓存
     */
    loadTutorialCache: function () {
        const savedCache = localStorage.getItem('tutorialCache');
        if (savedCache) {
            try {
                this.tutorialCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载教程缓存失败:', error);
            }
        }

        if (!this.tutorialCache.cache) {
            this.tutorialCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.saveTutorialCache();
        }
    },

    /**
     * 保存教程缓存
     */
    saveTutorialCache: function () {
        localStorage.setItem('tutorialCache', JSON.stringify(this.tutorialCache));
    },

    /**
     * 初始化教程系统
     */
    initTutorialSystem: function () {
        // 初始化教程
        this.tutorials = {};

        // 初始化教程进度
        this.tutorialProgress = {};

        // 初始化教程历史
        this.tutorialHistory = [];

        // 启动恢复
        if (this.tutorialConfig.useTutorialResume) {
            this.startResume();
        }

        // 启动提示
        if (this.tutorialConfig.useTutorialHints) {
            this.startHints();
        }

        // 启动监控
        if (this.tutorialConfig.useTutorialMonitoring) {
            this.startMonitoring();
        }

        // 启动备份
        if (this.tutorialConfig.useTutorialBackup) {
            this.startBackup();
        }
    },

    /**
     * 启动恢复
     */
    startResume: function () {
        setInterval(() => {
            if (this.tutorialConfig.useTutorialResume) {
                this.resumeTutorial();
            }
        }, this.tutorialConfig.resumeInterval);
    },

    /**
     * 启动提示
     */
    startHints: function () {
        setInterval(() => {
            if (this.tutorialConfig.useTutorialHints) {
                this.showHint();
            }
        }, this.tutorialConfig.hintInterval);
    },

    /**
     * 启动监控
     */
    startMonitoring: function () {
        setInterval(() => {
            if (this.tutorialConfig.useTutorialMonitoring) {
                this.monitorTutorial();
            }
        }, this.tutorialConfig.monitoringInterval);
    },

    /**
     * 启动备份
     */
    startBackup: function () {
        setInterval(() => {
            if (this.tutorialConfig.useTutorialBackup) {
                this.backupTutorial();
            }
        }, this.tutorialConfig.backupInterval);
    },

    /**
     * 优化教程
     */
    optimizeTutorial: function () {
        // 启用步骤
        if (this.tutorialConfig.useTutorialSteps) {
            this.enableTutorialSteps();
        }

        // 启用进度
        if (this.tutorialConfig.useTutorialProgress) {
            this.enableTutorialProgress();
        }

        // 启用完成
        if (this.tutorialConfig.useTutorialCompletion) {
            this.enableTutorialCompletion();
        }

        // 启用跳过
        if (this.tutorialConfig.useTutorialSkip) {
            this.enableTutorialSkip();
        }

        // 启用恢复
        if (this.tutorialConfig.useTutorialResume) {
            this.enableTutorialResume();
        }

        // 启用提示
        if (this.tutorialConfig.useTutorialHints) {
            this.enableTutorialHints();
        }

        // 启用引导
        if (this.tutorialConfig.useTutorialGuidance) {
            this.enableTutorialGuidance();
        }

        // 启用交互
        if (this.tutorialConfig.useTutorialInteractive) {
            this.enableTutorialInteractive();
        }

        // 启用反馈
        if (this.tutorialConfig.useTutorialFeedback) {
            this.enableTutorialFeedback();
        }

        // 启用通知
        if (this.tutorialConfig.useTutorialNotifications) {
            this.enableTutorialNotifications();
        }
    },

    /**
     * 启用步骤
     */
    enableTutorialSteps: function () {
        // 实现步骤逻辑
    },

    /**
     * 启用进度
     */
    enableTutorialProgress: function () {
        // 实现进度逻辑
    },

    /**
     * 启用完成
     */
    enableTutorialCompletion: function () {
        // 实现完成逻辑
    },

    /**
     * 启用跳过
     */
    enableTutorialSkip: function () {
        // 实现跳过逻辑
    },

    /**
     * 启用恢复
     */
    enableTutorialResume: function () {
        // 实现恢复逻辑
    },

    /**
     * 启用提示
     */
    enableTutorialHints: function () {
        // 实现提示逻辑
    },

    /**
     * 启用引导
     */
    enableTutorialGuidance: function () {
        // 实现引导逻辑
    },

    /**
     * 启用交互
     */
    enableTutorialInteractive: function () {
        // 实现交互逻辑
    },

    /**
     * 启用反馈
     */
    enableTutorialFeedback: function () {
        // 实现反馈逻辑
    },

    /**
     * 启用通知
     */
    enableTutorialNotifications: function () {
        // 实现通知逻辑
    },

    /**
     * 开始教程
     * @param {string} tutorialId - 教程ID
     * @returns {boolean} 是否成功
     */
    startTutorial: function (tutorialId) {
        if (!this.tutorialConfig.enabled) {
            return false;
        }

        const tutorial = this.tutorials[tutorialId];

        if (!tutorial) {
            return false;
        }

        // 初始化进度
        this.tutorialProgress[tutorialId] = {
            tutorialId: tutorialId,
            currentStep: 0,
            startedAt: Date.now(),
            completedAt: null,
            skippedAt: null,
            abandonedAt: null,
            stepsCompleted: 0,
            stepsSkipped: 0,
            hintsShown: 0,
            guidanceShown: 0,
            interactions: 0,
            status: 'in-progress'
        };

        // 更新统计
        this.tutorialStats.stats.totalTutorials++;

        this.saveTutorialStats();

        return true;
    },

    /**
     * 完成教程
     * @param {string} tutorialId - 教程ID
     * @returns {boolean} 是否成功
     */
    completeTutorial: function (tutorialId) {
        const progress = this.tutorialProgress[tutorialId];

        if (!progress) {
            return false;
        }

        progress.status = 'completed';
        progress.completedAt = Date.now();

        // 更新统计
        this.tutorialStats.stats.completedTutorials++;

        // 计算平均完成时间
        const completionTime = progress.completedAt - progress.startedAt;
        const totalCompletionTime = this.tutorialStats.stats.averageCompletionTime * (this.tutorialStats.stats.completedTutorials - 1) + completionTime;
        this.tutorialStats.stats.averageCompletionTime = totalCompletionTime / this.tutorialStats.stats.completedTutorials;

        this.saveTutorialStats();

        return true;
    },

    /**
     * 跳过教程
     * @param {string} tutorialId - 教程ID
     * @returns {boolean} 是否成功
     */
    skipTutorial: function (tutorialId) {
        const progress = this.tutorialProgress[tutorialId];

        if (!progress) {
            return false;
        }

        if (this.tutorialConfig.skipConfirmation) {
            // 需要确认
            return false;
        }

        progress.status = 'skipped';
        progress.skippedAt = Date.now();

        // 更新统计
        this.tutorialStats.stats.skippedTutorials++;

        this.saveTutorialStats();

        return true;
    },

    /**
     * 恢复教程
     * @param {string} tutorialId - 教程ID
     * @returns {boolean} 是否成功
     */
    resumeTutorial: function () {
        // 实现恢复逻辑

        // 更新统计
        this.tutorialStats.stats.resumedTutorials++;

        this.saveTutorialStats();
    },

    /**
     * 显示提示
     */
    showHint: function () {
        // 实现提示逻辑

        // 更新统计
        this.tutorialStats.stats.totalHints++;

        this.saveTutorialStats();
    },

    /**
     * 提交教程反馈
     * @param {string} tutorialId - 教程ID
     * @param {string} feedbackType - 反馈类型
     * @returns {boolean} 是否成功
     */
    submitTutorialFeedback: function (tutorialId, feedbackType) {
        if (!this.tutorialConfig.enabled) {
            return false;
        }

        if (!this.tutorialConfig.feedbackTypes.includes(feedbackType)) {
            return false;
        }

        // 更新统计
        this.tutorialStats.stats.totalTutorialFeedback++;
        this.tutorialStats.stats[feedbackType + 'Feedback']++;

        this.saveTutorialStats();

        return true;
    },

    /**
     * 监控教程
     */
    monitorTutorial: function () {
        // 实现监控逻辑

        // 更新统计
        this.tutorialStats.stats.totalMonitors++;

        this.saveTutorialStats();
    },

    /**
     * 备份教程
     */
    backupTutorial: function () {
        // 实现备份逻辑

        // 更新统计
        this.tutorialStats.stats.totalBackups++;

        this.saveTutorialStats();
    },

    /**
     * 获取教程统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.tutorialStats.stats;
    },

    /**
     * 设置教程配置
     * @param {Object} config - 配置对象
     */
    setTutorialConfig: function (config) {
        this.tutorialConfig = { ...this.tutorialConfig, ...config };
        this.saveTutorialConfig();
    },

    /**
     * 获取教程配置
     * @returns {Object} 配置对象
     */
    getTutorialConfig: function () {
        return this.tutorialConfig;
    }
};

// 优化：渲染系统性能优化
function optimizeRendering() {
    // 优化：使用离屏Canvas缓存静态元素
    if (!state.offscreenCanvas) {
        state.offscreenCanvas = document.createElement('canvas');
        state.offscreenCanvas.width = CONFIG.canvasWidth;
        state.offscreenCanvas.height = CONFIG.canvasHeight;
        state.offscreenCtx = state.offscreenCanvas.getContext('2d');
    }

    // 优化：缓存背景和静态平台
    if (!state.backgroundCached) {
        cacheBackground();
        state.backgroundCached = true;
    }

    // 优化：减少不必要的重绘
    state.lastRenderedState = {
        playerX: state.player.x,
        playerY: state.player.y,
        playerHealth: state.player.health,
        score: state.score,
        currentLevel: state.currentLevel
    };
}

// 优化：缓存背景和静态平台
function cacheBackground() {
    const offscreenCtx = state.offscreenCtx;

    // 绘制背景
    offscreenCtx.fillStyle = '#1a1a2e';
    offscreenCtx.fillRect(0, 0, CONFIG.canvasWidth, CONFIG.canvasHeight);

    // 绘制渐变背景
    const gradient = offscreenCtx.createLinearGradient(0, 0, 0, CONFIG.canvasHeight);
    gradient.addColorStop(0, '#16213e');
    gradient.addColorStop(0.5, '#1a1a2e');
    gradient.addColorStop(1, '#0f3460');
    offscreenCtx.fillStyle = gradient;
    offscreenCtx.fillRect(0, 0, CONFIG.canvasWidth, CONFIG.canvasHeight);

    // 绘制静态平台
    state.platforms.forEach(platform => {
        offscreenCtx.fillStyle = '#4a5568';
        offscreenCtx.fillRect(platform.x, platform.y, platform.width, platform.height);

        // 平台边框
        offscreenCtx.strokeStyle = '#2d3748';
        offscreenCtx.lineWidth = 2;
        offscreenCtx.strokeRect(platform.x, platform.y, platform.width, platform.height);

        // 平台顶部高光
        offscreenCtx.fillStyle = '#718096';
        offscreenCtx.fillRect(platform.x, platform.y, platform.width, 4);
    });
}

// 优化：绘制函数
function draw() {
    // 优化：清除画布
    ctx.clearRect(0, 0, CONFIG.canvasWidth, CONFIG.canvasHeight);

    // 优化：绘制缓存的背景
    if (state.offscreenCanvas) {
        ctx.drawImage(state.offscreenCanvas, 0, 0);
    }

    // 优化：绘制道具
    drawProps();

    // 优化：绘制敌人
    drawEnemies();

    // 优化：绘制玩家
    drawPlayer();

    // 优化：绘制攻击效果
    drawAttackEffects();

    // 优化：绘制粒子
    drawParticles();

    // 优化：绘制UI
    drawUI();
}

// 优化：绘制UI
function drawUI() {
    // 优化：只在值变化时更新UI
    const player = state.player;

    // 优化：绘制血条背景
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(10, 10, 200, 20);

    // 优化：绘制血条
    const healthPercent = player.health / player.maxHealth;
    ctx.fillStyle = healthPercent > 0.5 ? '#48bb78' : healthPercent > 0.25 ? '#ed8936' : '#f56565';
    ctx.fillRect(12, 12, 196 * healthPercent, 16);

    // 优化：绘制血条边框
    ctx.strokeStyle = '#2d3748';
    ctx.lineWidth = 2;
    ctx.strokeRect(10, 10, 200, 20);

    // 优化：绘制分数
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'right';
    ctx.fillText(`分数: ${state.score}`, CONFIG.canvasWidth - 10, 25);

    // 优化：绘制关卡
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`关卡: ${state.currentLevel + 1}`, 10, 50);

    // 优化：绘制连击
    if (player.comboCount > 0) {
        ctx.fillStyle = '#f6e05e';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`${player.comboCount} 连击`, CONFIG.canvasWidth / 2, 30);
    }

    // 优化：绘制无敌帧指示器
    if (player.invincibilityFrames > 0) {
        ctx.fillStyle = `rgba(255, 255, 255, ${player.invincibilityFrames / 35 * 0.5})`;
        ctx.fillRect(0, 0, CONFIG.canvasWidth, CONFIG.canvasHeight);
    }
}

// 优化：绘制玩家
function drawPlayer() {
    const player = state.player;

    // 优化：使用离屏Canvas缓存玩家角色
    if (!state.playerCanvas) {
        state.playerCanvas = document.createElement('canvas');
        state.playerCanvas.width = player.width;
        state.playerCanvas.height = player.height;
        const playerCtx = state.playerCanvas.getContext('2d');

        // 绘制火柴人身体
        playerCtx.fillStyle = '#ffffff';
        playerCtx.fillRect(player.width * 0.3, 0, player.width * 0.4, player.height * 0.3);

        // 绘制火柴人四肢
        playerCtx.fillRect(0, player.height * 0.3, player.width * 0.3, player.height * 0.4);
        playerCtx.fillRect(player.width * 0.7, player.height * 0.3, player.width * 0.3, player.height * 0.4);
        playerCtx.fillRect(player.width * 0.2, player.height * 0.7, player.width * 0.2, player.height * 0.3);
        playerCtx.fillRect(player.width * 0.6, player.height * 0.7, player.width * 0.2, player.height * 0.3);

        // 绘制火柴人眼睛
        playerCtx.fillStyle = '#000000';
        playerCtx.fillRect(player.width * 0.35, player.height * 0.1, player.width * 0.1, player.height * 0.1);
        playerCtx.fillRect(player.width * 0.55, player.height * 0.1, player.width * 0.1, player.height * 0.1);

        // 绘制火柴人嘴巴
        playerCtx.fillRect(player.width * 0.4, player.height * 0.25, player.width * 0.2, player.height * 0.05);
    }

    // 优化：绘制玩家角色
    ctx.save();

    // 优化：应用无敌帧闪烁效果
    if (player.invincibilityFrames > 0) {
        ctx.globalAlpha = 0.5 + Math.sin(player.invincibilityFrames * 0.5) * 0.5;
    }

    // 优化：应用攻击效果
    if (player.isAttacking) {
        ctx.shadowColor = '#f6e05e';
        ctx.shadowBlur = 20;
    }

    // 优化：绘制玩家
    ctx.drawImage(state.playerCanvas, player.x, player.y);

    ctx.restore();
}

// 优化：绘制敌人
function drawEnemies() {
    state.enemies.forEach(enemy => {
        // 优化：使用颜色编码敌人类型
        let enemyColor;
        switch (enemy.type) {
            case 'normal':
                enemyColor = '#e53e3e';
                break;
            case 'jumping':
                enemyColor = '#805ad5';
                break;
            case 'tracking':
                enemyColor = '#38a169';
                break;
            case 'flying':
                enemyColor = '#d69e2e';
                break;
            case 'shooter':
                enemyColor = '#3182ce';
                break;
            case 'exploder':
                enemyColor = '#dd6b20';
                break;
            default:
                enemyColor = '#718096';
        }

        // 优化：绘制敌人身体
        ctx.fillStyle = enemyColor;
        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);

        // 优化：绘制敌人血条
        if (enemy.health < enemy.maxHealth) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(enemy.x, enemy.y - 10, enemy.width, 5);

            ctx.fillStyle = enemy.health > enemy.maxHealth * 0.5 ? '#48bb78' :
                enemy.health > enemy.maxHealth * 0.25 ? '#ed8936' : '#f56565';
            ctx.fillRect(enemy.x, enemy.y - 10, enemy.width * (enemy.health / enemy.maxHealth), 5);
        }

        // 优化：绘制敌人眼睛
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(enemy.x + enemy.width * 0.2, enemy.y + enemy.height * 0.2, enemy.width * 0.2, enemy.height * 0.2);
        ctx.fillRect(enemy.x + enemy.width * 0.6, enemy.y + enemy.height * 0.2, enemy.width * 0.2, enemy.height * 0.2);

        // 优化：绘制敌人被击中效果
        if (enemy.isHit) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
        }
    });
}

// 优化：绘制攻击效果
function drawAttackEffects() {
    state.attackEffects.forEach(effect => {
        const progress = effect.timer / effect.duration;
        const alpha = 1 - progress;
        const scale = 1 + progress * 0.5;

        ctx.save();
        ctx.globalAlpha = alpha;

        // 优化：根据攻击类型绘制不同的效果
        switch (effect.type) {
            case 'normal':
                ctx.fillStyle = `rgba(246, 224, 94, ${alpha})`;
                ctx.fillRect(effect.x, effect.y, effect.width, effect.height);
                break;
            case 'heavy':
                ctx.fillStyle = `rgba(237, 137, 54, ${alpha})`;
                ctx.fillRect(effect.x, effect.y, effect.width, effect.height);

                // 优化：添加冲击波效果
                ctx.strokeStyle = `rgba(237, 137, 54, ${alpha})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(effect.x + effect.width / 2, effect.y + effect.height / 2,
                    effect.width / 2 * scale, 0, Math.PI * 2);
                ctx.stroke();
                break;
            case 'special':
                ctx.fillStyle = `rgba(245, 101, 101, ${alpha})`;
                ctx.fillRect(effect.x, effect.y, effect.width, effect.height);

                // 优化：添加特殊效果
                for (let i = 0; i < 5; i++) {
                    const angle = (i / 5) * Math.PI * 2 + progress * Math.PI;
                    const x = effect.x + effect.width / 2 + Math.cos(angle) * effect.width / 2 * scale;
                    const y = effect.y + effect.height / 2 + Math.sin(angle) * effect.height / 2 * scale;

                    ctx.fillStyle = `rgba(245, 101, 101, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 5 * scale, 0, Math.PI * 2);
                    ctx.fill();
                }
                break;
        }

        ctx.restore();
    });
}

// 优化：绘制粒子
function drawParticles() {
    state.particles.forEach(particle => {
        ctx.save();
        ctx.globalAlpha = particle.alpha;
        ctx.fillStyle = particle.color;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    });
}

// 优化：添加屏幕震动效果
function addScreenShake() {
    state.screenShake = {
        intensity: 10,
        duration: 10
    };
}

// 优化：应用屏幕震动
function applyScreenShake() {
    if (state.screenShake && state.screenShake.duration > 0) {
        const shakeX = (Math.random() - 0.5) * state.screenShake.intensity;
        const shakeY = (Math.random() - 0.5) * state.screenShake.intensity;

        ctx.save();
        ctx.translate(shakeX, shakeY);

        state.screenShake.duration--;

        return true;
    }

    return false;
}

// 优化：恢复屏幕震动
function restoreScreenShake() {
    if (state.screenShake && state.screenShake.duration >= 0) {
        ctx.restore();
    }
}

// 优化：游戏循环
function gameLoop(timestamp) {
    if (!state.gameRunning) return;

    const deltaTime = timestamp - state.lastTime;

    // 优化：限制最大帧时间，避免跳帧
    const maxDeltaTime = 50;
    const clampedDeltaTime = Math.min(deltaTime, maxDeltaTime);

    state.lastTime = timestamp;

    // 优化：更新性能指标
    if (!state.performanceMetrics) {
        state.performanceMetrics = {
            frameCount: 0,
            fps: 0,
            lastFpsUpdate: 0
        };
    }

    state.performanceMetrics.frameCount++;

    // 优化：每秒更新一次FPS
    if (timestamp - state.performanceMetrics.lastFpsUpdate >= 1000) {
        state.performanceMetrics.fps = state.performanceMetrics.frameCount;
        state.performanceMetrics.frameCount = 0;
        state.performanceMetrics.lastFpsUpdate = timestamp;
    }

    // 优化：应用屏幕震动
    const screenShakeApplied = applyScreenShake();

    // 优化：更新游戏状态
    updatePlayer();
    updateEnemies();
    updateProps();
    updateBombs();
    updateParticles();
    updateAttackEffects();
    updateEnemyEffects();

    // 优化：绘制游戏
    draw();

    // 优化：恢复屏幕震动
    if (screenShakeApplied) {
        restoreScreenShake();
    }

    // 优化：更新动态难度
    dynamicDifficulty.adjustDifficulty();

    // 优化：更新状态缓存
    updateStateCache();

    state.animationId = requestAnimationFrame(gameLoop);
}

// 页面加载完成后初始化游戏
window.addEventListener('load', function () {
    try {
        StickmanAdventure.init();
    } catch (error) {
        console.error('初始化火柴人冒险游戏时出错:', error);
    }
});

// 优化：游戏物理引擎优化
const GamePhysicsOptimizer = {
    physicsConfig: {},
    physicsStats: {},
    physicsCache: {},

    /**
     * 初始化游戏物理引擎优化
     */
    init: function () {
        this.loadPhysicsConfig();
        this.loadPhysicsStats();
        this.loadPhysicsCache();
        this.initPhysicsSystem();
        this.optimizePhysics();
    },

    /**
     * 加载物理配置
     */
    loadPhysicsConfig: function () {
        this.physicsConfig = {
            enabled: true,
            useGravity: true,
            gravity: 0.6,
            useFriction: true,
            groundFriction: 0.85,
            airResistance: 0.98,
            useCollisionDetection: true,
            collisionDetectionMethod: 'aabb',
            useSpatialHashing: true,
            cellSize: 100,
            useContinuousCollision: false,
            useSubStepping: true,
            subSteps: 4,
            useSleeping: false,
            sleepThreshold: 0.1,
            useBroadPhase: true,
            broadPhaseMethod: 'sweep',
            useNarrowPhase: true,
            narrowPhaseMethod: 'sat',
            useResponse: true,
            responseMethod: 'impulse',
            useSolver: true,
            solverIterations: 10,
            useWarmStarting: true,
            useRestitution: true,
            restitution: 0.3,
            useDamping: true,
            linearDamping: 0.05,
            angularDamping: 0.05,
            useConstraints: true,
            constraintIterations: 5,
            useJoints: false,
            jointIterations: 3,
            useRaycasting: false,
            raycastPrecision: 0.01,
            useDebugging: false,
            debugMode: 'none',
            useProfiling: true,
            profilingInterval: 1000,
            useLogging: true,
            logLevel: 'warn'
        };

        const customConfig = localStorage.getItem('physicsConfig');
        if (customConfig) {
            try {
                const config = JSON.parse(customConfig);
                this.physicsConfig = { ...this.physicsConfig, ...config };
            } catch (error) {
                console.error('加载物理配置失败:', error);
            }
        }
    },

    /**
     * 保存物理配置
     */
    savePhysicsConfig: function () {
        localStorage.setItem('physicsConfig', JSON.stringify(this.physicsConfig));
    },

    /**
     * 加载物理统计
     */
    loadPhysicsStats: function () {
        const savedStats = localStorage.getItem('physicsStats');
        if (savedStats) {
            try {
                this.physicsStats = JSON.parse(savedStats);
            } catch (error) {
                console.error('加载物理统计失败:', error);
            }
        }

        if (!this.physicsStats.stats) {
            this.physicsStats = {
                stats: {
                    totalUpdates: 0,
                    totalCollisions: 0,
                    totalRaycasts: 0,
                    totalConstraints: 0,
                    totalJoints: 0,
                    averageUpdateTime: 0,
                    averageCollisionTime: 0,
                    averageRaycastTime: 0,
                    averageConstraintTime: 0,
                    averageJointTime: 0,
                    maxUpdateTime: 0,
                    maxCollisionTime: 0,
                    maxRaycastTime: 0,
                    maxConstraintTime: 0,
                    maxJointTime: 0,
                    totalObjects: 0,
                    activeObjects: 0,
                    sleepingObjects: 0,
                    totalBroadPhase: 0,
                    totalNarrowPhase: 0,
                    totalResponse: 0,
                    totalSolver: 0
                }
            };

            this.savePhysicsStats();
        }
    },

    /**
     * 保存物理统计
     */
    savePhysicsStats: function () {
        localStorage.setItem('physicsStats', JSON.stringify(this.physicsStats));
    },

    /**
     * 加载物理缓存
     */
    loadPhysicsCache: function () {
        const savedCache = localStorage.getItem('physicsCache');
        if (savedCache) {
            try {
                this.physicsCache = JSON.parse(savedCache);
            } catch (error) {
                console.error('加载物理缓存失败:', error);
            }
        }

        if (!this.physicsCache.cache) {
            this.physicsCache = {
                cache: {},
                stats: {
                    size: 0,
                    hits: 0,
                    misses: 0,
                    hitRate: 0
                }
            };

            this.savePhysicsCache();
        }
    },

    /**
     * 保存物理缓存
     */
    savePhysicsCache: function () {
        localStorage.setItem('physicsCache', JSON.stringify(this.physicsCache));
    },

    /**
     * 初始化物理系统
     */
    initPhysicsSystem: function () {
        // 初始化物理世界
        this.physicsWorld = {
            gravity: this.physicsConfig.gravity,
            objects: [],
            constraints: [],
            joints: [],
            spatialHash: {}
        };

        // 初始化物理对象池
        this.physicsObjectPool = [];

        // 启动性能分析
        if (this.physicsConfig.useProfiling) {
            this.startProfiling();
        }
    },

    /**
     * 启动性能分析
     */
    startProfiling: function () {
        setInterval(() => {
            if (this.physicsConfig.useProfiling) {
                this.profilePhysics();
            }
        }, this.physicsConfig.profilingInterval);
    },

    /**
     * 性能分析
     */
    profilePhysics: function () {
        // 实现性能分析逻辑

        // 更新统计
        this.physicsStats.stats.totalUpdates++;

        this.savePhysicsStats();
    },

    /**
     * 优化物理
     */
    optimizePhysics: function () {
        // 启用重力
        if (this.physicsConfig.useGravity) {
            this.enableGravity();
        }

        // 启用摩擦力
        if (this.physicsConfig.useFriction) {
            this.enableFriction();
        }

        // 启用碰撞检测
        if (this.physicsConfig.useCollisionDetection) {
            this.enableCollisionDetection();
        }

        // 启用空间哈希
        if (this.physicsConfig.useSpatialHashing) {
            this.enableSpatialHashing();
        }

        // 启用连续碰撞检测
        if (this.physicsConfig.useContinuousCollision) {
            this.enableContinuousCollision();
        }

        // 启用子步进
        if (this.physicsConfig.useSubStepping) {
            this.enableSubStepping();
        }

        // 启用休眠
        if (this.physicsConfig.useSleeping) {
            this.enableSleeping();
        }

        // 启用宽相
        if (this.physicsConfig.useBroadPhase) {
            this.enableBroadPhase();
        }

        // 启用窄相
        if (this.physicsConfig.useNarrowPhase) {
            this.enableNarrowPhase();
        }

        // 启用响应
        if (this.physicsConfig.useResponse) {
            this.enableResponse();
        }

        // 启用求解器
        if (this.physicsConfig.useSolver) {
            this.enableSolver();
        }

        // 启用热启动
        if (this.physicsConfig.useWarmStarting) {
            this.enableWarmStarting();
        }

        // 启用恢复系数
        if (this.physicsConfig.useRestitution) {
            this.enableRestitution();
        }

        // 启用阻尼
        if (this.physicsConfig.useDamping) {
            this.enableDamping();
        }

        // 启用约束
        if (this.physicsConfig.useConstraints) {
            this.enableConstraints();
        }

        // 启用关节
        if (this.physicsConfig.useJoints) {
            this.enableJoints();
        }

        // 启用射线投射
        if (this.physicsConfig.useRaycasting) {
            this.enableRaycasting();
        }
    },

    /**
     * 启用重力
     */
    enableGravity: function () {
        // 实现重力逻辑
    },

    /**
     * 启用摩擦力
     */
    enableFriction: function () {
        // 实现摩擦力逻辑
    },

    /**
     * 启用碰撞检测
     */
    enableCollisionDetection: function () {
        // 实现碰撞检测逻辑
    },

    /**
     * 启用空间哈希
     */
    enableSpatialHashing: function () {
        // 实现空间哈希逻辑
    },

    /**
     * 启用连续碰撞检测
     */
    enableContinuousCollision: function () {
        // 实现连续碰撞检测逻辑
    },

    /**
     * 启用子步进
     */
    enableSubStepping: function () {
        // 实现子步进逻辑
    },

    /**
     * 启用休眠
     */
    enableSleeping: function () {
        // 实现休眠逻辑
    },

    /**
     * 启用宽相
     */
    enableBroadPhase: function () {
        // 实现宽相逻辑
    },

    /**
     * 启用窄相
     */
    enableNarrowPhase: function () {
        // 实现窄相逻辑
    },

    /**
     * 启用响应
     */
    enableResponse: function () {
        // 实现响应逻辑
    },

    /**
     * 启用求解器
     */
    enableSolver: function () {
        // 实现求解器逻辑
    },

    /**
     * 启用热启动
     */
    enableWarmStarting: function () {
        // 实现热启动逻辑
    },

    /**
     * 启用恢复系数
     */
    enableRestitution: function () {
        // 实现恢复系数逻辑
    },

    /**
     * 启用阻尼
     */
    enableDamping: function () {
        // 实现阻尼逻辑
    },

    /**
     * 启用约束
     */
    enableConstraints: function () {
        // 实现约束逻辑
    },

    /**
     * 启用关节
     */
    enableJoints: function () {
        // 实现关节逻辑
    },

    /**
     * 启用射线投射
     */
    enableRaycasting: function () {
        // 实现射线投射逻辑
    },

    /**
     * 更新物理
     * @param {number} deltaTime - 时间增量
     */
    updatePhysics: function (deltaTime) {
        if (!this.physicsConfig.enabled) {
            return;
        }

        const startTime = performance.now();

        // 应用重力
        if (this.physicsConfig.useGravity) {
            this.applyGravity();
        }

        // 应用摩擦力
        if (this.physicsConfig.useFriction) {
            this.applyFriction();
        }

        // 更新位置
        this.updatePositions(deltaTime);

        // 碰撞检测
        if (this.physicsConfig.useCollisionDetection) {
            this.detectCollisions();
        }

        // 应用阻尼
        if (this.physicsConfig.useDamping) {
            this.applyDamping();
        }

        // 求解约束
        if (this.physicsConfig.useConstraints) {
            this.solveConstraints();
        }

        // 求解关节
        if (this.physicsConfig.useJoints) {
            this.solveJoints();
        }

        const endTime = performance.now();
        const updateTime = endTime - startTime;

        // 更新统计
        this.physicsStats.stats.totalUpdates++;
        this.physicsStats.stats.averageUpdateTime =
            (this.physicsStats.stats.averageUpdateTime * (this.physicsStats.stats.totalUpdates - 1) + updateTime) /
            this.physicsStats.stats.totalUpdates;
        this.physicsStats.stats.maxUpdateTime = Math.max(this.physicsStats.stats.maxUpdateTime, updateTime);

        this.savePhysicsStats();
    },

    /**
     * 应用重力
     */
    applyGravity: function () {
        // 实现重力应用逻辑
    },

    /**
     * 应用摩擦力
     */
    applyFriction: function () {
        // 实现摩擦力应用逻辑
    },

    /**
     * 更新位置
     * @param {number} deltaTime - 时间增量
     */
    updatePositions: function (deltaTime) {
        // 实现位置更新逻辑
    },

    /**
     * 检测碰撞
     */
    detectCollisions: function () {
        const startTime = performance.now();

        // 实现碰撞检测逻辑

        const endTime = performance.now();
        const collisionTime = endTime - startTime;

        // 更新统计
        this.physicsStats.stats.totalCollisions++;
        this.physicsStats.stats.averageCollisionTime =
            (this.physicsStats.stats.averageCollisionTime * (this.physicsStats.stats.totalCollisions - 1) + collisionTime) /
            this.physicsStats.stats.totalCollisions;
        this.physicsStats.stats.maxCollisionTime = Math.max(this.physicsStats.stats.maxCollisionTime, collisionTime);

        this.savePhysicsStats();
    },

    /**
     * 应用阻尼
     */
    applyDamping: function () {
        // 实现阻尼应用逻辑
    },

    /**
     * 求解约束
     */
    solveConstraints: function () {
        // 实现约束求解逻辑
    },

    /**
     * 求解关节
     */
    solveJoints: function () {
        // 实现关节求解逻辑
    },

    /**
     * 射线投射
     * @param {Object} ray - 射线对象
     * @returns {Object|null} 射线投射结果
     */
    raycast: function (ray) {
        if (!this.physicsConfig.useRaycasting) {
            return null;
        }

        const startTime = performance.now();

        // 实现射线投射逻辑

        const endTime = performance.now();
        const raycastTime = endTime - startTime;

        // 更新统计
        this.physicsStats.stats.totalRaycasts++;
        this.physicsStats.stats.averageRaycastTime =
            (this.physicsStats.stats.averageRaycastTime * (this.physicsStats.stats.totalRaycasts - 1) + raycastTime) /
            this.physicsStats.stats.totalRaycasts;
        this.physicsStats.stats.maxRaycastTime = Math.max(this.physicsStats.stats.maxRaycastTime, raycastTime);

        this.savePhysicsStats();

        return null;
    },

    /**
     * 获取物理统计
     * @returns {Object} 统计信息
     */
    getStats: function () {
        return this.physicsStats.stats;
    },

    /**
     * 设置物理配置
     * @param {Object} config - 配置对象
     */
    setPhysicsConfig: function (config) {
        this.physicsConfig = { ...this.physicsConfig, ...config };
        this.savePhysicsConfig();
    },

    /**
     * 获取物理配置
     * @returns {Object} 配置对象
     */
    getPhysicsConfig: function () {
        return this.physicsConfig;
    }
};
 
 / /   OS�8nbA I OS
 
 const GameAIOptimizer = { init: function() { console.log(\"AI�Ż���ʼ��\"); } }
GameAIOptimizer.aiConfig = { enabled: true, usePathfinding: true, useBehaviorTree: true, useMemory: true };
GameAIOptimizer.aiStats = { stats: { totalDecisions: 0 } };
GameAIOptimizer.init = function() { this.loadAIConfig(); this.optimizeAI(); };
GameAIOptimizer.loadAIConfig = function() { 
    const customConfig = localStorage.getItem('aiConfig');
    if (customConfig) { try { this.aiConfig = { ...this.aiConfig, ...JSON.parse(customConfig) }; } catch(e) {} }
};
GameAIOptimizer.optimizeAI = function() { 
    if (this.aiConfig.usePathfinding) this.enablePathfinding(); 
    if (this.aiConfig.useBehaviorTree) this.enableBehaviorTree();
    if (this.aiConfig.useMemory) this.enableMemory();
};
GameAIOptimizer.enablePathfinding = function() { console.log('Ѱ·������'); };
GameAIOptimizer.enableBehaviorTree = function() { console.log('��Ϊ��������'); };
GameAIOptimizer.enableMemory = function() { console.log('����������'); };
GameAIOptimizer.updateAI = function(dt) { 
    if (!this.aiConfig.enabled) return;
    this.aiStats.stats.totalDecisions++;
    localStorage.setItem('aiStats', JSON.stringify(this.aiStats));
};
GameAIOptimizer.getStats = function() { return this.aiStats.stats; };

// �Ż�����Ϸ�����Ż�
const GameNetworkOptimizer = { 
    networkConfig: { enabled: false, useWebSocket: false, useHTTP: true, useCaching: true, useCompression: true },
    networkStats: { stats: { totalRequests: 0, totalResponses: 0, totalErrors: 0, averageLatency: 0 } },
    networkCache: { cache: {}, stats: { hits: 0, misses: 0, hitRate: 0 } },
    init: function() { this.loadNetworkConfig(); this.loadNetworkStats(); this.loadNetworkCache(); this.initNetworkSystem(); this.optimizeNetwork(); },
    loadNetworkConfig: function() { 
        const customConfig = localStorage.getItem('networkConfig');
        if (customConfig) { try { this.networkConfig = { ...this.networkConfig, ...JSON.parse(customConfig) }; } catch(e) {} }
    },
    saveNetworkConfig: function() { localStorage.setItem('networkConfig', JSON.stringify(this.networkConfig)); },
    loadNetworkStats: function() { 
        const savedStats = localStorage.getItem('networkStats');
        if (savedStats) { try { this.networkStats = JSON.parse(savedStats); } catch(e) {} }
        if (!this.networkStats.stats) { this.networkStats = { stats: { totalRequests: 0, totalResponses: 0, totalErrors: 0, averageLatency: 0 } }; this.saveNetworkStats(); }
    },
    saveNetworkStats: function() { localStorage.setItem('networkStats', JSON.stringify(this.networkStats)); },
    loadNetworkCache: function() { 
        const savedCache = localStorage.getItem('networkCache');
        if (savedCache) { try { this.networkCache = JSON.parse(savedCache); } catch(e) {} }
        if (!this.networkCache.cache) { this.networkCache = { cache: {}, stats: { hits: 0, misses: 0, hitRate: 0 } }; this.saveNetworkCache(); }
    },
    saveNetworkCache: function() { localStorage.setItem('networkCache', JSON.stringify(this.networkCache)); },
    initNetworkSystem: function() { this.networkWorld = { connections: [], requests: [], responses: [] }; },
    optimizeNetwork: function() { 
        if (this.networkConfig.useCaching) this.enableCaching(); 
        if (this.networkConfig.useCompression) this.enableCompression();
        if (this.networkConfig.useWebSocket) this.enableWebSocket();
    },
    enableCaching: function() { console.log('����������'); },
    enableCompression: function() { console.log('ѹ��������'); },
    enableWebSocket: function() { console.log('WebSocket������'); },
    sendRequest: function(url, options) { 
        if (!this.networkConfig.enabled) return Promise.reject('����δ����');
        this.networkStats.stats.totalRequests++;
        const startTime = performance.now();
        return fetch(url, options).then(response => { 
            const endTime = performance.now();
            const latency = endTime - startTime;
            this.networkStats.stats.totalResponses++;
            this.networkStats.stats.averageLatency = (this.networkStats.stats.averageLatency * (this.networkStats.stats.totalResponses - 1) + latency) / this.networkStats.stats.totalResponses;
            this.saveNetworkStats();
            return response;
        }).catch(error => { 
            this.networkStats.stats.totalErrors++;
            this.saveNetworkStats();
            throw error;
        });
    },
    getStats: function() { return this.networkStats.stats; },
    setNetworkConfig: function(config) { this.networkConfig = { ...this.networkConfig, ...config }; this.saveNetworkConfig(); },
    getNetworkConfig: function() { return this.networkConfig; }
};

// �Ż�����Ϸ�洢�Ż�
const GameStorageOptimizer = { 
    storageConfig: { enabled: true, useLocalStorage: true, useIndexedDB: false, useCompression: true, useEncryption: false },
    storageStats: { stats: { totalReads: 0, totalWrites: 0, totalDeletes: 0, totalErrors: 0, averageReadTime: 0, averageWriteTime: 0 } },
    storageCache: { cache: {}, stats: { hits: 0, misses: 0, hitRate: 0 } },
    init: function() { this.loadStorageConfig(); this.loadStorageStats(); this.loadStorageCache(); this.initStorageSystem(); this.optimizeStorage(); },
    loadStorageConfig: function() { 
        const customConfig = localStorage.getItem('storageConfig');
        if (customConfig) { try { this.storageConfig = { ...this.storageConfig, ...JSON.parse(customConfig) }; } catch(e) {} }
    },
    saveStorageConfig: function() { localStorage.setItem('storageConfig', JSON.stringify(this.storageConfig)); },
    loadStorageStats: function() { 
        const savedStats = localStorage.getItem('storageStats');
        if (savedStats) { try { this.storageStats = JSON.parse(savedStats); } catch(e) {} }
        if (!this.storageStats.stats) { this.storageStats = { stats: { totalReads: 0, totalWrites: 0, totalDeletes: 0, totalErrors: 0, averageReadTime: 0, averageWriteTime: 0 } }; this.saveStorageStats(); }
    },
    saveStorageStats: function() { localStorage.setItem('storageStats', JSON.stringify(this.storageStats)); },
    loadStorageCache: function() { 
        const savedCache = localStorage.getItem('storageCache');
        if (savedCache) { try { this.storageCache = JSON.parse(savedCache); } catch(e) {} }
        if (!this.storageCache.cache) { this.storageCache = { cache: {}, stats: { hits: 0, misses: 0, hitRate: 0 } }; this.saveStorageCache(); }
    },
    saveStorageCache: function() { localStorage.setItem('storageCache', JSON.stringify(this.storageCache)); },
    initStorageSystem: function() { this.storageWorld = { data: {}, indexes: {} }; },
    optimizeStorage: function() { 
        if (this.storageConfig.useCompression) this.enableCompression(); 
        if (this.storageConfig.useEncryption) this.enableEncryption();
        if (this.storageConfig.useIndexedDB) this.enableIndexedDB();
    },
    enableCompression: function() { console.log('ѹ��������'); },
    enableEncryption: function() { console.log('����������'); },
    enableIndexedDB: function() { console.log('IndexedDB������'); },
    read: function(key) { 
        if (!this.storageConfig.enabled) return null;
        this.storageStats.stats.totalReads++;
        const startTime = performance.now();
        try {
            let data = null;
            if (this.storageConfig.useLocalStorage) { data = localStorage.getItem(key); }
            if (this.storageCache.cache[key]) { this.storageCache.stats.hits++; } else { this.storageCache.stats.misses++; }
            const endTime = performance.now();
            const readTime = endTime - startTime;
            this.storageStats.stats.averageReadTime = (this.storageStats.stats.averageReadTime * (this.storageStats.stats.totalReads - 1) + readTime) / this.storageStats.stats.totalReads;
            this.saveStorageStats();
            return data;
        } catch(error) { 
            this.storageStats.stats.totalErrors++;
            this.saveStorageStats();
            throw error;
        }
    },
    write: function(key, value) { 
        if (!this.storageConfig.enabled) return false;
        this.storageStats.stats.totalWrites++;
        const startTime = performance.now();
        try {
            if (this.storageConfig.useLocalStorage) { localStorage.setItem(key, value); }
            this.storageCache.cache[key] = value;
            const endTime = performance.now();
            const writeTime = endTime - startTime;
            this.storageStats.stats.averageWriteTime = (this.storageStats.stats.averageWriteTime * (this.storageStats.stats.totalWrites - 1) + writeTime) / this.storageStats.stats.totalWrites;
            this.saveStorageStats();
            this.saveStorageCache();
            return true;
        } catch(error) { 
            this.storageStats.stats.totalErrors++;
            this.saveStorageStats();
            throw error;
        }
    },
    delete: function(key) { 
        if (!this.storageConfig.enabled) return false;
        this.storageStats.stats.totalDeletes++;
        try {
            if (this.storageConfig.useLocalStorage) { localStorage.removeItem(key); }
            delete this.storageCache.cache[key];
            this.saveStorageCache();
            this.saveStorageStats();
            return true;
        } catch(error) { 
            this.storageStats.stats.totalErrors++;
            this.saveStorageStats();
            throw error;
        }
    },
    getStats: function() { return this.storageStats.stats; },
    setStorageConfig: function(config) { this.storageConfig = { ...this.storageConfig, ...config }; this.saveStorageConfig(); },
    getStorageConfig: function() { return this.storageConfig; }
};

// �Ż�����Ϸ��ȫ�Ż�
const GameSecurityOptimizer = { 
    securityConfig: { enabled: true, useEncryption: true, useAuthentication: false, useValidation: true, useSanitization: true },
    securityStats: { stats: { totalChecks: 0, totalValidations: 0, totalEncryptions: 0, totalDecryptions: 0, totalErrors: 0, averageCheckTime: 0, averageValidationTime: 0 } },
    securityCache: { cache: {}, stats: { hits: 0, misses: 0, hitRate: 0 } },
    init: function() { this.loadSecurityConfig(); this.loadSecurityStats(); this.loadSecurityCache(); this.initSecuritySystem(); this.optimizeSecurity(); },
    loadSecurityConfig: function() { 
        const customConfig = localStorage.getItem('securityConfig');
        if (customConfig) { try { this.securityConfig = { ...this.securityConfig, ...JSON.parse(customConfig) }; } catch(e) {} }
    },
    saveSecurityConfig: function() { localStorage.setItem('securityConfig', JSON.stringify(this.securityConfig)); },
    loadSecurityStats: function() { 
        const savedStats = localStorage.getItem('securityStats');
        if (savedStats) { try { this.securityStats = JSON.parse(savedStats); } catch(e) {} }
        if (!this.securityStats.stats) { this.securityStats = { stats: { totalChecks: 0, totalValidations: 0, totalEncryptions: 0, totalDecryptions: 0, totalErrors: 0, averageCheckTime: 0, averageValidationTime: 0 } }; this.saveSecurityStats(); }
    },
    saveSecurityStats: function() { localStorage.setItem('securityStats', JSON.stringify(this.securityStats)); },
    loadSecurityCache: function() { 
        const savedCache = localStorage.getItem('securityCache');
        if (savedCache) { try { this.securityCache = JSON.parse(savedCache); } catch(e) {} }
        if (!this.securityCache.cache) { this.securityCache = { cache: {}, stats: { hits: 0, misses: 0, hitRate: 0 } }; this.saveSecurityCache(); }
    },
    saveSecurityCache: function() { localStorage.setItem('securityCache', JSON.stringify(this.securityCache)); },
    initSecuritySystem: function() { this.securityWorld = { users: [], sessions: [], tokens: [] }; },
    optimizeSecurity: function() { 
        if (this.securityConfig.useEncryption) this.enableEncryption(); 
        if (this.securityConfig.useAuthentication) this.enableAuthentication();
        if (this.securityConfig.useValidation) this.enableValidation();
        if (this.securityConfig.useSanitization) this.enableSanitization();
    },
    enableEncryption: function() { console.log('����������'); },
    enableAuthentication: function() { console.log('������֤������'); },
    enableValidation: function() { console.log('��֤������'); },
    enableSanitization: function() { console.log('����������'); },
    encrypt: function(data) { 
        if (!this.securityConfig.enabled) return data;
        this.securityStats.stats.totalEncryptions++;
        try {
            let encrypted = data;
            if (this.securityConfig.useEncryption) { encrypted = btoa(encodeURIComponent(data)); }
            this.saveSecurityStats();
            return encrypted;
        } catch(error) { 
            this.securityStats.stats.totalErrors++;
            this.saveSecurityStats();
            throw error;
        }
    },
    decrypt: function(data) { 
        if (!this.securityConfig.enabled) return data;
        this.securityStats.stats.totalDecryptions++;
        try {
            let decrypted = data;
            if (this.securityConfig.useEncryption) { decrypted = decodeURIComponent(atob(data)); }
            this.saveSecurityStats();
            return decrypted;
        } catch(error) { 
            this.securityStats.stats.totalErrors++;
            this.saveSecurityStats();
            throw error;
        }
    },
    validate: function(data) { 
        if (!this.securityConfig.enabled) return true;
        this.securityStats.stats.totalValidations++;
        const startTime = performance.now();
        try {
            let valid = true;
            if (this.securityConfig.useValidation) { valid = data !== null && data !== undefined && data !== ''; }
            const endTime = performance.now();
            const validationTime = endTime - startTime;
            this.securityStats.stats.averageValidationTime = (this.securityStats.stats.averageValidationTime * (this.securityStats.stats.totalValidations - 1) + validationTime) / this.securityStats.stats.totalValidations;
            this.saveSecurityStats();
            return valid;
        } catch(error) { 
            this.securityStats.stats.totalErrors++;
            this.saveSecurityStats();
            throw error;
        }
    },
    sanitize: function(data) { 
        if (!this.securityConfig.enabled) return data;
        try {
            let sanitized = data;
            if (this.securityConfig.useSanitization) { sanitized = data.toString().replace(/[<>\"'&]/g, ''); }
            return sanitized;
        } catch(error) { 
            this.securityStats.stats.totalErrors++;
            this.saveSecurityStats();
            throw error;
        }
    },
    checkSecurity: function() { 
        if (!this.securityConfig.enabled) return true;
        this.securityStats.stats.totalChecks++;
        const startTime = performance.now();
        try {
            const secure = true;
            const endTime = performance.now();
            const checkTime = endTime - startTime;
            this.securityStats.stats.averageCheckTime = (this.securityStats.stats.averageCheckTime * (this.securityStats.stats.totalChecks - 1) + checkTime) / this.securityStats.stats.totalChecks;
            this.saveSecurityStats();
            return secure;
        } catch(error) { 
            this.securityStats.stats.totalErrors++;
            this.saveSecurityStats();
            throw error;
        }
    },
    getStats: function() { return this.securityStats.stats; },
    setSecurityConfig: function(config) { this.securityConfig = { ...this.securityConfig, ...config }; this.saveSecurityConfig(); },
    getSecurityConfig: function() { return this.securityConfig; }
};

// �Ż�����Ϸ��־�Ż�
const GameLogOptimizer = { 
    logConfig: { enabled: true, useConsole: true, useFile: false, useBuffering: true, bufferSize: 100 },
    logStats: { stats: { totalLogs: 0, totalErrors: 0, totalWarnings: 0, totalInfo: 0, totalDebug: 0, averageLogTime: 0 } },
    logCache: { cache: [], stats: { size: 0, hits: 0, misses: 0, hitRate: 0 } },
    init: function() { this.loadLogConfig(); this.loadLogStats(); this.loadLogCache(); this.initLogSystem(); this.optimizeLog(); },
    loadLogConfig: function() { 
        const customConfig = localStorage.getItem('logConfig');
        if (customConfig) { try { this.logConfig = { ...this.logConfig, ...JSON.parse(customConfig) }; } catch(e) {} }
    },
    saveLogConfig: function() { localStorage.setItem('logConfig', JSON.stringify(this.logConfig)); },
    loadLogStats: function() { 
        const savedStats = localStorage.getItem('logStats');
        if (savedStats) { try { this.logStats = JSON.parse(savedStats); } catch(e) {} }
        if (!this.logStats.stats) { this.logStats = { stats: { totalLogs: 0, totalErrors: 0, totalWarnings: 0, totalInfo: 0, totalDebug: 0, averageLogTime: 0 } }; this.saveLogStats(); }
    },
    saveLogStats: function() { localStorage.setItem('logStats', JSON.stringify(this.logStats)); },
    loadLogCache: function() { 
        const savedCache = localStorage.getItem('logCache');
        if (savedCache) { try { this.logCache = JSON.parse(savedCache); } catch(e) {} }
        if (!this.logCache.cache) { this.logCache = { cache: [], stats: { size: 0, hits: 0, misses: 0, hitRate: 0 } }; this.saveLogCache(); }
    },
    saveLogCache: function() { localStorage.setItem('logCache', JSON.stringify(this.logCache)); },
    initLogSystem: function() { this.logWorld = { logs: [], errors: [], warnings: [] }; },
    optimizeLog: function() { 
        if (this.logConfig.useBuffering) this.enableBuffering(); 
        if (this.logConfig.useConsole) this.enableConsole();
        if (this.logConfig.useFile) this.enableFile();
    },
    enableBuffering: function() { console.log('����������'); },
    enableConsole: function() { console.log('����̨������'); },
    enableFile: function() { console.log('�ļ�������'); },
    log: function(message, level) { 
        if (!this.logConfig.enabled) return;
        this.logStats.stats.totalLogs++;
        const startTime = performance.now();
        try {
            const logEntry = { message, level, timestamp: Date.now() };
            if (this.logConfig.useBuffering) { this.logCache.cache.push(logEntry); if (this.logCache.cache.length >= this.logConfig.bufferSize) this.flush(); }
            if (this.logConfig.useConsole) { console.log(`[${level.toUpperCase()}] ${message}`); }
            if (level === 'error') { this.logStats.stats.totalErrors++; } else if (level === 'warning') { this.logStats.stats.totalWarnings++; } else if (level === 'info') { this.logStats.stats.totalInfo++; } else if (level === 'debug') { this.logStats.stats.totalDebug++; }
            const endTime = performance.now();
            const logTime = endTime - startTime;
            this.logStats.stats.averageLogTime = (this.logStats.stats.averageLogTime * (this.logStats.stats.totalLogs - 1) + logTime) / this.logStats.stats.totalLogs;
            this.saveLogStats();
            this.saveLogCache();
        } catch(error) { 
            this.logStats.stats.totalErrors++;
            this.saveLogStats();
            throw error;
        }
    },
    info: function(message) { this.log(message, 'info'); },
    warn: function(message) { this.log(message, 'warning'); },
    error: function(message) { this.log(message, 'error'); },
    debug: function(message) { this.log(message, 'debug'); },
    flush: function() { 
        if (!this.logConfig.enabled) return;
        try {
            this.logCache.cache = [];
            this.saveLogCache();
        } catch(error) { 
            this.logStats.stats.totalErrors++;
            this.saveLogStats();
            throw error;
        }
    },
    clear: function() { 
        if (!this.logConfig.enabled) return;
        try {
            this.logCache.cache = [];
            this.saveLogCache();
        } catch(error) { 
            this.logStats.stats.totalErrors++;
            this.saveLogStats();
            throw error;
        }
    },
    getLogs: function() { return this.logCache.cache; },
    getStats: function() { return this.logStats.stats; },
    setLogConfig: function(config) { this.logConfig = { ...this.logConfig, ...config }; this.saveLogConfig(); },
    getLogConfig: function() { return this.logConfig; }
};

// �Ż�����Ϸ�����Ż�
const GamePerformanceOptimizer = { 
    performanceConfig: { enabled: true, useProfiling: true, useMonitoring: true, useOptimization: true, useCaching: true },
    performanceStats: { stats: { totalFrames: 0, totalUpdates: 0, totalDraws: 0, averageFPS: 0, averageUpdateTime: 0, averageDrawTime: 0, maxFPS: 0, minFPS: 0 } },
    performanceCache: { cache: {}, stats: { hits: 0, misses: 0, hitRate: 0 } },
    init: function() { this.loadPerformanceConfig(); this.loadPerformanceStats(); this.loadPerformanceCache(); this.initPerformanceSystem(); this.optimizePerformance(); },
    loadPerformanceConfig: function() { 
        const customConfig = localStorage.getItem('performanceConfig');
        if (customConfig) { try { this.performanceConfig = { ...this.performanceConfig, ...JSON.parse(customConfig) }; } catch(e) {} }
    },
    savePerformanceConfig: function() { localStorage.setItem('performanceConfig', JSON.stringify(this.performanceConfig)); },
    loadPerformanceStats: function() { 
        const savedStats = localStorage.getItem('performanceStats');
        if (savedStats) { try { this.performanceStats = JSON.parse(savedStats); } catch(e) {} }
        if (!this.performanceStats.stats) { this.performanceStats = { stats: { totalFrames: 0, totalUpdates: 0, totalDraws: 0, averageFPS: 0, averageUpdateTime: 0, averageDrawTime: 0, maxFPS: 0, minFPS: 0 } }; this.savePerformanceStats(); }
    },
    savePerformanceStats: function() { localStorage.setItem('performanceStats', JSON.stringify(this.performanceStats)); },
    loadPerformanceCache: function() { 
        const savedCache = localStorage.getItem('performanceCache');
        if (savedCache) { try { this.performanceCache = JSON.parse(savedCache); } catch(e) {} }
        if (!this.performanceCache.cache) { this.performanceCache = { cache: {}, stats: { hits: 0, misses: 0, hitRate: 0 } }; this.savePerformanceCache(); }
    },
    savePerformanceCache: function() { localStorage.setItem('performanceCache', JSON.stringify(this.performanceCache)); },
    initPerformanceSystem: function() { this.performanceWorld = { metrics: {}, profiles: {}, monitors: {} }; },
    optimizePerformance: function() { 
        if (this.performanceConfig.useProfiling) this.enableProfiling(); 
        if (this.performanceConfig.useMonitoring) this.enableMonitoring();
        if (this.performanceConfig.useOptimization) this.enableOptimization();
        if (this.performanceConfig.useCaching) this.enableCaching();
    },
    enableProfiling: function() { console.log('���ܷ���������'); },
    enableMonitoring: function() { console.log('���ܼ��������'); },
    enableOptimization: function() { console.log('�����Ż�������'); },
    enableCaching: function() { console.log('���ܻ���������'); },
    startProfiling: function() { 
        if (!this.performanceConfig.enabled) return;
        try {
            this.performanceWorld.profiling = true;
            this.performanceWorld.startTime = performance.now();
        } catch(error) { 
            this.performanceStats.stats.totalErrors++;
            this.savePerformanceStats();
            throw error;
        }
    },
    stopProfiling: function() { 
        if (!this.performanceConfig.enabled) return;
        try {
            this.performanceWorld.profiling = false;
            const endTime = performance.now();
            const duration = endTime - this.performanceWorld.startTime;
            return duration;
        } catch(error) { 
            this.performanceStats.stats.totalErrors++;
            this.savePerformanceStats();
            throw error;
        }
    },
    measureFPS: function() { 
        if (!this.performanceConfig.enabled) return 0;
        try {
            const now = performance.now();
            if (!this.performanceWorld.lastFrameTime) { this.performanceWorld.lastFrameTime = now; return 0; }
            const delta = now - this.performanceWorld.lastFrameTime;
            this.performanceWorld.lastFrameTime = now;
            const fps = 1000 / delta;
            this.performanceStats.stats.totalFrames++;
            this.performanceStats.stats.averageFPS = (this.performanceStats.stats.averageFPS * (this.performanceStats.stats.totalFrames - 1) + fps) / this.performanceStats.stats.totalFrames;
            this.performanceStats.stats.maxFPS = Math.max(this.performanceStats.stats.maxFPS, fps);
            this.performanceStats.stats.minFPS = Math.min(this.performanceStats.stats.minFPS, fps) || fps;
            this.savePerformanceStats();
            return fps;
        } catch(error) { 
            this.performanceStats.stats.totalErrors++;
            this.savePerformanceStats();
            throw error;
        }
    },
    measureUpdate: function() { 
        if (!this.performanceConfig.enabled) return 0;
        try {
            const startTime = performance.now();
            return () => {
                const endTime = performance.now();
                const updateTime = endTime - startTime;
                this.performanceStats.stats.totalUpdates++;
                this.performanceStats.stats.averageUpdateTime = (this.performanceStats.stats.averageUpdateTime * (this.performanceStats.stats.totalUpdates - 1) + updateTime) / this.performanceStats.stats.totalUpdates;
                this.savePerformanceStats();
                return updateTime;
            };
        } catch(error) { 
            this.performanceStats.stats.totalErrors++;
            this.savePerformanceStats();
            throw error;
        }
    },
    measureDraw: function() { 
        if (!this.performanceConfig.enabled) return 0;
        try {
            const startTime = performance.now();
            return () => {
                const endTime = performance.now();
                const drawTime = endTime - startTime;
                this.performanceStats.stats.totalDraws++;
                this.performanceStats.stats.averageDrawTime = (this.performanceStats.stats.averageDrawTime * (this.performanceStats.stats.totalDraws - 1) + drawTime) / this.performanceStats.stats.totalDraws;
                this.savePerformanceStats();
                return drawTime;
            };
        } catch(error) { 
            this.performanceStats.stats.totalErrors++;
            this.savePerformanceStats();
            throw error;
        }
    },
    getStats: function() { return this.performanceStats.stats; },
    setPerformanceConfig: function(config) { this.performanceConfig = { ...this.performanceConfig, ...config }; this.savePerformanceConfig(); },
    getPerformanceConfig: function() { return this.performanceConfig; }
};

// �Ż�����Ϸ�ڴ��Ż�
const GameMemoryOptimizer = { 
    memoryConfig: { enabled: true, usePool: true, useGarbageCollection: true, useCompression: true, useLazyLoading: false },
    memoryStats: { stats: { totalAllocations: 0, totalDeallocations: 0, totalReallocations: 0, totalMemoryUsed: 0, totalMemoryFreed: 0, averageAllocationTime: 0, averageDeallocationTime: 0 } },
    memoryCache: { cache: {}, stats: { size: 0, hits: 0, misses: 0, hitRate: 0 } },
    init: function() { this.loadMemoryConfig(); this.loadMemoryStats(); this.loadMemoryCache(); this.initMemorySystem(); this.optimizeMemory(); },
    loadMemoryConfig: function() { 
        const customConfig = localStorage.getItem('memoryConfig');
        if (customConfig) { try { this.memoryConfig = { ...this.memoryConfig, ...JSON.parse(customConfig) }; } catch(e) {} }
    },
    saveMemoryConfig: function() { localStorage.setItem('memoryConfig', JSON.stringify(this.memoryConfig)); },
    loadMemoryStats: function() { 
        const savedStats = localStorage.getItem('memoryStats');
        if (savedStats) { try { this.memoryStats = JSON.parse(savedStats); } catch(e) {} }
        if (!this.memoryStats.stats) { this.memoryStats = { stats: { totalAllocations: 0, totalDeallocations: 0, totalReallocations: 0, totalMemoryUsed: 0, totalMemoryFreed: 0, averageAllocationTime: 0, averageDeallocationTime: 0 } }; this.saveMemoryStats(); }
    },
    saveMemoryStats: function() { localStorage.setItem('memoryStats', JSON.stringify(this.memoryStats)); },
    loadMemoryCache: function() { 
        const savedCache = localStorage.getItem('memoryCache');
        if (savedCache) { try { this.memoryCache = JSON.parse(savedCache); } catch(e) {} }
        if (!this.memoryCache.cache) { this.memoryCache = { cache: {}, stats: { size: 0, hits: 0, misses: 0, hitRate: 0 } }; this.saveMemoryCache(); }
    },
    saveMemoryCache: function() { localStorage.setItem('memoryCache', JSON.stringify(this.memoryCache)); },
    initMemorySystem: function() { this.memoryWorld = { pools: {}, allocations: {}, deallocations: {} }; },
    optimizeMemory: function() { 
        if (this.memoryConfig.usePool) this.enablePool(); 
        if (this.memoryConfig.useGarbageCollection) this.enableGarbageCollection();
        if (this.memoryConfig.useCompression) this.enableCompression();
        if (this.memoryConfig.useLazyLoading) this.enableLazyLoading();
    },
    enablePool: function() { console.log('�����������'); },
    enableGarbageCollection: function() { console.log('��������������'); },
    enableCompression: function() { console.log('�ڴ�ѹ��������'); },
    enableLazyLoading: function() { console.log('������������'); },
    allocate: function(size) { 
        if (!this.memoryConfig.enabled) return null;
        this.memoryStats.stats.totalAllocations++;
        const startTime = performance.now();
        try {
            let allocation = null;
            if (this.memoryConfig.usePool) { allocation = this.getFromPool(size); }
            if (!allocation) { allocation = new ArrayBuffer(size); }
            this.memoryStats.stats.totalMemoryUsed += size;
            const endTime = performance.now();
            const allocationTime = endTime - startTime;
            this.memoryStats.stats.averageAllocationTime = (this.memoryStats.stats.averageAllocationTime * (this.memoryStats.stats.totalAllocations - 1) + allocationTime) / this.memoryStats.stats.totalAllocations;
            this.saveMemoryStats();
            return allocation;
        } catch(error) { 
            this.memoryStats.stats.totalErrors++;
            this.saveMemoryStats();
            throw error;
        }
    },
    deallocate: function(allocation, size) { 
        if (!this.memoryConfig.enabled) return false;
        this.memoryStats.stats.totalDeallocations++;
        const startTime = performance.now();
        try {
            if (this.memoryConfig.usePool) { this.returnToPool(allocation, size); }
            this.memoryStats.stats.totalMemoryFreed += size;
            const endTime = performance.now();
            const deallocationTime = endTime - startTime;
            this.memoryStats.stats.averageDeallocationTime = (this.memoryStats.stats.averageDeallocationTime * (this.memoryStats.stats.totalDeallocations - 1) + deallocationTime) / this.memoryStats.stats.totalDeallocations;
            this.saveMemoryStats();
            return true;
        } catch(error) { 
            this.memoryStats.stats.totalErrors++;
            this.saveMemoryStats();
            throw error;
        }
    },
    getFromPool: function(size) { 
        if (!this.memoryConfig.enabled) return null;
        try {
            const poolKey = size.toString();
            if (this.memoryWorld.pools[poolKey] && this.memoryWorld.pools[poolKey].length > 0) { 
                this.memoryCache.stats.hits++;
                return this.memoryWorld.pools[poolKey].pop(); 
            }
            this.memoryCache.stats.misses++;
            this.saveMemoryCache();
            return null;
        } catch(error) { 
            this.memoryStats.stats.totalErrors++;
            this.saveMemoryStats();
            throw error;
        }
    },
    returnToPool: function(allocation, size) { 
        if (!this.memoryConfig.enabled) return false;
        try {
            const poolKey = size.toString();
            if (!this.memoryWorld.pools[poolKey]) { this.memoryWorld.pools[poolKey] = []; }
            if (this.memoryWorld.pools[poolKey].length < 100) { this.memoryWorld.pools[poolKey].push(allocation); }
            return true;
        } catch(error) { 
            this.memoryStats.stats.totalErrors++;
            this.saveMemoryStats();
            throw error;
        }
    },
    garbageCollect: function() { 
        if (!this.memoryConfig.enabled) return false;
        try {
            if (this.memoryConfig.useGarbageCollection && window.gc) { window.gc(); }
            return true;
        } catch(error) { 
            this.memoryStats.stats.totalErrors++;
            this.saveMemoryStats();
            throw error;
        }
    },
    getMemoryUsage: function() { 
        if (!this.memoryConfig.enabled) return 0;
        try {
            if (performance.memory) { return performance.memory.usedJSHeapSize; }
            return 0;
        } catch(error) { 
            this.memoryStats.stats.totalErrors++;
            this.saveMemoryStats();
            throw error;
        }
    },
    getStats: function() { return this.memoryStats.stats; },
    setMemoryConfig: function(config) { this.memoryConfig = { ...this.memoryConfig, ...config }; this.saveMemoryConfig(); },
    getMemoryConfig: function() { return this.memoryConfig; }
};
